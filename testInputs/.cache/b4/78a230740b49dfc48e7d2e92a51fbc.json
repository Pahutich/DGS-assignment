{"id":"../node_modules/box2d.package.ts/Dynamics/b2WorldCallbacks.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":20,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"./b2Body","loc":{"line":21,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Body_1 = require(\"./b2Body\");\r\n// #endif\r\n/// Joints and fixtures are destroyed when their associated\r\n/// body is destroyed. Implement this listener so that you\r\n/// may nullify references to these joints and shapes.\r\nvar b2DestructionListener = /** @class */ (function () {\r\n    function b2DestructionListener() {\r\n    }\r\n    /// Called when any joint is about to be destroyed due\r\n    /// to the destruction of one of its attached bodies.\r\n    b2DestructionListener.prototype.SayGoodbyeJoint = function (joint) { };\r\n    /// Called when any fixture is about to be destroyed due\r\n    /// to the destruction of its parent body.\r\n    b2DestructionListener.prototype.SayGoodbyeFixture = function (fixture) { };\r\n    // #if B2_ENABLE_PARTICLE\r\n    /// Called when any particle group is about to be destroyed.\r\n    b2DestructionListener.prototype.SayGoodbyeParticleGroup = function (group) { };\r\n    /// Called when a particle is about to be destroyed.\r\n    /// The index can be used in conjunction with\r\n    /// b2ParticleSystem::GetUserDataBuffer() or\r\n    /// b2ParticleSystem::GetParticleHandleFromIndex() to determine which\r\n    /// particle has been destroyed.\r\n    b2DestructionListener.prototype.SayGoodbyeParticle = function (system, index) { };\r\n    return b2DestructionListener;\r\n}());\r\nexports.b2DestructionListener = b2DestructionListener;\r\n/// Implement this class to provide collision filtering. In other words, you can implement\r\n/// this class if you want finer control over contact creation.\r\nvar b2ContactFilter = /** @class */ (function () {\r\n    function b2ContactFilter() {\r\n    }\r\n    /// Return true if contact calculations should be performed between these two shapes.\r\n    /// @warning for performance reasons this is only called when the AABBs begin to overlap.\r\n    b2ContactFilter.prototype.ShouldCollide = function (fixtureA, fixtureB) {\r\n        var bodyA = fixtureA.GetBody();\r\n        var bodyB = fixtureB.GetBody();\r\n        // At least one body should be dynamic or kinematic.\r\n        if (bodyB.GetType() === b2Body_1.b2BodyType.b2_staticBody && bodyA.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n            return false;\r\n        }\r\n        // Does a joint prevent collision?\r\n        if (!bodyB.ShouldCollideConnected(bodyA)) {\r\n            return false;\r\n        }\r\n        var filter1 = fixtureA.GetFilterData();\r\n        var filter2 = fixtureB.GetFilterData();\r\n        if (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0) {\r\n            return (filter1.groupIndex > 0);\r\n        }\r\n        var collide = (((filter1.maskBits & filter2.categoryBits) !== 0) && ((filter1.categoryBits & filter2.maskBits) !== 0));\r\n        return collide;\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2ContactFilter.prototype.ShouldCollideFixtureParticle = function (fixture, system, index) {\r\n        return true;\r\n    };\r\n    b2ContactFilter.prototype.ShouldCollideParticleParticle = function (system, indexA, indexB) {\r\n        return true;\r\n    };\r\n    // #endif\r\n    b2ContactFilter.b2_defaultFilter = new b2ContactFilter();\r\n    return b2ContactFilter;\r\n}());\r\nexports.b2ContactFilter = b2ContactFilter;\r\n/// Contact impulses for reporting. Impulses are used instead of forces because\r\n/// sub-step forces may approach infinity for rigid body collisions. These\r\n/// match up one-to-one with the contact points in b2Manifold.\r\nvar b2ContactImpulse = /** @class */ (function () {\r\n    function b2ContactImpulse() {\r\n        this.normalImpulses = b2Settings_1.b2MakeNumberArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.tangentImpulses = b2Settings_1.b2MakeNumberArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.count = 0;\r\n    }\r\n    return b2ContactImpulse;\r\n}());\r\nexports.b2ContactImpulse = b2ContactImpulse;\r\n/// Implement this class to get contact information. You can use these results for\r\n/// things like sounds and game logic. You can also get contact results by\r\n/// traversing the contact lists after the time step. However, you might miss\r\n/// some contacts because continuous physics leads to sub-stepping.\r\n/// Additionally you may receive multiple callbacks for the same contact in a\r\n/// single time step.\r\n/// You should strive to make your callbacks efficient because there may be\r\n/// many callbacks per time step.\r\n/// @warning You cannot create/destroy Box2D entities inside these callbacks.\r\nvar b2ContactListener = /** @class */ (function () {\r\n    function b2ContactListener() {\r\n    }\r\n    /// Called when two fixtures begin to touch.\r\n    b2ContactListener.prototype.BeginContact = function (contact) { };\r\n    /// Called when two fixtures cease to touch.\r\n    b2ContactListener.prototype.EndContact = function (contact) { };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2ContactListener.prototype.BeginContactFixtureParticle = function (system, contact) { };\r\n    b2ContactListener.prototype.EndContactFixtureParticle = function (system, contact) { };\r\n    b2ContactListener.prototype.BeginContactParticleParticle = function (system, contact) { };\r\n    b2ContactListener.prototype.EndContactParticleParticle = function (system, contact) { };\r\n    // #endif\r\n    /// This is called after a contact is updated. This allows you to inspect a\r\n    /// contact before it goes to the solver. If you are careful, you can modify the\r\n    /// contact manifold (e.g. disable contact).\r\n    /// A copy of the old manifold is provided so that you can detect changes.\r\n    /// Note: this is called only for awake bodies.\r\n    /// Note: this is called even when the number of contact points is zero.\r\n    /// Note: this is not called for sensors.\r\n    /// Note: if you set the number of contact points to zero, you will not\r\n    /// get an EndContact callback. However, you may get a BeginContact callback\r\n    /// the next step.\r\n    b2ContactListener.prototype.PreSolve = function (contact, oldManifold) { };\r\n    /// This lets you inspect a contact after the solver is finished. This is useful\r\n    /// for inspecting impulses.\r\n    /// Note: the contact manifold does not include time of impact impulses, which can be\r\n    /// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly\r\n    /// in a separate data structure.\r\n    /// Note: this is only called for contacts that are touching, solid, and awake.\r\n    b2ContactListener.prototype.PostSolve = function (contact, impulse) { };\r\n    b2ContactListener.b2_defaultListener = new b2ContactListener();\r\n    return b2ContactListener;\r\n}());\r\nexports.b2ContactListener = b2ContactListener;\r\n/// Callback class for AABB queries.\r\n/// See b2World::Query\r\nvar b2QueryCallback = /** @class */ (function () {\r\n    function b2QueryCallback() {\r\n    }\r\n    /// Called for each fixture found in the query AABB.\r\n    /// @return false to terminate the query.\r\n    b2QueryCallback.prototype.ReportFixture = function (fixture) {\r\n        return true;\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2QueryCallback.prototype.ReportParticle = function (system, index) {\r\n        return false;\r\n    };\r\n    b2QueryCallback.prototype.ShouldQueryParticleSystem = function (system) {\r\n        return true;\r\n    };\r\n    return b2QueryCallback;\r\n}());\r\nexports.b2QueryCallback = b2QueryCallback;\r\n/// Callback class for ray casts.\r\n/// See b2World::RayCast\r\nvar b2RayCastCallback = /** @class */ (function () {\r\n    function b2RayCastCallback() {\r\n    }\r\n    /// Called for each fixture found in the query. You control how the ray cast\r\n    /// proceeds by returning a float:\r\n    /// return -1: ignore this fixture and continue\r\n    /// return 0: terminate the ray cast\r\n    /// return fraction: clip the ray to this point\r\n    /// return 1: don't clip the ray and continue\r\n    /// @param fixture the fixture hit by the ray\r\n    /// @param point the point of initial intersection\r\n    /// @param normal the normal vector at the point of intersection\r\n    /// @return -1 to filter, 0 to terminate, fraction to clip the ray for\r\n    /// closest hit, 1 to continue\r\n    b2RayCastCallback.prototype.ReportFixture = function (fixture, point, normal, fraction) {\r\n        return fraction;\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2RayCastCallback.prototype.ReportParticle = function (system, index, point, normal, fraction) {\r\n        return 0;\r\n    };\r\n    b2RayCastCallback.prototype.ShouldQueryParticleSystem = function (system) {\r\n        return true;\r\n    };\r\n    return b2RayCastCallback;\r\n}());\r\nexports.b2RayCastCallback = b2RayCastCallback;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2WorldCallbacks.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2WorldCallbacks.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;EAgBE;;AAEF,mDAA+E;AAI/E,mCAA8C;AAM9C,SAAS;AAET,2DAA2D;AAC3D,0DAA0D;AAC1D,sDAAsD;AACtD;IAAA;IAoBA,CAAC;IAnBC,sDAAsD;IACtD,qDAAqD;IAC9C,+CAAe,GAAtB,UAAuB,KAAc,IAAS,CAAC;IAE/C,wDAAwD;IACxD,0CAA0C;IACnC,iDAAiB,GAAxB,UAAyB,OAAkB,IAAS,CAAC;IAErD,yBAAyB;IACzB,4DAA4D;IACrD,uDAAuB,GAA9B,UAA+B,KAAsB,IAAS,CAAC;IAE/D,oDAAoD;IACpD,6CAA6C;IAC7C,4CAA4C;IAC5C,qEAAqE;IACrE,gCAAgC;IACzB,kDAAkB,GAAzB,UAA0B,MAAwB,EAAE,KAAa,IAAS,CAAC;IAE7E,4BAAC;AAAD,CAAC,AApBD,IAoBC;AApBY,sDAAqB;AAsBlC,0FAA0F;AAC1F,+DAA+D;AAC/D;IAAA;IAuCA,CAAC;IAtCC,qFAAqF;IACrF,yFAAyF;IAClF,uCAAa,GAApB,UAAqB,QAAmB,EAAE,QAAmB;QAC3D,IAAM,KAAK,GAAW,QAAQ,CAAC,OAAO,EAAE,CAAC;QACzC,IAAM,KAAK,GAAW,QAAQ,CAAC,OAAO,EAAE,CAAC;QAEzC,oDAAoD;QACpD,IAAI,KAAK,CAAC,OAAO,EAAE,KAAK,mBAAU,CAAC,aAAa,IAAI,KAAK,CAAC,OAAO,EAAE,KAAK,mBAAU,CAAC,aAAa,EAAE;YAChG,OAAO,KAAK,CAAC;SACd;QAED,kCAAkC;QAClC,IAAI,CAAC,KAAK,CAAC,sBAAsB,CAAC,KAAK,CAAC,EAAE;YACxC,OAAO,KAAK,CAAC;SACd;QAED,IAAM,OAAO,GAAa,QAAQ,CAAC,aAAa,EAAE,CAAC;QACnD,IAAM,OAAO,GAAa,QAAQ,CAAC,aAAa,EAAE,CAAC;QAEnD,IAAI,OAAO,CAAC,UAAU,KAAK,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,KAAK,CAAC,EAAE;YACzE,OAAO,CAAC,OAAO,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;SACjC;QAED,IAAM,OAAO,GAAY,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;QAClI,OAAO,OAAO,CAAC;IACjB,CAAC;IAED,yBAAyB;IAClB,sDAA4B,GAAnC,UAAoC,OAAkB,EAAE,MAAwB,EAAE,KAAa;QAC7F,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,uDAA6B,GAApC,UAAqC,MAAwB,EAAE,MAAc,EAAE,MAAc;QAC3F,OAAO,IAAI,CAAC;IACd,CAAC;IACD,SAAS;IAEc,gCAAgB,GAAoB,IAAI,eAAe,EAAE,CAAC;IACnF,sBAAC;CAAA,AAvCD,IAuCC;AAvCY,0CAAe;AAyC5B,+EAA+E;AAC/E,0EAA0E;AAC1E,8DAA8D;AAC9D;IAAA;QACS,mBAAc,GAAa,8BAAiB,CAAC,iCAAoB,CAAC,CAAC;QACnE,oBAAe,GAAa,8BAAiB,CAAC,iCAAoB,CAAC,CAAC;QACpE,UAAK,GAAW,CAAC,CAAC;IAC3B,CAAC;IAAD,uBAAC;AAAD,CAAC,AAJD,IAIC;AAJY,4CAAgB;AAM7B,kFAAkF;AAClF,0EAA0E;AAC1E,6EAA6E;AAC7E,mEAAmE;AACnE,6EAA6E;AAC7E,qBAAqB;AACrB,2EAA2E;AAC3E,iCAAiC;AACjC,6EAA6E;AAC7E;IAAA;IAmCA,CAAC;IAlCC,4CAA4C;IACrC,wCAAY,GAAnB,UAAoB,OAAkB,IAAS,CAAC;IAEhD,4CAA4C;IACrC,sCAAU,GAAjB,UAAkB,OAAkB,IAAS,CAAC;IAE9C,yBAAyB;IAClB,uDAA2B,GAAlC,UAAmC,MAAwB,EAAE,OAA8B,IAAS,CAAC;IAC9F,qDAAyB,GAAhC,UAAiC,MAAwB,EAAE,OAA8B,IAAS,CAAC;IAC5F,wDAA4B,GAAnC,UAAoC,MAAwB,EAAE,OAA0B,IAAS,CAAC;IAC3F,sDAA0B,GAAjC,UAAkC,MAAwB,EAAE,OAA0B,IAAS,CAAC;IAChG,SAAS;IAET,2EAA2E;IAC3E,gFAAgF;IAChF,4CAA4C;IAC5C,0EAA0E;IAC1E,+CAA+C;IAC/C,wEAAwE;IACxE,yCAAyC;IACzC,uEAAuE;IACvE,4EAA4E;IAC5E,kBAAkB;IACX,oCAAQ,GAAf,UAAgB,OAAkB,EAAE,WAAuB,IAAS,CAAC;IAErE,gFAAgF;IAChF,4BAA4B;IAC5B,qFAAqF;IACrF,wFAAwF;IACxF,iCAAiC;IACjC,+EAA+E;IACxE,qCAAS,GAAhB,UAAiB,OAAkB,EAAE,OAAyB,IAAS,CAAC;IAEjD,oCAAkB,GAAsB,IAAI,iBAAiB,EAAE,CAAC;IACzF,wBAAC;CAAA,AAnCD,IAmCC;AAnCY,8CAAiB;AAqC9B,oCAAoC;AACpC,sBAAsB;AACtB;IAAA;IAeA,CAAC;IAdC,oDAAoD;IACpD,yCAAyC;IAClC,uCAAa,GAApB,UAAqB,OAAkB;QACrC,OAAO,IAAI,CAAC;IACd,CAAC;IAED,yBAAyB;IAClB,wCAAc,GAArB,UAAsB,MAAwB,EAAE,KAAa;QAC3D,OAAO,KAAK,CAAC;IACf,CAAC;IACM,mDAAyB,GAAhC,UAAiC,MAAwB;QACvD,OAAO,IAAI,CAAC;IACd,CAAC;IAEH,sBAAC;AAAD,CAAC,AAfD,IAeC;AAfY,0CAAe;AAmB5B,iCAAiC;AACjC,wBAAwB;AACxB;IAAA;IAwBA,CAAC;IAvBC,4EAA4E;IAC5E,kCAAkC;IAClC,+CAA+C;IAC/C,oCAAoC;IACpC,+CAA+C;IAC/C,6CAA6C;IAC7C,6CAA6C;IAC7C,kDAAkD;IAClD,gEAAgE;IAChE,sEAAsE;IACtE,8BAA8B;IACvB,yCAAa,GAApB,UAAqB,OAAkB,EAAE,KAAa,EAAE,MAAc,EAAE,QAAgB;QACtF,OAAO,QAAQ,CAAC;IAClB,CAAC;IAED,yBAAyB;IAClB,0CAAc,GAArB,UAAsB,MAAwB,EAAE,KAAa,EAAE,KAAa,EAAE,MAAc,EAAE,QAAgB;QAC5G,OAAO,CAAC,CAAC;IACX,CAAC;IACM,qDAAyB,GAAhC,UAAiC,MAAwB;QACvD,OAAO,IAAI,CAAC;IACd,CAAC;IAEH,wBAAC;AAAD,CAAC,AAxBD,IAwBC;AAxBY,8CAAiB","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2_maxManifoldPoints, b2MakeNumberArray } from \"../Common/b2Settings\";\r\nimport { b2Vec2 } from \"../Common/b2Math\";\r\nimport { b2Manifold } from \"../Collision/b2Collision\";\r\nimport { b2Contact } from \"./Contacts/b2Contact\";\r\nimport { b2Body, b2BodyType } from \"./b2Body\";\r\nimport { b2Joint } from \"./Joints/b2Joint\";\r\nimport { b2Fixture, b2Filter } from \"./b2Fixture\";\r\n// #if B2_ENABLE_PARTICLE\r\nimport { b2ParticleGroup } from \"../Particle/b2ParticleGroup\";\r\nimport { b2ParticleSystem, b2ParticleContact, b2ParticleBodyContact } from \"../Particle/b2ParticleSystem\";\r\n// #endif\r\n\r\n/// Joints and fixtures are destroyed when their associated\r\n/// body is destroyed. Implement this listener so that you\r\n/// may nullify references to these joints and shapes.\r\nexport class b2DestructionListener {\r\n  /// Called when any joint is about to be destroyed due\r\n  /// to the destruction of one of its attached bodies.\r\n  public SayGoodbyeJoint(joint: b2Joint): void {}\r\n\r\n  /// Called when any fixture is about to be destroyed due\r\n  /// to the destruction of its parent body.\r\n  public SayGoodbyeFixture(fixture: b2Fixture): void {}\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  /// Called when any particle group is about to be destroyed.\r\n  public SayGoodbyeParticleGroup(group: b2ParticleGroup): void {}\r\n\r\n  /// Called when a particle is about to be destroyed.\r\n  /// The index can be used in conjunction with\r\n  /// b2ParticleSystem::GetUserDataBuffer() or\r\n  /// b2ParticleSystem::GetParticleHandleFromIndex() to determine which\r\n  /// particle has been destroyed.\r\n  public SayGoodbyeParticle(system: b2ParticleSystem, index: number): void {}\r\n  // #endif\r\n}\r\n\r\n/// Implement this class to provide collision filtering. In other words, you can implement\r\n/// this class if you want finer control over contact creation.\r\nexport class b2ContactFilter {\r\n  /// Return true if contact calculations should be performed between these two shapes.\r\n  /// @warning for performance reasons this is only called when the AABBs begin to overlap.\r\n  public ShouldCollide(fixtureA: b2Fixture, fixtureB: b2Fixture): boolean {\r\n    const bodyA: b2Body = fixtureA.GetBody();\r\n    const bodyB: b2Body = fixtureB.GetBody();\r\n\r\n    // At least one body should be dynamic or kinematic.\r\n    if (bodyB.GetType() === b2BodyType.b2_staticBody && bodyA.GetType() === b2BodyType.b2_staticBody) {\r\n      return false;\r\n    }\r\n\r\n    // Does a joint prevent collision?\r\n    if (!bodyB.ShouldCollideConnected(bodyA)) {\r\n      return false;\r\n    }\r\n\r\n    const filter1: b2Filter = fixtureA.GetFilterData();\r\n    const filter2: b2Filter = fixtureB.GetFilterData();\r\n\r\n    if (filter1.groupIndex === filter2.groupIndex && filter1.groupIndex !== 0) {\r\n      return (filter1.groupIndex > 0);\r\n    }\r\n\r\n    const collide: boolean = (((filter1.maskBits & filter2.categoryBits) !== 0) && ((filter1.categoryBits & filter2.maskBits) !== 0));\r\n    return collide;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public ShouldCollideFixtureParticle(fixture: b2Fixture, system: b2ParticleSystem, index: number): boolean {\r\n    return true;\r\n  }\r\n\r\n  public ShouldCollideParticleParticle(system: b2ParticleSystem, indexA: number, indexB: number): boolean {\r\n    return true;\r\n  }\r\n  // #endif\r\n\r\n  public static readonly b2_defaultFilter: b2ContactFilter = new b2ContactFilter();\r\n}\r\n\r\n/// Contact impulses for reporting. Impulses are used instead of forces because\r\n/// sub-step forces may approach infinity for rigid body collisions. These\r\n/// match up one-to-one with the contact points in b2Manifold.\r\nexport class b2ContactImpulse {\r\n  public normalImpulses: number[] = b2MakeNumberArray(b2_maxManifoldPoints);\r\n  public tangentImpulses: number[] = b2MakeNumberArray(b2_maxManifoldPoints);\r\n  public count: number = 0;\r\n}\r\n\r\n/// Implement this class to get contact information. You can use these results for\r\n/// things like sounds and game logic. You can also get contact results by\r\n/// traversing the contact lists after the time step. However, you might miss\r\n/// some contacts because continuous physics leads to sub-stepping.\r\n/// Additionally you may receive multiple callbacks for the same contact in a\r\n/// single time step.\r\n/// You should strive to make your callbacks efficient because there may be\r\n/// many callbacks per time step.\r\n/// @warning You cannot create/destroy Box2D entities inside these callbacks.\r\nexport class b2ContactListener {\r\n  /// Called when two fixtures begin to touch.\r\n  public BeginContact(contact: b2Contact): void {}\r\n\r\n  /// Called when two fixtures cease to touch.\r\n  public EndContact(contact: b2Contact): void {}\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public BeginContactFixtureParticle(system: b2ParticleSystem, contact: b2ParticleBodyContact): void {}\r\n  public EndContactFixtureParticle(system: b2ParticleSystem, contact: b2ParticleBodyContact): void {}\r\n  public BeginContactParticleParticle(system: b2ParticleSystem, contact: b2ParticleContact): void {}\r\n  public EndContactParticleParticle(system: b2ParticleSystem, contact: b2ParticleContact): void {}\r\n  // #endif\r\n\r\n  /// This is called after a contact is updated. This allows you to inspect a\r\n  /// contact before it goes to the solver. If you are careful, you can modify the\r\n  /// contact manifold (e.g. disable contact).\r\n  /// A copy of the old manifold is provided so that you can detect changes.\r\n  /// Note: this is called only for awake bodies.\r\n  /// Note: this is called even when the number of contact points is zero.\r\n  /// Note: this is not called for sensors.\r\n  /// Note: if you set the number of contact points to zero, you will not\r\n  /// get an EndContact callback. However, you may get a BeginContact callback\r\n  /// the next step.\r\n  public PreSolve(contact: b2Contact, oldManifold: b2Manifold): void {}\r\n\r\n  /// This lets you inspect a contact after the solver is finished. This is useful\r\n  /// for inspecting impulses.\r\n  /// Note: the contact manifold does not include time of impact impulses, which can be\r\n  /// arbitrarily large if the sub-step is small. Hence the impulse is provided explicitly\r\n  /// in a separate data structure.\r\n  /// Note: this is only called for contacts that are touching, solid, and awake.\r\n  public PostSolve(contact: b2Contact, impulse: b2ContactImpulse): void {}\r\n\r\n  public static readonly b2_defaultListener: b2ContactListener = new b2ContactListener();\r\n}\r\n\r\n/// Callback class for AABB queries.\r\n/// See b2World::Query\r\nexport class b2QueryCallback {\r\n  /// Called for each fixture found in the query AABB.\r\n  /// @return false to terminate the query.\r\n  public ReportFixture(fixture: b2Fixture): boolean {\r\n    return true;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public ReportParticle(system: b2ParticleSystem, index: number): boolean {\r\n    return false;\r\n  }\r\n  public ShouldQueryParticleSystem(system: b2ParticleSystem): boolean {\r\n    return true;\r\n  }\r\n  // #endif\r\n}\r\n\r\nexport type b2QueryCallbackFunction = (fixture: b2Fixture) => boolean;\r\n\r\n/// Callback class for ray casts.\r\n/// See b2World::RayCast\r\nexport class b2RayCastCallback {\r\n  /// Called for each fixture found in the query. You control how the ray cast\r\n  /// proceeds by returning a float:\r\n  /// return -1: ignore this fixture and continue\r\n  /// return 0: terminate the ray cast\r\n  /// return fraction: clip the ray to this point\r\n  /// return 1: don't clip the ray and continue\r\n  /// @param fixture the fixture hit by the ray\r\n  /// @param point the point of initial intersection\r\n  /// @param normal the normal vector at the point of intersection\r\n  /// @return -1 to filter, 0 to terminate, fraction to clip the ray for\r\n  /// closest hit, 1 to continue\r\n  public ReportFixture(fixture: b2Fixture, point: b2Vec2, normal: b2Vec2, fraction: number): number {\r\n    return fraction;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public ReportParticle(system: b2ParticleSystem, index: number, point: b2Vec2, normal: b2Vec2, fraction: number): number {\r\n    return 0;\r\n  }\r\n  public ShouldQueryParticleSystem(system: b2ParticleSystem): boolean {\r\n    return true;\r\n  }\r\n  // #endif\r\n}\r\n\r\nexport type b2RayCastCallbackFunction = (fixture: b2Fixture, point: b2Vec2, normal: b2Vec2, fraction: number) => number;\r\n"]}},"error":null,"hash":"5e2fbb5d142b07e3f2fa26b9b68b3d37","cacheData":{"env":{}}}