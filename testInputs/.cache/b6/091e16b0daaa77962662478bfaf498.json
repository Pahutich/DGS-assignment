{"id":"../node_modules/box2d.package.ts/Dynamics/Joints/b2PrismaticJoint.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":30,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2PrismaticJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":31,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2PrismaticJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Joint","loc":{"line":32,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2PrismaticJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2Joint.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Joint_1 = require(\"./b2Joint\");\r\n/// Prismatic joint definition. This requires defining a line of\r\n/// motion using an axis and an anchor point. The definition uses local\r\n/// anchor points and a local axis so that the initial configuration\r\n/// can violate the constraint slightly. The joint translation is zero\r\n/// when the local anchor points coincide in world space. Using local\r\n/// anchors and a local axis helps when saving and loading a game.\r\nvar b2PrismaticJointDef = /** @class */ (function (_super) {\r\n    __extends(b2PrismaticJointDef, _super);\r\n    function b2PrismaticJointDef() {\r\n        var _this = _super.call(this, b2Joint_1.b2JointType.e_prismaticJoint) || this;\r\n        _this.localAnchorA = new b2Math_1.b2Vec2();\r\n        _this.localAnchorB = new b2Math_1.b2Vec2();\r\n        _this.localAxisA = new b2Math_1.b2Vec2(1, 0);\r\n        _this.referenceAngle = 0;\r\n        _this.enableLimit = false;\r\n        _this.lowerTranslation = 0;\r\n        _this.upperTranslation = 0;\r\n        _this.enableMotor = false;\r\n        _this.maxMotorForce = 0;\r\n        _this.motorSpeed = 0;\r\n        return _this;\r\n    }\r\n    b2PrismaticJointDef.prototype.Initialize = function (bA, bB, anchor, axis) {\r\n        this.bodyA = bA;\r\n        this.bodyB = bB;\r\n        this.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n        this.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n        this.bodyA.GetLocalVector(axis, this.localAxisA);\r\n        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();\r\n    };\r\n    return b2PrismaticJointDef;\r\n}(b2Joint_1.b2JointDef));\r\nexports.b2PrismaticJointDef = b2PrismaticJointDef;\r\nvar b2PrismaticJoint = /** @class */ (function (_super) {\r\n    __extends(b2PrismaticJoint, _super);\r\n    function b2PrismaticJoint(def) {\r\n        var _this = _super.call(this, def) || this;\r\n        // Solver shared\r\n        _this.m_localAnchorA = new b2Math_1.b2Vec2();\r\n        _this.m_localAnchorB = new b2Math_1.b2Vec2();\r\n        _this.m_localXAxisA = new b2Math_1.b2Vec2();\r\n        _this.m_localYAxisA = new b2Math_1.b2Vec2();\r\n        _this.m_referenceAngle = 0;\r\n        _this.m_impulse = new b2Math_1.b2Vec3(0, 0, 0);\r\n        _this.m_motorImpulse = 0;\r\n        _this.m_lowerTranslation = 0;\r\n        _this.m_upperTranslation = 0;\r\n        _this.m_maxMotorForce = 0;\r\n        _this.m_motorSpeed = 0;\r\n        _this.m_enableLimit = false;\r\n        _this.m_enableMotor = false;\r\n        _this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n        // Solver temp\r\n        _this.m_indexA = 0;\r\n        _this.m_indexB = 0;\r\n        _this.m_localCenterA = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterB = new b2Math_1.b2Vec2();\r\n        _this.m_invMassA = 0;\r\n        _this.m_invMassB = 0;\r\n        _this.m_invIA = 0;\r\n        _this.m_invIB = 0;\r\n        _this.m_axis = new b2Math_1.b2Vec2(0, 0);\r\n        _this.m_perp = new b2Math_1.b2Vec2(0, 0);\r\n        _this.m_s1 = 0;\r\n        _this.m_s2 = 0;\r\n        _this.m_a1 = 0;\r\n        _this.m_a2 = 0;\r\n        _this.m_K = new b2Math_1.b2Mat33();\r\n        _this.m_K3 = new b2Math_1.b2Mat33();\r\n        _this.m_K2 = new b2Math_1.b2Mat22();\r\n        _this.m_motorMass = 0;\r\n        _this.m_qA = new b2Math_1.b2Rot();\r\n        _this.m_qB = new b2Math_1.b2Rot();\r\n        _this.m_lalcA = new b2Math_1.b2Vec2();\r\n        _this.m_lalcB = new b2Math_1.b2Vec2();\r\n        _this.m_rA = new b2Math_1.b2Vec2();\r\n        _this.m_rB = new b2Math_1.b2Vec2();\r\n        _this.m_localAnchorA.Copy(b2Settings_1.b2Maybe(def.localAnchorA, b2Math_1.b2Vec2.ZERO));\r\n        _this.m_localAnchorB.Copy(b2Settings_1.b2Maybe(def.localAnchorB, b2Math_1.b2Vec2.ZERO));\r\n        _this.m_localXAxisA.Copy(b2Settings_1.b2Maybe(def.localAxisA, new b2Math_1.b2Vec2(1, 0))).SelfNormalize();\r\n        b2Math_1.b2Vec2.CrossOneV(_this.m_localXAxisA, _this.m_localYAxisA);\r\n        _this.m_referenceAngle = b2Settings_1.b2Maybe(def.referenceAngle, 0);\r\n        _this.m_lowerTranslation = b2Settings_1.b2Maybe(def.lowerTranslation, 0);\r\n        _this.m_upperTranslation = b2Settings_1.b2Maybe(def.upperTranslation, 0);\r\n        _this.m_maxMotorForce = b2Settings_1.b2Maybe(def.maxMotorForce, 0);\r\n        _this.m_motorSpeed = b2Settings_1.b2Maybe(def.motorSpeed, 0);\r\n        _this.m_enableLimit = b2Settings_1.b2Maybe(def.enableLimit, false);\r\n        _this.m_enableMotor = b2Settings_1.b2Maybe(def.enableMotor, false);\r\n        return _this;\r\n    }\r\n    b2PrismaticJoint.prototype.InitVelocityConstraints = function (data) {\r\n        this.m_indexA = this.m_bodyA.m_islandIndex;\r\n        this.m_indexB = this.m_bodyB.m_islandIndex;\r\n        this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n        this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n        this.m_invMassA = this.m_bodyA.m_invMass;\r\n        this.m_invMassB = this.m_bodyB.m_invMass;\r\n        this.m_invIA = this.m_bodyA.m_invI;\r\n        this.m_invIB = this.m_bodyB.m_invI;\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        // Compute the effective masses.\r\n        // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n        var rA = b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n        // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n        var rB = b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n        // b2Vec2 d = (cB - cA) + rB - rA;\r\n        var d = b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.SubVV(cB, cA, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.SubVV(rB, rA, b2Math_1.b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_d);\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        // Compute motor Jacobian and effective mass.\r\n        {\r\n            // m_axis = b2Mul(qA, m_localXAxisA);\r\n            b2Math_1.b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n            // m_a1 = b2Cross(d + rA, m_axis);\r\n            this.m_a1 = b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.AddVV(d, rA, b2Math_1.b2Vec2.s_t0), this.m_axis);\r\n            // m_a2 = b2Cross(rB, m_axis);\r\n            this.m_a2 = b2Math_1.b2Vec2.CrossVV(rB, this.m_axis);\r\n            this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n            if (this.m_motorMass > 0) {\r\n                this.m_motorMass = 1 / this.m_motorMass;\r\n            }\r\n        }\r\n        // Prismatic constraint.\r\n        {\r\n            // m_perp = b2Mul(qA, m_localYAxisA);\r\n            b2Math_1.b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n            // m_s1 = b2Cross(d + rA, m_perp);\r\n            this.m_s1 = b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.AddVV(d, rA, b2Math_1.b2Vec2.s_t0), this.m_perp);\r\n            // m_s2 = b2Cross(rB, m_perp);\r\n            this.m_s2 = b2Math_1.b2Vec2.CrossVV(rB, this.m_perp);\r\n            // float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;\r\n            this.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\r\n            // float32 k12 = iA * m_s1 + iB * m_s2;\r\n            this.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;\r\n            // float32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;\r\n            this.m_K.ex.z = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\r\n            this.m_K.ey.x = this.m_K.ex.y;\r\n            // float32 k22 = iA + iB;\r\n            this.m_K.ey.y = iA + iB;\r\n            if (this.m_K.ey.y === 0) {\r\n                // For bodies with fixed rotation.\r\n                this.m_K.ey.y = 1;\r\n            }\r\n            // float32 k23 = iA * m_a1 + iB * m_a2;\r\n            this.m_K.ey.z = iA * this.m_a1 + iB * this.m_a2;\r\n            this.m_K.ez.x = this.m_K.ex.z;\r\n            this.m_K.ez.y = this.m_K.ey.z;\r\n            // float32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;\r\n            this.m_K.ez.z = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n            // m_K.ex.Set(k11, k12, k13);\r\n            // m_K.ey.Set(k12, k22, k23);\r\n            // m_K.ez.Set(k13, k23, k33);\r\n        }\r\n        // Compute motor and limit terms.\r\n        if (this.m_enableLimit) {\r\n            // float32 jointTranslation = b2Dot(m_axis, d);\r\n            var jointTranslation = b2Math_1.b2Vec2.DotVV(this.m_axis, d);\r\n            if (b2Math_1.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings_1.b2_linearSlop) {\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_equalLimits;\r\n            }\r\n            else if (jointTranslation <= this.m_lowerTranslation) {\r\n                if (this.m_limitState !== b2Joint_1.b2LimitState.e_atLowerLimit) {\r\n                    this.m_limitState = b2Joint_1.b2LimitState.e_atLowerLimit;\r\n                    this.m_impulse.z = 0;\r\n                }\r\n            }\r\n            else if (jointTranslation >= this.m_upperTranslation) {\r\n                if (this.m_limitState !== b2Joint_1.b2LimitState.e_atUpperLimit) {\r\n                    this.m_limitState = b2Joint_1.b2LimitState.e_atUpperLimit;\r\n                    this.m_impulse.z = 0;\r\n                }\r\n            }\r\n            else {\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n                this.m_impulse.z = 0;\r\n            }\r\n        }\r\n        else {\r\n            this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n            this.m_impulse.z = 0;\r\n        }\r\n        if (!this.m_enableMotor) {\r\n            this.m_motorImpulse = 0;\r\n        }\r\n        if (data.step.warmStarting) {\r\n            // Account for variable time step.\r\n            // m_impulse *= data.step.dtRatio;\r\n            this.m_impulse.SelfMul(data.step.dtRatio);\r\n            this.m_motorImpulse *= data.step.dtRatio;\r\n            // b2Vec2 P = m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis;\r\n            var P = b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.MulSV(this.m_impulse.x, this.m_perp, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.MulSV((this.m_motorImpulse + this.m_impulse.z), this.m_axis, b2Math_1.b2Vec2.s_t1), b2PrismaticJoint.InitVelocityConstraints_s_P);\r\n            // float32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;\r\n            var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\r\n            // float32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;\r\n            var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * LA;\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * LB;\r\n        }\r\n        else {\r\n            this.m_impulse.SetZero();\r\n            this.m_motorImpulse = 0;\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2PrismaticJoint.prototype.SolveVelocityConstraints = function (data) {\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        // Solve linear motor constraint.\r\n        if (this.m_enableMotor && this.m_limitState !== b2Joint_1.b2LimitState.e_equalLimits) {\r\n            // float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n            var Cdot = b2Math_1.b2Vec2.DotVV(this.m_axis, b2Math_1.b2Vec2.SubVV(vB, vA, b2Math_1.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n            var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\r\n            var oldImpulse = this.m_motorImpulse;\r\n            var maxImpulse = data.step.dt * this.m_maxMotorForce;\r\n            this.m_motorImpulse = b2Math_1.b2Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);\r\n            impulse = this.m_motorImpulse - oldImpulse;\r\n            // b2Vec2 P = impulse * m_axis;\r\n            var P = b2Math_1.b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n            var LA = impulse * this.m_a1;\r\n            var LB = impulse * this.m_a2;\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * LA;\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * LB;\r\n        }\r\n        // b2Vec2 Cdot1;\r\n        // Cdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;\r\n        var Cdot1_x = b2Math_1.b2Vec2.DotVV(this.m_perp, b2Math_1.b2Vec2.SubVV(vB, vA, b2Math_1.b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;\r\n        // Cdot1.y = wB - wA;\r\n        var Cdot1_y = wB - wA;\r\n        if (this.m_enableLimit && this.m_limitState !== b2Joint_1.b2LimitState.e_inactiveLimit) {\r\n            // Solve prismatic and limit constraint in block form.\r\n            // float32 Cdot2;\r\n            // Cdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n            var Cdot2 = b2Math_1.b2Vec2.DotVV(this.m_axis, b2Math_1.b2Vec2.SubVV(vB, vA, b2Math_1.b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n            // b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n            // b2Vec3 f1 = m_impulse;\r\n            var f1 = b2PrismaticJoint.SolveVelocityConstraints_s_f1.Copy(this.m_impulse);\r\n            // b2Vec3 df =  m_K.Solve33(-Cdot);\r\n            var df3 = this.m_K.Solve33((-Cdot1_x), (-Cdot1_y), (-Cdot2), b2PrismaticJoint.SolveVelocityConstraints_s_df3);\r\n            // m_impulse += df;\r\n            this.m_impulse.SelfAdd(df3);\r\n            if (this.m_limitState === b2Joint_1.b2LimitState.e_atLowerLimit) {\r\n                this.m_impulse.z = b2Math_1.b2Max(this.m_impulse.z, 0);\r\n            }\r\n            else if (this.m_limitState === b2Joint_1.b2LimitState.e_atUpperLimit) {\r\n                this.m_impulse.z = b2Math_1.b2Min(this.m_impulse.z, 0);\r\n            }\r\n            // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) + f1(1:2)\r\n            // b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.ez.x, m_K.ez.y);\r\n            var b_x = (-Cdot1_x) - (this.m_impulse.z - f1.z) * this.m_K.ez.x;\r\n            var b_y = (-Cdot1_y) - (this.m_impulse.z - f1.z) * this.m_K.ez.y;\r\n            // b2Vec2 f2r = m_K.Solve22(b) + b2Vec2(f1.x, f1.y);\r\n            var f2r = this.m_K.Solve22(b_x, b_y, b2PrismaticJoint.SolveVelocityConstraints_s_f2r);\r\n            f2r.x += f1.x;\r\n            f2r.y += f1.y;\r\n            // m_impulse.x = f2r.x;\r\n            this.m_impulse.x = f2r.x;\r\n            // m_impulse.y = f2r.y;\r\n            this.m_impulse.y = f2r.y;\r\n            // df = m_impulse - f1;\r\n            df3.x = this.m_impulse.x - f1.x;\r\n            df3.y = this.m_impulse.y - f1.y;\r\n            df3.z = this.m_impulse.z - f1.z;\r\n            // b2Vec2 P = df.x * m_perp + df.z * m_axis;\r\n            var P = b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.MulSV(df3.x, this.m_perp, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.MulSV(df3.z, this.m_axis, b2Math_1.b2Vec2.s_t1), b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n            // float32 LA = df.x * m_s1 + df.y + df.z * m_a1;\r\n            var LA = df3.x * this.m_s1 + df3.y + df3.z * this.m_a1;\r\n            // float32 LB = df.x * m_s2 + df.y + df.z * m_a2;\r\n            var LB = df3.x * this.m_s2 + df3.y + df3.z * this.m_a2;\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * LA;\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * LB;\r\n        }\r\n        else {\r\n            // Limit is inactive, just solve the prismatic constraint in block form.\r\n            // b2Vec2 df = m_K.Solve22(-Cdot1);\r\n            var df2 = this.m_K.Solve22((-Cdot1_x), (-Cdot1_y), b2PrismaticJoint.SolveVelocityConstraints_s_df2);\r\n            this.m_impulse.x += df2.x;\r\n            this.m_impulse.y += df2.y;\r\n            // b2Vec2 P = df.x * m_perp;\r\n            var P = b2Math_1.b2Vec2.MulSV(df2.x, this.m_perp, b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n            // float32 LA = df.x * m_s1 + df.y;\r\n            var LA = df2.x * this.m_s1 + df2.y;\r\n            // float32 LB = df.x * m_s2 + df.y;\r\n            var LB = df2.x * this.m_s2 + df2.y;\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * LA;\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * LB;\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2PrismaticJoint.prototype.SolvePositionConstraints = function (data) {\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n        var rA = b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n        // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n        var rB = b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n        // b2Vec2 d = cB + rB - cA - rA;\r\n        var d = b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVV(cB, rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVV(cA, rA, b2Math_1.b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_d);\r\n        // b2Vec2 axis = b2Mul(qA, m_localXAxisA);\r\n        var axis = b2Math_1.b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n        // float32 a1 = b2Cross(d + rA, axis);\r\n        var a1 = b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.AddVV(d, rA, b2Math_1.b2Vec2.s_t0), axis);\r\n        // float32 a2 = b2Cross(rB, axis);\r\n        var a2 = b2Math_1.b2Vec2.CrossVV(rB, axis);\r\n        // b2Vec2 perp = b2Mul(qA, m_localYAxisA);\r\n        var perp = b2Math_1.b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n        // float32 s1 = b2Cross(d + rA, perp);\r\n        var s1 = b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.AddVV(d, rA, b2Math_1.b2Vec2.s_t0), perp);\r\n        // float32 s2 = b2Cross(rB, perp);\r\n        var s2 = b2Math_1.b2Vec2.CrossVV(rB, perp);\r\n        // b2Vec3 impulse;\r\n        var impulse = b2PrismaticJoint.SolvePositionConstraints_s_impulse;\r\n        // b2Vec2 C1;\r\n        // C1.x = b2Dot(perp, d);\r\n        var C1_x = b2Math_1.b2Vec2.DotVV(perp, d);\r\n        // C1.y = aB - aA - m_referenceAngle;\r\n        var C1_y = aB - aA - this.m_referenceAngle;\r\n        var linearError = b2Math_1.b2Abs(C1_x);\r\n        var angularError = b2Math_1.b2Abs(C1_y);\r\n        var active = false;\r\n        var C2 = 0;\r\n        if (this.m_enableLimit) {\r\n            // float32 translation = b2Dot(axis, d);\r\n            var translation = b2Math_1.b2Vec2.DotVV(axis, d);\r\n            if (b2Math_1.b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2Settings_1.b2_linearSlop) {\r\n                // Prevent large angular corrections\r\n                C2 = b2Math_1.b2Clamp(translation, (-b2Settings_1.b2_maxLinearCorrection), b2Settings_1.b2_maxLinearCorrection);\r\n                linearError = b2Math_1.b2Max(linearError, b2Math_1.b2Abs(translation));\r\n                active = true;\r\n            }\r\n            else if (translation <= this.m_lowerTranslation) {\r\n                // Prevent large linear corrections and allow some slop.\r\n                C2 = b2Math_1.b2Clamp(translation - this.m_lowerTranslation + b2Settings_1.b2_linearSlop, (-b2Settings_1.b2_maxLinearCorrection), 0);\r\n                linearError = b2Math_1.b2Max(linearError, this.m_lowerTranslation - translation);\r\n                active = true;\r\n            }\r\n            else if (translation >= this.m_upperTranslation) {\r\n                // Prevent large linear corrections and allow some slop.\r\n                C2 = b2Math_1.b2Clamp(translation - this.m_upperTranslation - b2Settings_1.b2_linearSlop, 0, b2Settings_1.b2_maxLinearCorrection);\r\n                linearError = b2Math_1.b2Max(linearError, translation - this.m_upperTranslation);\r\n                active = true;\r\n            }\r\n        }\r\n        if (active) {\r\n            // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n            // float32 k12 = iA * s1 + iB * s2;\r\n            var k12 = iA * s1 + iB * s2;\r\n            // float32 k13 = iA * s1 * a1 + iB * s2 * a2;\r\n            var k13 = iA * s1 * a1 + iB * s2 * a2;\r\n            // float32 k22 = iA + iB;\r\n            var k22 = iA + iB;\r\n            if (k22 === 0) {\r\n                // For fixed rotation\r\n                k22 = 1;\r\n            }\r\n            // float32 k23 = iA * a1 + iB * a2;\r\n            var k23 = iA * a1 + iB * a2;\r\n            // float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n            var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n            // b2Mat33 K;\r\n            var K = this.m_K3;\r\n            // K.ex.Set(k11, k12, k13);\r\n            K.ex.SetXYZ(k11, k12, k13);\r\n            // K.ey.Set(k12, k22, k23);\r\n            K.ey.SetXYZ(k12, k22, k23);\r\n            // K.ez.Set(k13, k23, k33);\r\n            K.ez.SetXYZ(k13, k23, k33);\r\n            // b2Vec3 C;\r\n            // C.x = C1.x;\r\n            // C.y = C1.y;\r\n            // C.z = C2;\r\n            // impulse = K.Solve33(-C);\r\n            impulse = K.Solve33((-C1_x), (-C1_y), (-C2), impulse);\r\n        }\r\n        else {\r\n            // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n            var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n            // float32 k12 = iA * s1 + iB * s2;\r\n            var k12 = iA * s1 + iB * s2;\r\n            // float32 k22 = iA + iB;\r\n            var k22 = iA + iB;\r\n            if (k22 === 0) {\r\n                k22 = 1;\r\n            }\r\n            // b2Mat22 K;\r\n            var K2 = this.m_K2;\r\n            // K.ex.Set(k11, k12);\r\n            K2.ex.Set(k11, k12);\r\n            // K.ey.Set(k12, k22);\r\n            K2.ey.Set(k12, k22);\r\n            // b2Vec2 impulse1 = K.Solve(-C1);\r\n            var impulse1 = K2.Solve((-C1_x), (-C1_y), b2PrismaticJoint.SolvePositionConstraints_s_impulse1);\r\n            impulse.x = impulse1.x;\r\n            impulse.y = impulse1.y;\r\n            impulse.z = 0;\r\n        }\r\n        // b2Vec2 P = impulse.x * perp + impulse.z * axis;\r\n        var P = b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.MulSV(impulse.x, perp, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.MulSV(impulse.z, axis, b2Math_1.b2Vec2.s_t1), b2PrismaticJoint.SolvePositionConstraints_s_P);\r\n        // float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n        var LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n        // float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n        var LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n        // cA -= mA * P;\r\n        cA.SelfMulSub(mA, P);\r\n        aA -= iA * LA;\r\n        // cB += mB * P;\r\n        cB.SelfMulAdd(mB, P);\r\n        aB += iB * LB;\r\n        // data.positions[this.m_indexA].c = cA;\r\n        data.positions[this.m_indexA].a = aA;\r\n        // data.positions[this.m_indexB].c = cB;\r\n        data.positions[this.m_indexB].a = aB;\r\n        return linearError <= b2Settings_1.b2_linearSlop && angularError <= b2Settings_1.b2_angularSlop;\r\n    };\r\n    b2PrismaticJoint.prototype.GetAnchorA = function (out) {\r\n        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n    };\r\n    b2PrismaticJoint.prototype.GetAnchorB = function (out) {\r\n        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n    };\r\n    b2PrismaticJoint.prototype.GetReactionForce = function (inv_dt, out) {\r\n        // return inv_dt * (m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis);\r\n        out.x = inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x);\r\n        out.y = inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y);\r\n        return out;\r\n    };\r\n    b2PrismaticJoint.prototype.GetReactionTorque = function (inv_dt) {\r\n        return inv_dt * this.m_impulse.y;\r\n    };\r\n    b2PrismaticJoint.prototype.GetLocalAnchorA = function () { return this.m_localAnchorA; };\r\n    b2PrismaticJoint.prototype.GetLocalAnchorB = function () { return this.m_localAnchorB; };\r\n    b2PrismaticJoint.prototype.GetLocalAxisA = function () { return this.m_localXAxisA; };\r\n    b2PrismaticJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; };\r\n    b2PrismaticJoint.prototype.GetJointTranslation = function () {\r\n        // b2Vec2 pA = m_bodyA.GetWorldPoint(m_localAnchorA);\r\n        var pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PrismaticJoint.GetJointTranslation_s_pA);\r\n        // b2Vec2 pB = m_bodyB.GetWorldPoint(m_localAnchorB);\r\n        var pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PrismaticJoint.GetJointTranslation_s_pB);\r\n        // b2Vec2 d = pB - pA;\r\n        var d = b2Math_1.b2Vec2.SubVV(pB, pA, b2PrismaticJoint.GetJointTranslation_s_d);\r\n        // b2Vec2 axis = m_bodyA.GetWorldVector(m_localXAxisA);\r\n        var axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, b2PrismaticJoint.GetJointTranslation_s_axis);\r\n        // float32 translation = b2Dot(d, axis);\r\n        var translation = b2Math_1.b2Vec2.DotVV(d, axis);\r\n        return translation;\r\n    };\r\n    b2PrismaticJoint.prototype.GetJointSpeed = function () {\r\n        var bA = this.m_bodyA;\r\n        var bB = this.m_bodyB;\r\n        // b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);\r\n        var rA = b2Math_1.b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);\r\n        // b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);\r\n        var rB = b2Math_1.b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);\r\n        // b2Vec2 pA = bA->m_sweep.c + rA;\r\n        var pA = b2Math_1.b2Vec2.AddVV(bA.m_sweep.c, rA, b2Math_1.b2Vec2.s_t0); // pA uses s_t0\r\n        // b2Vec2 pB = bB->m_sweep.c + rB;\r\n        var pB = b2Math_1.b2Vec2.AddVV(bB.m_sweep.c, rB, b2Math_1.b2Vec2.s_t1); // pB uses s_t1\r\n        // b2Vec2 d = pB - pA;\r\n        var d = b2Math_1.b2Vec2.SubVV(pB, pA, b2Math_1.b2Vec2.s_t2); // d uses s_t2\r\n        // b2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);\r\n        var axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);\r\n        var vA = bA.m_linearVelocity;\r\n        var vB = bB.m_linearVelocity;\r\n        var wA = bA.m_angularVelocity;\r\n        var wB = bB.m_angularVelocity;\r\n        // float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));\r\n        var speed = b2Math_1.b2Vec2.DotVV(d, b2Math_1.b2Vec2.CrossSV(wA, axis, b2Math_1.b2Vec2.s_t0)) +\r\n            b2Math_1.b2Vec2.DotVV(axis, b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, rA, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t0));\r\n        return speed;\r\n    };\r\n    b2PrismaticJoint.prototype.IsLimitEnabled = function () {\r\n        return this.m_enableLimit;\r\n    };\r\n    b2PrismaticJoint.prototype.EnableLimit = function (flag) {\r\n        if (flag !== this.m_enableLimit) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_enableLimit = flag;\r\n            this.m_impulse.z = 0;\r\n        }\r\n    };\r\n    b2PrismaticJoint.prototype.GetLowerLimit = function () {\r\n        return this.m_lowerTranslation;\r\n    };\r\n    b2PrismaticJoint.prototype.GetUpperLimit = function () {\r\n        return this.m_upperTranslation;\r\n    };\r\n    b2PrismaticJoint.prototype.SetLimits = function (lower, upper) {\r\n        if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_lowerTranslation = lower;\r\n            this.m_upperTranslation = upper;\r\n            this.m_impulse.z = 0;\r\n        }\r\n    };\r\n    b2PrismaticJoint.prototype.IsMotorEnabled = function () {\r\n        return this.m_enableMotor;\r\n    };\r\n    b2PrismaticJoint.prototype.EnableMotor = function (flag) {\r\n        if (flag !== this.m_enableMotor) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_enableMotor = flag;\r\n        }\r\n    };\r\n    b2PrismaticJoint.prototype.SetMotorSpeed = function (speed) {\r\n        if (speed !== this.m_motorSpeed) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_motorSpeed = speed;\r\n        }\r\n    };\r\n    b2PrismaticJoint.prototype.GetMotorSpeed = function () {\r\n        return this.m_motorSpeed;\r\n    };\r\n    b2PrismaticJoint.prototype.SetMaxMotorForce = function (force) {\r\n        if (force !== this.m_maxMotorForce) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_maxMotorForce = force;\r\n        }\r\n    };\r\n    b2PrismaticJoint.prototype.GetMaxMotorForce = function () { return this.m_maxMotorForce; };\r\n    b2PrismaticJoint.prototype.GetMotorForce = function (inv_dt) {\r\n        return inv_dt * this.m_motorImpulse;\r\n    };\r\n    b2PrismaticJoint.prototype.Dump = function (log) {\r\n        var indexA = this.m_bodyA.m_islandIndex;\r\n        var indexB = this.m_bodyB.m_islandIndex;\r\n        log(\"  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\\n\");\r\n        log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n        log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n        log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n        log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n        log(\"  jd.localAxisA.Set(%.15f, %.15f);\\n\", this.m_localXAxisA.x, this.m_localXAxisA.y);\r\n        log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n        log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.lowerTranslation = %.15f;\\n\", this.m_lowerTranslation);\r\n        log(\"  jd.upperTranslation = %.15f;\\n\", this.m_upperTranslation);\r\n        log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n        log(\"  jd.maxMotorForce = %.15f;\\n\", this.m_maxMotorForce);\r\n        log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n    };\r\n    b2PrismaticJoint.InitVelocityConstraints_s_d = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.InitVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.SolveVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.SolveVelocityConstraints_s_f2r = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.SolveVelocityConstraints_s_f1 = new b2Math_1.b2Vec3();\r\n    b2PrismaticJoint.SolveVelocityConstraints_s_df3 = new b2Math_1.b2Vec3();\r\n    b2PrismaticJoint.SolveVelocityConstraints_s_df2 = new b2Math_1.b2Vec2();\r\n    // A velocity based solver computes reaction forces(impulses) using the velocity constraint solver.Under this context,\r\n    // the position solver is not there to resolve forces.It is only there to cope with integration error.\r\n    //\r\n    // Therefore, the pseudo impulses in the position solver do not have any physical meaning.Thus it is okay if they suck.\r\n    //\r\n    // We could take the active state from the velocity solver.However, the joint might push past the limit when the velocity\r\n    // solver indicates the limit is inactive.\r\n    b2PrismaticJoint.SolvePositionConstraints_s_d = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.SolvePositionConstraints_s_impulse = new b2Math_1.b2Vec3();\r\n    b2PrismaticJoint.SolvePositionConstraints_s_impulse1 = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.SolvePositionConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.GetJointTranslation_s_pA = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.GetJointTranslation_s_pB = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.GetJointTranslation_s_d = new b2Math_1.b2Vec2();\r\n    b2PrismaticJoint.GetJointTranslation_s_axis = new b2Math_1.b2Vec2();\r\n    return b2PrismaticJoint;\r\n}(b2Joint_1.b2Joint));\r\nexports.b2PrismaticJoint = b2PrismaticJoint;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2PrismaticJoint.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Joints/b2PrismaticJoint.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2_linearSlop, b2_maxLinearCorrection, b2_angularSlop, b2Maybe } from \"../../Common/b2Settings\";\r\nimport { b2Abs, b2Min, b2Max, b2Clamp, b2Vec2, b2Mat22, b2Vec3, b2Mat33, b2Rot, XY } from \"../../Common/b2Math\";\r\nimport { b2Body } from \"../b2Body\";\r\nimport { b2Joint, b2JointDef, b2JointType, b2LimitState, b2IJointDef } from \"./b2Joint\";\r\nimport { b2SolverData } from \"../b2TimeStep\";\r\n\r\nexport interface b2IPrismaticJointDef extends b2IJointDef {\r\n  localAnchorA?: XY;\r\n\r\n  localAnchorB?: XY;\r\n\r\n  localAxisA?: XY;\r\n\r\n  referenceAngle?: number;\r\n\r\n  enableLimit?: boolean;\r\n\r\n  lowerTranslation?: number;\r\n\r\n  upperTranslation?: number;\r\n\r\n  enableMotor?: boolean;\r\n\r\n  maxMotorForce?: number;\r\n\r\n  motorSpeed?: number;\r\n}\r\n\r\n/// Prismatic joint definition. This requires defining a line of\r\n/// motion using an axis and an anchor point. The definition uses local\r\n/// anchor points and a local axis so that the initial configuration\r\n/// can violate the constraint slightly. The joint translation is zero\r\n/// when the local anchor points coincide in world space. Using local\r\n/// anchors and a local axis helps when saving and loading a game.\r\nexport class b2PrismaticJointDef extends b2JointDef implements b2IPrismaticJointDef {\r\n  public readonly localAnchorA: b2Vec2 = new b2Vec2();\r\n\r\n  public readonly localAnchorB: b2Vec2 = new b2Vec2();\r\n\r\n  public readonly localAxisA: b2Vec2 = new b2Vec2(1, 0);\r\n\r\n  public referenceAngle: number = 0;\r\n\r\n  public enableLimit = false;\r\n\r\n  public lowerTranslation: number = 0;\r\n\r\n  public upperTranslation: number = 0;\r\n\r\n  public enableMotor = false;\r\n\r\n  public maxMotorForce: number = 0;\r\n\r\n  public motorSpeed: number = 0;\r\n\r\n  constructor() {\r\n    super(b2JointType.e_prismaticJoint);\r\n  }\r\n\r\n  public Initialize(bA: b2Body, bB: b2Body, anchor: b2Vec2, axis: b2Vec2): void {\r\n    this.bodyA = bA;\r\n    this.bodyB = bB;\r\n    this.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n    this.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n    this.bodyA.GetLocalVector(axis, this.localAxisA);\r\n    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();\r\n  }\r\n}\r\n\r\nexport class b2PrismaticJoint extends b2Joint {\r\n  // Solver shared\r\n  public readonly m_localAnchorA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localAnchorB: b2Vec2 = new b2Vec2();\r\n  public readonly m_localXAxisA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localYAxisA: b2Vec2 = new b2Vec2();\r\n  public m_referenceAngle: number = 0;\r\n  public readonly m_impulse: b2Vec3 = new b2Vec3(0, 0, 0);\r\n  public m_motorImpulse: number = 0;\r\n  public m_lowerTranslation: number = 0;\r\n  public m_upperTranslation: number = 0;\r\n  public m_maxMotorForce: number = 0;\r\n  public m_motorSpeed: number = 0;\r\n  public m_enableLimit: boolean = false;\r\n  public m_enableMotor: boolean = false;\r\n  public m_limitState: b2LimitState = b2LimitState.e_inactiveLimit;\r\n\r\n  // Solver temp\r\n  public m_indexA: number = 0;\r\n  public m_indexB: number = 0;\r\n  public readonly m_localCenterA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterB: b2Vec2 = new b2Vec2();\r\n  public m_invMassA: number = 0;\r\n  public m_invMassB: number = 0;\r\n  public m_invIA: number = 0;\r\n  public m_invIB: number = 0;\r\n  public readonly m_axis: b2Vec2 = new b2Vec2(0, 0);\r\n  public readonly m_perp: b2Vec2 = new b2Vec2(0, 0);\r\n  public m_s1: number = 0;\r\n  public m_s2: number = 0;\r\n  public m_a1: number = 0;\r\n  public m_a2: number = 0;\r\n  public readonly m_K: b2Mat33 = new b2Mat33();\r\n  public readonly m_K3: b2Mat33 = new b2Mat33();\r\n  public readonly m_K2: b2Mat22 = new b2Mat22();\r\n  public m_motorMass: number = 0;\r\n\r\n  public readonly m_qA: b2Rot = new b2Rot();\r\n  public readonly m_qB: b2Rot = new b2Rot();\r\n  public readonly m_lalcA: b2Vec2 = new b2Vec2();\r\n  public readonly m_lalcB: b2Vec2 = new b2Vec2();\r\n  public readonly m_rA: b2Vec2 = new b2Vec2();\r\n  public readonly m_rB: b2Vec2 = new b2Vec2();\r\n\r\n  constructor(def: b2IPrismaticJointDef) {\r\n    super(def);\r\n\r\n    this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));\r\n    this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));\r\n    this.m_localXAxisA.Copy(b2Maybe(def.localAxisA, new b2Vec2(1, 0))).SelfNormalize();\r\n    b2Vec2.CrossOneV(this.m_localXAxisA, this.m_localYAxisA);\r\n    this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);\r\n    this.m_lowerTranslation = b2Maybe(def.lowerTranslation, 0);\r\n    this.m_upperTranslation = b2Maybe(def.upperTranslation, 0);\r\n    this.m_maxMotorForce = b2Maybe(def.maxMotorForce, 0);\r\n    this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);\r\n    this.m_enableLimit = b2Maybe(def.enableLimit, false);\r\n    this.m_enableMotor = b2Maybe(def.enableMotor, false);\r\n  }\r\n\r\n  private static InitVelocityConstraints_s_d = new b2Vec2();\r\n  private static InitVelocityConstraints_s_P = new b2Vec2();\r\n  public InitVelocityConstraints(data: b2SolverData): void {\r\n    this.m_indexA = this.m_bodyA.m_islandIndex;\r\n    this.m_indexB = this.m_bodyB.m_islandIndex;\r\n    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n    this.m_invMassA = this.m_bodyA.m_invMass;\r\n    this.m_invMassB = this.m_bodyB.m_invMass;\r\n    this.m_invIA = this.m_bodyA.m_invI;\r\n    this.m_invIB = this.m_bodyB.m_invI;\r\n\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    const aA: number = data.positions[this.m_indexA].a;\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    const aB: number = data.positions[this.m_indexB].a;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    // Compute the effective masses.\r\n    // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n    b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n    const rA: b2Vec2 = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n    // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n    b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n    const rB: b2Vec2 = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n    // b2Vec2 d = (cB - cA) + rB - rA;\r\n    const d: b2Vec2 = b2Vec2.AddVV(\r\n      b2Vec2.SubVV(cB, cA, b2Vec2.s_t0),\r\n      b2Vec2.SubVV(rB, rA, b2Vec2.s_t1),\r\n      b2PrismaticJoint.InitVelocityConstraints_s_d);\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    // Compute motor Jacobian and effective mass.\r\n    {\r\n      // m_axis = b2Mul(qA, m_localXAxisA);\r\n      b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n      // m_a1 = b2Cross(d + rA, m_axis);\r\n      this.m_a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_axis);\r\n      // m_a2 = b2Cross(rB, m_axis);\r\n      this.m_a2 = b2Vec2.CrossVV(rB, this.m_axis);\r\n\r\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n      if (this.m_motorMass > 0) {\r\n        this.m_motorMass = 1 / this.m_motorMass;\r\n      }\r\n    }\r\n\r\n    // Prismatic constraint.\r\n    {\r\n      // m_perp = b2Mul(qA, m_localYAxisA);\r\n      b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n\r\n      // m_s1 = b2Cross(d + rA, m_perp);\r\n      this.m_s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), this.m_perp);\r\n      // m_s2 = b2Cross(rB, m_perp);\r\n      this.m_s2 = b2Vec2.CrossVV(rB, this.m_perp);\r\n\r\n      // float32 k11 = mA + mB + iA * m_s1 * m_s1 + iB * m_s2 * m_s2;\r\n      this.m_K.ex.x = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\r\n      // float32 k12 = iA * m_s1 + iB * m_s2;\r\n      this.m_K.ex.y = iA * this.m_s1 + iB * this.m_s2;\r\n      // float32 k13 = iA * m_s1 * m_a1 + iB * m_s2 * m_a2;\r\n      this.m_K.ex.z = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\r\n      this.m_K.ey.x = this.m_K.ex.y;\r\n      // float32 k22 = iA + iB;\r\n      this.m_K.ey.y = iA + iB;\r\n      if (this.m_K.ey.y === 0) {\r\n        // For bodies with fixed rotation.\r\n        this.m_K.ey.y = 1;\r\n      }\r\n      // float32 k23 = iA * m_a1 + iB * m_a2;\r\n      this.m_K.ey.z = iA * this.m_a1 + iB * this.m_a2;\r\n      this.m_K.ez.x = this.m_K.ex.z;\r\n      this.m_K.ez.y = this.m_K.ey.z;\r\n      // float32 k33 = mA + mB + iA * m_a1 * m_a1 + iB * m_a2 * m_a2;\r\n      this.m_K.ez.z = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\r\n\r\n      // m_K.ex.Set(k11, k12, k13);\r\n      // m_K.ey.Set(k12, k22, k23);\r\n      // m_K.ez.Set(k13, k23, k33);\r\n    }\r\n\r\n    // Compute motor and limit terms.\r\n    if (this.m_enableLimit) {\r\n      // float32 jointTranslation = b2Dot(m_axis, d);\r\n      const jointTranslation: number = b2Vec2.DotVV(this.m_axis, d);\r\n      if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {\r\n        this.m_limitState = b2LimitState.e_equalLimits;\r\n      } else if (jointTranslation <= this.m_lowerTranslation) {\r\n        if (this.m_limitState !== b2LimitState.e_atLowerLimit) {\r\n          this.m_limitState = b2LimitState.e_atLowerLimit;\r\n          this.m_impulse.z = 0;\r\n        }\r\n      } else if (jointTranslation >= this.m_upperTranslation) {\r\n        if (this.m_limitState !== b2LimitState.e_atUpperLimit) {\r\n          this.m_limitState = b2LimitState.e_atUpperLimit;\r\n          this.m_impulse.z = 0;\r\n        }\r\n      } else {\r\n        this.m_limitState = b2LimitState.e_inactiveLimit;\r\n        this.m_impulse.z = 0;\r\n      }\r\n    } else {\r\n      this.m_limitState = b2LimitState.e_inactiveLimit;\r\n      this.m_impulse.z = 0;\r\n    }\r\n\r\n    if (!this.m_enableMotor) {\r\n      this.m_motorImpulse = 0;\r\n    }\r\n\r\n    if (data.step.warmStarting) {\r\n      // Account for variable time step.\r\n      // m_impulse *= data.step.dtRatio;\r\n      this.m_impulse.SelfMul(data.step.dtRatio);\r\n      this.m_motorImpulse *= data.step.dtRatio;\r\n\r\n      // b2Vec2 P = m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis;\r\n      const P: b2Vec2 = b2Vec2.AddVV(\r\n        b2Vec2.MulSV(this.m_impulse.x, this.m_perp, b2Vec2.s_t0),\r\n        b2Vec2.MulSV((this.m_motorImpulse + this.m_impulse.z), this.m_axis, b2Vec2.s_t1),\r\n        b2PrismaticJoint.InitVelocityConstraints_s_P);\r\n      // float32 LA = m_impulse.x * m_s1 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a1;\r\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\r\n      // float32 LB = m_impulse.x * m_s2 + m_impulse.y + (m_motorImpulse + m_impulse.z) * m_a2;\r\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * LA;\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * LB;\r\n    } else {\r\n      this.m_impulse.SetZero();\r\n      this.m_motorImpulse = 0;\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolveVelocityConstraints_s_P = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_f2r = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_f1 = new b2Vec3();\r\n  private static SolveVelocityConstraints_s_df3 = new b2Vec3();\r\n  private static SolveVelocityConstraints_s_df2 = new b2Vec2();\r\n  public SolveVelocityConstraints(data: b2SolverData): void {\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    // Solve linear motor constraint.\r\n    if (this.m_enableMotor && this.m_limitState !== b2LimitState.e_equalLimits) {\r\n      // float32 Cdot = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n      const Cdot: number = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\r\n      const oldImpulse = this.m_motorImpulse;\r\n      const maxImpulse = data.step.dt * this.m_maxMotorForce;\r\n      this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, (-maxImpulse), maxImpulse);\r\n      impulse = this.m_motorImpulse - oldImpulse;\r\n\r\n      // b2Vec2 P = impulse * m_axis;\r\n      const P: b2Vec2 = b2Vec2.MulSV(impulse, this.m_axis, b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n      const LA = impulse * this.m_a1;\r\n      const LB = impulse * this.m_a2;\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * LA;\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * LB;\r\n    }\r\n\r\n    // b2Vec2 Cdot1;\r\n    // Cdot1.x = b2Dot(m_perp, vB - vA) + m_s2 * wB - m_s1 * wA;\r\n    const Cdot1_x: number = b2Vec2.DotVV(this.m_perp, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_s2 * wB - this.m_s1 * wA;\r\n    // Cdot1.y = wB - wA;\r\n    const Cdot1_y = wB - wA;\r\n\r\n    if (this.m_enableLimit && this.m_limitState !== b2LimitState.e_inactiveLimit) {\r\n      // Solve prismatic and limit constraint in block form.\r\n      // float32 Cdot2;\r\n      // Cdot2 = b2Dot(m_axis, vB - vA) + m_a2 * wB - m_a1 * wA;\r\n      const Cdot2: number = b2Vec2.DotVV(this.m_axis, b2Vec2.SubVV(vB, vA, b2Vec2.s_t0)) + this.m_a2 * wB - this.m_a1 * wA;\r\n      // b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n\r\n      // b2Vec3 f1 = m_impulse;\r\n      const f1 = b2PrismaticJoint.SolveVelocityConstraints_s_f1.Copy(this.m_impulse);\r\n      // b2Vec3 df =  m_K.Solve33(-Cdot);\r\n      const df3 = this.m_K.Solve33((-Cdot1_x), (-Cdot1_y), (-Cdot2), b2PrismaticJoint.SolveVelocityConstraints_s_df3);\r\n      // m_impulse += df;\r\n      this.m_impulse.SelfAdd(df3);\r\n\r\n      if (this.m_limitState === b2LimitState.e_atLowerLimit) {\r\n        this.m_impulse.z = b2Max(this.m_impulse.z, 0);\r\n      } else if (this.m_limitState === b2LimitState.e_atUpperLimit) {\r\n        this.m_impulse.z = b2Min(this.m_impulse.z, 0);\r\n      }\r\n\r\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) + f1(1:2)\r\n      // b2Vec2 b = -Cdot1 - (m_impulse.z - f1.z) * b2Vec2(m_K.ez.x, m_K.ez.y);\r\n      const b_x = (-Cdot1_x) - (this.m_impulse.z - f1.z) * this.m_K.ez.x;\r\n      const b_y = (-Cdot1_y) - (this.m_impulse.z - f1.z) * this.m_K.ez.y;\r\n      // b2Vec2 f2r = m_K.Solve22(b) + b2Vec2(f1.x, f1.y);\r\n      const f2r = this.m_K.Solve22(b_x, b_y, b2PrismaticJoint.SolveVelocityConstraints_s_f2r);\r\n      f2r.x += f1.x;\r\n      f2r.y += f1.y;\r\n      // m_impulse.x = f2r.x;\r\n      this.m_impulse.x = f2r.x;\r\n      // m_impulse.y = f2r.y;\r\n      this.m_impulse.y = f2r.y;\r\n\r\n      // df = m_impulse - f1;\r\n      df3.x = this.m_impulse.x - f1.x;\r\n      df3.y = this.m_impulse.y - f1.y;\r\n      df3.z = this.m_impulse.z - f1.z;\r\n\r\n      // b2Vec2 P = df.x * m_perp + df.z * m_axis;\r\n      const P: b2Vec2 = b2Vec2.AddVV(\r\n        b2Vec2.MulSV(df3.x, this.m_perp, b2Vec2.s_t0),\r\n        b2Vec2.MulSV(df3.z, this.m_axis, b2Vec2.s_t1),\r\n        b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n      // float32 LA = df.x * m_s1 + df.y + df.z * m_a1;\r\n      const LA = df3.x * this.m_s1 + df3.y + df3.z * this.m_a1;\r\n      // float32 LB = df.x * m_s2 + df.y + df.z * m_a2;\r\n      const LB = df3.x * this.m_s2 + df3.y + df3.z * this.m_a2;\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * LA;\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * LB;\r\n    } else {\r\n      // Limit is inactive, just solve the prismatic constraint in block form.\r\n      // b2Vec2 df = m_K.Solve22(-Cdot1);\r\n      const df2 = this.m_K.Solve22((-Cdot1_x), (-Cdot1_y), b2PrismaticJoint.SolveVelocityConstraints_s_df2);\r\n      this.m_impulse.x += df2.x;\r\n      this.m_impulse.y += df2.y;\r\n\r\n      // b2Vec2 P = df.x * m_perp;\r\n      const P: b2Vec2 = b2Vec2.MulSV(df2.x, this.m_perp, b2PrismaticJoint.SolveVelocityConstraints_s_P);\r\n      // float32 LA = df.x * m_s1 + df.y;\r\n      const LA = df2.x * this.m_s1 + df2.y;\r\n      // float32 LB = df.x * m_s2 + df.y;\r\n      const LB = df2.x * this.m_s2 + df2.y;\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * LA;\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * LB;\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  // A velocity based solver computes reaction forces(impulses) using the velocity constraint solver.Under this context,\r\n  // the position solver is not there to resolve forces.It is only there to cope with integration error.\r\n  //\r\n  // Therefore, the pseudo impulses in the position solver do not have any physical meaning.Thus it is okay if they suck.\r\n  //\r\n  // We could take the active state from the velocity solver.However, the joint might push past the limit when the velocity\r\n  // solver indicates the limit is inactive.\r\n  private static SolvePositionConstraints_s_d = new b2Vec2();\r\n  private static SolvePositionConstraints_s_impulse = new b2Vec3();\r\n  private static SolvePositionConstraints_s_impulse1 = new b2Vec2();\r\n  private static SolvePositionConstraints_s_P = new b2Vec2();\r\n  public SolvePositionConstraints(data: b2SolverData): boolean {\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    let aA: number = data.positions[this.m_indexA].a;\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    let aB: number = data.positions[this.m_indexB].a;\r\n\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n    const rA: b2Vec2 = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n    // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n    const rB: b2Vec2 = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n    // b2Vec2 d = cB + rB - cA - rA;\r\n    const d: b2Vec2 = b2Vec2.SubVV(\r\n      b2Vec2.AddVV(cB, rB, b2Vec2.s_t0),\r\n      b2Vec2.AddVV(cA, rA, b2Vec2.s_t1),\r\n      b2PrismaticJoint.SolvePositionConstraints_s_d);\r\n\r\n    // b2Vec2 axis = b2Mul(qA, m_localXAxisA);\r\n    const axis: b2Vec2 = b2Rot.MulRV(qA, this.m_localXAxisA, this.m_axis);\r\n    // float32 a1 = b2Cross(d + rA, axis);\r\n    const a1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), axis);\r\n    // float32 a2 = b2Cross(rB, axis);\r\n    const a2 = b2Vec2.CrossVV(rB, axis);\r\n    // b2Vec2 perp = b2Mul(qA, m_localYAxisA);\r\n    const perp: b2Vec2 = b2Rot.MulRV(qA, this.m_localYAxisA, this.m_perp);\r\n\r\n    // float32 s1 = b2Cross(d + rA, perp);\r\n    const s1 = b2Vec2.CrossVV(b2Vec2.AddVV(d, rA, b2Vec2.s_t0), perp);\r\n    // float32 s2 = b2Cross(rB, perp);\r\n    const s2 = b2Vec2.CrossVV(rB, perp);\r\n\r\n    // b2Vec3 impulse;\r\n    let impulse = b2PrismaticJoint.SolvePositionConstraints_s_impulse;\r\n    // b2Vec2 C1;\r\n    // C1.x = b2Dot(perp, d);\r\n    const C1_x: number = b2Vec2.DotVV(perp, d);\r\n    // C1.y = aB - aA - m_referenceAngle;\r\n    const C1_y = aB - aA - this.m_referenceAngle;\r\n\r\n    let linearError = b2Abs(C1_x);\r\n    const angularError = b2Abs(C1_y);\r\n\r\n    let active = false;\r\n    let C2: number = 0;\r\n    if (this.m_enableLimit) {\r\n      // float32 translation = b2Dot(axis, d);\r\n      const translation: number = b2Vec2.DotVV(axis, d);\r\n      if (b2Abs(this.m_upperTranslation - this.m_lowerTranslation) < 2 * b2_linearSlop) {\r\n        // Prevent large angular corrections\r\n        C2 = b2Clamp(translation, (-b2_maxLinearCorrection), b2_maxLinearCorrection);\r\n        linearError = b2Max(linearError, b2Abs(translation));\r\n        active = true;\r\n      } else if (translation <= this.m_lowerTranslation) {\r\n        // Prevent large linear corrections and allow some slop.\r\n        C2 = b2Clamp(translation - this.m_lowerTranslation + b2_linearSlop, (-b2_maxLinearCorrection), 0);\r\n        linearError = b2Max(linearError, this.m_lowerTranslation - translation);\r\n        active = true;\r\n      } else if (translation >= this.m_upperTranslation) {\r\n        // Prevent large linear corrections and allow some slop.\r\n        C2 = b2Clamp(translation - this.m_upperTranslation - b2_linearSlop, 0, b2_maxLinearCorrection);\r\n        linearError = b2Max(linearError, translation - this.m_upperTranslation);\r\n        active = true;\r\n      }\r\n    }\r\n\r\n    if (active) {\r\n      // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n      // float32 k12 = iA * s1 + iB * s2;\r\n      const k12 = iA * s1 + iB * s2;\r\n      // float32 k13 = iA * s1 * a1 + iB * s2 * a2;\r\n      const k13 = iA * s1 * a1 + iB * s2 * a2;\r\n      // float32 k22 = iA + iB;\r\n      let k22 = iA + iB;\r\n      if (k22 === 0) {\r\n        // For fixed rotation\r\n        k22 = 1;\r\n      }\r\n      // float32 k23 = iA * a1 + iB * a2;\r\n      const k23 = iA * a1 + iB * a2;\r\n      // float32 k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\r\n\r\n      // b2Mat33 K;\r\n      const K = this.m_K3;\r\n      // K.ex.Set(k11, k12, k13);\r\n      K.ex.SetXYZ(k11, k12, k13);\r\n      // K.ey.Set(k12, k22, k23);\r\n      K.ey.SetXYZ(k12, k22, k23);\r\n      // K.ez.Set(k13, k23, k33);\r\n      K.ez.SetXYZ(k13, k23, k33);\r\n\r\n      // b2Vec3 C;\r\n      // C.x = C1.x;\r\n      // C.y = C1.y;\r\n      // C.z = C2;\r\n\r\n      // impulse = K.Solve33(-C);\r\n      impulse = K.Solve33((-C1_x), (-C1_y), (-C2), impulse);\r\n    } else {\r\n      // float32 k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\r\n      // float32 k12 = iA * s1 + iB * s2;\r\n      const k12 = iA * s1 + iB * s2;\r\n      // float32 k22 = iA + iB;\r\n      let k22 = iA + iB;\r\n      if (k22 === 0) {\r\n        k22 = 1;\r\n      }\r\n\r\n      // b2Mat22 K;\r\n      const K2 = this.m_K2;\r\n      // K.ex.Set(k11, k12);\r\n      K2.ex.Set(k11, k12);\r\n      // K.ey.Set(k12, k22);\r\n      K2.ey.Set(k12, k22);\r\n\r\n      // b2Vec2 impulse1 = K.Solve(-C1);\r\n      const impulse1 = K2.Solve((-C1_x), (-C1_y), b2PrismaticJoint.SolvePositionConstraints_s_impulse1);\r\n      impulse.x = impulse1.x;\r\n      impulse.y = impulse1.y;\r\n      impulse.z = 0;\r\n    }\r\n\r\n    // b2Vec2 P = impulse.x * perp + impulse.z * axis;\r\n    const P: b2Vec2 = b2Vec2.AddVV(\r\n      b2Vec2.MulSV(impulse.x, perp, b2Vec2.s_t0),\r\n      b2Vec2.MulSV(impulse.z, axis, b2Vec2.s_t1),\r\n      b2PrismaticJoint.SolvePositionConstraints_s_P);\r\n    // float32 LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1;\r\n    // float32 LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2;\r\n\r\n    // cA -= mA * P;\r\n    cA.SelfMulSub(mA, P);\r\n    aA -= iA * LA;\r\n    // cB += mB * P;\r\n    cB.SelfMulAdd(mB, P);\r\n    aB += iB * LB;\r\n\r\n    // data.positions[this.m_indexA].c = cA;\r\n    data.positions[this.m_indexA].a = aA;\r\n    // data.positions[this.m_indexB].c = cB;\r\n    data.positions[this.m_indexB].a = aB;\r\n\r\n    return linearError <= b2_linearSlop && angularError <= b2_angularSlop;\r\n  }\r\n\r\n  public GetAnchorA<T extends XY>(out: T): T {\r\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n  }\r\n\r\n  public GetAnchorB<T extends XY>(out: T): T {\r\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n  }\r\n\r\n  public GetReactionForce<T extends XY>(inv_dt: number, out: T): T {\r\n    // return inv_dt * (m_impulse.x * m_perp + (m_motorImpulse + m_impulse.z) * m_axis);\r\n    out.x = inv_dt * (this.m_impulse.x * this.m_perp.x + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.x);\r\n    out.y = inv_dt * (this.m_impulse.x * this.m_perp.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_axis.y);\r\n    return out;\r\n  }\r\n\r\n  public GetReactionTorque(inv_dt: number): number {\r\n    return inv_dt * this.m_impulse.y;\r\n  }\r\n\r\n  public GetLocalAnchorA(): Readonly<b2Vec2> { return this.m_localAnchorA; }\r\n\r\n  public GetLocalAnchorB(): Readonly<b2Vec2> { return this.m_localAnchorB; }\r\n\r\n  public GetLocalAxisA(): Readonly<b2Vec2> { return this.m_localXAxisA; }\r\n\r\n  public GetReferenceAngle() { return this.m_referenceAngle; }\r\n\r\n  private static GetJointTranslation_s_pA = new b2Vec2();\r\n  private static GetJointTranslation_s_pB = new b2Vec2();\r\n  private static GetJointTranslation_s_d = new b2Vec2();\r\n  private static GetJointTranslation_s_axis = new b2Vec2();\r\n  public GetJointTranslation(): number {\r\n    // b2Vec2 pA = m_bodyA.GetWorldPoint(m_localAnchorA);\r\n    const pA = this.m_bodyA.GetWorldPoint(this.m_localAnchorA, b2PrismaticJoint.GetJointTranslation_s_pA);\r\n    // b2Vec2 pB = m_bodyB.GetWorldPoint(m_localAnchorB);\r\n    const pB = this.m_bodyB.GetWorldPoint(this.m_localAnchorB, b2PrismaticJoint.GetJointTranslation_s_pB);\r\n    // b2Vec2 d = pB - pA;\r\n    const d: b2Vec2 = b2Vec2.SubVV(pB, pA, b2PrismaticJoint.GetJointTranslation_s_d);\r\n    // b2Vec2 axis = m_bodyA.GetWorldVector(m_localXAxisA);\r\n    const axis = this.m_bodyA.GetWorldVector(this.m_localXAxisA, b2PrismaticJoint.GetJointTranslation_s_axis);\r\n\r\n    // float32 translation = b2Dot(d, axis);\r\n    const translation: number = b2Vec2.DotVV(d, axis);\r\n    return translation;\r\n  }\r\n\r\n  public GetJointSpeed(): number {\r\n    const bA: b2Body = this.m_bodyA;\r\n    const bB: b2Body = this.m_bodyB;\r\n\r\n    // b2Vec2 rA = b2Mul(bA->m_xf.q, m_localAnchorA - bA->m_sweep.localCenter);\r\n    b2Vec2.SubVV(this.m_localAnchorA, bA.m_sweep.localCenter, this.m_lalcA);\r\n    const rA: b2Vec2 = b2Rot.MulRV(bA.m_xf.q, this.m_lalcA, this.m_rA);\r\n    // b2Vec2 rB = b2Mul(bB->m_xf.q, m_localAnchorB - bB->m_sweep.localCenter);\r\n    b2Vec2.SubVV(this.m_localAnchorB, bB.m_sweep.localCenter, this.m_lalcB);\r\n    const rB: b2Vec2 = b2Rot.MulRV(bB.m_xf.q, this.m_lalcB, this.m_rB);\r\n    // b2Vec2 pA = bA->m_sweep.c + rA;\r\n    const pA: b2Vec2 = b2Vec2.AddVV(bA.m_sweep.c, rA, b2Vec2.s_t0); // pA uses s_t0\r\n    // b2Vec2 pB = bB->m_sweep.c + rB;\r\n    const pB: b2Vec2 = b2Vec2.AddVV(bB.m_sweep.c, rB, b2Vec2.s_t1); // pB uses s_t1\r\n    // b2Vec2 d = pB - pA;\r\n    const d: b2Vec2 = b2Vec2.SubVV(pB, pA, b2Vec2.s_t2); // d uses s_t2\r\n    // b2Vec2 axis = b2Mul(bA.m_xf.q, m_localXAxisA);\r\n    const axis = bA.GetWorldVector(this.m_localXAxisA, this.m_axis);\r\n\r\n    const vA = bA.m_linearVelocity;\r\n    const vB = bB.m_linearVelocity;\r\n    const wA = bA.m_angularVelocity;\r\n    const wB = bB.m_angularVelocity;\r\n\r\n    // float32 speed = b2Dot(d, b2Cross(wA, axis)) + b2Dot(axis, vB + b2Cross(wB, rB) - vA - b2Cross(wA, rA));\r\n    const speed =\r\n      b2Vec2.DotVV(d, b2Vec2.CrossSV(wA, axis, b2Vec2.s_t0)) +\r\n      b2Vec2.DotVV(\r\n        axis,\r\n        b2Vec2.SubVV(\r\n          b2Vec2.AddVCrossSV(vB, wB, rB, b2Vec2.s_t0),\r\n          b2Vec2.AddVCrossSV(vA, wA, rA, b2Vec2.s_t1),\r\n          b2Vec2.s_t0));\r\n    return speed;\r\n  }\r\n\r\n  public IsLimitEnabled() {\r\n    return this.m_enableLimit;\r\n  }\r\n\r\n  public EnableLimit(flag: boolean) {\r\n    if (flag !== this.m_enableLimit) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_enableLimit = flag;\r\n      this.m_impulse.z = 0;\r\n    }\r\n  }\r\n\r\n  public GetLowerLimit() {\r\n    return this.m_lowerTranslation;\r\n  }\r\n\r\n  public GetUpperLimit() {\r\n    return this.m_upperTranslation;\r\n  }\r\n\r\n  public SetLimits(lower: number, upper: number): void {\r\n    if (lower !== this.m_lowerTranslation || upper !== this.m_upperTranslation) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_lowerTranslation = lower;\r\n      this.m_upperTranslation = upper;\r\n      this.m_impulse.z = 0;\r\n    }\r\n  }\r\n\r\n  public IsMotorEnabled(): boolean {\r\n    return this.m_enableMotor;\r\n  }\r\n\r\n  public EnableMotor(flag: boolean): void {\r\n    if (flag !== this.m_enableMotor) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_enableMotor = flag;\r\n    }\r\n  }\r\n\r\n  public SetMotorSpeed(speed: number): void {\r\n    if (speed !== this.m_motorSpeed) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_motorSpeed = speed;\r\n    }\r\n  }\r\n\r\n  public GetMotorSpeed() {\r\n    return this.m_motorSpeed;\r\n  }\r\n\r\n  public SetMaxMotorForce(force: number): void {\r\n    if (force !== this.m_maxMotorForce) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_maxMotorForce = force;\r\n    }\r\n  }\r\n\r\n  public GetMaxMotorForce(): number { return this.m_maxMotorForce; }\r\n\r\n  public GetMotorForce(inv_dt: number): number {\r\n    return inv_dt * this.m_motorImpulse;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void) {\r\n    const indexA = this.m_bodyA.m_islandIndex;\r\n    const indexB = this.m_bodyB.m_islandIndex;\r\n\r\n    log(\"  const jd: b2PrismaticJointDef = new b2PrismaticJointDef();\\n\");\r\n    log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n    log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n    log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n    log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n    log(\"  jd.localAxisA.Set(%.15f, %.15f);\\n\", this.m_localXAxisA.x, this.m_localXAxisA.y);\r\n    log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n    log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.lowerTranslation = %.15f;\\n\", this.m_lowerTranslation);\r\n    log(\"  jd.upperTranslation = %.15f;\\n\", this.m_upperTranslation);\r\n    log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n    log(\"  jd.maxMotorForce = %.15f;\\n\", this.m_maxMotorForce);\r\n    log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n  }\r\n}\r\n"]}},"error":null,"hash":"b3b0a6355d61d5077db2ab1ba0745828","cacheData":{"env":{}}}