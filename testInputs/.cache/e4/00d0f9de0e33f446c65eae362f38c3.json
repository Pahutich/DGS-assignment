{"id":"../node_modules/box2d.package.ts/Collision/b2Distance.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Distance.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Distance.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\n/// A distance proxy is used by the GJK algorithm.\r\n/// It encapsulates any shape.\r\nvar b2DistanceProxy = /** @class */ (function () {\r\n    function b2DistanceProxy() {\r\n        this.m_buffer = b2Math_1.b2Vec2.MakeArray(2);\r\n        this.m_vertices = this.m_buffer;\r\n        this.m_count = 0;\r\n        this.m_radius = 0;\r\n    }\r\n    b2DistanceProxy.prototype.Copy = function (other) {\r\n        if (other.m_vertices === other.m_buffer) {\r\n            this.m_vertices = this.m_buffer;\r\n            this.m_buffer[0].Copy(other.m_buffer[0]);\r\n            this.m_buffer[1].Copy(other.m_buffer[1]);\r\n        }\r\n        else {\r\n            this.m_vertices = other.m_vertices;\r\n        }\r\n        this.m_count = other.m_count;\r\n        this.m_radius = other.m_radius;\r\n        return this;\r\n    };\r\n    b2DistanceProxy.prototype.Reset = function () {\r\n        this.m_vertices = this.m_buffer;\r\n        this.m_count = 0;\r\n        this.m_radius = 0;\r\n        return this;\r\n    };\r\n    b2DistanceProxy.prototype.SetShape = function (shape, index) {\r\n        shape.SetupDistanceProxy(this, index);\r\n    };\r\n    b2DistanceProxy.prototype.SetVerticesRadius = function (vertices, count, radius) {\r\n        this.m_vertices = vertices;\r\n        this.m_count = count;\r\n        this.m_radius = radius;\r\n    };\r\n    b2DistanceProxy.prototype.GetSupport = function (d) {\r\n        var bestIndex = 0;\r\n        var bestValue = b2Math_1.b2Vec2.DotVV(this.m_vertices[0], d);\r\n        for (var i = 1; i < this.m_count; ++i) {\r\n            var value = b2Math_1.b2Vec2.DotVV(this.m_vertices[i], d);\r\n            if (value > bestValue) {\r\n                bestIndex = i;\r\n                bestValue = value;\r\n            }\r\n        }\r\n        return bestIndex;\r\n    };\r\n    b2DistanceProxy.prototype.GetSupportVertex = function (d) {\r\n        var bestIndex = 0;\r\n        var bestValue = b2Math_1.b2Vec2.DotVV(this.m_vertices[0], d);\r\n        for (var i = 1; i < this.m_count; ++i) {\r\n            var value = b2Math_1.b2Vec2.DotVV(this.m_vertices[i], d);\r\n            if (value > bestValue) {\r\n                bestIndex = i;\r\n                bestValue = value;\r\n            }\r\n        }\r\n        return this.m_vertices[bestIndex];\r\n    };\r\n    b2DistanceProxy.prototype.GetVertexCount = function () {\r\n        return this.m_count;\r\n    };\r\n    b2DistanceProxy.prototype.GetVertex = function (index) {\r\n        // DEBUG: b2Assert(0 <= index && index < this.m_count);\r\n        return this.m_vertices[index];\r\n    };\r\n    return b2DistanceProxy;\r\n}());\r\nexports.b2DistanceProxy = b2DistanceProxy;\r\nvar b2SimplexCache = /** @class */ (function () {\r\n    function b2SimplexCache() {\r\n        this.metric = 0;\r\n        this.count = 0;\r\n        this.indexA = [0, 0, 0];\r\n        this.indexB = [0, 0, 0];\r\n    }\r\n    b2SimplexCache.prototype.Reset = function () {\r\n        this.metric = 0;\r\n        this.count = 0;\r\n        return this;\r\n    };\r\n    return b2SimplexCache;\r\n}());\r\nexports.b2SimplexCache = b2SimplexCache;\r\nvar b2DistanceInput = /** @class */ (function () {\r\n    function b2DistanceInput() {\r\n        this.proxyA = new b2DistanceProxy();\r\n        this.proxyB = new b2DistanceProxy();\r\n        this.transformA = new b2Math_1.b2Transform();\r\n        this.transformB = new b2Math_1.b2Transform();\r\n        this.useRadii = false;\r\n    }\r\n    b2DistanceInput.prototype.Reset = function () {\r\n        this.proxyA.Reset();\r\n        this.proxyB.Reset();\r\n        this.transformA.SetIdentity();\r\n        this.transformB.SetIdentity();\r\n        this.useRadii = false;\r\n        return this;\r\n    };\r\n    return b2DistanceInput;\r\n}());\r\nexports.b2DistanceInput = b2DistanceInput;\r\nvar b2DistanceOutput = /** @class */ (function () {\r\n    function b2DistanceOutput() {\r\n        this.pointA = new b2Math_1.b2Vec2();\r\n        this.pointB = new b2Math_1.b2Vec2();\r\n        this.distance = 0;\r\n        this.iterations = 0; ///< number of GJK iterations used\r\n    }\r\n    b2DistanceOutput.prototype.Reset = function () {\r\n        this.pointA.SetZero();\r\n        this.pointB.SetZero();\r\n        this.distance = 0;\r\n        this.iterations = 0;\r\n        return this;\r\n    };\r\n    return b2DistanceOutput;\r\n}());\r\nexports.b2DistanceOutput = b2DistanceOutput;\r\n/// Input parameters for b2ShapeCast\r\nvar b2ShapeCastInput = /** @class */ (function () {\r\n    function b2ShapeCastInput() {\r\n        this.proxyA = new b2DistanceProxy();\r\n        this.proxyB = new b2DistanceProxy();\r\n        this.transformA = new b2Math_1.b2Transform();\r\n        this.transformB = new b2Math_1.b2Transform();\r\n        this.translationB = new b2Math_1.b2Vec2();\r\n    }\r\n    return b2ShapeCastInput;\r\n}());\r\nexports.b2ShapeCastInput = b2ShapeCastInput;\r\n/// Output results for b2ShapeCast\r\nvar b2ShapeCastOutput = /** @class */ (function () {\r\n    function b2ShapeCastOutput() {\r\n        this.point = new b2Math_1.b2Vec2();\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.lambda = 0.0;\r\n        this.iterations = 0;\r\n    }\r\n    return b2ShapeCastOutput;\r\n}());\r\nexports.b2ShapeCastOutput = b2ShapeCastOutput;\r\nexports.b2_gjkCalls = 0;\r\nexports.b2_gjkIters = 0;\r\nexports.b2_gjkMaxIters = 0;\r\nfunction b2_gjk_reset() {\r\n    exports.b2_gjkCalls = 0;\r\n    exports.b2_gjkIters = 0;\r\n    exports.b2_gjkMaxIters = 0;\r\n}\r\nexports.b2_gjk_reset = b2_gjk_reset;\r\nvar b2SimplexVertex = /** @class */ (function () {\r\n    function b2SimplexVertex() {\r\n        this.wA = new b2Math_1.b2Vec2(); // support point in proxyA\r\n        this.wB = new b2Math_1.b2Vec2(); // support point in proxyB\r\n        this.w = new b2Math_1.b2Vec2(); // wB - wA\r\n        this.a = 0; // barycentric coordinate for closest point\r\n        this.indexA = 0; // wA index\r\n        this.indexB = 0; // wB index\r\n    }\r\n    b2SimplexVertex.prototype.Copy = function (other) {\r\n        this.wA.Copy(other.wA); // support point in proxyA\r\n        this.wB.Copy(other.wB); // support point in proxyB\r\n        this.w.Copy(other.w); // wB - wA\r\n        this.a = other.a; // barycentric coordinate for closest point\r\n        this.indexA = other.indexA; // wA index\r\n        this.indexB = other.indexB; // wB index\r\n        return this;\r\n    };\r\n    return b2SimplexVertex;\r\n}());\r\nexports.b2SimplexVertex = b2SimplexVertex;\r\nvar b2Simplex = /** @class */ (function () {\r\n    function b2Simplex() {\r\n        this.m_v1 = new b2SimplexVertex();\r\n        this.m_v2 = new b2SimplexVertex();\r\n        this.m_v3 = new b2SimplexVertex();\r\n        this.m_vertices = [ /*3*/];\r\n        this.m_count = 0;\r\n        this.m_vertices[0] = this.m_v1;\r\n        this.m_vertices[1] = this.m_v2;\r\n        this.m_vertices[2] = this.m_v3;\r\n    }\r\n    b2Simplex.prototype.ReadCache = function (cache, proxyA, transformA, proxyB, transformB) {\r\n        // DEBUG: b2Assert(0 <= cache.count && cache.count <= 3);\r\n        // Copy data from cache.\r\n        this.m_count = cache.count;\r\n        var vertices = this.m_vertices;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var v = vertices[i];\r\n            v.indexA = cache.indexA[i];\r\n            v.indexB = cache.indexB[i];\r\n            var wALocal = proxyA.GetVertex(v.indexA);\r\n            var wBLocal = proxyB.GetVertex(v.indexB);\r\n            b2Math_1.b2Transform.MulXV(transformA, wALocal, v.wA);\r\n            b2Math_1.b2Transform.MulXV(transformB, wBLocal, v.wB);\r\n            b2Math_1.b2Vec2.SubVV(v.wB, v.wA, v.w);\r\n            v.a = 0;\r\n        }\r\n        // Compute the new simplex metric, if it is substantially different than\r\n        // old metric then flush the simplex.\r\n        if (this.m_count > 1) {\r\n            var metric1 = cache.metric;\r\n            var metric2 = this.GetMetric();\r\n            if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < b2Settings_1.b2_epsilon) {\r\n                // Reset the simplex.\r\n                this.m_count = 0;\r\n            }\r\n        }\r\n        // If the cache is empty or invalid ...\r\n        if (this.m_count === 0) {\r\n            var v = vertices[0];\r\n            v.indexA = 0;\r\n            v.indexB = 0;\r\n            var wALocal = proxyA.GetVertex(0);\r\n            var wBLocal = proxyB.GetVertex(0);\r\n            b2Math_1.b2Transform.MulXV(transformA, wALocal, v.wA);\r\n            b2Math_1.b2Transform.MulXV(transformB, wBLocal, v.wB);\r\n            b2Math_1.b2Vec2.SubVV(v.wB, v.wA, v.w);\r\n            v.a = 1;\r\n            this.m_count = 1;\r\n        }\r\n    };\r\n    b2Simplex.prototype.WriteCache = function (cache) {\r\n        cache.metric = this.GetMetric();\r\n        cache.count = this.m_count;\r\n        var vertices = this.m_vertices;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            cache.indexA[i] = vertices[i].indexA;\r\n            cache.indexB[i] = vertices[i].indexB;\r\n        }\r\n    };\r\n    b2Simplex.prototype.GetSearchDirection = function (out) {\r\n        switch (this.m_count) {\r\n            case 1:\r\n                return b2Math_1.b2Vec2.NegV(this.m_v1.w, out);\r\n            case 2: {\r\n                var e12 = b2Math_1.b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, out);\r\n                var sgn = b2Math_1.b2Vec2.CrossVV(e12, b2Math_1.b2Vec2.NegV(this.m_v1.w, b2Math_1.b2Vec2.s_t0));\r\n                if (sgn > 0) {\r\n                    // Origin is left of e12.\r\n                    return b2Math_1.b2Vec2.CrossOneV(e12, out);\r\n                }\r\n                else {\r\n                    // Origin is right of e12.\r\n                    return b2Math_1.b2Vec2.CrossVOne(e12, out);\r\n                }\r\n            }\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                return out.SetZero();\r\n        }\r\n    };\r\n    b2Simplex.prototype.GetClosestPoint = function (out) {\r\n        switch (this.m_count) {\r\n            case 0:\r\n                // DEBUG: b2Assert(false);\r\n                return out.SetZero();\r\n            case 1:\r\n                return out.Copy(this.m_v1.w);\r\n            case 2:\r\n                return out.Set(this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x, this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);\r\n            case 3:\r\n                return out.SetZero();\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                return out.SetZero();\r\n        }\r\n    };\r\n    b2Simplex.prototype.GetWitnessPoints = function (pA, pB) {\r\n        switch (this.m_count) {\r\n            case 0:\r\n                // DEBUG: b2Assert(false);\r\n                break;\r\n            case 1:\r\n                pA.Copy(this.m_v1.wA);\r\n                pB.Copy(this.m_v1.wB);\r\n                break;\r\n            case 2:\r\n                pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;\r\n                pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;\r\n                pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;\r\n                pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;\r\n                break;\r\n            case 3:\r\n                pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;\r\n                pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;\r\n                break;\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                break;\r\n        }\r\n    };\r\n    b2Simplex.prototype.GetMetric = function () {\r\n        switch (this.m_count) {\r\n            case 0:\r\n                // DEBUG: b2Assert(false);\r\n                return 0;\r\n            case 1:\r\n                return 0;\r\n            case 2:\r\n                return b2Math_1.b2Vec2.DistanceVV(this.m_v1.w, this.m_v2.w);\r\n            case 3:\r\n                return b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.SubVV(this.m_v3.w, this.m_v1.w, b2Math_1.b2Vec2.s_t1));\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                return 0;\r\n        }\r\n    };\r\n    b2Simplex.prototype.Solve2 = function () {\r\n        var w1 = this.m_v1.w;\r\n        var w2 = this.m_v2.w;\r\n        var e12 = b2Math_1.b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);\r\n        // w1 region\r\n        var d12_2 = (-b2Math_1.b2Vec2.DotVV(w1, e12));\r\n        if (d12_2 <= 0) {\r\n            // a2 <= 0, so we clamp it to 0\r\n            this.m_v1.a = 1;\r\n            this.m_count = 1;\r\n            return;\r\n        }\r\n        // w2 region\r\n        var d12_1 = b2Math_1.b2Vec2.DotVV(w2, e12);\r\n        if (d12_1 <= 0) {\r\n            // a1 <= 0, so we clamp it to 0\r\n            this.m_v2.a = 1;\r\n            this.m_count = 1;\r\n            this.m_v1.Copy(this.m_v2);\r\n            return;\r\n        }\r\n        // Must be in e12 region.\r\n        var inv_d12 = 1 / (d12_1 + d12_2);\r\n        this.m_v1.a = d12_1 * inv_d12;\r\n        this.m_v2.a = d12_2 * inv_d12;\r\n        this.m_count = 2;\r\n    };\r\n    b2Simplex.prototype.Solve3 = function () {\r\n        var w1 = this.m_v1.w;\r\n        var w2 = this.m_v2.w;\r\n        var w3 = this.m_v3.w;\r\n        // Edge12\r\n        // [1      1     ][a1] = [1]\r\n        // [w1.e12 w2.e12][a2] = [0]\r\n        // a3 = 0\r\n        var e12 = b2Math_1.b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);\r\n        var w1e12 = b2Math_1.b2Vec2.DotVV(w1, e12);\r\n        var w2e12 = b2Math_1.b2Vec2.DotVV(w2, e12);\r\n        var d12_1 = w2e12;\r\n        var d12_2 = (-w1e12);\r\n        // Edge13\r\n        // [1      1     ][a1] = [1]\r\n        // [w1.e13 w3.e13][a3] = [0]\r\n        // a2 = 0\r\n        var e13 = b2Math_1.b2Vec2.SubVV(w3, w1, b2Simplex.s_e13);\r\n        var w1e13 = b2Math_1.b2Vec2.DotVV(w1, e13);\r\n        var w3e13 = b2Math_1.b2Vec2.DotVV(w3, e13);\r\n        var d13_1 = w3e13;\r\n        var d13_2 = (-w1e13);\r\n        // Edge23\r\n        // [1      1     ][a2] = [1]\r\n        // [w2.e23 w3.e23][a3] = [0]\r\n        // a1 = 0\r\n        var e23 = b2Math_1.b2Vec2.SubVV(w3, w2, b2Simplex.s_e23);\r\n        var w2e23 = b2Math_1.b2Vec2.DotVV(w2, e23);\r\n        var w3e23 = b2Math_1.b2Vec2.DotVV(w3, e23);\r\n        var d23_1 = w3e23;\r\n        var d23_2 = (-w2e23);\r\n        // Triangle123\r\n        var n123 = b2Math_1.b2Vec2.CrossVV(e12, e13);\r\n        var d123_1 = n123 * b2Math_1.b2Vec2.CrossVV(w2, w3);\r\n        var d123_2 = n123 * b2Math_1.b2Vec2.CrossVV(w3, w1);\r\n        var d123_3 = n123 * b2Math_1.b2Vec2.CrossVV(w1, w2);\r\n        // w1 region\r\n        if (d12_2 <= 0 && d13_2 <= 0) {\r\n            this.m_v1.a = 1;\r\n            this.m_count = 1;\r\n            return;\r\n        }\r\n        // e12\r\n        if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {\r\n            var inv_d12 = 1 / (d12_1 + d12_2);\r\n            this.m_v1.a = d12_1 * inv_d12;\r\n            this.m_v2.a = d12_2 * inv_d12;\r\n            this.m_count = 2;\r\n            return;\r\n        }\r\n        // e13\r\n        if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {\r\n            var inv_d13 = 1 / (d13_1 + d13_2);\r\n            this.m_v1.a = d13_1 * inv_d13;\r\n            this.m_v3.a = d13_2 * inv_d13;\r\n            this.m_count = 2;\r\n            this.m_v2.Copy(this.m_v3);\r\n            return;\r\n        }\r\n        // w2 region\r\n        if (d12_1 <= 0 && d23_2 <= 0) {\r\n            this.m_v2.a = 1;\r\n            this.m_count = 1;\r\n            this.m_v1.Copy(this.m_v2);\r\n            return;\r\n        }\r\n        // w3 region\r\n        if (d13_1 <= 0 && d23_1 <= 0) {\r\n            this.m_v3.a = 1;\r\n            this.m_count = 1;\r\n            this.m_v1.Copy(this.m_v3);\r\n            return;\r\n        }\r\n        // e23\r\n        if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {\r\n            var inv_d23 = 1 / (d23_1 + d23_2);\r\n            this.m_v2.a = d23_1 * inv_d23;\r\n            this.m_v3.a = d23_2 * inv_d23;\r\n            this.m_count = 2;\r\n            this.m_v1.Copy(this.m_v3);\r\n            return;\r\n        }\r\n        // Must be in triangle123\r\n        var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);\r\n        this.m_v1.a = d123_1 * inv_d123;\r\n        this.m_v2.a = d123_2 * inv_d123;\r\n        this.m_v3.a = d123_3 * inv_d123;\r\n        this.m_count = 3;\r\n    };\r\n    b2Simplex.s_e12 = new b2Math_1.b2Vec2();\r\n    b2Simplex.s_e13 = new b2Math_1.b2Vec2();\r\n    b2Simplex.s_e23 = new b2Math_1.b2Vec2();\r\n    return b2Simplex;\r\n}());\r\nexports.b2Simplex = b2Simplex;\r\nvar b2Distance_s_simplex = new b2Simplex();\r\nvar b2Distance_s_saveA = [0, 0, 0];\r\nvar b2Distance_s_saveB = [0, 0, 0];\r\nvar b2Distance_s_p = new b2Math_1.b2Vec2();\r\nvar b2Distance_s_d = new b2Math_1.b2Vec2();\r\nvar b2Distance_s_normal = new b2Math_1.b2Vec2();\r\nvar b2Distance_s_supportA = new b2Math_1.b2Vec2();\r\nvar b2Distance_s_supportB = new b2Math_1.b2Vec2();\r\nfunction b2Distance(output, cache, input) {\r\n    ++exports.b2_gjkCalls;\r\n    var proxyA = input.proxyA;\r\n    var proxyB = input.proxyB;\r\n    var transformA = input.transformA;\r\n    var transformB = input.transformB;\r\n    // Initialize the simplex.\r\n    var simplex = b2Distance_s_simplex;\r\n    simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);\r\n    // Get simplex vertices as an array.\r\n    var vertices = simplex.m_vertices;\r\n    var k_maxIters = 20;\r\n    // These store the vertices of the last simplex so that we\r\n    // can check for duplicates and prevent cycling.\r\n    var saveA = b2Distance_s_saveA;\r\n    var saveB = b2Distance_s_saveB;\r\n    var saveCount = 0;\r\n    // Main iteration loop.\r\n    var iter = 0;\r\n    while (iter < k_maxIters) {\r\n        // Copy simplex so we can identify duplicates.\r\n        saveCount = simplex.m_count;\r\n        for (var i = 0; i < saveCount; ++i) {\r\n            saveA[i] = vertices[i].indexA;\r\n            saveB[i] = vertices[i].indexB;\r\n        }\r\n        switch (simplex.m_count) {\r\n            case 1:\r\n                break;\r\n            case 2:\r\n                simplex.Solve2();\r\n                break;\r\n            case 3:\r\n                simplex.Solve3();\r\n                break;\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                break;\r\n        }\r\n        // If we have 3 points, then the origin is in the corresponding triangle.\r\n        if (simplex.m_count === 3) {\r\n            break;\r\n        }\r\n        // Get search direction.\r\n        var d = simplex.GetSearchDirection(b2Distance_s_d);\r\n        // Ensure the search direction is numerically fit.\r\n        if (d.LengthSquared() < b2Settings_1.b2_epsilon_sq) {\r\n            // The origin is probably contained by a line segment\r\n            // or triangle. Thus the shapes are overlapped.\r\n            // We can't return zero here even though there may be overlap.\r\n            // In case the simplex is a point, segment, or triangle it is difficult\r\n            // to determine if the origin is contained in the CSO or very close to it.\r\n            break;\r\n        }\r\n        // Compute a tentative new simplex vertex using support points.\r\n        var vertex = vertices[simplex.m_count];\r\n        vertex.indexA = proxyA.GetSupport(b2Math_1.b2Rot.MulTRV(transformA.q, b2Math_1.b2Vec2.NegV(d, b2Math_1.b2Vec2.s_t0), b2Distance_s_supportA));\r\n        b2Math_1.b2Transform.MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);\r\n        vertex.indexB = proxyB.GetSupport(b2Math_1.b2Rot.MulTRV(transformB.q, d, b2Distance_s_supportB));\r\n        b2Math_1.b2Transform.MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);\r\n        b2Math_1.b2Vec2.SubVV(vertex.wB, vertex.wA, vertex.w);\r\n        // Iteration count is equated to the number of support point calls.\r\n        ++iter;\r\n        ++exports.b2_gjkIters;\r\n        // Check for duplicate support points. This is the main termination criteria.\r\n        var duplicate = false;\r\n        for (var i = 0; i < saveCount; ++i) {\r\n            if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\r\n                duplicate = true;\r\n                break;\r\n            }\r\n        }\r\n        // If we found a duplicate support point we must exit to avoid cycling.\r\n        if (duplicate) {\r\n            break;\r\n        }\r\n        // New vertex is ok and needed.\r\n        ++simplex.m_count;\r\n    }\r\n    exports.b2_gjkMaxIters = b2Math_1.b2Max(exports.b2_gjkMaxIters, iter);\r\n    // Prepare output.\r\n    simplex.GetWitnessPoints(output.pointA, output.pointB);\r\n    output.distance = b2Math_1.b2Vec2.DistanceVV(output.pointA, output.pointB);\r\n    output.iterations = iter;\r\n    // Cache the simplex.\r\n    simplex.WriteCache(cache);\r\n    // Apply radii if requested.\r\n    if (input.useRadii) {\r\n        var rA = proxyA.m_radius;\r\n        var rB = proxyB.m_radius;\r\n        if (output.distance > (rA + rB) && output.distance > b2Settings_1.b2_epsilon) {\r\n            // Shapes are still no overlapped.\r\n            // Move the witness points to the outer surface.\r\n            output.distance -= rA + rB;\r\n            var normal = b2Math_1.b2Vec2.SubVV(output.pointB, output.pointA, b2Distance_s_normal);\r\n            normal.Normalize();\r\n            output.pointA.SelfMulAdd(rA, normal);\r\n            output.pointB.SelfMulSub(rB, normal);\r\n        }\r\n        else {\r\n            // Shapes are overlapped when radii are considered.\r\n            // Move the witness points to the middle.\r\n            var p = b2Math_1.b2Vec2.MidVV(output.pointA, output.pointB, b2Distance_s_p);\r\n            output.pointA.Copy(p);\r\n            output.pointB.Copy(p);\r\n            output.distance = 0;\r\n        }\r\n    }\r\n}\r\nexports.b2Distance = b2Distance;\r\n/// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.\r\n// GJK-raycast\r\n// Algorithm by Gino van den Bergen.\r\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls. 2010\r\n// bool b2ShapeCast(b2ShapeCastOutput* output, const b2ShapeCastInput* input);\r\nvar b2ShapeCast_s_n = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_simplex = new b2Simplex();\r\nvar b2ShapeCast_s_wA = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_wB = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_v = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_p = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_pointA = new b2Math_1.b2Vec2();\r\nvar b2ShapeCast_s_pointB = new b2Math_1.b2Vec2();\r\nfunction b2ShapeCast(output, input) {\r\n    output.iterations = 0;\r\n    output.lambda = 1.0;\r\n    output.normal.SetZero();\r\n    output.point.SetZero();\r\n    // const b2DistanceProxy* proxyA = &input.proxyA;\r\n    var proxyA = input.proxyA;\r\n    // const b2DistanceProxy* proxyB = &input.proxyB;\r\n    var proxyB = input.proxyB;\r\n    // float32 radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);\r\n    var radiusA = b2Math_1.b2Max(proxyA.m_radius, b2Settings_1.b2_polygonRadius);\r\n    // float32 radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);\r\n    var radiusB = b2Math_1.b2Max(proxyB.m_radius, b2Settings_1.b2_polygonRadius);\r\n    // float32 radius = radiusA + radiusB;\r\n    var radius = radiusA + radiusB;\r\n    // b2Transform xfA = input.transformA;\r\n    var xfA = input.transformA;\r\n    // b2Transform xfB = input.transformB;\r\n    var xfB = input.transformB;\r\n    // b2Vec2 r = input.translationB;\r\n    var r = input.translationB;\r\n    // b2Vec2 n(0.0f, 0.0f);\r\n    var n = b2ShapeCast_s_n.Set(0.0, 0.0);\r\n    // float32 lambda = 0.0f;\r\n    var lambda = 0.0;\r\n    // Initial simplex\r\n    var simplex = b2ShapeCast_s_simplex;\r\n    simplex.m_count = 0;\r\n    // Get simplex vertices as an array.\r\n    // b2SimplexVertex* vertices = &simplex.m_v1;\r\n    var vertices = simplex.m_vertices;\r\n    // Get support point in -r direction\r\n    // int32 indexA = proxyA.GetSupport(b2MulT(xfA.q, -r));\r\n    var indexA = proxyA.GetSupport(b2Math_1.b2Rot.MulTRV(xfA.q, b2Math_1.b2Vec2.NegV(r, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t0));\r\n    // b2Vec2 wA = b2Mul(xfA, proxyA.GetVertex(indexA));\r\n    var wA = b2Math_1.b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);\r\n    // int32 indexB = proxyB.GetSupport(b2MulT(xfB.q, r));\r\n    var indexB = proxyB.GetSupport(b2Math_1.b2Rot.MulTRV(xfB.q, r, b2Math_1.b2Vec2.s_t0));\r\n    // b2Vec2 wB = b2Mul(xfB, proxyB.GetVertex(indexB));\r\n    var wB = b2Math_1.b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);\r\n    // b2Vec2 v = wA - wB;\r\n    var v = b2Math_1.b2Vec2.SubVV(wA, wB, b2ShapeCast_s_v);\r\n    // Sigma is the target distance between polygons\r\n    // float32 sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);\r\n    var sigma = b2Math_1.b2Max(b2Settings_1.b2_polygonRadius, radius - b2Settings_1.b2_polygonRadius);\r\n    // const float32 tolerance = 0.5f * b2_linearSlop;\r\n    var tolerance = 0.5 * b2Settings_1.b2_linearSlop;\r\n    // Main iteration loop.\r\n    // const int32 k_maxIters = 20;\r\n    var k_maxIters = 20;\r\n    // int32 iter = 0;\r\n    var iter = 0;\r\n    // while (iter < k_maxIters && b2Abs(v.Length() - sigma) > tolerance)\r\n    while (iter < k_maxIters && b2Math_1.b2Abs(v.Length() - sigma) > tolerance) {\r\n        // DEBUG: b2Assert(simplex.m_count < 3);\r\n        output.iterations += 1;\r\n        // Support in direction -v (A - B)\r\n        // indexA = proxyA.GetSupport(b2MulT(xfA.q, -v));\r\n        indexA = proxyA.GetSupport(b2Math_1.b2Rot.MulTRV(xfA.q, b2Math_1.b2Vec2.NegV(v, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t0));\r\n        // wA = b2Mul(xfA, proxyA.GetVertex(indexA));\r\n        wA = b2Math_1.b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);\r\n        // indexB = proxyB.GetSupport(b2MulT(xfB.q, v));\r\n        indexB = proxyB.GetSupport(b2Math_1.b2Rot.MulTRV(xfB.q, v, b2Math_1.b2Vec2.s_t0));\r\n        // wB = b2Mul(xfB, proxyB.GetVertex(indexB));\r\n        wB = b2Math_1.b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);\r\n        // b2Vec2 p = wA - wB;\r\n        var p = b2Math_1.b2Vec2.SubVV(wA, wB, b2ShapeCast_s_p);\r\n        // -v is a normal at p\r\n        v.Normalize();\r\n        // Intersect ray with plane\r\n        var vp = b2Math_1.b2Vec2.DotVV(v, p);\r\n        var vr = b2Math_1.b2Vec2.DotVV(v, r);\r\n        if (vp - sigma > lambda * vr) {\r\n            if (vr <= 0.0) {\r\n                return false;\r\n            }\r\n            lambda = (vp - sigma) / vr;\r\n            if (lambda > 1.0) {\r\n                return false;\r\n            }\r\n            // n = -v;\r\n            n.Copy(v).SelfNeg();\r\n            simplex.m_count = 0;\r\n        }\r\n        // Reverse simplex since it works with B - A.\r\n        // Shift by lambda * r because we want the closest point to the current clip point.\r\n        // Note that the support point p is not shifted because we want the plane equation\r\n        // to be formed in unshifted space.\r\n        // b2SimplexVertex* vertex = vertices + simplex.m_count;\r\n        var vertex = vertices[simplex.m_count];\r\n        vertex.indexA = indexB;\r\n        // vertex.wA = wB + lambda * r;\r\n        vertex.wA.Copy(wB).SelfMulAdd(lambda, r);\r\n        vertex.indexB = indexA;\r\n        // vertex.wB = wA;\r\n        vertex.wB.Copy(wA);\r\n        // vertex.w = vertex.wB - vertex.wA;\r\n        vertex.w.Copy(vertex.wB).SelfSub(vertex.wA);\r\n        vertex.a = 1.0;\r\n        simplex.m_count += 1;\r\n        switch (simplex.m_count) {\r\n            case 1:\r\n                break;\r\n            case 2:\r\n                simplex.Solve2();\r\n                break;\r\n            case 3:\r\n                simplex.Solve3();\r\n                break;\r\n            default:\r\n            // DEBUG: b2Assert(false);\r\n        }\r\n        // If we have 3 points, then the origin is in the corresponding triangle.\r\n        if (simplex.m_count === 3) {\r\n            // Overlap\r\n            return false;\r\n        }\r\n        // Get search direction.\r\n        // v = simplex.GetClosestPoint();\r\n        simplex.GetClosestPoint(v);\r\n        // Iteration count is equated to the number of support point calls.\r\n        ++iter;\r\n    }\r\n    // Prepare output.\r\n    var pointA = b2ShapeCast_s_pointA;\r\n    var pointB = b2ShapeCast_s_pointB;\r\n    simplex.GetWitnessPoints(pointA, pointB);\r\n    if (v.LengthSquared() > 0.0) {\r\n        // n = -v;\r\n        n.Copy(v).SelfNeg();\r\n        n.Normalize();\r\n    }\r\n    // output.point = pointA + radiusA * n;\r\n    output.normal.Copy(n);\r\n    output.lambda = lambda;\r\n    output.iterations = iter;\r\n    return true;\r\n}\r\nexports.b2ShapeCast = b2ShapeCast;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Distance.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2Distance.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_epsilon, b2_epsilon_sq, b2_polygonRadius, b2_linearSlop } from \"../Common/b2Settings\";\r\nimport { b2Max, b2Vec2, b2Rot, b2Transform, b2Abs } from \"../Common/b2Math\";\r\nimport { b2Shape } from \"./Shapes/b2Shape\";\r\n\r\n/// A distance proxy is used by the GJK algorithm.\r\n/// It encapsulates any shape.\r\nexport class b2DistanceProxy {\r\n  public readonly m_buffer: b2Vec2[] = b2Vec2.MakeArray(2);\r\n  public m_vertices: b2Vec2[] = this.m_buffer;\r\n  public m_count: number = 0;\r\n  public m_radius: number = 0;\r\n\r\n  public Copy(other: Readonly<b2DistanceProxy>): this {\r\n    if (other.m_vertices === other.m_buffer) {\r\n      this.m_vertices = this.m_buffer;\r\n      this.m_buffer[0].Copy(other.m_buffer[0]);\r\n      this.m_buffer[1].Copy(other.m_buffer[1]);\r\n    } else {\r\n      this.m_vertices = other.m_vertices;\r\n    }\r\n    this.m_count = other.m_count;\r\n    this.m_radius = other.m_radius;\r\n    return this;\r\n  }\r\n\r\n  public Reset(): b2DistanceProxy {\r\n    this.m_vertices = this.m_buffer;\r\n    this.m_count = 0;\r\n    this.m_radius = 0;\r\n    return this;\r\n  }\r\n\r\n  public SetShape(shape: b2Shape, index: number): void {\r\n    shape.SetupDistanceProxy(this, index);\r\n  }\r\n\r\n  public SetVerticesRadius(vertices: b2Vec2[], count: number, radius: number): void {\r\n    this.m_vertices = vertices;\r\n    this.m_count = count;\r\n    this.m_radius = radius;\r\n  }\r\n\r\n  public GetSupport(d: b2Vec2): number {\r\n    let bestIndex: number = 0;\r\n    let bestValue: number = b2Vec2.DotVV(this.m_vertices[0], d);\r\n    for (let i: number = 1; i < this.m_count; ++i) {\r\n      const value: number = b2Vec2.DotVV(this.m_vertices[i], d);\r\n      if (value > bestValue) {\r\n        bestIndex = i;\r\n        bestValue = value;\r\n      }\r\n    }\r\n\r\n    return bestIndex;\r\n  }\r\n\r\n  public GetSupportVertex(d: b2Vec2): b2Vec2 {\r\n    let bestIndex: number = 0;\r\n    let bestValue: number = b2Vec2.DotVV(this.m_vertices[0], d);\r\n    for (let i: number = 1; i < this.m_count; ++i) {\r\n      const value: number = b2Vec2.DotVV(this.m_vertices[i], d);\r\n      if (value > bestValue) {\r\n        bestIndex = i;\r\n        bestValue = value;\r\n      }\r\n    }\r\n\r\n    return this.m_vertices[bestIndex];\r\n  }\r\n\r\n  public GetVertexCount(): number {\r\n    return this.m_count;\r\n  }\r\n\r\n  public GetVertex(index: number): b2Vec2 {\r\n    // DEBUG: b2Assert(0 <= index && index < this.m_count);\r\n    return this.m_vertices[index];\r\n  }\r\n}\r\n\r\nexport class b2SimplexCache {\r\n  public metric: number = 0;\r\n  public count: number = 0;\r\n  public readonly indexA: [number, number, number] = [ 0, 0, 0 ];\r\n  public readonly indexB: [number, number, number] = [ 0, 0, 0 ];\r\n\r\n  public Reset(): b2SimplexCache {\r\n    this.metric = 0;\r\n    this.count = 0;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class b2DistanceInput {\r\n  public readonly proxyA: b2DistanceProxy = new b2DistanceProxy();\r\n  public readonly proxyB: b2DistanceProxy = new b2DistanceProxy();\r\n  public readonly transformA: b2Transform = new b2Transform();\r\n  public readonly transformB: b2Transform = new b2Transform();\r\n  public useRadii: boolean = false;\r\n\r\n  public Reset(): b2DistanceInput {\r\n    this.proxyA.Reset();\r\n    this.proxyB.Reset();\r\n    this.transformA.SetIdentity();\r\n    this.transformB.SetIdentity();\r\n    this.useRadii = false;\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class b2DistanceOutput {\r\n  public readonly pointA: b2Vec2 = new b2Vec2();\r\n  public readonly pointB: b2Vec2 = new b2Vec2();\r\n  public distance: number = 0;\r\n  public iterations: number = 0; ///< number of GJK iterations used\r\n\r\n  public Reset(): b2DistanceOutput {\r\n    this.pointA.SetZero();\r\n    this.pointB.SetZero();\r\n    this.distance = 0;\r\n    this.iterations = 0;\r\n    return this;\r\n  }\r\n}\r\n\r\n/// Input parameters for b2ShapeCast\r\nexport class b2ShapeCastInput {\r\n\tpublic readonly proxyA: b2DistanceProxy = new b2DistanceProxy();\r\n\tpublic readonly proxyB: b2DistanceProxy = new b2DistanceProxy();\r\n\tpublic readonly transformA: b2Transform = new b2Transform();\r\n\tpublic readonly transformB: b2Transform = new b2Transform();\r\n\tpublic readonly translationB: b2Vec2 = new b2Vec2();\r\n}\r\n\r\n/// Output results for b2ShapeCast\r\nexport class b2ShapeCastOutput {\r\n\tpublic readonly point: b2Vec2 = new b2Vec2();\r\n\tpublic readonly normal: b2Vec2 = new b2Vec2();\r\n\tpublic lambda: number = 0.0;\r\n\tpublic iterations: number = 0;\r\n}\r\n\r\nexport let b2_gjkCalls: number = 0;\r\nexport let b2_gjkIters: number = 0;\r\nexport let b2_gjkMaxIters: number = 0;\r\nexport function b2_gjk_reset(): void {\r\n  b2_gjkCalls = 0;\r\n  b2_gjkIters = 0;\r\n  b2_gjkMaxIters = 0;\r\n}\r\n\r\nexport class b2SimplexVertex {\r\n  public readonly wA: b2Vec2 = new b2Vec2(); // support point in proxyA\r\n  public readonly wB: b2Vec2 = new b2Vec2(); // support point in proxyB\r\n  public readonly w: b2Vec2 = new b2Vec2(); // wB - wA\r\n  public a: number = 0; // barycentric coordinate for closest point\r\n  public indexA: number = 0; // wA index\r\n  public indexB: number = 0; // wB index\r\n\r\n  public Copy(other: b2SimplexVertex): b2SimplexVertex {\r\n    this.wA.Copy(other.wA);     // support point in proxyA\r\n    this.wB.Copy(other.wB);     // support point in proxyB\r\n    this.w.Copy(other.w);       // wB - wA\r\n    this.a = other.a;           // barycentric coordinate for closest point\r\n    this.indexA = other.indexA; // wA index\r\n    this.indexB = other.indexB; // wB index\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class b2Simplex {\r\n  public readonly m_v1: b2SimplexVertex = new b2SimplexVertex();\r\n  public readonly m_v2: b2SimplexVertex = new b2SimplexVertex();\r\n  public readonly m_v3: b2SimplexVertex = new b2SimplexVertex();\r\n  public readonly m_vertices: b2SimplexVertex[] = [/*3*/];\r\n  public m_count: number = 0;\r\n\r\n  constructor() {\r\n    this.m_vertices[0] = this.m_v1;\r\n    this.m_vertices[1] = this.m_v2;\r\n    this.m_vertices[2] = this.m_v3;\r\n  }\r\n\r\n  public ReadCache(cache: b2SimplexCache, proxyA: b2DistanceProxy, transformA: b2Transform, proxyB: b2DistanceProxy, transformB: b2Transform): void {\r\n    // DEBUG: b2Assert(0 <= cache.count && cache.count <= 3);\r\n\r\n    // Copy data from cache.\r\n    this.m_count = cache.count;\r\n    const vertices: b2SimplexVertex[] = this.m_vertices;\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const v: b2SimplexVertex = vertices[i];\r\n      v.indexA = cache.indexA[i];\r\n      v.indexB = cache.indexB[i];\r\n      const wALocal: b2Vec2 = proxyA.GetVertex(v.indexA);\r\n      const wBLocal: b2Vec2 = proxyB.GetVertex(v.indexB);\r\n      b2Transform.MulXV(transformA, wALocal, v.wA);\r\n      b2Transform.MulXV(transformB, wBLocal, v.wB);\r\n      b2Vec2.SubVV(v.wB, v.wA, v.w);\r\n      v.a = 0;\r\n    }\r\n\r\n    // Compute the new simplex metric, if it is substantially different than\r\n    // old metric then flush the simplex.\r\n    if (this.m_count > 1) {\r\n      const metric1: number = cache.metric;\r\n      const metric2: number = this.GetMetric();\r\n      if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < b2_epsilon) {\r\n        // Reset the simplex.\r\n        this.m_count = 0;\r\n      }\r\n    }\r\n\r\n    // If the cache is empty or invalid ...\r\n    if (this.m_count === 0) {\r\n      const v: b2SimplexVertex = vertices[0];\r\n      v.indexA = 0;\r\n      v.indexB = 0;\r\n      const wALocal: b2Vec2 = proxyA.GetVertex(0);\r\n      const wBLocal: b2Vec2 = proxyB.GetVertex(0);\r\n      b2Transform.MulXV(transformA, wALocal, v.wA);\r\n      b2Transform.MulXV(transformB, wBLocal, v.wB);\r\n      b2Vec2.SubVV(v.wB, v.wA, v.w);\r\n      v.a = 1;\r\n      this.m_count = 1;\r\n    }\r\n  }\r\n\r\n  public WriteCache(cache: b2SimplexCache): void {\r\n    cache.metric = this.GetMetric();\r\n    cache.count = this.m_count;\r\n    const vertices: b2SimplexVertex[] = this.m_vertices;\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      cache.indexA[i] = vertices[i].indexA;\r\n      cache.indexB[i] = vertices[i].indexB;\r\n    }\r\n  }\r\n\r\n  public GetSearchDirection(out: b2Vec2): b2Vec2 {\r\n    switch (this.m_count) {\r\n    case 1:\r\n      return b2Vec2.NegV(this.m_v1.w, out);\r\n\r\n    case 2: {\r\n        const e12: b2Vec2 = b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, out);\r\n        const sgn: number = b2Vec2.CrossVV(e12, b2Vec2.NegV(this.m_v1.w, b2Vec2.s_t0));\r\n        if (sgn > 0) {\r\n          // Origin is left of e12.\r\n          return b2Vec2.CrossOneV(e12, out);\r\n        } else {\r\n          // Origin is right of e12.\r\n          return b2Vec2.CrossVOne(e12, out);\r\n        }\r\n      }\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      return out.SetZero();\r\n    }\r\n  }\r\n\r\n  public GetClosestPoint(out: b2Vec2): b2Vec2 {\r\n    switch (this.m_count) {\r\n    case 0:\r\n      // DEBUG: b2Assert(false);\r\n      return out.SetZero();\r\n\r\n    case 1:\r\n      return out.Copy(this.m_v1.w);\r\n\r\n    case 2:\r\n      return out.Set(\r\n        this.m_v1.a * this.m_v1.w.x + this.m_v2.a * this.m_v2.w.x,\r\n        this.m_v1.a * this.m_v1.w.y + this.m_v2.a * this.m_v2.w.y);\r\n\r\n    case 3:\r\n      return out.SetZero();\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      return out.SetZero();\r\n    }\r\n  }\r\n\r\n  public GetWitnessPoints(pA: b2Vec2, pB: b2Vec2): void {\r\n    switch (this.m_count) {\r\n    case 0:\r\n      // DEBUG: b2Assert(false);\r\n      break;\r\n\r\n    case 1:\r\n      pA.Copy(this.m_v1.wA);\r\n      pB.Copy(this.m_v1.wB);\r\n      break;\r\n\r\n    case 2:\r\n      pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x;\r\n      pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y;\r\n      pB.x = this.m_v1.a * this.m_v1.wB.x + this.m_v2.a * this.m_v2.wB.x;\r\n      pB.y = this.m_v1.a * this.m_v1.wB.y + this.m_v2.a * this.m_v2.wB.y;\r\n      break;\r\n\r\n    case 3:\r\n      pB.x = pA.x = this.m_v1.a * this.m_v1.wA.x + this.m_v2.a * this.m_v2.wA.x + this.m_v3.a * this.m_v3.wA.x;\r\n      pB.y = pA.y = this.m_v1.a * this.m_v1.wA.y + this.m_v2.a * this.m_v2.wA.y + this.m_v3.a * this.m_v3.wA.y;\r\n      break;\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      break;\r\n    }\r\n  }\r\n\r\n  public GetMetric(): number {\r\n    switch (this.m_count) {\r\n    case 0:\r\n      // DEBUG: b2Assert(false);\r\n      return 0;\r\n\r\n    case 1:\r\n      return 0;\r\n\r\n    case 2:\r\n      return b2Vec2.DistanceVV(this.m_v1.w, this.m_v2.w);\r\n\r\n    case 3:\r\n      return b2Vec2.CrossVV(b2Vec2.SubVV(this.m_v2.w, this.m_v1.w, b2Vec2.s_t0), b2Vec2.SubVV(this.m_v3.w, this.m_v1.w, b2Vec2.s_t1));\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  public Solve2(): void {\r\n    const w1: b2Vec2 = this.m_v1.w;\r\n    const w2: b2Vec2 = this.m_v2.w;\r\n    const e12: b2Vec2 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);\r\n\r\n    // w1 region\r\n    const d12_2: number = (-b2Vec2.DotVV(w1, e12));\r\n    if (d12_2 <= 0) {\r\n      // a2 <= 0, so we clamp it to 0\r\n      this.m_v1.a = 1;\r\n      this.m_count = 1;\r\n      return;\r\n    }\r\n\r\n    // w2 region\r\n    const d12_1: number = b2Vec2.DotVV(w2, e12);\r\n    if (d12_1 <= 0) {\r\n      // a1 <= 0, so we clamp it to 0\r\n      this.m_v2.a = 1;\r\n      this.m_count = 1;\r\n      this.m_v1.Copy(this.m_v2);\r\n      return;\r\n    }\r\n\r\n    // Must be in e12 region.\r\n    const inv_d12: number = 1 / (d12_1 + d12_2);\r\n    this.m_v1.a = d12_1 * inv_d12;\r\n    this.m_v2.a = d12_2 * inv_d12;\r\n    this.m_count = 2;\r\n  }\r\n\r\n  public Solve3(): void {\r\n    const w1: b2Vec2 = this.m_v1.w;\r\n    const w2: b2Vec2 = this.m_v2.w;\r\n    const w3: b2Vec2 = this.m_v3.w;\r\n\r\n    // Edge12\r\n    // [1      1     ][a1] = [1]\r\n    // [w1.e12 w2.e12][a2] = [0]\r\n    // a3 = 0\r\n    const e12: b2Vec2 = b2Vec2.SubVV(w2, w1, b2Simplex.s_e12);\r\n    const w1e12: number = b2Vec2.DotVV(w1, e12);\r\n    const w2e12: number = b2Vec2.DotVV(w2, e12);\r\n    const d12_1: number = w2e12;\r\n    const d12_2: number = (-w1e12);\r\n\r\n    // Edge13\r\n    // [1      1     ][a1] = [1]\r\n    // [w1.e13 w3.e13][a3] = [0]\r\n    // a2 = 0\r\n    const e13: b2Vec2 = b2Vec2.SubVV(w3, w1, b2Simplex.s_e13);\r\n    const w1e13: number = b2Vec2.DotVV(w1, e13);\r\n    const w3e13: number = b2Vec2.DotVV(w3, e13);\r\n    const d13_1: number = w3e13;\r\n    const d13_2: number = (-w1e13);\r\n\r\n    // Edge23\r\n    // [1      1     ][a2] = [1]\r\n    // [w2.e23 w3.e23][a3] = [0]\r\n    // a1 = 0\r\n    const e23: b2Vec2 = b2Vec2.SubVV(w3, w2, b2Simplex.s_e23);\r\n    const w2e23: number = b2Vec2.DotVV(w2, e23);\r\n    const w3e23: number = b2Vec2.DotVV(w3, e23);\r\n    const d23_1: number = w3e23;\r\n    const d23_2: number = (-w2e23);\r\n\r\n    // Triangle123\r\n    const n123: number = b2Vec2.CrossVV(e12, e13);\r\n\r\n    const d123_1: number = n123 * b2Vec2.CrossVV(w2, w3);\r\n    const d123_2: number = n123 * b2Vec2.CrossVV(w3, w1);\r\n    const d123_3: number = n123 * b2Vec2.CrossVV(w1, w2);\r\n\r\n    // w1 region\r\n    if (d12_2 <= 0 && d13_2 <= 0) {\r\n      this.m_v1.a = 1;\r\n      this.m_count = 1;\r\n      return;\r\n    }\r\n\r\n    // e12\r\n    if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {\r\n      const inv_d12: number = 1 / (d12_1 + d12_2);\r\n      this.m_v1.a = d12_1 * inv_d12;\r\n      this.m_v2.a = d12_2 * inv_d12;\r\n      this.m_count = 2;\r\n      return;\r\n    }\r\n\r\n    // e13\r\n    if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {\r\n      const inv_d13: number = 1 / (d13_1 + d13_2);\r\n      this.m_v1.a = d13_1 * inv_d13;\r\n      this.m_v3.a = d13_2 * inv_d13;\r\n      this.m_count = 2;\r\n      this.m_v2.Copy(this.m_v3);\r\n      return;\r\n    }\r\n\r\n    // w2 region\r\n    if (d12_1 <= 0 && d23_2 <= 0) {\r\n      this.m_v2.a = 1;\r\n      this.m_count = 1;\r\n      this.m_v1.Copy(this.m_v2);\r\n      return;\r\n    }\r\n\r\n    // w3 region\r\n    if (d13_1 <= 0 && d23_1 <= 0) {\r\n      this.m_v3.a = 1;\r\n      this.m_count = 1;\r\n      this.m_v1.Copy(this.m_v3);\r\n      return;\r\n    }\r\n\r\n    // e23\r\n    if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {\r\n      const inv_d23: number = 1 / (d23_1 + d23_2);\r\n      this.m_v2.a = d23_1 * inv_d23;\r\n      this.m_v3.a = d23_2 * inv_d23;\r\n      this.m_count = 2;\r\n      this.m_v1.Copy(this.m_v3);\r\n      return;\r\n    }\r\n\r\n    // Must be in triangle123\r\n    const inv_d123: number = 1 / (d123_1 + d123_2 + d123_3);\r\n    this.m_v1.a = d123_1 * inv_d123;\r\n    this.m_v2.a = d123_2 * inv_d123;\r\n    this.m_v3.a = d123_3 * inv_d123;\r\n    this.m_count = 3;\r\n  }\r\n  private static s_e12: b2Vec2 = new b2Vec2();\r\n  private static s_e13: b2Vec2 = new b2Vec2();\r\n  private static s_e23: b2Vec2 = new b2Vec2();\r\n}\r\n\r\nconst b2Distance_s_simplex: b2Simplex = new b2Simplex();\r\nconst b2Distance_s_saveA: [number, number, number] = [ 0, 0, 0 ];\r\nconst b2Distance_s_saveB: [number, number, number] = [ 0, 0, 0 ];\r\nconst b2Distance_s_p: b2Vec2 = new b2Vec2();\r\nconst b2Distance_s_d: b2Vec2 = new b2Vec2();\r\nconst b2Distance_s_normal: b2Vec2 = new b2Vec2();\r\nconst b2Distance_s_supportA: b2Vec2 = new b2Vec2();\r\nconst b2Distance_s_supportB: b2Vec2 = new b2Vec2();\r\nexport function b2Distance(output: b2DistanceOutput, cache: b2SimplexCache, input: b2DistanceInput): void {\r\n  ++b2_gjkCalls;\r\n\r\n  const proxyA: b2DistanceProxy = input.proxyA;\r\n  const proxyB: b2DistanceProxy = input.proxyB;\r\n\r\n  const transformA: b2Transform = input.transformA;\r\n  const transformB: b2Transform = input.transformB;\r\n\r\n  // Initialize the simplex.\r\n  const simplex: b2Simplex = b2Distance_s_simplex;\r\n  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);\r\n\r\n  // Get simplex vertices as an array.\r\n  const vertices: b2SimplexVertex[] = simplex.m_vertices;\r\n  const k_maxIters: number = 20;\r\n\r\n  // These store the vertices of the last simplex so that we\r\n  // can check for duplicates and prevent cycling.\r\n  const saveA: [number, number, number] = b2Distance_s_saveA;\r\n  const saveB: [number, number, number] = b2Distance_s_saveB;\r\n  let saveCount: number = 0;\r\n\r\n  // Main iteration loop.\r\n  let iter: number = 0;\r\n  while (iter < k_maxIters) {\r\n    // Copy simplex so we can identify duplicates.\r\n    saveCount = simplex.m_count;\r\n    for (let i: number = 0; i < saveCount; ++i) {\r\n      saveA[i] = vertices[i].indexA;\r\n      saveB[i] = vertices[i].indexB;\r\n    }\r\n\r\n    switch (simplex.m_count) {\r\n    case 1:\r\n      break;\r\n\r\n    case 2:\r\n      simplex.Solve2();\r\n      break;\r\n\r\n    case 3:\r\n      simplex.Solve3();\r\n      break;\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      break;\r\n    }\r\n\r\n    // If we have 3 points, then the origin is in the corresponding triangle.\r\n    if (simplex.m_count === 3) {\r\n      break;\r\n    }\r\n\r\n    // Get search direction.\r\n    const d: b2Vec2 = simplex.GetSearchDirection(b2Distance_s_d);\r\n\r\n    // Ensure the search direction is numerically fit.\r\n    if (d.LengthSquared() < b2_epsilon_sq) {\r\n      // The origin is probably contained by a line segment\r\n      // or triangle. Thus the shapes are overlapped.\r\n\r\n      // We can't return zero here even though there may be overlap.\r\n      // In case the simplex is a point, segment, or triangle it is difficult\r\n      // to determine if the origin is contained in the CSO or very close to it.\r\n      break;\r\n    }\r\n\r\n    // Compute a tentative new simplex vertex using support points.\r\n    const vertex: b2SimplexVertex = vertices[simplex.m_count];\r\n    vertex.indexA = proxyA.GetSupport(b2Rot.MulTRV(transformA.q, b2Vec2.NegV(d, b2Vec2.s_t0), b2Distance_s_supportA));\r\n    b2Transform.MulXV(transformA, proxyA.GetVertex(vertex.indexA), vertex.wA);\r\n    vertex.indexB = proxyB.GetSupport(b2Rot.MulTRV(transformB.q, d, b2Distance_s_supportB));\r\n    b2Transform.MulXV(transformB, proxyB.GetVertex(vertex.indexB), vertex.wB);\r\n    b2Vec2.SubVV(vertex.wB, vertex.wA, vertex.w);\r\n\r\n    // Iteration count is equated to the number of support point calls.\r\n    ++iter;\r\n    ++b2_gjkIters;\r\n\r\n    // Check for duplicate support points. This is the main termination criteria.\r\n    let duplicate: boolean = false;\r\n    for (let i: number = 0; i < saveCount; ++i) {\r\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\r\n        duplicate = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // If we found a duplicate support point we must exit to avoid cycling.\r\n    if (duplicate) {\r\n      break;\r\n    }\r\n\r\n    // New vertex is ok and needed.\r\n    ++simplex.m_count;\r\n  }\r\n\r\n  b2_gjkMaxIters = b2Max(b2_gjkMaxIters, iter);\r\n\r\n  // Prepare output.\r\n  simplex.GetWitnessPoints(output.pointA, output.pointB);\r\n  output.distance = b2Vec2.DistanceVV(output.pointA, output.pointB);\r\n  output.iterations = iter;\r\n\r\n  // Cache the simplex.\r\n  simplex.WriteCache(cache);\r\n\r\n  // Apply radii if requested.\r\n  if (input.useRadii) {\r\n    const rA: number = proxyA.m_radius;\r\n    const rB: number = proxyB.m_radius;\r\n\r\n    if (output.distance > (rA + rB) && output.distance > b2_epsilon) {\r\n      // Shapes are still no overlapped.\r\n      // Move the witness points to the outer surface.\r\n      output.distance -= rA + rB;\r\n      const normal: b2Vec2 = b2Vec2.SubVV(output.pointB, output.pointA, b2Distance_s_normal);\r\n      normal.Normalize();\r\n      output.pointA.SelfMulAdd(rA, normal);\r\n      output.pointB.SelfMulSub(rB, normal);\r\n    } else {\r\n      // Shapes are overlapped when radii are considered.\r\n      // Move the witness points to the middle.\r\n      const p: b2Vec2 = b2Vec2.MidVV(output.pointA, output.pointB, b2Distance_s_p);\r\n      output.pointA.Copy(p);\r\n      output.pointB.Copy(p);\r\n      output.distance = 0;\r\n    }\r\n  }\r\n}\r\n\r\n/// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.\r\n\r\n// GJK-raycast\r\n// Algorithm by Gino van den Bergen.\r\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls. 2010\r\n// bool b2ShapeCast(b2ShapeCastOutput* output, const b2ShapeCastInput* input);\r\nconst b2ShapeCast_s_n = new b2Vec2();\r\nconst b2ShapeCast_s_simplex = new b2Simplex();\r\nconst b2ShapeCast_s_wA = new b2Vec2();\r\nconst b2ShapeCast_s_wB = new b2Vec2();\r\nconst b2ShapeCast_s_v = new b2Vec2();\r\nconst b2ShapeCast_s_p = new b2Vec2();\r\nconst b2ShapeCast_s_pointA = new b2Vec2();\r\nconst b2ShapeCast_s_pointB = new b2Vec2();\r\nexport function b2ShapeCast(output: b2ShapeCastOutput, input: b2ShapeCastInput): boolean {\r\n  output.iterations = 0;\r\n  output.lambda = 1.0;\r\n  output.normal.SetZero();\r\n  output.point.SetZero();\r\n\r\n  // const b2DistanceProxy* proxyA = &input.proxyA;\r\n  const proxyA = input.proxyA;\r\n  // const b2DistanceProxy* proxyB = &input.proxyB;\r\n  const proxyB = input.proxyB;\r\n\r\n  // float32 radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);\r\n  const radiusA = b2Max(proxyA.m_radius, b2_polygonRadius);\r\n  // float32 radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);\r\n  const radiusB = b2Max(proxyB.m_radius, b2_polygonRadius);\r\n  // float32 radius = radiusA + radiusB;\r\n  const radius = radiusA + radiusB;\r\n\r\n  // b2Transform xfA = input.transformA;\r\n  const xfA = input.transformA;\r\n  // b2Transform xfB = input.transformB;\r\n  const xfB = input.transformB;\r\n\r\n  // b2Vec2 r = input.translationB;\r\n  const r = input.translationB;\r\n  // b2Vec2 n(0.0f, 0.0f);\r\n  const n = b2ShapeCast_s_n.Set(0.0, 0.0);\r\n  // float32 lambda = 0.0f;\r\n  let lambda = 0.0;\r\n\r\n  // Initial simplex\r\n  const simplex = b2ShapeCast_s_simplex;\r\n  simplex.m_count = 0;\r\n\r\n  // Get simplex vertices as an array.\r\n  // b2SimplexVertex* vertices = &simplex.m_v1;\r\n  const vertices = simplex.m_vertices;\r\n\r\n  // Get support point in -r direction\r\n  // int32 indexA = proxyA.GetSupport(b2MulT(xfA.q, -r));\r\n  let indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(r, b2Vec2.s_t1), b2Vec2.s_t0));\r\n  // b2Vec2 wA = b2Mul(xfA, proxyA.GetVertex(indexA));\r\n  let wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);\r\n  // int32 indexB = proxyB.GetSupport(b2MulT(xfB.q, r));\r\n  let indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, r, b2Vec2.s_t0));\r\n  // b2Vec2 wB = b2Mul(xfB, proxyB.GetVertex(indexB));\r\n  let wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);\r\n  // b2Vec2 v = wA - wB;\r\n  const v = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_v);\r\n\r\n  // Sigma is the target distance between polygons\r\n  // float32 sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);\r\n  const sigma = b2Max(b2_polygonRadius, radius - b2_polygonRadius);\r\n  // const float32 tolerance = 0.5f * b2_linearSlop;\r\n  const tolerance = 0.5 * b2_linearSlop;\r\n\r\n  // Main iteration loop.\r\n  // const int32 k_maxIters = 20;\r\n  const k_maxIters = 20;\r\n  // int32 iter = 0;\r\n  let iter = 0;\r\n  // while (iter < k_maxIters && b2Abs(v.Length() - sigma) > tolerance)\r\n  while (iter < k_maxIters && b2Abs(v.Length() - sigma) > tolerance) {\r\n    // DEBUG: b2Assert(simplex.m_count < 3);\r\n\r\n    output.iterations += 1;\r\n\r\n    // Support in direction -v (A - B)\r\n    // indexA = proxyA.GetSupport(b2MulT(xfA.q, -v));\r\n    indexA = proxyA.GetSupport(b2Rot.MulTRV(xfA.q, b2Vec2.NegV(v, b2Vec2.s_t1), b2Vec2.s_t0));\r\n    // wA = b2Mul(xfA, proxyA.GetVertex(indexA));\r\n    wA = b2Transform.MulXV(xfA, proxyA.GetVertex(indexA), b2ShapeCast_s_wA);\r\n    // indexB = proxyB.GetSupport(b2MulT(xfB.q, v));\r\n    indexB = proxyB.GetSupport(b2Rot.MulTRV(xfB.q, v, b2Vec2.s_t0));\r\n    // wB = b2Mul(xfB, proxyB.GetVertex(indexB));\r\n    wB = b2Transform.MulXV(xfB, proxyB.GetVertex(indexB), b2ShapeCast_s_wB);\r\n    // b2Vec2 p = wA - wB;\r\n    const p = b2Vec2.SubVV(wA, wB, b2ShapeCast_s_p);\r\n\r\n    // -v is a normal at p\r\n    v.Normalize();\r\n\r\n    // Intersect ray with plane\r\n    const vp = b2Vec2.DotVV(v, p);\r\n    const vr = b2Vec2.DotVV(v, r);\r\n    if (vp - sigma > lambda * vr) {\r\n      if (vr <= 0.0) {\r\n        return false;\r\n      }\r\n\r\n      lambda = (vp - sigma) / vr;\r\n      if (lambda > 1.0) {\r\n        return false;\r\n      }\r\n\r\n      // n = -v;\r\n      n.Copy(v).SelfNeg();\r\n      simplex.m_count = 0;\r\n    }\r\n\r\n    // Reverse simplex since it works with B - A.\r\n    // Shift by lambda * r because we want the closest point to the current clip point.\r\n    // Note that the support point p is not shifted because we want the plane equation\r\n    // to be formed in unshifted space.\r\n    // b2SimplexVertex* vertex = vertices + simplex.m_count;\r\n    const vertex: b2SimplexVertex = vertices[simplex.m_count];\r\n    vertex.indexA = indexB;\r\n    // vertex.wA = wB + lambda * r;\r\n    vertex.wA.Copy(wB).SelfMulAdd(lambda, r);\r\n    vertex.indexB = indexA;\r\n    // vertex.wB = wA;\r\n    vertex.wB.Copy(wA);\r\n    // vertex.w = vertex.wB - vertex.wA;\r\n    vertex.w.Copy(vertex.wB).SelfSub(vertex.wA);\r\n    vertex.a = 1.0;\r\n    simplex.m_count += 1;\r\n\r\n    switch (simplex.m_count) {\r\n    case 1:\r\n      break;\r\n\r\n    case 2:\r\n      simplex.Solve2();\r\n      break;\r\n\r\n    case 3:\r\n      simplex.Solve3();\r\n      break;\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n    }\r\n\r\n    // If we have 3 points, then the origin is in the corresponding triangle.\r\n    if (simplex.m_count === 3) {\r\n      // Overlap\r\n      return false;\r\n    }\r\n\r\n    // Get search direction.\r\n    // v = simplex.GetClosestPoint();\r\n    simplex.GetClosestPoint(v);\r\n\r\n    // Iteration count is equated to the number of support point calls.\r\n    ++iter;\r\n  }\r\n\r\n  // Prepare output.\r\n  const pointA = b2ShapeCast_s_pointA;\r\n  const pointB = b2ShapeCast_s_pointB;\r\n  simplex.GetWitnessPoints(pointA, pointB);\r\n\r\n  if (v.LengthSquared() > 0.0) {\r\n    // n = -v;\r\n    n.Copy(v).SelfNeg();\r\n    n.Normalize();\r\n  }\r\n\r\n  // output.point = pointA + radiusA * n;\r\n  output.normal.Copy(n);\r\n  output.lambda = lambda;\r\n  output.iterations = iter;\r\n  return true;\r\n}\r\n"]}},"error":null,"hash":"cd50fa0e6d030b87d8917743f967b59a","cacheData":{"env":{}}}