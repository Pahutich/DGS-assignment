{"id":"../node_modules/box2d.package.ts/Collision/b2BroadPhase.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"./b2DynamicTree","loc":{"line":20,"column":30},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2BroadPhase.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2DynamicTree.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\nvar b2DynamicTree_1 = require(\"./b2DynamicTree\");\r\nfunction std_iter_swap(array, a, b) {\r\n    var tmp = array[a];\r\n    array[a] = array[b];\r\n    array[b] = tmp;\r\n}\r\nfunction default_compare(a, b) { return a < b; }\r\nfunction std_sort(array, first, len, cmp) {\r\n    if (first === void 0) { first = 0; }\r\n    if (len === void 0) { len = array.length - first; }\r\n    if (cmp === void 0) { cmp = default_compare; }\r\n    var left = first;\r\n    var stack = [];\r\n    var pos = 0;\r\n    for (;;) { /* outer loop */\r\n        for (; left + 1 < len; len++) { /* sort left to len-1 */\r\n            var pivot = array[left + Math.floor(Math.random() * (len - left))]; /* pick random pivot */\r\n            stack[pos++] = len; /* sort right part later */\r\n            for (var right = left - 1;;) { /* inner loop: partitioning */\r\n                while (cmp(array[++right], pivot)) { } /* look for greater element */\r\n                while (cmp(pivot, array[--len])) { } /* look for smaller element */\r\n                if (right >= len) {\r\n                    break;\r\n                } /* partition point found? */\r\n                std_iter_swap(array, right, len); /* the only swap */\r\n            } /* partitioned, continue left part */\r\n        }\r\n        if (pos === 0) {\r\n            break;\r\n        } /* stack empty? */\r\n        left = len; /* left to right is sorted */\r\n        len = stack[--pos]; /* get next range to sort */\r\n    }\r\n    return array;\r\n}\r\nvar b2Pair = /** @class */ (function () {\r\n    function b2Pair(proxyA, proxyB) {\r\n        this.proxyA = proxyA;\r\n        this.proxyB = proxyB;\r\n    }\r\n    return b2Pair;\r\n}());\r\nexports.b2Pair = b2Pair;\r\n/// The broad-phase is used for computing pairs and performing volume queries and ray casts.\r\n/// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.\r\n/// It is up to the client to consume the new pairs and to track subsequent overlap.\r\nvar b2BroadPhase = /** @class */ (function () {\r\n    function b2BroadPhase() {\r\n        this.m_tree = new b2DynamicTree_1.b2DynamicTree();\r\n        this.m_proxyCount = 0;\r\n        // public m_moveCapacity: number = 16;\r\n        this.m_moveCount = 0;\r\n        this.m_moveBuffer = [];\r\n        // public m_pairCapacity: number = 16;\r\n        this.m_pairCount = 0;\r\n        this.m_pairBuffer = [];\r\n    }\r\n    // public m_queryProxyId: number = 0;\r\n    /// Create a proxy with an initial AABB. Pairs are not reported until\r\n    /// UpdatePairs is called.\r\n    b2BroadPhase.prototype.CreateProxy = function (aabb, userData) {\r\n        var proxy = this.m_tree.CreateProxy(aabb, userData);\r\n        ++this.m_proxyCount;\r\n        this.BufferMove(proxy);\r\n        return proxy;\r\n    };\r\n    /// Destroy a proxy. It is up to the client to remove any pairs.\r\n    b2BroadPhase.prototype.DestroyProxy = function (proxy) {\r\n        this.UnBufferMove(proxy);\r\n        --this.m_proxyCount;\r\n        this.m_tree.DestroyProxy(proxy);\r\n    };\r\n    /// Call MoveProxy as many times as you like, then when you are done\r\n    /// call UpdatePairs to finalized the proxy pairs (for your time step).\r\n    b2BroadPhase.prototype.MoveProxy = function (proxy, aabb, displacement) {\r\n        var buffer = this.m_tree.MoveProxy(proxy, aabb, displacement);\r\n        if (buffer) {\r\n            this.BufferMove(proxy);\r\n        }\r\n    };\r\n    /// Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.\r\n    b2BroadPhase.prototype.TouchProxy = function (proxy) {\r\n        this.BufferMove(proxy);\r\n    };\r\n    /// Get the fat AABB for a proxy.\r\n    // public GetFatAABB(proxy: b2TreeNode<T>): b2AABB {\r\n    //   return this.m_tree.GetFatAABB(proxy);\r\n    // }\r\n    /// Get user data from a proxy. Returns NULL if the id is invalid.\r\n    // public GetUserData(proxy: b2TreeNode<T>): T {\r\n    //   return this.m_tree.GetUserData(proxy);\r\n    // }\r\n    /// Test overlap of fat AABBs.\r\n    // public TestOverlap(proxyA: b2TreeNode<T>, proxyB: b2TreeNode<T>): boolean {\r\n    //   const aabbA: b2AABB = this.m_tree.GetFatAABB(proxyA);\r\n    //   const aabbB: b2AABB = this.m_tree.GetFatAABB(proxyB);\r\n    //   return b2TestOverlapAABB(aabbA, aabbB);\r\n    // }\r\n    /// Get the number of proxies.\r\n    b2BroadPhase.prototype.GetProxyCount = function () {\r\n        return this.m_proxyCount;\r\n    };\r\n    /// Update the pairs. This results in pair callbacks. This can only add pairs.\r\n    b2BroadPhase.prototype.UpdatePairs = function (callback) {\r\n        var _this = this;\r\n        // Reset pair buffer\r\n        this.m_pairCount = 0;\r\n        var _loop_1 = function (i_1) {\r\n            var queryProxy = this_1.m_moveBuffer[i_1];\r\n            if (queryProxy === null) {\r\n                return \"continue\";\r\n            }\r\n            // This is called from box2d.b2DynamicTree::Query when we are gathering pairs.\r\n            // boolean b2BroadPhase::QueryCallback(int32 proxyId);\r\n            // We have to query the tree with the fat AABB so that\r\n            // we don't fail to create a pair that may touch later.\r\n            var fatAABB = queryProxy.aabb; // this.m_tree.GetFatAABB(queryProxy);\r\n            // Query tree, create pairs and add them pair buffer.\r\n            this_1.m_tree.Query(fatAABB, function (proxy) {\r\n                // A proxy cannot form a pair with itself.\r\n                if (proxy.m_id === queryProxy.m_id) {\r\n                    return true;\r\n                }\r\n                // const proxyA = proxy < queryProxy ? proxy : queryProxy;\r\n                // const proxyB = proxy >= queryProxy ? proxy : queryProxy;\r\n                var proxyA;\r\n                var proxyB;\r\n                if (proxy.m_id < queryProxy.m_id) {\r\n                    proxyA = proxy;\r\n                    proxyB = queryProxy;\r\n                }\r\n                else {\r\n                    proxyA = queryProxy;\r\n                    proxyB = proxy;\r\n                }\r\n                // Grow the pair buffer as needed.\r\n                if (_this.m_pairCount === _this.m_pairBuffer.length) {\r\n                    _this.m_pairBuffer[_this.m_pairCount] = new b2Pair(proxyA, proxyB);\r\n                }\r\n                else {\r\n                    var pair = _this.m_pairBuffer[_this.m_pairCount];\r\n                    pair.proxyA = proxyA;\r\n                    pair.proxyB = proxyB;\r\n                }\r\n                ++_this.m_pairCount;\r\n                return true;\r\n            });\r\n        };\r\n        var this_1 = this;\r\n        // Perform tree queries for all moving proxies.\r\n        for (var i_1 = 0; i_1 < this.m_moveCount; ++i_1) {\r\n            _loop_1(i_1);\r\n        }\r\n        // Reset move buffer\r\n        this.m_moveCount = 0;\r\n        // Sort the pair buffer to expose duplicates.\r\n        std_sort(this.m_pairBuffer, 0, this.m_pairCount, b2PairLessThan);\r\n        // Send the pairs back to the client.\r\n        var i = 0;\r\n        while (i < this.m_pairCount) {\r\n            var primaryPair = this.m_pairBuffer[i];\r\n            var userDataA = primaryPair.proxyA.userData; // this.m_tree.GetUserData(primaryPair.proxyA);\r\n            var userDataB = primaryPair.proxyB.userData; // this.m_tree.GetUserData(primaryPair.proxyB);\r\n            callback(userDataA, userDataB);\r\n            ++i;\r\n            // Skip any duplicate pairs.\r\n            while (i < this.m_pairCount) {\r\n                var pair = this.m_pairBuffer[i];\r\n                if (pair.proxyA.m_id !== primaryPair.proxyA.m_id || pair.proxyB.m_id !== primaryPair.proxyB.m_id) {\r\n                    break;\r\n                }\r\n                ++i;\r\n            }\r\n        }\r\n        // Try to keep the tree balanced.\r\n        // this.m_tree.Rebalance(4);\r\n    };\r\n    /// Query an AABB for overlapping proxies. The callback class\r\n    /// is called for each proxy that overlaps the supplied AABB.\r\n    b2BroadPhase.prototype.Query = function (aabb, callback) {\r\n        this.m_tree.Query(aabb, callback);\r\n    };\r\n    b2BroadPhase.prototype.QueryPoint = function (point, callback) {\r\n        this.m_tree.QueryPoint(point, callback);\r\n    };\r\n    /// Ray-cast against the proxies in the tree. This relies on the callback\r\n    /// to perform a exact ray-cast in the case were the proxy contains a shape.\r\n    /// The callback also performs the any collision filtering. This has performance\r\n    /// roughly equal to k * log(n), where k is the number of collisions and n is the\r\n    /// number of proxies in the tree.\r\n    /// @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\n    /// @param callback a callback class that is called for each proxy that is hit by the ray.\r\n    b2BroadPhase.prototype.RayCast = function (input, callback) {\r\n        this.m_tree.RayCast(input, callback);\r\n    };\r\n    /// Get the height of the embedded tree.\r\n    b2BroadPhase.prototype.GetTreeHeight = function () {\r\n        return this.m_tree.GetHeight();\r\n    };\r\n    /// Get the balance of the embedded tree.\r\n    b2BroadPhase.prototype.GetTreeBalance = function () {\r\n        return this.m_tree.GetMaxBalance();\r\n    };\r\n    /// Get the quality metric of the embedded tree.\r\n    b2BroadPhase.prototype.GetTreeQuality = function () {\r\n        return this.m_tree.GetAreaRatio();\r\n    };\r\n    /// Shift the world origin. Useful for large worlds.\r\n    /// The shift formula is: position -= newOrigin\r\n    /// @param newOrigin the new origin with respect to the old origin\r\n    b2BroadPhase.prototype.ShiftOrigin = function (newOrigin) {\r\n        this.m_tree.ShiftOrigin(newOrigin);\r\n    };\r\n    b2BroadPhase.prototype.BufferMove = function (proxy) {\r\n        this.m_moveBuffer[this.m_moveCount] = proxy;\r\n        ++this.m_moveCount;\r\n    };\r\n    b2BroadPhase.prototype.UnBufferMove = function (proxy) {\r\n        var i = this.m_moveBuffer.indexOf(proxy);\r\n        this.m_moveBuffer[i] = null;\r\n    };\r\n    return b2BroadPhase;\r\n}());\r\nexports.b2BroadPhase = b2BroadPhase;\r\n/// This is used to sort pairs.\r\nfunction b2PairLessThan(pair1, pair2) {\r\n    if (pair1.proxyA.m_id < pair2.proxyA.m_id) {\r\n        return true;\r\n    }\r\n    if (pair1.proxyA.m_id === pair2.proxyA.m_id) {\r\n        return pair1.proxyB.m_id < pair2.proxyB.m_id;\r\n    }\r\n    return false;\r\n}\r\nexports.b2PairLessThan = b2PairLessThan;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2BroadPhase.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2BroadPhase.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2Vec2, XY } from \"../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput } from \"./b2Collision\";\r\nimport { b2TreeNode, b2DynamicTree } from \"./b2DynamicTree\";\r\n\r\nfunction std_iter_swap<T>(array: T[], a: number, b: number): void {\r\n  const tmp: T = array[a];\r\n  array[a] = array[b];\r\n  array[b] = tmp;\r\n}\r\n\r\nfunction default_compare<T>(a: T, b: T): boolean { return a < b; }\r\n\r\nfunction std_sort<T>(array: T[], first: number = 0, len: number = array.length - first, cmp: (a: T, b: T) => boolean = default_compare): T[] {\r\n  let left = first;\r\n  const stack: number[] = [];\r\n  let pos = 0;\r\n\r\n  for (; ; ) { /* outer loop */\r\n    for (; left + 1 < len; len++) { /* sort left to len-1 */\r\n      const pivot = array[left + Math.floor(Math.random() * (len - left))]; /* pick random pivot */\r\n      stack[pos++] = len; /* sort right part later */\r\n      for (let right = left - 1; ; ) { /* inner loop: partitioning */\r\n        while (cmp(array[++right], pivot)) {} /* look for greater element */\r\n        while (cmp(pivot, array[--len])) {} /* look for smaller element */\r\n        if (right >= len) {\r\n          break;\r\n        } /* partition point found? */\r\n        std_iter_swap(array, right, len); /* the only swap */\r\n      } /* partitioned, continue left part */\r\n    }\r\n    if (pos === 0) {\r\n      break;\r\n    } /* stack empty? */\r\n    left = len; /* left to right is sorted */\r\n    len = stack[--pos]; /* get next range to sort */\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nexport class b2Pair<T> {\r\n  constructor(public proxyA: b2TreeNode<T>, public proxyB: b2TreeNode<T>) {}\r\n}\r\n\r\n/// The broad-phase is used for computing pairs and performing volume queries and ray casts.\r\n/// This broad-phase does not persist pairs. Instead, this reports potentially new pairs.\r\n/// It is up to the client to consume the new pairs and to track subsequent overlap.\r\nexport class b2BroadPhase<T> {\r\n  public readonly m_tree: b2DynamicTree<T> = new b2DynamicTree<T>();\r\n  public m_proxyCount: number = 0;\r\n  // public m_moveCapacity: number = 16;\r\n  public m_moveCount: number = 0;\r\n  public readonly m_moveBuffer: Array<b2TreeNode<T> | null> = [];\r\n  // public m_pairCapacity: number = 16;\r\n  public m_pairCount: number = 0;\r\n  public readonly m_pairBuffer: Array<b2Pair<T>> = [];\r\n  // public m_queryProxyId: number = 0;\r\n\r\n  /// Create a proxy with an initial AABB. Pairs are not reported until\r\n  /// UpdatePairs is called.\r\n  public CreateProxy(aabb: b2AABB, userData: T): b2TreeNode<T> {\r\n    const proxy: b2TreeNode<T> = this.m_tree.CreateProxy(aabb, userData);\r\n    ++this.m_proxyCount;\r\n    this.BufferMove(proxy);\r\n    return proxy;\r\n  }\r\n\r\n  /// Destroy a proxy. It is up to the client to remove any pairs.\r\n  public DestroyProxy(proxy: b2TreeNode<T>): void {\r\n    this.UnBufferMove(proxy);\r\n    --this.m_proxyCount;\r\n    this.m_tree.DestroyProxy(proxy);\r\n  }\r\n\r\n  /// Call MoveProxy as many times as you like, then when you are done\r\n  /// call UpdatePairs to finalized the proxy pairs (for your time step).\r\n  public MoveProxy(proxy: b2TreeNode<T>, aabb: b2AABB, displacement: b2Vec2): void {\r\n    const buffer: boolean = this.m_tree.MoveProxy(proxy, aabb, displacement);\r\n    if (buffer) {\r\n      this.BufferMove(proxy);\r\n    }\r\n  }\r\n\r\n  /// Call to trigger a re-processing of it's pairs on the next call to UpdatePairs.\r\n  public TouchProxy(proxy: b2TreeNode<T>): void {\r\n    this.BufferMove(proxy);\r\n  }\r\n\r\n  /// Get the fat AABB for a proxy.\r\n  // public GetFatAABB(proxy: b2TreeNode<T>): b2AABB {\r\n  //   return this.m_tree.GetFatAABB(proxy);\r\n  // }\r\n\r\n  /// Get user data from a proxy. Returns NULL if the id is invalid.\r\n  // public GetUserData(proxy: b2TreeNode<T>): T {\r\n  //   return this.m_tree.GetUserData(proxy);\r\n  // }\r\n\r\n  /// Test overlap of fat AABBs.\r\n  // public TestOverlap(proxyA: b2TreeNode<T>, proxyB: b2TreeNode<T>): boolean {\r\n  //   const aabbA: b2AABB = this.m_tree.GetFatAABB(proxyA);\r\n  //   const aabbB: b2AABB = this.m_tree.GetFatAABB(proxyB);\r\n  //   return b2TestOverlapAABB(aabbA, aabbB);\r\n  // }\r\n\r\n  /// Get the number of proxies.\r\n  public GetProxyCount(): number {\r\n    return this.m_proxyCount;\r\n  }\r\n\r\n  /// Update the pairs. This results in pair callbacks. This can only add pairs.\r\n  public UpdatePairs(callback: (a: T, b: T) => void): void {\r\n    // Reset pair buffer\r\n    this.m_pairCount = 0;\r\n\r\n    // Perform tree queries for all moving proxies.\r\n    for (let i: number = 0; i < this.m_moveCount; ++i) {\r\n      const queryProxy: b2TreeNode<T> | null = this.m_moveBuffer[i];\r\n      if (queryProxy === null) {\r\n        continue;\r\n      }\r\n\r\n      // This is called from box2d.b2DynamicTree::Query when we are gathering pairs.\r\n      // boolean b2BroadPhase::QueryCallback(int32 proxyId);\r\n\r\n      // We have to query the tree with the fat AABB so that\r\n      // we don't fail to create a pair that may touch later.\r\n      const fatAABB: b2AABB = queryProxy.aabb; // this.m_tree.GetFatAABB(queryProxy);\r\n\r\n      // Query tree, create pairs and add them pair buffer.\r\n      this.m_tree.Query(fatAABB, (proxy: b2TreeNode<T>): boolean => {\r\n        // A proxy cannot form a pair with itself.\r\n        if (proxy.m_id === queryProxy.m_id) {\r\n          return true;\r\n        }\r\n\r\n        // const proxyA = proxy < queryProxy ? proxy : queryProxy;\r\n        // const proxyB = proxy >= queryProxy ? proxy : queryProxy;\r\n        let proxyA: b2TreeNode<T>;\r\n        let proxyB: b2TreeNode<T>;\r\n        if (proxy.m_id < queryProxy.m_id) {\r\n          proxyA = proxy;\r\n          proxyB = queryProxy;\r\n        } else {\r\n          proxyA = queryProxy;\r\n          proxyB = proxy;\r\n        }\r\n\r\n        // Grow the pair buffer as needed.\r\n        if (this.m_pairCount === this.m_pairBuffer.length) {\r\n          this.m_pairBuffer[this.m_pairCount] = new b2Pair(proxyA, proxyB);\r\n        } else {\r\n          const pair: b2Pair<T> = this.m_pairBuffer[this.m_pairCount];\r\n          pair.proxyA = proxyA;\r\n          pair.proxyB = proxyB;\r\n        }\r\n\r\n        ++this.m_pairCount;\r\n\r\n        return true;\r\n      });\r\n    }\r\n\r\n    // Reset move buffer\r\n    this.m_moveCount = 0;\r\n\r\n    // Sort the pair buffer to expose duplicates.\r\n    std_sort(this.m_pairBuffer, 0, this.m_pairCount, b2PairLessThan);\r\n\r\n    // Send the pairs back to the client.\r\n    let i: number = 0;\r\n    while (i < this.m_pairCount) {\r\n      const primaryPair: b2Pair<T> = this.m_pairBuffer[i];\r\n      const userDataA: T = primaryPair.proxyA.userData; // this.m_tree.GetUserData(primaryPair.proxyA);\r\n      const userDataB: T = primaryPair.proxyB.userData; // this.m_tree.GetUserData(primaryPair.proxyB);\r\n\r\n      callback(userDataA, userDataB);\r\n      ++i;\r\n\r\n      // Skip any duplicate pairs.\r\n      while (i < this.m_pairCount) {\r\n        const pair: b2Pair<T> = this.m_pairBuffer[i];\r\n        if (pair.proxyA.m_id !== primaryPair.proxyA.m_id || pair.proxyB.m_id !== primaryPair.proxyB.m_id) {\r\n          break;\r\n        }\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    // Try to keep the tree balanced.\r\n    // this.m_tree.Rebalance(4);\r\n  }\r\n\r\n  /// Query an AABB for overlapping proxies. The callback class\r\n  /// is called for each proxy that overlaps the supplied AABB.\r\n  public Query(aabb: b2AABB, callback: (node: b2TreeNode<T>) => boolean): void {\r\n    this.m_tree.Query(aabb, callback);\r\n  }\r\n\r\n  public QueryPoint(point: XY, callback: (node: b2TreeNode<T>) => boolean): void {\r\n    this.m_tree.QueryPoint(point, callback);\r\n  }\r\n\r\n  /// Ray-cast against the proxies in the tree. This relies on the callback\r\n  /// to perform a exact ray-cast in the case were the proxy contains a shape.\r\n  /// The callback also performs the any collision filtering. This has performance\r\n  /// roughly equal to k * log(n), where k is the number of collisions and n is the\r\n  /// number of proxies in the tree.\r\n  /// @param input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\n  /// @param callback a callback class that is called for each proxy that is hit by the ray.\r\n  public RayCast(input: b2RayCastInput, callback: (input: b2RayCastInput, node: b2TreeNode<T>) => number): void {\r\n    this.m_tree.RayCast(input, callback);\r\n  }\r\n\r\n  /// Get the height of the embedded tree.\r\n  public GetTreeHeight(): number {\r\n    return this.m_tree.GetHeight();\r\n  }\r\n\r\n  /// Get the balance of the embedded tree.\r\n  public GetTreeBalance(): number {\r\n    return this.m_tree.GetMaxBalance();\r\n  }\r\n\r\n  /// Get the quality metric of the embedded tree.\r\n  public GetTreeQuality(): number {\r\n    return this.m_tree.GetAreaRatio();\r\n  }\r\n\r\n  /// Shift the world origin. Useful for large worlds.\r\n  /// The shift formula is: position -= newOrigin\r\n  /// @param newOrigin the new origin with respect to the old origin\r\n  public ShiftOrigin(newOrigin: XY): void {\r\n    this.m_tree.ShiftOrigin(newOrigin);\r\n  }\r\n\r\n  public BufferMove(proxy: b2TreeNode<T>): void {\r\n    this.m_moveBuffer[this.m_moveCount] = proxy;\r\n    ++this.m_moveCount;\r\n  }\r\n\r\n  public UnBufferMove(proxy: b2TreeNode<T>): void {\r\n    const i: number = this.m_moveBuffer.indexOf(proxy);\r\n    this.m_moveBuffer[i] = null;\r\n  }\r\n}\r\n\r\n/// This is used to sort pairs.\r\nexport function b2PairLessThan<T>(pair1: b2Pair<T>, pair2: b2Pair<T>): boolean {\r\n  if (pair1.proxyA.m_id < pair2.proxyA.m_id) {\r\n    return true;\r\n  }\r\n\r\n  if (pair1.proxyA.m_id === pair2.proxyA.m_id) {\r\n    return pair1.proxyB.m_id < pair2.proxyB.m_id;\r\n  }\r\n\r\n  return false;\r\n}\r\n"]}},"error":null,"hash":"d0e420e8e9b03f0aa56dde5088607f1b","cacheData":{"env":{}}}