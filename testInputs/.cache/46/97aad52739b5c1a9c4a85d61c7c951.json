{"id":"../node_modules/box2d.package.ts/Dynamics/b2Fixture.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Fixture.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Collision/b2Collision","loc":{"line":22,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Fixture.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"../Collision/Shapes/b2Shape","loc":{"line":23,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Fixture.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Collision_1 = require(\"../Collision/b2Collision\");\r\nvar b2Shape_1 = require(\"../Collision/Shapes/b2Shape\");\r\n/// This holds contact filtering data.\r\nvar b2Filter = /** @class */ (function () {\r\n    function b2Filter() {\r\n        /// The collision category bits. Normally you would just set one bit.\r\n        this.categoryBits = 0x0001;\r\n        /// The collision mask bits. This states the categories that this\r\n        /// shape would accept for collision.\r\n        this.maskBits = 0xFFFF;\r\n        /// Collision groups allow a certain group of objects to never collide (negative)\r\n        /// or always collide (positive). Zero means no collision group. Non-zero group\r\n        /// filtering always wins against the mask bits.\r\n        this.groupIndex = 0;\r\n    }\r\n    b2Filter.prototype.Clone = function () {\r\n        return new b2Filter().Copy(this);\r\n    };\r\n    b2Filter.prototype.Copy = function (other) {\r\n        // DEBUG: b2Assert(this !== other);\r\n        this.categoryBits = other.categoryBits;\r\n        this.maskBits = other.maskBits;\r\n        this.groupIndex = other.groupIndex || 0;\r\n        return this;\r\n    };\r\n    b2Filter.DEFAULT = new b2Filter();\r\n    return b2Filter;\r\n}());\r\nexports.b2Filter = b2Filter;\r\n/// A fixture definition is used to create a fixture. This class defines an\r\n/// abstract fixture definition. You can reuse fixture definitions safely.\r\nvar b2FixtureDef = /** @class */ (function () {\r\n    function b2FixtureDef() {\r\n        /// Use this to store application specific fixture data.\r\n        this.userData = null;\r\n        /// The friction coefficient, usually in the range [0,1].\r\n        this.friction = 0.2;\r\n        /// The restitution (elasticity) usually in the range [0,1].\r\n        this.restitution = 0;\r\n        /// The density, usually in kg/m^2.\r\n        this.density = 0;\r\n        /// A sensor shape collects contact information but never generates a collision\r\n        /// response.\r\n        this.isSensor = false;\r\n        /// Contact filtering data.\r\n        this.filter = new b2Filter();\r\n    }\r\n    return b2FixtureDef;\r\n}());\r\nexports.b2FixtureDef = b2FixtureDef;\r\n/// This proxy is used internally to connect fixtures to the broad-phase.\r\nvar b2FixtureProxy = /** @class */ (function () {\r\n    function b2FixtureProxy(fixture, childIndex) {\r\n        this.aabb = new b2Collision_1.b2AABB();\r\n        this.childIndex = 0;\r\n        this.fixture = fixture;\r\n        this.childIndex = childIndex;\r\n        this.fixture.m_shape.ComputeAABB(this.aabb, this.fixture.m_body.GetTransform(), childIndex);\r\n        this.treeNode = this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb, this);\r\n    }\r\n    b2FixtureProxy.prototype.Reset = function () {\r\n        this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode);\r\n    };\r\n    b2FixtureProxy.prototype.Touch = function () {\r\n        this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode);\r\n    };\r\n    b2FixtureProxy.prototype.Synchronize = function (transform1, transform2, displacement) {\r\n        if (transform1 === transform2) {\r\n            this.fixture.m_shape.ComputeAABB(this.aabb, transform1, this.childIndex);\r\n            this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, displacement);\r\n        }\r\n        else {\r\n            // Compute an AABB that covers the swept shape (may miss some rotation effect).\r\n            var aabb1 = b2FixtureProxy.Synchronize_s_aabb1;\r\n            var aabb2 = b2FixtureProxy.Synchronize_s_aabb2;\r\n            this.fixture.m_shape.ComputeAABB(aabb1, transform1, this.childIndex);\r\n            this.fixture.m_shape.ComputeAABB(aabb2, transform2, this.childIndex);\r\n            this.aabb.Combine2(aabb1, aabb2);\r\n            this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, displacement);\r\n        }\r\n    };\r\n    b2FixtureProxy.Synchronize_s_aabb1 = new b2Collision_1.b2AABB();\r\n    b2FixtureProxy.Synchronize_s_aabb2 = new b2Collision_1.b2AABB();\r\n    return b2FixtureProxy;\r\n}());\r\nexports.b2FixtureProxy = b2FixtureProxy;\r\n/// A fixture is used to attach a shape to a body for collision detection. A fixture\r\n/// inherits its transform from its parent. Fixtures hold additional non-geometric data\r\n/// such as friction, collision filters, etc.\r\n/// Fixtures are created via b2Body::CreateFixture.\r\n/// @warning you cannot reuse fixtures.\r\nvar b2Fixture = /** @class */ (function () {\r\n    function b2Fixture(body, def) {\r\n        this.m_density = 0;\r\n        this.m_next = null;\r\n        this.m_friction = 0;\r\n        this.m_restitution = 0;\r\n        this.m_proxies = [];\r\n        this.m_filter = new b2Filter();\r\n        this.m_isSensor = false;\r\n        this.m_userData = null;\r\n        this.m_body = body;\r\n        this.m_shape = def.shape.Clone();\r\n        this.m_userData = b2Settings_1.b2Maybe(def.userData, null);\r\n        this.m_friction = b2Settings_1.b2Maybe(def.friction, 0.2);\r\n        this.m_restitution = b2Settings_1.b2Maybe(def.restitution, 0);\r\n        this.m_filter.Copy(b2Settings_1.b2Maybe(def.filter, b2Filter.DEFAULT));\r\n        this.m_isSensor = b2Settings_1.b2Maybe(def.isSensor, false);\r\n        this.m_density = b2Settings_1.b2Maybe(def.density, 0);\r\n    }\r\n    Object.defineProperty(b2Fixture.prototype, \"m_proxyCount\", {\r\n        get: function () { return this.m_proxies.length; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    b2Fixture.prototype.Reset = function () {\r\n        // The proxies must be destroyed before calling this.\r\n        // DEBUG: b2Assert(this.m_proxyCount === 0);\r\n    };\r\n    /// Get the type of the child shape. You can use this to down cast to the concrete shape.\r\n    /// @return the shape type.\r\n    b2Fixture.prototype.GetType = function () {\r\n        return this.m_shape.GetType();\r\n    };\r\n    /// Get the child shape. You can modify the child shape, however you should not change the\r\n    /// number of vertices because this will crash some collision caching mechanisms.\r\n    /// Manipulating the shape may lead to non-physical behavior.\r\n    b2Fixture.prototype.GetShape = function () {\r\n        return this.m_shape;\r\n    };\r\n    /// Set if this fixture is a sensor.\r\n    b2Fixture.prototype.SetSensor = function (sensor) {\r\n        if (sensor !== this.m_isSensor) {\r\n            this.m_body.SetAwake(true);\r\n            this.m_isSensor = sensor;\r\n        }\r\n    };\r\n    /// Is this fixture a sensor (non-solid)?\r\n    /// @return the true if the shape is a sensor.\r\n    b2Fixture.prototype.IsSensor = function () {\r\n        return this.m_isSensor;\r\n    };\r\n    /// Set the contact filtering data. This will not update contacts until the next time\r\n    /// step when either parent body is active and awake.\r\n    /// This automatically calls Refilter.\r\n    b2Fixture.prototype.SetFilterData = function (filter) {\r\n        this.m_filter.Copy(filter);\r\n        this.Refilter();\r\n    };\r\n    /// Get the contact filtering data.\r\n    b2Fixture.prototype.GetFilterData = function () {\r\n        return this.m_filter;\r\n    };\r\n    /// Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.\r\n    b2Fixture.prototype.Refilter = function () {\r\n        // Flag associated contacts for filtering.\r\n        var edge = this.m_body.GetContactList();\r\n        while (edge) {\r\n            var contact = edge.contact;\r\n            var fixtureA = contact.GetFixtureA();\r\n            var fixtureB = contact.GetFixtureB();\r\n            if (fixtureA === this || fixtureB === this) {\r\n                contact.FlagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n        // Touch each proxy so that new pairs may be created\r\n        this.TouchProxies();\r\n    };\r\n    /// Get the parent body of this fixture. This is NULL if the fixture is not attached.\r\n    /// @return the parent body.\r\n    b2Fixture.prototype.GetBody = function () {\r\n        return this.m_body;\r\n    };\r\n    /// Get the next fixture in the parent body's fixture list.\r\n    /// @return the next shape.\r\n    b2Fixture.prototype.GetNext = function () {\r\n        return this.m_next;\r\n    };\r\n    /// Get the user data that was assigned in the fixture definition. Use this to\r\n    /// store your application specific data.\r\n    b2Fixture.prototype.GetUserData = function () {\r\n        return this.m_userData;\r\n    };\r\n    /// Set the user data. Use this to store your application specific data.\r\n    b2Fixture.prototype.SetUserData = function (data) {\r\n        this.m_userData = data;\r\n    };\r\n    /// Test a point for containment in this fixture.\r\n    /// @param p a point in world coordinates.\r\n    b2Fixture.prototype.TestPoint = function (p) {\r\n        return this.m_shape.TestPoint(this.m_body.GetTransform(), p);\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2Fixture.prototype.ComputeDistance = function (p, normal, childIndex) {\r\n        return this.m_shape.ComputeDistance(this.m_body.GetTransform(), p, normal, childIndex);\r\n    };\r\n    // #endif\r\n    /// Cast a ray against this shape.\r\n    /// @param output the ray-cast results.\r\n    /// @param input the ray-cast input parameters.\r\n    b2Fixture.prototype.RayCast = function (output, input, childIndex) {\r\n        return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);\r\n    };\r\n    /// Get the mass data for this fixture. The mass data is based on the density and\r\n    /// the shape. The rotational inertia is about the shape's origin. This operation\r\n    /// may be expensive.\r\n    b2Fixture.prototype.GetMassData = function (massData) {\r\n        if (massData === void 0) { massData = new b2Shape_1.b2MassData(); }\r\n        this.m_shape.ComputeMass(massData, this.m_density);\r\n        return massData;\r\n    };\r\n    /// Set the density of this fixture. This will _not_ automatically adjust the mass\r\n    /// of the body. You must call b2Body::ResetMassData to update the body's mass.\r\n    b2Fixture.prototype.SetDensity = function (density) {\r\n        this.m_density = density;\r\n    };\r\n    /// Get the density of this fixture.\r\n    b2Fixture.prototype.GetDensity = function () {\r\n        return this.m_density;\r\n    };\r\n    /// Get the coefficient of friction.\r\n    b2Fixture.prototype.GetFriction = function () {\r\n        return this.m_friction;\r\n    };\r\n    /// Set the coefficient of friction. This will _not_ change the friction of\r\n    /// existing contacts.\r\n    b2Fixture.prototype.SetFriction = function (friction) {\r\n        this.m_friction = friction;\r\n    };\r\n    /// Get the coefficient of restitution.\r\n    b2Fixture.prototype.GetRestitution = function () {\r\n        return this.m_restitution;\r\n    };\r\n    /// Set the coefficient of restitution. This will _not_ change the restitution of\r\n    /// existing contacts.\r\n    b2Fixture.prototype.SetRestitution = function (restitution) {\r\n        this.m_restitution = restitution;\r\n    };\r\n    /// Get the fixture's AABB. This AABB may be enlarge and/or stale.\r\n    /// If you need a more accurate AABB, compute it using the shape and\r\n    /// the body transform.\r\n    b2Fixture.prototype.GetAABB = function (childIndex) {\r\n        // DEBUG: b2Assert(0 <= childIndex && childIndex < this.m_proxyCount);\r\n        return this.m_proxies[childIndex].aabb;\r\n    };\r\n    /// Dump this fixture to the log file.\r\n    b2Fixture.prototype.Dump = function (log, bodyIndex) {\r\n        log(\"    const fd: b2FixtureDef = new b2FixtureDef();\\n\");\r\n        log(\"    fd.friction = %.15f;\\n\", this.m_friction);\r\n        log(\"    fd.restitution = %.15f;\\n\", this.m_restitution);\r\n        log(\"    fd.density = %.15f;\\n\", this.m_density);\r\n        log(\"    fd.isSensor = %s;\\n\", (this.m_isSensor) ? (\"true\") : (\"false\"));\r\n        log(\"    fd.filter.categoryBits = %d;\\n\", this.m_filter.categoryBits);\r\n        log(\"    fd.filter.maskBits = %d;\\n\", this.m_filter.maskBits);\r\n        log(\"    fd.filter.groupIndex = %d;\\n\", this.m_filter.groupIndex);\r\n        this.m_shape.Dump(log);\r\n        log(\"\\n\");\r\n        log(\"    fd.shape = shape;\\n\");\r\n        log(\"\\n\");\r\n        log(\"    bodies[%d].CreateFixture(fd);\\n\", bodyIndex);\r\n    };\r\n    // These support body activation/deactivation.\r\n    b2Fixture.prototype.CreateProxies = function () {\r\n        if (this.m_proxies.length !== 0) {\r\n            throw new Error();\r\n        }\r\n        // Create proxies in the broad-phase.\r\n        for (var i = 0; i < this.m_shape.GetChildCount(); ++i) {\r\n            this.m_proxies[i] = new b2FixtureProxy(this, i);\r\n        }\r\n    };\r\n    b2Fixture.prototype.DestroyProxies = function () {\r\n        // Destroy proxies in the broad-phase.\r\n        for (var _i = 0, _a = this.m_proxies; _i < _a.length; _i++) {\r\n            var proxy = _a[_i];\r\n            proxy.Reset();\r\n        }\r\n        this.m_proxies.length = 0;\r\n    };\r\n    b2Fixture.prototype.TouchProxies = function () {\r\n        for (var _i = 0, _a = this.m_proxies; _i < _a.length; _i++) {\r\n            var proxy = _a[_i];\r\n            proxy.Touch();\r\n        }\r\n    };\r\n    b2Fixture.prototype.SynchronizeProxies = function (transform1, transform2, displacement) {\r\n        for (var _i = 0, _a = this.m_proxies; _i < _a.length; _i++) {\r\n            var proxy = _a[_i];\r\n            proxy.Synchronize(transform1, transform2, displacement);\r\n        }\r\n    };\r\n    return b2Fixture;\r\n}());\r\nexports.b2Fixture = b2Fixture;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Fixture.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2Fixture.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2Maybe } from \"../Common/b2Settings\";\r\nimport { b2Vec2, b2Transform, XY } from \"../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../Collision/b2Collision\";\r\nimport { b2TreeNode } from \"../Collision/b2DynamicTree\";\r\nimport { b2Shape, b2ShapeType, b2MassData } from \"../Collision/Shapes/b2Shape\";\r\nimport { b2Body } from \"./b2Body\";\r\n\r\n/// This holds contact filtering data.\r\nexport interface b2IFilter {\r\n  /// The collision category bits. Normally you would just set one bit.\r\n  categoryBits: number;\r\n\r\n  /// The collision mask bits. This states the categories that this\r\n  /// shape would accept for collision.\r\n  maskBits: number;\r\n\r\n  /// Collision groups allow a certain group of objects to never collide (negative)\r\n  /// or always collide (positive). Zero means no collision group. Non-zero group\r\n  /// filtering always wins against the mask bits.\r\n  groupIndex?: number;\r\n}\r\n\r\n/// This holds contact filtering data.\r\nexport class b2Filter implements b2IFilter {\r\n  public static readonly DEFAULT: Readonly<b2Filter> = new b2Filter();\r\n\r\n  /// The collision category bits. Normally you would just set one bit.\r\n  public categoryBits: number = 0x0001;\r\n\r\n  /// The collision mask bits. This states the categories that this\r\n  /// shape would accept for collision.\r\n  public maskBits: number = 0xFFFF;\r\n\r\n  /// Collision groups allow a certain group of objects to never collide (negative)\r\n  /// or always collide (positive). Zero means no collision group. Non-zero group\r\n  /// filtering always wins against the mask bits.\r\n  public groupIndex: number = 0;\r\n\r\n  public Clone(): b2Filter {\r\n    return new b2Filter().Copy(this);\r\n  }\r\n\r\n  public Copy(other: b2IFilter): this {\r\n    // DEBUG: b2Assert(this !== other);\r\n    this.categoryBits = other.categoryBits;\r\n    this.maskBits = other.maskBits;\r\n    this.groupIndex = other.groupIndex || 0;\r\n    return this;\r\n  }\r\n}\r\n\r\n/// A fixture definition is used to create a fixture. This class defines an\r\n/// abstract fixture definition. You can reuse fixture definitions safely.\r\nexport interface b2IFixtureDef {\r\n  /// The shape, this must be set. The shape will be cloned, so you\r\n  /// can create the shape on the stack.\r\n  shape: b2Shape;\r\n\r\n  /// Use this to store application specific fixture data.\r\n  userData?: any;\r\n\r\n  /// The friction coefficient, usually in the range [0,1].\r\n  friction?: number;\r\n\r\n  /// The restitution (elasticity) usually in the range [0,1].\r\n  restitution?: number;\r\n\r\n  /// The density, usually in kg/m^2.\r\n  density?: number;\r\n\r\n  /// A sensor shape collects contact information but never generates a collision\r\n  /// response.\r\n  isSensor?: boolean;\r\n\r\n  /// Contact filtering data.\r\n  filter?: b2IFilter;\r\n}\r\n\r\n/// A fixture definition is used to create a fixture. This class defines an\r\n/// abstract fixture definition. You can reuse fixture definitions safely.\r\nexport class b2FixtureDef implements b2IFixtureDef {\r\n  /// The shape, this must be set. The shape will be cloned, so you\r\n  /// can create the shape on the stack.\r\n  public shape!: b2Shape;\r\n\r\n  /// Use this to store application specific fixture data.\r\n  public userData: any = null;\r\n\r\n  /// The friction coefficient, usually in the range [0,1].\r\n  public friction: number = 0.2;\r\n\r\n  /// The restitution (elasticity) usually in the range [0,1].\r\n  public restitution: number = 0;\r\n\r\n  /// The density, usually in kg/m^2.\r\n  public density: number = 0;\r\n\r\n  /// A sensor shape collects contact information but never generates a collision\r\n  /// response.\r\n  public isSensor: boolean = false;\r\n\r\n  /// Contact filtering data.\r\n  public readonly filter: b2Filter = new b2Filter();\r\n}\r\n\r\n/// This proxy is used internally to connect fixtures to the broad-phase.\r\nexport class b2FixtureProxy {\r\n  public readonly aabb: b2AABB = new b2AABB();\r\n  public readonly fixture: b2Fixture;\r\n  public readonly childIndex: number = 0;\r\n  public treeNode: b2TreeNode<b2FixtureProxy>;\r\n  constructor(fixture: b2Fixture, childIndex: number) {\r\n    this.fixture = fixture;\r\n    this.childIndex = childIndex;\r\n    this.fixture.m_shape.ComputeAABB(this.aabb, this.fixture.m_body.GetTransform(), childIndex);\r\n    this.treeNode = this.fixture.m_body.m_world.m_contactManager.m_broadPhase.CreateProxy(this.aabb, this);\r\n}\r\n  public Reset(): void {\r\n    this.fixture.m_body.m_world.m_contactManager.m_broadPhase.DestroyProxy(this.treeNode);\r\n  }\r\n  public Touch(): void {\r\n    this.fixture.m_body.m_world.m_contactManager.m_broadPhase.TouchProxy(this.treeNode);\r\n  }\r\n  private static Synchronize_s_aabb1 = new b2AABB();\r\n  private static Synchronize_s_aabb2 = new b2AABB();\r\n  public Synchronize(transform1: b2Transform, transform2: b2Transform, displacement: b2Vec2): void {\r\n    if (transform1 === transform2) {\r\n      this.fixture.m_shape.ComputeAABB(this.aabb, transform1, this.childIndex);\r\n      this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, displacement);\r\n    } else {\r\n      // Compute an AABB that covers the swept shape (may miss some rotation effect).\r\n      const aabb1: b2AABB = b2FixtureProxy.Synchronize_s_aabb1;\r\n      const aabb2: b2AABB = b2FixtureProxy.Synchronize_s_aabb2;\r\n      this.fixture.m_shape.ComputeAABB(aabb1, transform1, this.childIndex);\r\n      this.fixture.m_shape.ComputeAABB(aabb2, transform2, this.childIndex);\r\n      this.aabb.Combine2(aabb1, aabb2);\r\n      this.fixture.m_body.m_world.m_contactManager.m_broadPhase.MoveProxy(this.treeNode, this.aabb, displacement);\r\n    }\r\n  }\r\n}\r\n\r\n/// A fixture is used to attach a shape to a body for collision detection. A fixture\r\n/// inherits its transform from its parent. Fixtures hold additional non-geometric data\r\n/// such as friction, collision filters, etc.\r\n/// Fixtures are created via b2Body::CreateFixture.\r\n/// @warning you cannot reuse fixtures.\r\nexport class b2Fixture {\r\n  public m_density: number = 0;\r\n\r\n  public m_next: b2Fixture | null = null;\r\n  public readonly m_body: b2Body;\r\n\r\n  public readonly m_shape: b2Shape;\r\n\r\n  public m_friction: number = 0;\r\n  public m_restitution: number = 0;\r\n\r\n  public readonly m_proxies: b2FixtureProxy[] = [];\r\n  public get m_proxyCount(): number { return this.m_proxies.length; }\r\n\r\n  public readonly m_filter: b2Filter = new b2Filter();\r\n\r\n  public m_isSensor: boolean = false;\r\n\r\n  public m_userData: any = null;\r\n\r\n  constructor(body: b2Body, def: b2IFixtureDef) {\r\n    this.m_body = body;\r\n    this.m_shape = def.shape.Clone();\r\n    this.m_userData = b2Maybe(def.userData, null);\r\n    this.m_friction = b2Maybe(def.friction,  0.2);\r\n    this.m_restitution = b2Maybe(def.restitution, 0);\r\n    this.m_filter.Copy(b2Maybe(def.filter, b2Filter.DEFAULT));\r\n    this.m_isSensor = b2Maybe(def.isSensor, false);\r\n    this.m_density = b2Maybe(def.density, 0);\r\n  }\r\n\r\n  public Reset(): void {\r\n    // The proxies must be destroyed before calling this.\r\n    // DEBUG: b2Assert(this.m_proxyCount === 0);\r\n  }\r\n\r\n  /// Get the type of the child shape. You can use this to down cast to the concrete shape.\r\n  /// @return the shape type.\r\n  public GetType(): b2ShapeType {\r\n    return this.m_shape.GetType();\r\n  }\r\n\r\n  /// Get the child shape. You can modify the child shape, however you should not change the\r\n  /// number of vertices because this will crash some collision caching mechanisms.\r\n  /// Manipulating the shape may lead to non-physical behavior.\r\n  public GetShape(): b2Shape {\r\n    return this.m_shape;\r\n  }\r\n\r\n  /// Set if this fixture is a sensor.\r\n  public SetSensor(sensor: boolean): void {\r\n    if (sensor !== this.m_isSensor) {\r\n      this.m_body.SetAwake(true);\r\n      this.m_isSensor = sensor;\r\n    }\r\n  }\r\n\r\n  /// Is this fixture a sensor (non-solid)?\r\n  /// @return the true if the shape is a sensor.\r\n  public IsSensor(): boolean {\r\n    return this.m_isSensor;\r\n  }\r\n\r\n  /// Set the contact filtering data. This will not update contacts until the next time\r\n  /// step when either parent body is active and awake.\r\n  /// This automatically calls Refilter.\r\n  public SetFilterData(filter: b2Filter): void {\r\n    this.m_filter.Copy(filter);\r\n\r\n    this.Refilter();\r\n  }\r\n\r\n  /// Get the contact filtering data.\r\n  public GetFilterData(): Readonly<b2Filter> {\r\n    return this.m_filter;\r\n  }\r\n\r\n  /// Call this if you want to establish collision that was previously disabled by b2ContactFilter::ShouldCollide.\r\n  public Refilter(): void {\r\n    // Flag associated contacts for filtering.\r\n    let edge = this.m_body.GetContactList();\r\n\r\n    while (edge) {\r\n      const contact = edge.contact;\r\n      const fixtureA = contact.GetFixtureA();\r\n      const fixtureB = contact.GetFixtureB();\r\n      if (fixtureA === this || fixtureB === this) {\r\n        contact.FlagForFiltering();\r\n      }\r\n\r\n      edge = edge.next;\r\n    }\r\n\r\n    // Touch each proxy so that new pairs may be created\r\n    this.TouchProxies();\r\n  }\r\n\r\n  /// Get the parent body of this fixture. This is NULL if the fixture is not attached.\r\n  /// @return the parent body.\r\n  public GetBody(): b2Body {\r\n    return this.m_body;\r\n  }\r\n\r\n  /// Get the next fixture in the parent body's fixture list.\r\n  /// @return the next shape.\r\n  public GetNext(): b2Fixture | null {\r\n    return this.m_next;\r\n  }\r\n\r\n  /// Get the user data that was assigned in the fixture definition. Use this to\r\n  /// store your application specific data.\r\n  public GetUserData(): any {\r\n    return this.m_userData;\r\n  }\r\n\r\n  /// Set the user data. Use this to store your application specific data.\r\n  public SetUserData(data: any): void {\r\n    this.m_userData = data;\r\n  }\r\n\r\n  /// Test a point for containment in this fixture.\r\n  /// @param p a point in world coordinates.\r\n  public TestPoint(p: XY): boolean {\r\n    return this.m_shape.TestPoint(this.m_body.GetTransform(), p);\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public ComputeDistance(p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    return this.m_shape.ComputeDistance(this.m_body.GetTransform(), p, normal, childIndex);\r\n  }\r\n  // #endif\r\n\r\n  /// Cast a ray against this shape.\r\n  /// @param output the ray-cast results.\r\n  /// @param input the ray-cast input parameters.\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, childIndex: number): boolean {\r\n    return this.m_shape.RayCast(output, input, this.m_body.GetTransform(), childIndex);\r\n  }\r\n\r\n  /// Get the mass data for this fixture. The mass data is based on the density and\r\n  /// the shape. The rotational inertia is about the shape's origin. This operation\r\n  /// may be expensive.\r\n  public GetMassData(massData: b2MassData = new b2MassData()): b2MassData {\r\n    this.m_shape.ComputeMass(massData, this.m_density);\r\n\r\n    return massData;\r\n  }\r\n\r\n  /// Set the density of this fixture. This will _not_ automatically adjust the mass\r\n  /// of the body. You must call b2Body::ResetMassData to update the body's mass.\r\n  public SetDensity(density: number): void {\r\n    this.m_density = density;\r\n  }\r\n\r\n  /// Get the density of this fixture.\r\n  public GetDensity(): number {\r\n    return this.m_density;\r\n  }\r\n\r\n  /// Get the coefficient of friction.\r\n  public GetFriction(): number {\r\n    return this.m_friction;\r\n  }\r\n\r\n  /// Set the coefficient of friction. This will _not_ change the friction of\r\n  /// existing contacts.\r\n  public SetFriction(friction: number): void {\r\n    this.m_friction = friction;\r\n  }\r\n\r\n  /// Get the coefficient of restitution.\r\n  public GetRestitution(): number {\r\n    return this.m_restitution;\r\n  }\r\n\r\n  /// Set the coefficient of restitution. This will _not_ change the restitution of\r\n  /// existing contacts.\r\n  public SetRestitution(restitution: number): void {\r\n    this.m_restitution = restitution;\r\n  }\r\n\r\n  /// Get the fixture's AABB. This AABB may be enlarge and/or stale.\r\n  /// If you need a more accurate AABB, compute it using the shape and\r\n  /// the body transform.\r\n  public GetAABB(childIndex: number): Readonly<b2AABB> {\r\n    // DEBUG: b2Assert(0 <= childIndex && childIndex < this.m_proxyCount);\r\n    return this.m_proxies[childIndex].aabb;\r\n  }\r\n\r\n  /// Dump this fixture to the log file.\r\n  public Dump(log: (format: string, ...args: any[]) => void, bodyIndex: number): void {\r\n    log(\"    const fd: b2FixtureDef = new b2FixtureDef();\\n\");\r\n    log(\"    fd.friction = %.15f;\\n\", this.m_friction);\r\n    log(\"    fd.restitution = %.15f;\\n\", this.m_restitution);\r\n    log(\"    fd.density = %.15f;\\n\", this.m_density);\r\n    log(\"    fd.isSensor = %s;\\n\", (this.m_isSensor) ? (\"true\") : (\"false\"));\r\n    log(\"    fd.filter.categoryBits = %d;\\n\", this.m_filter.categoryBits);\r\n    log(\"    fd.filter.maskBits = %d;\\n\", this.m_filter.maskBits);\r\n    log(\"    fd.filter.groupIndex = %d;\\n\", this.m_filter.groupIndex);\r\n\r\n    this.m_shape.Dump(log);\r\n\r\n    log(\"\\n\");\r\n    log(\"    fd.shape = shape;\\n\");\r\n    log(\"\\n\");\r\n    log(\"    bodies[%d].CreateFixture(fd);\\n\", bodyIndex);\r\n  }\r\n\r\n  // These support body activation/deactivation.\r\n  public CreateProxies(): void {\r\n    if (this.m_proxies.length !== 0) { throw new Error(); }\r\n    // Create proxies in the broad-phase.\r\n    for (let i: number = 0; i < this.m_shape.GetChildCount(); ++i) {\r\n      this.m_proxies[i] = new b2FixtureProxy(this, i);\r\n    }\r\n  }\r\n\r\n  public DestroyProxies(): void {\r\n    // Destroy proxies in the broad-phase.\r\n    for (const proxy of this.m_proxies) {\r\n      proxy.Reset();\r\n    }\r\n    this.m_proxies.length = 0;\r\n  }\r\n\r\n  public TouchProxies(): void {\r\n    for (const proxy of this.m_proxies) {\r\n      proxy.Touch();\r\n    }\r\n  }\r\n\r\n  public SynchronizeProxies(transform1: b2Transform, transform2: b2Transform, displacement: b2Vec2): void {\r\n    for (const proxy of this.m_proxies) {\r\n      proxy.Synchronize(transform1, transform2, displacement);\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"25ae7f9d2581088960185b86c2063cba","cacheData":{"env":{}}}