{"id":"../node_modules/box2d.package.ts/Collision/b2Collision.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Distance","loc":{"line":23,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Distance.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Distance_1 = require(\"./b2Distance\");\r\n/// @file\r\n/// Structures and functions used for computing contact points, distance\r\n/// queries, and TOI queries.\r\nvar b2ContactFeatureType;\r\n(function (b2ContactFeatureType) {\r\n    b2ContactFeatureType[b2ContactFeatureType[\"e_vertex\"] = 0] = \"e_vertex\";\r\n    b2ContactFeatureType[b2ContactFeatureType[\"e_face\"] = 1] = \"e_face\";\r\n})(b2ContactFeatureType = exports.b2ContactFeatureType || (exports.b2ContactFeatureType = {}));\r\n/// The features that intersect to form the contact point\r\n/// This must be 4 bytes or less.\r\nvar b2ContactFeature = /** @class */ (function () {\r\n    function b2ContactFeature() {\r\n        this._key = 0;\r\n        this._key_invalid = false;\r\n        this._indexA = 0;\r\n        this._indexB = 0;\r\n        this._typeA = 0;\r\n        this._typeB = 0;\r\n    }\r\n    Object.defineProperty(b2ContactFeature.prototype, \"key\", {\r\n        get: function () {\r\n            if (this._key_invalid) {\r\n                this._key_invalid = false;\r\n                this._key = this._indexA | (this._indexB << 8) | (this._typeA << 16) | (this._typeB << 24);\r\n            }\r\n            return this._key;\r\n        },\r\n        set: function (value) {\r\n            this._key = value;\r\n            this._key_invalid = false;\r\n            this._indexA = this._key & 0xff;\r\n            this._indexB = (this._key >> 8) & 0xff;\r\n            this._typeA = (this._key >> 16) & 0xff;\r\n            this._typeB = (this._key >> 24) & 0xff;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(b2ContactFeature.prototype, \"indexA\", {\r\n        get: function () {\r\n            return this._indexA;\r\n        },\r\n        set: function (value) {\r\n            this._indexA = value;\r\n            this._key_invalid = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(b2ContactFeature.prototype, \"indexB\", {\r\n        get: function () {\r\n            return this._indexB;\r\n        },\r\n        set: function (value) {\r\n            this._indexB = value;\r\n            this._key_invalid = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(b2ContactFeature.prototype, \"typeA\", {\r\n        get: function () {\r\n            return this._typeA;\r\n        },\r\n        set: function (value) {\r\n            this._typeA = value;\r\n            this._key_invalid = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(b2ContactFeature.prototype, \"typeB\", {\r\n        get: function () {\r\n            return this._typeB;\r\n        },\r\n        set: function (value) {\r\n            this._typeB = value;\r\n            this._key_invalid = true;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return b2ContactFeature;\r\n}());\r\nexports.b2ContactFeature = b2ContactFeature;\r\n/// Contact ids to facilitate warm starting.\r\nvar b2ContactID = /** @class */ (function () {\r\n    function b2ContactID() {\r\n        this.cf = new b2ContactFeature();\r\n    }\r\n    b2ContactID.prototype.Copy = function (o) {\r\n        this.key = o.key;\r\n        return this;\r\n    };\r\n    b2ContactID.prototype.Clone = function () {\r\n        return new b2ContactID().Copy(this);\r\n    };\r\n    Object.defineProperty(b2ContactID.prototype, \"key\", {\r\n        get: function () {\r\n            return this.cf.key;\r\n        },\r\n        set: function (value) {\r\n            this.cf.key = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return b2ContactID;\r\n}());\r\nexports.b2ContactID = b2ContactID;\r\n/// A manifold point is a contact point belonging to a contact\r\n/// manifold. It holds details related to the geometry and dynamics\r\n/// of the contact points.\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleB\r\n/// -e_faceA: the local center of cirlceB or the clip point of polygonB\r\n/// -e_faceB: the clip point of polygonA\r\n/// This structure is stored across time steps, so we keep it small.\r\n/// Note: the impulses are used for internal caching and may not\r\n/// provide reliable contact forces, especially for high speed collisions.\r\nvar b2ManifoldPoint = /** @class */ (function () {\r\n    function b2ManifoldPoint() {\r\n        this.localPoint = new b2Math_1.b2Vec2(); ///< usage depends on manifold type\r\n        this.normalImpulse = 0; ///< the non-penetration impulse\r\n        this.tangentImpulse = 0; ///< the friction impulse\r\n        this.id = new b2ContactID(); ///< uniquely identifies a contact point between two shapes\r\n    }\r\n    b2ManifoldPoint.MakeArray = function (length) {\r\n        return b2Settings_1.b2MakeArray(length, function (i) { return new b2ManifoldPoint(); });\r\n    };\r\n    b2ManifoldPoint.prototype.Reset = function () {\r\n        this.localPoint.SetZero();\r\n        this.normalImpulse = 0;\r\n        this.tangentImpulse = 0;\r\n        this.id.key = 0;\r\n    };\r\n    b2ManifoldPoint.prototype.Copy = function (o) {\r\n        this.localPoint.Copy(o.localPoint);\r\n        this.normalImpulse = o.normalImpulse;\r\n        this.tangentImpulse = o.tangentImpulse;\r\n        this.id.Copy(o.id);\r\n        return this;\r\n    };\r\n    return b2ManifoldPoint;\r\n}());\r\nexports.b2ManifoldPoint = b2ManifoldPoint;\r\nvar b2ManifoldType;\r\n(function (b2ManifoldType) {\r\n    b2ManifoldType[b2ManifoldType[\"e_unknown\"] = -1] = \"e_unknown\";\r\n    b2ManifoldType[b2ManifoldType[\"e_circles\"] = 0] = \"e_circles\";\r\n    b2ManifoldType[b2ManifoldType[\"e_faceA\"] = 1] = \"e_faceA\";\r\n    b2ManifoldType[b2ManifoldType[\"e_faceB\"] = 2] = \"e_faceB\";\r\n})(b2ManifoldType = exports.b2ManifoldType || (exports.b2ManifoldType = {}));\r\n/// A manifold for two touching convex shapes.\r\n/// Box2D supports multiple types of contact:\r\n/// - clip point versus plane with radius\r\n/// - point versus point with radius (circles)\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleA\r\n/// -e_faceA: the center of faceA\r\n/// -e_faceB: the center of faceB\r\n/// Similarly the local normal usage:\r\n/// -e_circles: not used\r\n/// -e_faceA: the normal on polygonA\r\n/// -e_faceB: the normal on polygonB\r\n/// We store contacts in this way so that position correction can\r\n/// account for movement, which is critical for continuous physics.\r\n/// All contact scenarios must be expressed in one of these types.\r\n/// This structure is stored across time steps, so we keep it small.\r\nvar b2Manifold = /** @class */ (function () {\r\n    function b2Manifold() {\r\n        this.points = b2ManifoldPoint.MakeArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.localNormal = new b2Math_1.b2Vec2();\r\n        this.localPoint = new b2Math_1.b2Vec2();\r\n        this.type = b2ManifoldType.e_unknown;\r\n        this.pointCount = 0;\r\n    }\r\n    b2Manifold.prototype.Reset = function () {\r\n        for (var i = 0; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n            // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);\r\n            this.points[i].Reset();\r\n        }\r\n        this.localNormal.SetZero();\r\n        this.localPoint.SetZero();\r\n        this.type = b2ManifoldType.e_unknown;\r\n        this.pointCount = 0;\r\n    };\r\n    b2Manifold.prototype.Copy = function (o) {\r\n        this.pointCount = o.pointCount;\r\n        for (var i = 0; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n            // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);\r\n            this.points[i].Copy(o.points[i]);\r\n        }\r\n        this.localNormal.Copy(o.localNormal);\r\n        this.localPoint.Copy(o.localPoint);\r\n        this.type = o.type;\r\n        return this;\r\n    };\r\n    b2Manifold.prototype.Clone = function () {\r\n        return new b2Manifold().Copy(this);\r\n    };\r\n    return b2Manifold;\r\n}());\r\nexports.b2Manifold = b2Manifold;\r\nvar b2WorldManifold = /** @class */ (function () {\r\n    function b2WorldManifold() {\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.points = b2Math_1.b2Vec2.MakeArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.separations = b2Settings_1.b2MakeNumberArray(b2Settings_1.b2_maxManifoldPoints);\r\n    }\r\n    b2WorldManifold.prototype.Initialize = function (manifold, xfA, radiusA, xfB, radiusB) {\r\n        if (manifold.pointCount === 0) {\r\n            return;\r\n        }\r\n        switch (manifold.type) {\r\n            case b2ManifoldType.e_circles: {\r\n                this.normal.Set(1, 0);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_pointA);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, manifold.points[0].localPoint, b2WorldManifold.Initialize_s_pointB);\r\n                if (b2Math_1.b2Vec2.DistanceSquaredVV(pointA, pointB) > b2Settings_1.b2_epsilon_sq) {\r\n                    b2Math_1.b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n                }\r\n                var cA = b2Math_1.b2Vec2.AddVMulSV(pointA, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);\r\n                var cB = b2Math_1.b2Vec2.SubVMulSV(pointB, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);\r\n                b2Math_1.b2Vec2.MidVV(cA, cB, this.points[0]);\r\n                this.separations[0] = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cB, cA, b2Math_1.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n                break;\r\n            }\r\n            case b2ManifoldType.e_faceA: {\r\n                b2Math_1.b2Rot.MulRV(xfA.q, manifold.localNormal, this.normal);\r\n                var planePoint = b2Math_1.b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);\r\n                for (var i = 0; i < manifold.pointCount; ++i) {\r\n                    var clipPoint = b2Math_1.b2Transform.MulXV(xfB, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);\r\n                    var s = radiusA - b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(clipPoint, planePoint, b2Math_1.b2Vec2.s_t0), this.normal);\r\n                    var cA = b2Math_1.b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cA);\r\n                    var cB = b2Math_1.b2Vec2.SubVMulSV(clipPoint, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);\r\n                    b2Math_1.b2Vec2.MidVV(cA, cB, this.points[i]);\r\n                    this.separations[i] = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cB, cA, b2Math_1.b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n                }\r\n                break;\r\n            }\r\n            case b2ManifoldType.e_faceB: {\r\n                b2Math_1.b2Rot.MulRV(xfB.q, manifold.localNormal, this.normal);\r\n                var planePoint = b2Math_1.b2Transform.MulXV(xfB, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);\r\n                for (var i = 0; i < manifold.pointCount; ++i) {\r\n                    var clipPoint = b2Math_1.b2Transform.MulXV(xfA, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);\r\n                    var s = radiusB - b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(clipPoint, planePoint, b2Math_1.b2Vec2.s_t0), this.normal);\r\n                    var cB = b2Math_1.b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cB);\r\n                    var cA = b2Math_1.b2Vec2.SubVMulSV(clipPoint, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);\r\n                    b2Math_1.b2Vec2.MidVV(cA, cB, this.points[i]);\r\n                    this.separations[i] = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cA, cB, b2Math_1.b2Vec2.s_t0), this.normal); // b2Dot(cA - cB, normal);\r\n                }\r\n                // Ensure normal points from A to B.\r\n                this.normal.SelfNeg();\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    b2WorldManifold.Initialize_s_pointA = new b2Math_1.b2Vec2();\r\n    b2WorldManifold.Initialize_s_pointB = new b2Math_1.b2Vec2();\r\n    b2WorldManifold.Initialize_s_cA = new b2Math_1.b2Vec2();\r\n    b2WorldManifold.Initialize_s_cB = new b2Math_1.b2Vec2();\r\n    b2WorldManifold.Initialize_s_planePoint = new b2Math_1.b2Vec2();\r\n    b2WorldManifold.Initialize_s_clipPoint = new b2Math_1.b2Vec2();\r\n    return b2WorldManifold;\r\n}());\r\nexports.b2WorldManifold = b2WorldManifold;\r\n/// This is used for determining the state of contact points.\r\nvar b2PointState;\r\n(function (b2PointState) {\r\n    b2PointState[b2PointState[\"b2_nullState\"] = 0] = \"b2_nullState\";\r\n    b2PointState[b2PointState[\"b2_addState\"] = 1] = \"b2_addState\";\r\n    b2PointState[b2PointState[\"b2_persistState\"] = 2] = \"b2_persistState\";\r\n    b2PointState[b2PointState[\"b2_removeState\"] = 3] = \"b2_removeState\";\r\n})(b2PointState = exports.b2PointState || (exports.b2PointState = {}));\r\n/// Compute the point states given two manifolds. The states pertain to the transition from manifold1\r\n/// to manifold2. So state1 is either persist or remove while state2 is either add or persist.\r\nfunction b2GetPointStates(state1, state2, manifold1, manifold2) {\r\n    // Detect persists and removes.\r\n    var i;\r\n    for (i = 0; i < manifold1.pointCount; ++i) {\r\n        var id = manifold1.points[i].id;\r\n        var key = id.key;\r\n        state1[i] = b2PointState.b2_removeState;\r\n        for (var j = 0, jct = manifold2.pointCount; j < jct; ++j) {\r\n            if (manifold2.points[j].id.key === key) {\r\n                state1[i] = b2PointState.b2_persistState;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n        state1[i] = b2PointState.b2_nullState;\r\n    }\r\n    // Detect persists and adds.\r\n    for (i = 0; i < manifold2.pointCount; ++i) {\r\n        var id = manifold2.points[i].id;\r\n        var key = id.key;\r\n        state2[i] = b2PointState.b2_addState;\r\n        for (var j = 0, jct = manifold1.pointCount; j < jct; ++j) {\r\n            if (manifold1.points[j].id.key === key) {\r\n                state2[i] = b2PointState.b2_persistState;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n        state2[i] = b2PointState.b2_nullState;\r\n    }\r\n}\r\nexports.b2GetPointStates = b2GetPointStates;\r\n/// Used for computing contact manifolds.\r\nvar b2ClipVertex = /** @class */ (function () {\r\n    function b2ClipVertex() {\r\n        this.v = new b2Math_1.b2Vec2();\r\n        this.id = new b2ContactID();\r\n    }\r\n    b2ClipVertex.MakeArray = function (length) {\r\n        return b2Settings_1.b2MakeArray(length, function (i) { return new b2ClipVertex(); });\r\n    };\r\n    b2ClipVertex.prototype.Copy = function (other) {\r\n        this.v.Copy(other.v);\r\n        this.id.Copy(other.id);\r\n        return this;\r\n    };\r\n    return b2ClipVertex;\r\n}());\r\nexports.b2ClipVertex = b2ClipVertex;\r\n/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\nvar b2RayCastInput = /** @class */ (function () {\r\n    function b2RayCastInput() {\r\n        this.p1 = new b2Math_1.b2Vec2();\r\n        this.p2 = new b2Math_1.b2Vec2();\r\n        this.maxFraction = 1;\r\n    }\r\n    b2RayCastInput.prototype.Copy = function (o) {\r\n        this.p1.Copy(o.p1);\r\n        this.p2.Copy(o.p2);\r\n        this.maxFraction = o.maxFraction;\r\n        return this;\r\n    };\r\n    return b2RayCastInput;\r\n}());\r\nexports.b2RayCastInput = b2RayCastInput;\r\n/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2\r\n/// come from b2RayCastInput.\r\nvar b2RayCastOutput = /** @class */ (function () {\r\n    function b2RayCastOutput() {\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.fraction = 0;\r\n    }\r\n    b2RayCastOutput.prototype.Copy = function (o) {\r\n        this.normal.Copy(o.normal);\r\n        this.fraction = o.fraction;\r\n        return this;\r\n    };\r\n    return b2RayCastOutput;\r\n}());\r\nexports.b2RayCastOutput = b2RayCastOutput;\r\n/// An axis aligned bounding box.\r\nvar b2AABB = /** @class */ (function () {\r\n    function b2AABB() {\r\n        this.lowerBound = new b2Math_1.b2Vec2(); ///< the lower vertex\r\n        this.upperBound = new b2Math_1.b2Vec2(); ///< the upper vertex\r\n        this.m_cache_center = new b2Math_1.b2Vec2(); // access using GetCenter()\r\n        this.m_cache_extent = new b2Math_1.b2Vec2(); // access using GetExtents()\r\n    }\r\n    b2AABB.prototype.Copy = function (o) {\r\n        this.lowerBound.Copy(o.lowerBound);\r\n        this.upperBound.Copy(o.upperBound);\r\n        return this;\r\n    };\r\n    /// Verify that the bounds are sorted.\r\n    b2AABB.prototype.IsValid = function () {\r\n        if (!this.lowerBound.IsValid()) {\r\n            return false;\r\n        }\r\n        if (!this.upperBound.IsValid()) {\r\n            return false;\r\n        }\r\n        if (this.upperBound.x < this.lowerBound.x) {\r\n            return false;\r\n        }\r\n        if (this.upperBound.y < this.lowerBound.y) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    /// Get the center of the AABB.\r\n    b2AABB.prototype.GetCenter = function () {\r\n        return b2Math_1.b2Vec2.MidVV(this.lowerBound, this.upperBound, this.m_cache_center);\r\n    };\r\n    /// Get the extents of the AABB (half-widths).\r\n    b2AABB.prototype.GetExtents = function () {\r\n        return b2Math_1.b2Vec2.ExtVV(this.lowerBound, this.upperBound, this.m_cache_extent);\r\n    };\r\n    /// Get the perimeter length\r\n    b2AABB.prototype.GetPerimeter = function () {\r\n        var wx = this.upperBound.x - this.lowerBound.x;\r\n        var wy = this.upperBound.y - this.lowerBound.y;\r\n        return 2 * (wx + wy);\r\n    };\r\n    /// Combine an AABB into this one.\r\n    b2AABB.prototype.Combine1 = function (aabb) {\r\n        this.lowerBound.x = b2Math_1.b2Min(this.lowerBound.x, aabb.lowerBound.x);\r\n        this.lowerBound.y = b2Math_1.b2Min(this.lowerBound.y, aabb.lowerBound.y);\r\n        this.upperBound.x = b2Math_1.b2Max(this.upperBound.x, aabb.upperBound.x);\r\n        this.upperBound.y = b2Math_1.b2Max(this.upperBound.y, aabb.upperBound.y);\r\n        return this;\r\n    };\r\n    /// Combine two AABBs into this one.\r\n    b2AABB.prototype.Combine2 = function (aabb1, aabb2) {\r\n        this.lowerBound.x = b2Math_1.b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);\r\n        this.lowerBound.y = b2Math_1.b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);\r\n        this.upperBound.x = b2Math_1.b2Max(aabb1.upperBound.x, aabb2.upperBound.x);\r\n        this.upperBound.y = b2Math_1.b2Max(aabb1.upperBound.y, aabb2.upperBound.y);\r\n        return this;\r\n    };\r\n    b2AABB.Combine = function (aabb1, aabb2, out) {\r\n        out.Combine2(aabb1, aabb2);\r\n        return out;\r\n    };\r\n    /// Does this aabb contain the provided AABB.\r\n    b2AABB.prototype.Contains = function (aabb) {\r\n        if (this.lowerBound.x <= aabb.lowerBound.x) {\r\n            return false;\r\n        }\r\n        if (this.lowerBound.y <= aabb.lowerBound.y) {\r\n            return false;\r\n        }\r\n        if (aabb.upperBound.x <= this.upperBound.x) {\r\n            return false;\r\n        }\r\n        if (aabb.upperBound.y <= this.upperBound.y) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    // From Real-time Collision Detection, p179.\r\n    b2AABB.prototype.RayCast = function (output, input) {\r\n        var tmin = (-b2Settings_1.b2_maxFloat);\r\n        var tmax = b2Settings_1.b2_maxFloat;\r\n        var p_x = input.p1.x;\r\n        var p_y = input.p1.y;\r\n        var d_x = input.p2.x - input.p1.x;\r\n        var d_y = input.p2.y - input.p1.y;\r\n        var absD_x = b2Math_1.b2Abs(d_x);\r\n        var absD_y = b2Math_1.b2Abs(d_y);\r\n        var normal = output.normal;\r\n        if (absD_x < b2Settings_1.b2_epsilon) {\r\n            // Parallel.\r\n            if (p_x < this.lowerBound.x || this.upperBound.x < p_x) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            var inv_d = 1 / d_x;\r\n            var t1 = (this.lowerBound.x - p_x) * inv_d;\r\n            var t2 = (this.upperBound.x - p_x) * inv_d;\r\n            // Sign of the normal vector.\r\n            var s = (-1);\r\n            if (t1 > t2) {\r\n                var t3 = t1;\r\n                t1 = t2;\r\n                t2 = t3;\r\n                s = 1;\r\n            }\r\n            // Push the min up\r\n            if (t1 > tmin) {\r\n                normal.x = s;\r\n                normal.y = 0;\r\n                tmin = t1;\r\n            }\r\n            // Pull the max down\r\n            tmax = b2Math_1.b2Min(tmax, t2);\r\n            if (tmin > tmax) {\r\n                return false;\r\n            }\r\n        }\r\n        if (absD_y < b2Settings_1.b2_epsilon) {\r\n            // Parallel.\r\n            if (p_y < this.lowerBound.y || this.upperBound.y < p_y) {\r\n                return false;\r\n            }\r\n        }\r\n        else {\r\n            var inv_d = 1 / d_y;\r\n            var t1 = (this.lowerBound.y - p_y) * inv_d;\r\n            var t2 = (this.upperBound.y - p_y) * inv_d;\r\n            // Sign of the normal vector.\r\n            var s = (-1);\r\n            if (t1 > t2) {\r\n                var t3 = t1;\r\n                t1 = t2;\r\n                t2 = t3;\r\n                s = 1;\r\n            }\r\n            // Push the min up\r\n            if (t1 > tmin) {\r\n                normal.x = 0;\r\n                normal.y = s;\r\n                tmin = t1;\r\n            }\r\n            // Pull the max down\r\n            tmax = b2Math_1.b2Min(tmax, t2);\r\n            if (tmin > tmax) {\r\n                return false;\r\n            }\r\n        }\r\n        // Does the ray start inside the box?\r\n        // Does the ray intersect beyond the max fraction?\r\n        if (tmin < 0 || input.maxFraction < tmin) {\r\n            return false;\r\n        }\r\n        // Intersection.\r\n        output.fraction = tmin;\r\n        return true;\r\n    };\r\n    b2AABB.prototype.TestContain = function (point) {\r\n        if (point.x < this.lowerBound.x || this.upperBound.x < point.x) {\r\n            return false;\r\n        }\r\n        if (point.y < this.lowerBound.y || this.upperBound.y < point.y) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    b2AABB.prototype.TestOverlap = function (other) {\r\n        if (this.upperBound.x < other.lowerBound.x) {\r\n            return false;\r\n        }\r\n        if (this.upperBound.y < other.lowerBound.y) {\r\n            return false;\r\n        }\r\n        if (other.upperBound.x < this.lowerBound.x) {\r\n            return false;\r\n        }\r\n        if (other.upperBound.y < this.lowerBound.y) {\r\n            return false;\r\n        }\r\n        return true;\r\n    };\r\n    return b2AABB;\r\n}());\r\nexports.b2AABB = b2AABB;\r\nfunction b2TestOverlapAABB(a, b) {\r\n    if (a.upperBound.x < b.lowerBound.x) {\r\n        return false;\r\n    }\r\n    if (a.upperBound.y < b.lowerBound.y) {\r\n        return false;\r\n    }\r\n    if (b.upperBound.x < a.lowerBound.x) {\r\n        return false;\r\n    }\r\n    if (b.upperBound.y < a.lowerBound.y) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nexports.b2TestOverlapAABB = b2TestOverlapAABB;\r\n/// Clipping for contact manifolds.\r\nfunction b2ClipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {\r\n    // Start with no output points\r\n    var numOut = 0;\r\n    var vIn0 = vIn[0];\r\n    var vIn1 = vIn[1];\r\n    // Calculate the distance of end points to the line\r\n    var distance0 = b2Math_1.b2Vec2.DotVV(normal, vIn0.v) - offset;\r\n    var distance1 = b2Math_1.b2Vec2.DotVV(normal, vIn1.v) - offset;\r\n    // If the points are behind the plane\r\n    if (distance0 <= 0) {\r\n        vOut[numOut++].Copy(vIn0);\r\n    }\r\n    if (distance1 <= 0) {\r\n        vOut[numOut++].Copy(vIn1);\r\n    }\r\n    // If the points are on different sides of the plane\r\n    if (distance0 * distance1 < 0) {\r\n        // Find intersection point of edge and plane\r\n        var interp = distance0 / (distance0 - distance1);\r\n        var v = vOut[numOut].v;\r\n        v.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);\r\n        v.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);\r\n        // VertexA is hitting edgeB.\r\n        var id = vOut[numOut].id;\r\n        id.cf.indexA = vertexIndexA;\r\n        id.cf.indexB = vIn0.id.cf.indexB;\r\n        id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n        id.cf.typeB = b2ContactFeatureType.e_face;\r\n        ++numOut;\r\n    }\r\n    return numOut;\r\n}\r\nexports.b2ClipSegmentToLine = b2ClipSegmentToLine;\r\n/// Determine if two generic shapes overlap.\r\nvar b2TestOverlapShape_s_input = new b2Distance_1.b2DistanceInput();\r\nvar b2TestOverlapShape_s_simplexCache = new b2Distance_1.b2SimplexCache();\r\nvar b2TestOverlapShape_s_output = new b2Distance_1.b2DistanceOutput();\r\nfunction b2TestOverlapShape(shapeA, indexA, shapeB, indexB, xfA, xfB) {\r\n    var input = b2TestOverlapShape_s_input.Reset();\r\n    input.proxyA.SetShape(shapeA, indexA);\r\n    input.proxyB.SetShape(shapeB, indexB);\r\n    input.transformA.Copy(xfA);\r\n    input.transformB.Copy(xfB);\r\n    input.useRadii = true;\r\n    var simplexCache = b2TestOverlapShape_s_simplexCache.Reset();\r\n    simplexCache.count = 0;\r\n    var output = b2TestOverlapShape_s_output.Reset();\r\n    b2Distance_1.b2Distance(output, simplexCache, input);\r\n    return output.distance < 10 * b2Settings_1.b2_epsilon;\r\n}\r\nexports.b2TestOverlapShape = b2TestOverlapShape;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Collision.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2Collision.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_maxFloat, b2_epsilon, b2_epsilon_sq, b2_maxManifoldPoints, b2MakeArray, b2MakeNumberArray } from \"../Common/b2Settings\";\r\nimport { b2Abs, b2Min, b2Max, b2Vec2, b2Rot, b2Transform, XY } from \"../Common/b2Math\";\r\nimport { b2Shape } from \"./Shapes/b2Shape\";\r\nimport { b2Distance, b2DistanceInput, b2DistanceOutput, b2SimplexCache } from \"./b2Distance\";\r\n\r\n/// @file\r\n/// Structures and functions used for computing contact points, distance\r\n/// queries, and TOI queries.\r\n\r\nexport enum b2ContactFeatureType {\r\n  e_vertex = 0,\r\n  e_face = 1,\r\n}\r\n\r\n/// The features that intersect to form the contact point\r\n/// This must be 4 bytes or less.\r\nexport class b2ContactFeature {\r\n  private _key: number = 0;\r\n  private _key_invalid = false;\r\n  private _indexA: number = 0;\r\n  private _indexB: number = 0;\r\n  private _typeA: b2ContactFeatureType = 0;\r\n  private _typeB: b2ContactFeatureType = 0;\r\n\r\n  public get key(): number {\r\n    if (this._key_invalid) {\r\n      this._key_invalid = false;\r\n      this._key = this._indexA | (this._indexB << 8) | (this._typeA << 16) | (this._typeB << 24);\r\n    }\r\n    return this._key;\r\n  }\r\n\r\n  public set key(value: number) {\r\n    this._key = value;\r\n    this._key_invalid = false;\r\n    this._indexA = this._key & 0xff;\r\n    this._indexB = (this._key >> 8) & 0xff;\r\n    this._typeA = (this._key >> 16) & 0xff;\r\n    this._typeB = (this._key >> 24) & 0xff;\r\n  }\r\n\r\n  public get indexA(): number {\r\n    return this._indexA;\r\n  }\r\n\r\n  public set indexA(value: number) {\r\n    this._indexA = value;\r\n    this._key_invalid = true;\r\n  }\r\n\r\n  public get indexB(): number {\r\n    return this._indexB;\r\n  }\r\n\r\n  public set indexB(value: number) {\r\n    this._indexB = value;\r\n    this._key_invalid = true;\r\n  }\r\n\r\n  public get typeA(): number {\r\n    return this._typeA;\r\n  }\r\n\r\n  public set typeA(value: number) {\r\n    this._typeA = value;\r\n    this._key_invalid = true;\r\n  }\r\n\r\n  public get typeB(): number {\r\n    return this._typeB;\r\n  }\r\n\r\n  public set typeB(value: number) {\r\n    this._typeB = value;\r\n    this._key_invalid = true;\r\n  }\r\n}\r\n\r\n/// Contact ids to facilitate warm starting.\r\nexport class b2ContactID {\r\n  public readonly cf: b2ContactFeature = new b2ContactFeature();\r\n\r\n  public Copy(o: b2ContactID): b2ContactID {\r\n    this.key = o.key;\r\n    return this;\r\n  }\r\n\r\n  public Clone(): b2ContactID {\r\n    return new b2ContactID().Copy(this);\r\n  }\r\n\r\n  public get key(): number {\r\n    return this.cf.key;\r\n  }\r\n\r\n  public set key(value: number) {\r\n    this.cf.key = value;\r\n  }\r\n}\r\n\r\n/// A manifold point is a contact point belonging to a contact\r\n/// manifold. It holds details related to the geometry and dynamics\r\n/// of the contact points.\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleB\r\n/// -e_faceA: the local center of cirlceB or the clip point of polygonB\r\n/// -e_faceB: the clip point of polygonA\r\n/// This structure is stored across time steps, so we keep it small.\r\n/// Note: the impulses are used for internal caching and may not\r\n/// provide reliable contact forces, especially for high speed collisions.\r\nexport class b2ManifoldPoint {\r\n  public readonly localPoint: b2Vec2 = new b2Vec2();  ///< usage depends on manifold type\r\n  public normalImpulse: number = 0;      ///< the non-penetration impulse\r\n  public tangentImpulse: number = 0;      ///< the friction impulse\r\n  public readonly id: b2ContactID = new b2ContactID(); ///< uniquely identifies a contact point between two shapes\r\n\r\n  public static MakeArray(length: number): b2ManifoldPoint[] {\r\n    return b2MakeArray(length, (i: number): b2ManifoldPoint => new b2ManifoldPoint());\r\n  }\r\n\r\n  public Reset(): void {\r\n    this.localPoint.SetZero();\r\n    this.normalImpulse = 0;\r\n    this.tangentImpulse = 0;\r\n    this.id.key = 0;\r\n  }\r\n\r\n  public Copy(o: b2ManifoldPoint): b2ManifoldPoint {\r\n    this.localPoint.Copy(o.localPoint);\r\n    this.normalImpulse = o.normalImpulse;\r\n    this.tangentImpulse = o.tangentImpulse;\r\n    this.id.Copy(o.id);\r\n    return this;\r\n  }\r\n}\r\n\r\nexport enum b2ManifoldType {\r\n  e_unknown = -1,\r\n  e_circles = 0,\r\n  e_faceA = 1,\r\n  e_faceB = 2,\r\n}\r\n\r\n/// A manifold for two touching convex shapes.\r\n/// Box2D supports multiple types of contact:\r\n/// - clip point versus plane with radius\r\n/// - point versus point with radius (circles)\r\n/// The local point usage depends on the manifold type:\r\n/// -e_circles: the local center of circleA\r\n/// -e_faceA: the center of faceA\r\n/// -e_faceB: the center of faceB\r\n/// Similarly the local normal usage:\r\n/// -e_circles: not used\r\n/// -e_faceA: the normal on polygonA\r\n/// -e_faceB: the normal on polygonB\r\n/// We store contacts in this way so that position correction can\r\n/// account for movement, which is critical for continuous physics.\r\n/// All contact scenarios must be expressed in one of these types.\r\n/// This structure is stored across time steps, so we keep it small.\r\nexport class b2Manifold {\r\n  public readonly points: b2ManifoldPoint[] = b2ManifoldPoint.MakeArray(b2_maxManifoldPoints);\r\n  public readonly localNormal: b2Vec2 = new b2Vec2();\r\n  public readonly localPoint: b2Vec2 = new b2Vec2();\r\n  public type: b2ManifoldType = b2ManifoldType.e_unknown;\r\n  public pointCount: number = 0;\r\n\r\n  public Reset(): void {\r\n    for (let i: number = 0; i < b2_maxManifoldPoints; ++i) {\r\n      // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);\r\n      this.points[i].Reset();\r\n    }\r\n    this.localNormal.SetZero();\r\n    this.localPoint.SetZero();\r\n    this.type = b2ManifoldType.e_unknown;\r\n    this.pointCount = 0;\r\n  }\r\n\r\n  public Copy(o: b2Manifold): b2Manifold {\r\n    this.pointCount = o.pointCount;\r\n    for (let i: number = 0; i < b2_maxManifoldPoints; ++i) {\r\n      // DEBUG: b2Assert(this.points[i] instanceof b2ManifoldPoint);\r\n      this.points[i].Copy(o.points[i]);\r\n    }\r\n    this.localNormal.Copy(o.localNormal);\r\n    this.localPoint.Copy(o.localPoint);\r\n    this.type = o.type;\r\n    return this;\r\n  }\r\n\r\n  public Clone(): b2Manifold {\r\n    return new b2Manifold().Copy(this);\r\n  }\r\n}\r\n\r\nexport class b2WorldManifold {\r\n  public readonly normal: b2Vec2 = new b2Vec2();\r\n  public readonly points: b2Vec2[] = b2Vec2.MakeArray(b2_maxManifoldPoints);\r\n  public readonly separations: number[] = b2MakeNumberArray(b2_maxManifoldPoints);\r\n\r\n  private static Initialize_s_pointA = new b2Vec2();\r\n  private static Initialize_s_pointB = new b2Vec2();\r\n  private static Initialize_s_cA = new b2Vec2();\r\n  private static Initialize_s_cB = new b2Vec2();\r\n  private static Initialize_s_planePoint = new b2Vec2();\r\n  private static Initialize_s_clipPoint = new b2Vec2();\r\n  public Initialize(manifold: b2Manifold, xfA: b2Transform, radiusA: number, xfB: b2Transform, radiusB: number): void {\r\n    if (manifold.pointCount === 0) {\r\n      return;\r\n    }\r\n\r\n    switch (manifold.type) {\r\n    case b2ManifoldType.e_circles: {\r\n        this.normal.Set(1, 0);\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_pointA);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, manifold.points[0].localPoint, b2WorldManifold.Initialize_s_pointB);\r\n        if (b2Vec2.DistanceSquaredVV(pointA, pointB) > b2_epsilon_sq) {\r\n          b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n        }\r\n\r\n        const cA: b2Vec2 = b2Vec2.AddVMulSV(pointA, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);\r\n        const cB: b2Vec2 = b2Vec2.SubVMulSV(pointB, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);\r\n        b2Vec2.MidVV(cA, cB, this.points[0]);\r\n        this.separations[0] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n        break;\r\n      }\r\n\r\n    case b2ManifoldType.e_faceA: {\r\n        b2Rot.MulRV(xfA.q, manifold.localNormal, this.normal);\r\n        const planePoint: b2Vec2 = b2Transform.MulXV(xfA, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);\r\n\r\n        for (let i: number = 0; i < manifold.pointCount; ++i) {\r\n          const clipPoint: b2Vec2 = b2Transform.MulXV(xfB, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);\r\n          const s: number = radiusA - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);\r\n          const cA: b2Vec2 = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cA);\r\n          const cB: b2Vec2 = b2Vec2.SubVMulSV(clipPoint, radiusB, this.normal, b2WorldManifold.Initialize_s_cB);\r\n          b2Vec2.MidVV(cA, cB, this.points[i]);\r\n          this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cB, cA, b2Vec2.s_t0), this.normal); // b2Dot(cB - cA, normal);\r\n        }\r\n        break;\r\n      }\r\n\r\n    case b2ManifoldType.e_faceB: {\r\n        b2Rot.MulRV(xfB.q, manifold.localNormal, this.normal);\r\n        const planePoint: b2Vec2 = b2Transform.MulXV(xfB, manifold.localPoint, b2WorldManifold.Initialize_s_planePoint);\r\n\r\n        for (let i: number = 0; i < manifold.pointCount; ++i) {\r\n          const clipPoint: b2Vec2 = b2Transform.MulXV(xfA, manifold.points[i].localPoint, b2WorldManifold.Initialize_s_clipPoint);\r\n          const s: number = radiusB - b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal);\r\n          const cB: b2Vec2 = b2Vec2.AddVMulSV(clipPoint, s, this.normal, b2WorldManifold.Initialize_s_cB);\r\n          const cA: b2Vec2 = b2Vec2.SubVMulSV(clipPoint, radiusA, this.normal, b2WorldManifold.Initialize_s_cA);\r\n          b2Vec2.MidVV(cA, cB, this.points[i]);\r\n          this.separations[i] = b2Vec2.DotVV(b2Vec2.SubVV(cA, cB, b2Vec2.s_t0), this.normal); // b2Dot(cA - cB, normal);\r\n        }\r\n\r\n        // Ensure normal points from A to B.\r\n        this.normal.SelfNeg();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/// This is used for determining the state of contact points.\r\nexport enum b2PointState {\r\n  b2_nullState = 0, ///< point does not exist\r\n  b2_addState = 1, ///< point was added in the update\r\n  b2_persistState = 2, ///< point persisted across the update\r\n  b2_removeState = 3,  ///< point was removed in the update\r\n}\r\n\r\n/// Compute the point states given two manifolds. The states pertain to the transition from manifold1\r\n/// to manifold2. So state1 is either persist or remove while state2 is either add or persist.\r\nexport function b2GetPointStates(state1: b2PointState[], state2: b2PointState[], manifold1: b2Manifold, manifold2: b2Manifold): void {\r\n  // Detect persists and removes.\r\n  let i: number;\r\n  for (i = 0; i < manifold1.pointCount; ++i) {\r\n    const id: b2ContactID = manifold1.points[i].id;\r\n    const key: number = id.key;\r\n\r\n    state1[i] = b2PointState.b2_removeState;\r\n\r\n    for (let j: number = 0, jct = manifold2.pointCount; j < jct; ++j) {\r\n      if (manifold2.points[j].id.key === key) {\r\n        state1[i] = b2PointState.b2_persistState;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  for (; i < b2_maxManifoldPoints; ++i) {\r\n    state1[i] = b2PointState.b2_nullState;\r\n  }\r\n\r\n  // Detect persists and adds.\r\n  for (i = 0; i < manifold2.pointCount; ++i) {\r\n    const id: b2ContactID = manifold2.points[i].id;\r\n    const key: number = id.key;\r\n\r\n    state2[i] = b2PointState.b2_addState;\r\n\r\n    for (let j: number = 0, jct = manifold1.pointCount; j < jct; ++j) {\r\n      if (manifold1.points[j].id.key === key) {\r\n        state2[i] = b2PointState.b2_persistState;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  for (; i < b2_maxManifoldPoints; ++i) {\r\n    state2[i] = b2PointState.b2_nullState;\r\n  }\r\n}\r\n\r\n/// Used for computing contact manifolds.\r\nexport class b2ClipVertex {\r\n  public readonly v: b2Vec2 = new b2Vec2();\r\n  public readonly id: b2ContactID = new b2ContactID();\r\n\r\n  public static MakeArray(length: number): b2ClipVertex[] {\r\n    return b2MakeArray(length, (i: number): b2ClipVertex => new b2ClipVertex());\r\n  }\r\n\r\n  public Copy(other: b2ClipVertex): b2ClipVertex {\r\n    this.v.Copy(other.v);\r\n    this.id.Copy(other.id);\r\n    return this;\r\n  }\r\n}\r\n\r\n/// Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\r\nexport class b2RayCastInput {\r\n  public readonly p1: b2Vec2 = new b2Vec2();\r\n  public readonly p2: b2Vec2 = new b2Vec2();\r\n  public maxFraction: number = 1;\r\n\r\n  public Copy(o: b2RayCastInput): b2RayCastInput {\r\n    this.p1.Copy(o.p1);\r\n    this.p2.Copy(o.p2);\r\n    this.maxFraction = o.maxFraction;\r\n    return this;\r\n  }\r\n}\r\n\r\n/// Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and p2\r\n/// come from b2RayCastInput.\r\nexport class b2RayCastOutput {\r\n  public readonly normal: b2Vec2 = new b2Vec2();\r\n  public fraction: number = 0;\r\n\r\n  public Copy(o: b2RayCastOutput): b2RayCastOutput {\r\n    this.normal.Copy(o.normal);\r\n    this.fraction = o.fraction;\r\n    return this;\r\n  }\r\n}\r\n\r\n/// An axis aligned bounding box.\r\nexport class b2AABB {\r\n  public readonly lowerBound: b2Vec2 = new b2Vec2(); ///< the lower vertex\r\n  public readonly upperBound: b2Vec2 = new b2Vec2(); ///< the upper vertex\r\n\r\n  private readonly m_cache_center: b2Vec2 = new b2Vec2(); // access using GetCenter()\r\n  private readonly m_cache_extent: b2Vec2 = new b2Vec2(); // access using GetExtents()\r\n\r\n  public Copy(o: b2AABB): b2AABB {\r\n    this.lowerBound.Copy(o.lowerBound);\r\n    this.upperBound.Copy(o.upperBound);\r\n    return this;\r\n  }\r\n\r\n  /// Verify that the bounds are sorted.\r\n  public IsValid(): boolean {\r\n    if (!this.lowerBound.IsValid()) { return false; }\r\n    if (!this.upperBound.IsValid()) { return false; }\r\n    if (this.upperBound.x < this.lowerBound.x) { return false; }\r\n    if (this.upperBound.y < this.lowerBound.y) { return false; }\r\n    return true;\r\n  }\r\n\r\n  /// Get the center of the AABB.\r\n  public GetCenter(): b2Vec2 {\r\n    return b2Vec2.MidVV(this.lowerBound, this.upperBound, this.m_cache_center);\r\n  }\r\n\r\n  /// Get the extents of the AABB (half-widths).\r\n  public GetExtents(): b2Vec2 {\r\n    return b2Vec2.ExtVV(this.lowerBound, this.upperBound, this.m_cache_extent);\r\n  }\r\n\r\n  /// Get the perimeter length\r\n  public GetPerimeter(): number {\r\n    const wx: number = this.upperBound.x - this.lowerBound.x;\r\n    const wy: number = this.upperBound.y - this.lowerBound.y;\r\n    return 2 * (wx + wy);\r\n  }\r\n\r\n  /// Combine an AABB into this one.\r\n  public Combine1(aabb: b2AABB): b2AABB {\r\n    this.lowerBound.x = b2Min(this.lowerBound.x, aabb.lowerBound.x);\r\n    this.lowerBound.y = b2Min(this.lowerBound.y, aabb.lowerBound.y);\r\n    this.upperBound.x = b2Max(this.upperBound.x, aabb.upperBound.x);\r\n    this.upperBound.y = b2Max(this.upperBound.y, aabb.upperBound.y);\r\n    return this;\r\n  }\r\n\r\n  /// Combine two AABBs into this one.\r\n  public Combine2(aabb1: b2AABB, aabb2: b2AABB): b2AABB {\r\n    this.lowerBound.x = b2Min(aabb1.lowerBound.x, aabb2.lowerBound.x);\r\n    this.lowerBound.y = b2Min(aabb1.lowerBound.y, aabb2.lowerBound.y);\r\n    this.upperBound.x = b2Max(aabb1.upperBound.x, aabb2.upperBound.x);\r\n    this.upperBound.y = b2Max(aabb1.upperBound.y, aabb2.upperBound.y);\r\n    return this;\r\n  }\r\n\r\n  public static Combine(aabb1: b2AABB, aabb2: b2AABB, out: b2AABB): b2AABB {\r\n    out.Combine2(aabb1, aabb2);\r\n    return out;\r\n  }\r\n\r\n  /// Does this aabb contain the provided AABB.\r\n  public Contains(aabb: b2AABB): boolean {\r\n    if (this.lowerBound.x <= aabb.lowerBound.x) { return false; }\r\n    if (this.lowerBound.y <= aabb.lowerBound.y) { return false; }\r\n    if (aabb.upperBound.x <= this.upperBound.x) { return false; }\r\n    if (aabb.upperBound.y <= this.upperBound.y) { return false; }\r\n    return true;\r\n  }\r\n\r\n  // From Real-time Collision Detection, p179.\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput): boolean {\r\n    let tmin: number = (-b2_maxFloat);\r\n    let tmax: number = b2_maxFloat;\r\n\r\n    const p_x: number = input.p1.x;\r\n    const p_y: number = input.p1.y;\r\n    const d_x: number = input.p2.x - input.p1.x;\r\n    const d_y: number = input.p2.y - input.p1.y;\r\n    const absD_x: number = b2Abs(d_x);\r\n    const absD_y: number = b2Abs(d_y);\r\n\r\n    const normal: b2Vec2 = output.normal;\r\n\r\n    if (absD_x < b2_epsilon) {\r\n      // Parallel.\r\n      if (p_x < this.lowerBound.x || this.upperBound.x < p_x) {\r\n        return false;\r\n      }\r\n    } else {\r\n      const inv_d: number = 1 / d_x;\r\n      let t1: number = (this.lowerBound.x - p_x) * inv_d;\r\n      let t2: number = (this.upperBound.x - p_x) * inv_d;\r\n\r\n      // Sign of the normal vector.\r\n      let s: number = (-1);\r\n\r\n      if (t1 > t2) {\r\n        const t3: number = t1;\r\n        t1 = t2;\r\n        t2 = t3;\r\n        s = 1;\r\n      }\r\n\r\n      // Push the min up\r\n      if (t1 > tmin) {\r\n        normal.x = s;\r\n        normal.y = 0;\r\n        tmin = t1;\r\n      }\r\n\r\n      // Pull the max down\r\n      tmax = b2Min(tmax, t2);\r\n\r\n      if (tmin > tmax) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (absD_y < b2_epsilon) {\r\n      // Parallel.\r\n      if (p_y < this.lowerBound.y || this.upperBound.y < p_y) {\r\n        return false;\r\n      }\r\n    } else {\r\n      const inv_d: number = 1 / d_y;\r\n      let t1: number = (this.lowerBound.y - p_y) * inv_d;\r\n      let t2: number = (this.upperBound.y - p_y) * inv_d;\r\n\r\n      // Sign of the normal vector.\r\n      let s: number = (-1);\r\n\r\n      if (t1 > t2) {\r\n        const t3: number = t1;\r\n        t1 = t2;\r\n        t2 = t3;\r\n        s = 1;\r\n      }\r\n\r\n      // Push the min up\r\n      if (t1 > tmin) {\r\n        normal.x = 0;\r\n        normal.y = s;\r\n        tmin = t1;\r\n      }\r\n\r\n      // Pull the max down\r\n      tmax = b2Min(tmax, t2);\r\n\r\n      if (tmin > tmax) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // Does the ray start inside the box?\r\n    // Does the ray intersect beyond the max fraction?\r\n    if (tmin < 0 || input.maxFraction < tmin) {\r\n      return false;\r\n    }\r\n\r\n    // Intersection.\r\n    output.fraction = tmin;\r\n\r\n    return true;\r\n  }\r\n\r\n  public TestContain(point: XY): boolean {\r\n    if (point.x < this.lowerBound.x || this.upperBound.x < point.x) { return false; }\r\n    if (point.y < this.lowerBound.y || this.upperBound.y < point.y) { return false; }\r\n    return true;\r\n  }\r\n\r\n  public TestOverlap(other: b2AABB): boolean {\r\n    if (this.upperBound.x < other.lowerBound.x) { return false; }\r\n    if (this.upperBound.y < other.lowerBound.y) { return false; }\r\n    if (other.upperBound.x < this.lowerBound.x) { return false; }\r\n    if (other.upperBound.y < this.lowerBound.y) { return false; }\r\n    return true;\r\n  }\r\n}\r\n\r\nexport function b2TestOverlapAABB(a: b2AABB, b: b2AABB): boolean {\r\n  if (a.upperBound.x < b.lowerBound.x) { return false; }\r\n  if (a.upperBound.y < b.lowerBound.y) { return false; }\r\n  if (b.upperBound.x < a.lowerBound.x) { return false; }\r\n  if (b.upperBound.y < a.lowerBound.y) { return false; }\r\n  return true;\r\n}\r\n\r\n/// Clipping for contact manifolds.\r\nexport function b2ClipSegmentToLine(vOut: b2ClipVertex[], vIn: b2ClipVertex[], normal: b2Vec2, offset: number, vertexIndexA: number): number {\r\n  // Start with no output points\r\n  let numOut: number = 0;\r\n\r\n  const vIn0: b2ClipVertex = vIn[0];\r\n  const vIn1: b2ClipVertex = vIn[1];\r\n\r\n  // Calculate the distance of end points to the line\r\n  const distance0: number = b2Vec2.DotVV(normal, vIn0.v) - offset;\r\n  const distance1: number = b2Vec2.DotVV(normal, vIn1.v) - offset;\r\n\r\n  // If the points are behind the plane\r\n  if (distance0 <= 0) { vOut[numOut++].Copy(vIn0); }\r\n  if (distance1 <= 0) { vOut[numOut++].Copy(vIn1); }\r\n\r\n  // If the points are on different sides of the plane\r\n  if (distance0 * distance1 < 0) {\r\n    // Find intersection point of edge and plane\r\n    const interp: number = distance0 / (distance0 - distance1);\r\n    const v: b2Vec2 = vOut[numOut].v;\r\n    v.x = vIn0.v.x + interp * (vIn1.v.x - vIn0.v.x);\r\n    v.y = vIn0.v.y + interp * (vIn1.v.y - vIn0.v.y);\r\n\r\n    // VertexA is hitting edgeB.\r\n    const id: b2ContactID = vOut[numOut].id;\r\n    id.cf.indexA = vertexIndexA;\r\n    id.cf.indexB = vIn0.id.cf.indexB;\r\n    id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n    id.cf.typeB = b2ContactFeatureType.e_face;\r\n    ++numOut;\r\n  }\r\n\r\n  return numOut;\r\n}\r\n\r\n/// Determine if two generic shapes overlap.\r\nconst b2TestOverlapShape_s_input: b2DistanceInput = new b2DistanceInput();\r\nconst b2TestOverlapShape_s_simplexCache: b2SimplexCache = new b2SimplexCache();\r\nconst b2TestOverlapShape_s_output: b2DistanceOutput = new b2DistanceOutput();\r\nexport function b2TestOverlapShape(shapeA: b2Shape, indexA: number, shapeB: b2Shape, indexB: number, xfA: b2Transform, xfB: b2Transform): boolean {\r\n  const input: b2DistanceInput = b2TestOverlapShape_s_input.Reset();\r\n  input.proxyA.SetShape(shapeA, indexA);\r\n  input.proxyB.SetShape(shapeB, indexB);\r\n  input.transformA.Copy(xfA);\r\n  input.transformB.Copy(xfB);\r\n  input.useRadii = true;\r\n\r\n  const simplexCache: b2SimplexCache = b2TestOverlapShape_s_simplexCache.Reset();\r\n  simplexCache.count = 0;\r\n\r\n  const output: b2DistanceOutput = b2TestOverlapShape_s_output.Reset();\r\n\r\n  b2Distance(output, simplexCache, input);\r\n\r\n  return output.distance < 10 * b2_epsilon;\r\n}\r\n"]}},"error":null,"hash":"e8243c1f2bfad2865a8f22d246376bde","cacheData":{"env":{}}}