{"id":"../node_modules/box2d.package.ts/Dynamics/Joints/b2DistanceJoint.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":30,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2DistanceJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":31,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2DistanceJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Joint","loc":{"line":32,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2DistanceJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2Joint.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Joint_1 = require(\"./b2Joint\");\r\n/// Distance joint definition. This requires defining an\r\n/// anchor point on both bodies and the non-zero length of the\r\n/// distance joint. The definition uses local anchor points\r\n/// so that the initial configuration can violate the constraint\r\n/// slightly. This helps when saving and loading a game.\r\n/// @warning Do not use a zero or short length.\r\nvar b2DistanceJointDef = /** @class */ (function (_super) {\r\n    __extends(b2DistanceJointDef, _super);\r\n    function b2DistanceJointDef() {\r\n        var _this = _super.call(this, b2Joint_1.b2JointType.e_distanceJoint) || this;\r\n        _this.localAnchorA = new b2Math_1.b2Vec2();\r\n        _this.localAnchorB = new b2Math_1.b2Vec2();\r\n        _this.length = 1;\r\n        _this.frequencyHz = 0;\r\n        _this.dampingRatio = 0;\r\n        return _this;\r\n    }\r\n    b2DistanceJointDef.prototype.Initialize = function (b1, b2, anchor1, anchor2) {\r\n        this.bodyA = b1;\r\n        this.bodyB = b2;\r\n        this.bodyA.GetLocalPoint(anchor1, this.localAnchorA);\r\n        this.bodyB.GetLocalPoint(anchor2, this.localAnchorB);\r\n        this.length = b2Math_1.b2Vec2.DistanceVV(anchor1, anchor2);\r\n        this.frequencyHz = 0;\r\n        this.dampingRatio = 0;\r\n    };\r\n    return b2DistanceJointDef;\r\n}(b2Joint_1.b2JointDef));\r\nexports.b2DistanceJointDef = b2DistanceJointDef;\r\nvar b2DistanceJoint = /** @class */ (function (_super) {\r\n    __extends(b2DistanceJoint, _super);\r\n    function b2DistanceJoint(def) {\r\n        var _this = _super.call(this, def) || this;\r\n        _this.m_frequencyHz = 0;\r\n        _this.m_dampingRatio = 0;\r\n        _this.m_bias = 0;\r\n        // Solver shared\r\n        _this.m_localAnchorA = new b2Math_1.b2Vec2();\r\n        _this.m_localAnchorB = new b2Math_1.b2Vec2();\r\n        _this.m_gamma = 0;\r\n        _this.m_impulse = 0;\r\n        _this.m_length = 0;\r\n        // Solver temp\r\n        _this.m_indexA = 0;\r\n        _this.m_indexB = 0;\r\n        _this.m_u = new b2Math_1.b2Vec2();\r\n        _this.m_rA = new b2Math_1.b2Vec2();\r\n        _this.m_rB = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterA = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterB = new b2Math_1.b2Vec2();\r\n        _this.m_invMassA = 0;\r\n        _this.m_invMassB = 0;\r\n        _this.m_invIA = 0;\r\n        _this.m_invIB = 0;\r\n        _this.m_mass = 0;\r\n        _this.m_qA = new b2Math_1.b2Rot();\r\n        _this.m_qB = new b2Math_1.b2Rot();\r\n        _this.m_lalcA = new b2Math_1.b2Vec2();\r\n        _this.m_lalcB = new b2Math_1.b2Vec2();\r\n        _this.m_frequencyHz = b2Settings_1.b2Maybe(def.frequencyHz, 0);\r\n        _this.m_dampingRatio = b2Settings_1.b2Maybe(def.dampingRatio, 0);\r\n        _this.m_localAnchorA.Copy(def.localAnchorA);\r\n        _this.m_localAnchorB.Copy(def.localAnchorB);\r\n        _this.m_length = def.length;\r\n        return _this;\r\n    }\r\n    b2DistanceJoint.prototype.GetAnchorA = function (out) {\r\n        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n    };\r\n    b2DistanceJoint.prototype.GetAnchorB = function (out) {\r\n        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n    };\r\n    b2DistanceJoint.prototype.GetReactionForce = function (inv_dt, out) {\r\n        out.x = inv_dt * this.m_impulse * this.m_u.x;\r\n        out.y = inv_dt * this.m_impulse * this.m_u.y;\r\n        return out;\r\n    };\r\n    b2DistanceJoint.prototype.GetReactionTorque = function (inv_dt) {\r\n        return 0;\r\n    };\r\n    b2DistanceJoint.prototype.GetLocalAnchorA = function () { return this.m_localAnchorA; };\r\n    b2DistanceJoint.prototype.GetLocalAnchorB = function () { return this.m_localAnchorB; };\r\n    b2DistanceJoint.prototype.SetLength = function (length) {\r\n        this.m_length = length;\r\n    };\r\n    b2DistanceJoint.prototype.Length = function () {\r\n        return this.m_length;\r\n    };\r\n    b2DistanceJoint.prototype.SetFrequency = function (hz) {\r\n        this.m_frequencyHz = hz;\r\n    };\r\n    b2DistanceJoint.prototype.GetFrequency = function () {\r\n        return this.m_frequencyHz;\r\n    };\r\n    b2DistanceJoint.prototype.SetDampingRatio = function (ratio) {\r\n        this.m_dampingRatio = ratio;\r\n    };\r\n    b2DistanceJoint.prototype.GetDampingRatio = function () {\r\n        return this.m_dampingRatio;\r\n    };\r\n    b2DistanceJoint.prototype.Dump = function (log) {\r\n        var indexA = this.m_bodyA.m_islandIndex;\r\n        var indexB = this.m_bodyB.m_islandIndex;\r\n        log(\"  const jd: b2DistanceJointDef = new b2DistanceJointDef();\\n\");\r\n        log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n        log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n        log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n        log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n        log(\"  jd.length = %.15f;\\n\", this.m_length);\r\n        log(\"  jd.frequencyHz = %.15f;\\n\", this.m_frequencyHz);\r\n        log(\"  jd.dampingRatio = %.15f;\\n\", this.m_dampingRatio);\r\n        log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n    };\r\n    b2DistanceJoint.prototype.InitVelocityConstraints = function (data) {\r\n        this.m_indexA = this.m_bodyA.m_islandIndex;\r\n        this.m_indexB = this.m_bodyB.m_islandIndex;\r\n        this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n        this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n        this.m_invMassA = this.m_bodyA.m_invMass;\r\n        this.m_invMassB = this.m_bodyB.m_invMass;\r\n        this.m_invIA = this.m_bodyA.m_invI;\r\n        this.m_invIB = this.m_bodyB.m_invI;\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n        b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n        // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n        b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n        // m_u = cB + m_rB - cA - m_rA;\r\n        this.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;\r\n        this.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;\r\n        // Handle singularity.\r\n        var length = this.m_u.Length();\r\n        if (length > b2Settings_1.b2_linearSlop) {\r\n            this.m_u.SelfMul(1 / length);\r\n        }\r\n        else {\r\n            this.m_u.SetZero();\r\n        }\r\n        // float32 crAu = b2Cross(m_rA, m_u);\r\n        var crAu = b2Math_1.b2Vec2.CrossVV(this.m_rA, this.m_u);\r\n        // float32 crBu = b2Cross(m_rB, m_u);\r\n        var crBu = b2Math_1.b2Vec2.CrossVV(this.m_rB, this.m_u);\r\n        // float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;\r\n        var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\r\n        // Compute the effective mass matrix.\r\n        this.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n        if (this.m_frequencyHz > 0) {\r\n            var C = length - this.m_length;\r\n            // Frequency\r\n            var omega = 2 * b2Settings_1.b2_pi * this.m_frequencyHz;\r\n            // Damping coefficient\r\n            var d = 2 * this.m_mass * this.m_dampingRatio * omega;\r\n            // Spring stiffness\r\n            var k = this.m_mass * omega * omega;\r\n            // magic formulas\r\n            var h = data.step.dt;\r\n            this.m_gamma = h * (d + h * k);\r\n            this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;\r\n            this.m_bias = C * h * k * this.m_gamma;\r\n            invMass += this.m_gamma;\r\n            this.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n        }\r\n        else {\r\n            this.m_gamma = 0;\r\n            this.m_bias = 0;\r\n        }\r\n        if (data.step.warmStarting) {\r\n            // Scale the impulse to support a variable time step.\r\n            this.m_impulse *= data.step.dtRatio;\r\n            // b2Vec2 P = m_impulse * m_u;\r\n            var P = b2Math_1.b2Vec2.MulSV(this.m_impulse, this.m_u, b2DistanceJoint.InitVelocityConstraints_s_P);\r\n            // vA -= m_invMassA * P;\r\n            vA.SelfMulSub(this.m_invMassA, P);\r\n            // wA -= m_invIA * b2Cross(m_rA, P);\r\n            wA -= this.m_invIA * b2Math_1.b2Vec2.CrossVV(this.m_rA, P);\r\n            // vB += m_invMassB * P;\r\n            vB.SelfMulAdd(this.m_invMassB, P);\r\n            // wB += m_invIB * b2Cross(m_rB, P);\r\n            wB += this.m_invIB * b2Math_1.b2Vec2.CrossVV(this.m_rB, P);\r\n        }\r\n        else {\r\n            this.m_impulse = 0;\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2DistanceJoint.prototype.SolveVelocityConstraints = function (data) {\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        // b2Vec2 vpA = vA + b2Cross(wA, m_rA);\r\n        var vpA = b2Math_1.b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);\r\n        // b2Vec2 vpB = vB + b2Cross(wB, m_rB);\r\n        var vpB = b2Math_1.b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);\r\n        // float32 Cdot = b2Dot(m_u, vpB - vpA);\r\n        var Cdot = b2Math_1.b2Vec2.DotVV(this.m_u, b2Math_1.b2Vec2.SubVV(vpB, vpA, b2Math_1.b2Vec2.s_t0));\r\n        var impulse = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));\r\n        this.m_impulse += impulse;\r\n        // b2Vec2 P = impulse * m_u;\r\n        var P = b2Math_1.b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);\r\n        // vA -= m_invMassA * P;\r\n        vA.SelfMulSub(this.m_invMassA, P);\r\n        // wA -= m_invIA * b2Cross(m_rA, P);\r\n        wA -= this.m_invIA * b2Math_1.b2Vec2.CrossVV(this.m_rA, P);\r\n        // vB += m_invMassB * P;\r\n        vB.SelfMulAdd(this.m_invMassB, P);\r\n        // wB += m_invIB * b2Cross(m_rB, P);\r\n        wB += this.m_invIB * b2Math_1.b2Vec2.CrossVV(this.m_rB, P);\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2DistanceJoint.prototype.SolvePositionConstraints = function (data) {\r\n        if (this.m_frequencyHz > 0) {\r\n            // There is no position correction for soft distance constraints.\r\n            return true;\r\n        }\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n        var rA = b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA); // use m_rA\r\n        // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n        var rB = b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB); // use m_rB\r\n        // b2Vec2 u = cB + rB - cA - rA;\r\n        var u = this.m_u; // use m_u\r\n        u.x = cB.x + rB.x - cA.x - rA.x;\r\n        u.y = cB.y + rB.y - cA.y - rA.y;\r\n        // float32 length = u.Normalize();\r\n        var length = this.m_u.Normalize();\r\n        // float32 C = length - m_length;\r\n        var C = length - this.m_length;\r\n        C = b2Math_1.b2Clamp(C, (-b2Settings_1.b2_maxLinearCorrection), b2Settings_1.b2_maxLinearCorrection);\r\n        var impulse = (-this.m_mass * C);\r\n        // b2Vec2 P = impulse * u;\r\n        var P = b2Math_1.b2Vec2.MulSV(impulse, u, b2DistanceJoint.SolvePositionConstraints_s_P);\r\n        // cA -= m_invMassA * P;\r\n        cA.SelfMulSub(this.m_invMassA, P);\r\n        // aA -= m_invIA * b2Cross(rA, P);\r\n        aA -= this.m_invIA * b2Math_1.b2Vec2.CrossVV(rA, P);\r\n        // cB += m_invMassB * P;\r\n        cB.SelfMulAdd(this.m_invMassB, P);\r\n        // aB += m_invIB * b2Cross(rB, P);\r\n        aB += this.m_invIB * b2Math_1.b2Vec2.CrossVV(rB, P);\r\n        // data.positions[this.m_indexA].c = cA;\r\n        data.positions[this.m_indexA].a = aA;\r\n        // data.positions[this.m_indexB].c = cB;\r\n        data.positions[this.m_indexB].a = aB;\r\n        return b2Math_1.b2Abs(C) < b2Settings_1.b2_linearSlop;\r\n    };\r\n    b2DistanceJoint.InitVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2DistanceJoint.SolveVelocityConstraints_s_vpA = new b2Math_1.b2Vec2();\r\n    b2DistanceJoint.SolveVelocityConstraints_s_vpB = new b2Math_1.b2Vec2();\r\n    b2DistanceJoint.SolveVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2DistanceJoint.SolvePositionConstraints_s_P = new b2Math_1.b2Vec2();\r\n    return b2DistanceJoint;\r\n}(b2Joint_1.b2Joint));\r\nexports.b2DistanceJoint = b2DistanceJoint;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2DistanceJoint.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Joints/b2DistanceJoint.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2007 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2_pi, b2_linearSlop, b2_maxLinearCorrection, b2Maybe } from \"../../Common/b2Settings\";\r\nimport { b2Abs, b2Clamp, b2Vec2, b2Rot, XY } from \"../../Common/b2Math\";\r\nimport { b2Joint, b2JointDef, b2JointType, b2IJointDef } from \"./b2Joint\";\r\nimport { b2SolverData } from \"../b2TimeStep\";\r\nimport { b2Body } from \"../b2Body\";\r\n\r\nexport interface b2IDistanceJointDef extends b2IJointDef {\r\n  localAnchorA: XY;\r\n  localAnchorB: XY;\r\n  length: number;\r\n  frequencyHz?: number;\r\n  dampingRatio?: number;\r\n}\r\n\r\n/// Distance joint definition. This requires defining an\r\n/// anchor point on both bodies and the non-zero length of the\r\n/// distance joint. The definition uses local anchor points\r\n/// so that the initial configuration can violate the constraint\r\n/// slightly. This helps when saving and loading a game.\r\n/// @warning Do not use a zero or short length.\r\nexport class b2DistanceJointDef extends b2JointDef implements b2IDistanceJointDef {\r\n  public readonly localAnchorA: b2Vec2 = new b2Vec2();\r\n  public readonly localAnchorB: b2Vec2 = new b2Vec2();\r\n  public length: number = 1;\r\n  public frequencyHz: number = 0;\r\n  public dampingRatio: number = 0;\r\n\r\n  constructor() {\r\n    super(b2JointType.e_distanceJoint);\r\n  }\r\n\r\n  public Initialize(b1: b2Body, b2: b2Body, anchor1: XY, anchor2: XY): void {\r\n    this.bodyA = b1;\r\n    this.bodyB = b2;\r\n    this.bodyA.GetLocalPoint(anchor1, this.localAnchorA);\r\n    this.bodyB.GetLocalPoint(anchor2, this.localAnchorB);\r\n    this.length = b2Vec2.DistanceVV(anchor1, anchor2);\r\n    this.frequencyHz = 0;\r\n    this.dampingRatio = 0;\r\n  }\r\n}\r\n\r\nexport class b2DistanceJoint extends b2Joint {\r\n  public m_frequencyHz: number = 0;\r\n  public m_dampingRatio: number = 0;\r\n  public m_bias: number = 0;\r\n\r\n  // Solver shared\r\n  public readonly m_localAnchorA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localAnchorB: b2Vec2 = new b2Vec2();\r\n  public m_gamma: number = 0;\r\n  public m_impulse: number = 0;\r\n  public m_length: number = 0;\r\n\r\n  // Solver temp\r\n  public m_indexA: number = 0;\r\n  public m_indexB: number = 0;\r\n  public readonly m_u: b2Vec2 = new b2Vec2();\r\n  public readonly m_rA: b2Vec2 = new b2Vec2();\r\n  public readonly m_rB: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterB: b2Vec2 = new b2Vec2();\r\n  public m_invMassA: number = 0;\r\n  public m_invMassB: number = 0;\r\n  public m_invIA: number = 0;\r\n  public m_invIB: number = 0;\r\n  public m_mass: number = 0;\r\n\r\n  public readonly m_qA: b2Rot = new b2Rot();\r\n  public readonly m_qB: b2Rot = new b2Rot();\r\n  public readonly m_lalcA: b2Vec2 = new b2Vec2();\r\n  public readonly m_lalcB: b2Vec2 = new b2Vec2();\r\n\r\n  constructor(def: b2IDistanceJointDef) {\r\n    super(def);\r\n\r\n    this.m_frequencyHz = b2Maybe(def.frequencyHz, 0);\r\n    this.m_dampingRatio = b2Maybe(def.dampingRatio, 0);\r\n\r\n    this.m_localAnchorA.Copy(def.localAnchorA);\r\n    this.m_localAnchorB.Copy(def.localAnchorB);\r\n    this.m_length = def.length;\r\n  }\r\n\r\n  public GetAnchorA<T extends XY>(out: T): T {\r\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n  }\r\n\r\n  public GetAnchorB<T extends XY>(out: T): T {\r\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n  }\r\n\r\n  public GetReactionForce<T extends XY>(inv_dt: number, out: T): T {\r\n    out.x = inv_dt * this.m_impulse * this.m_u.x;\r\n    out.y = inv_dt * this.m_impulse * this.m_u.y;\r\n    return out;\r\n  }\r\n\r\n  public GetReactionTorque(inv_dt: number): number {\r\n    return 0;\r\n  }\r\n\r\n  public GetLocalAnchorA(): Readonly<b2Vec2> { return this.m_localAnchorA; }\r\n\r\n  public GetLocalAnchorB(): Readonly<b2Vec2> { return this.m_localAnchorB; }\r\n\r\n  public SetLength(length: number): void {\r\n    this.m_length = length;\r\n  }\r\n\r\n  public Length() {\r\n    return this.m_length;\r\n  }\r\n\r\n  public SetFrequency(hz: number): void {\r\n    this.m_frequencyHz = hz;\r\n  }\r\n\r\n  public GetFrequency() {\r\n    return this.m_frequencyHz;\r\n  }\r\n\r\n  public SetDampingRatio(ratio: number): void {\r\n    this.m_dampingRatio = ratio;\r\n  }\r\n\r\n  public GetDampingRatio() {\r\n    return this.m_dampingRatio;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void) {\r\n    const indexA: number = this.m_bodyA.m_islandIndex;\r\n    const indexB: number = this.m_bodyB.m_islandIndex;\r\n\r\n    log(\"  const jd: b2DistanceJointDef = new b2DistanceJointDef();\\n\");\r\n    log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n    log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n    log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n    log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n    log(\"  jd.length = %.15f;\\n\", this.m_length);\r\n    log(\"  jd.frequencyHz = %.15f;\\n\", this.m_frequencyHz);\r\n    log(\"  jd.dampingRatio = %.15f;\\n\", this.m_dampingRatio);\r\n    log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n  }\r\n\r\n  private static InitVelocityConstraints_s_P = new b2Vec2();\r\n  public InitVelocityConstraints(data: b2SolverData): void {\r\n    this.m_indexA = this.m_bodyA.m_islandIndex;\r\n    this.m_indexB = this.m_bodyB.m_islandIndex;\r\n    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n    this.m_invMassA = this.m_bodyA.m_invMass;\r\n    this.m_invMassB = this.m_bodyB.m_invMass;\r\n    this.m_invIA = this.m_bodyA.m_invI;\r\n    this.m_invIB = this.m_bodyB.m_invI;\r\n\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    const aA: number = data.positions[this.m_indexA].a;\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    const aB: number = data.positions[this.m_indexB].a;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n    b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n    b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n    // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n    b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n    b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n    // m_u = cB + m_rB - cA - m_rA;\r\n    this.m_u.x = cB.x + this.m_rB.x - cA.x - this.m_rA.x;\r\n    this.m_u.y = cB.y + this.m_rB.y - cA.y - this.m_rA.y;\r\n\r\n    // Handle singularity.\r\n    const length: number = this.m_u.Length();\r\n    if (length > b2_linearSlop) {\r\n      this.m_u.SelfMul(1 / length);\r\n    } else {\r\n      this.m_u.SetZero();\r\n    }\r\n\r\n    // float32 crAu = b2Cross(m_rA, m_u);\r\n    const crAu: number = b2Vec2.CrossVV(this.m_rA, this.m_u);\r\n    // float32 crBu = b2Cross(m_rB, m_u);\r\n    const crBu: number = b2Vec2.CrossVV(this.m_rB, this.m_u);\r\n    // float32 invMass = m_invMassA + m_invIA * crAu * crAu + m_invMassB + m_invIB * crBu * crBu;\r\n    let invMass: number = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\r\n\r\n    // Compute the effective mass matrix.\r\n    this.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n\r\n    if (this.m_frequencyHz > 0) {\r\n      const C: number = length - this.m_length;\r\n\r\n      // Frequency\r\n      const omega: number = 2 * b2_pi * this.m_frequencyHz;\r\n\r\n      // Damping coefficient\r\n      const d: number = 2 * this.m_mass * this.m_dampingRatio * omega;\r\n\r\n      // Spring stiffness\r\n      const k: number = this.m_mass * omega * omega;\r\n\r\n      // magic formulas\r\n      const h: number = data.step.dt;\r\n      this.m_gamma = h * (d + h * k);\r\n      this.m_gamma = this.m_gamma !== 0 ? 1 / this.m_gamma : 0;\r\n      this.m_bias = C * h * k * this.m_gamma;\r\n\r\n      invMass += this.m_gamma;\r\n      this.m_mass = invMass !== 0 ? 1 / invMass : 0;\r\n    } else {\r\n      this.m_gamma = 0;\r\n      this.m_bias = 0;\r\n    }\r\n\r\n    if (data.step.warmStarting) {\r\n      // Scale the impulse to support a variable time step.\r\n      this.m_impulse *= data.step.dtRatio;\r\n\r\n      // b2Vec2 P = m_impulse * m_u;\r\n      const P: b2Vec2 = b2Vec2.MulSV(this.m_impulse, this.m_u, b2DistanceJoint.InitVelocityConstraints_s_P);\r\n\r\n      // vA -= m_invMassA * P;\r\n      vA.SelfMulSub(this.m_invMassA, P);\r\n      // wA -= m_invIA * b2Cross(m_rA, P);\r\n      wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);\r\n      // vB += m_invMassB * P;\r\n      vB.SelfMulAdd(this.m_invMassB, P);\r\n      // wB += m_invIB * b2Cross(m_rB, P);\r\n      wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);\r\n    } else {\r\n      this.m_impulse = 0;\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolveVelocityConstraints_s_vpA = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_vpB = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_P = new b2Vec2();\r\n  public SolveVelocityConstraints(data: b2SolverData): void {\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    // b2Vec2 vpA = vA + b2Cross(wA, m_rA);\r\n    const vpA: b2Vec2 = b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2DistanceJoint.SolveVelocityConstraints_s_vpA);\r\n    // b2Vec2 vpB = vB + b2Cross(wB, m_rB);\r\n    const vpB: b2Vec2 = b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2DistanceJoint.SolveVelocityConstraints_s_vpB);\r\n    // float32 Cdot = b2Dot(m_u, vpB - vpA);\r\n    const Cdot: number = b2Vec2.DotVV(this.m_u, b2Vec2.SubVV(vpB, vpA, b2Vec2.s_t0));\r\n\r\n    const impulse: number = (-this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse));\r\n    this.m_impulse += impulse;\r\n\r\n    // b2Vec2 P = impulse * m_u;\r\n    const P: b2Vec2 = b2Vec2.MulSV(impulse, this.m_u, b2DistanceJoint.SolveVelocityConstraints_s_P);\r\n\r\n    // vA -= m_invMassA * P;\r\n    vA.SelfMulSub(this.m_invMassA, P);\r\n    // wA -= m_invIA * b2Cross(m_rA, P);\r\n    wA -= this.m_invIA * b2Vec2.CrossVV(this.m_rA, P);\r\n    // vB += m_invMassB * P;\r\n    vB.SelfMulAdd(this.m_invMassB, P);\r\n    // wB += m_invIB * b2Cross(m_rB, P);\r\n    wB += this.m_invIB * b2Vec2.CrossVV(this.m_rB, P);\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolvePositionConstraints_s_P = new b2Vec2();\r\n  public SolvePositionConstraints(data: b2SolverData): boolean {\r\n    if (this.m_frequencyHz > 0) {\r\n      // There is no position correction for soft distance constraints.\r\n      return true;\r\n    }\r\n\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    let aA: number = data.positions[this.m_indexA].a;\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    let aB: number = data.positions[this.m_indexB].a;\r\n\r\n    // const qA: b2Rot = new b2Rot(aA), qB: b2Rot = new b2Rot(aB);\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n    const rA: b2Vec2 = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA); // use m_rA\r\n    // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n    const rB: b2Vec2 = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB); // use m_rB\r\n    // b2Vec2 u = cB + rB - cA - rA;\r\n    const u: b2Vec2 = this.m_u; // use m_u\r\n    u.x = cB.x + rB.x - cA.x - rA.x;\r\n    u.y = cB.y + rB.y - cA.y - rA.y;\r\n\r\n    // float32 length = u.Normalize();\r\n    const length: number = this.m_u.Normalize();\r\n    // float32 C = length - m_length;\r\n    let C: number = length - this.m_length;\r\n    C = b2Clamp(C, (-b2_maxLinearCorrection), b2_maxLinearCorrection);\r\n\r\n    const impulse: number = (-this.m_mass * C);\r\n    // b2Vec2 P = impulse * u;\r\n    const P: b2Vec2 = b2Vec2.MulSV(impulse, u, b2DistanceJoint.SolvePositionConstraints_s_P);\r\n\r\n    // cA -= m_invMassA * P;\r\n    cA.SelfMulSub(this.m_invMassA, P);\r\n    // aA -= m_invIA * b2Cross(rA, P);\r\n    aA -= this.m_invIA * b2Vec2.CrossVV(rA, P);\r\n    // cB += m_invMassB * P;\r\n    cB.SelfMulAdd(this.m_invMassB, P);\r\n    // aB += m_invIB * b2Cross(rB, P);\r\n    aB += this.m_invIB * b2Vec2.CrossVV(rB, P);\r\n\r\n    // data.positions[this.m_indexA].c = cA;\r\n    data.positions[this.m_indexA].a = aA;\r\n    // data.positions[this.m_indexB].c = cB;\r\n    data.positions[this.m_indexB].a = aB;\r\n\r\n    return b2Abs(C) < b2_linearSlop;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"d1d04c81b98926e4d4c025ae672546d1","cacheData":{"env":{}}}