{"id":"../node_modules/box2d.package.ts/Dynamics/Joints/b2MotorJoint.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":32,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2MotorJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":33,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2MotorJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Joint","loc":{"line":34,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2MotorJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2Joint.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\n// DEBUG: import { b2IsValid } from \"../../Common/b2Math\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Joint_1 = require(\"./b2Joint\");\r\nvar b2MotorJointDef = /** @class */ (function (_super) {\r\n    __extends(b2MotorJointDef, _super);\r\n    function b2MotorJointDef() {\r\n        var _this = _super.call(this, b2Joint_1.b2JointType.e_motorJoint) || this;\r\n        _this.linearOffset = new b2Math_1.b2Vec2(0, 0);\r\n        _this.angularOffset = 0;\r\n        _this.maxForce = 1;\r\n        _this.maxTorque = 1;\r\n        _this.correctionFactor = 0.3;\r\n        return _this;\r\n    }\r\n    b2MotorJointDef.prototype.Initialize = function (bA, bB) {\r\n        this.bodyA = bA;\r\n        this.bodyB = bB;\r\n        // b2Vec2 xB = bodyB->GetPosition();\r\n        // linearOffset = bodyA->GetLocalPoint(xB);\r\n        this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);\r\n        var angleA = this.bodyA.GetAngle();\r\n        var angleB = this.bodyB.GetAngle();\r\n        this.angularOffset = angleB - angleA;\r\n    };\r\n    return b2MotorJointDef;\r\n}(b2Joint_1.b2JointDef));\r\nexports.b2MotorJointDef = b2MotorJointDef;\r\nvar b2MotorJoint = /** @class */ (function (_super) {\r\n    __extends(b2MotorJoint, _super);\r\n    function b2MotorJoint(def) {\r\n        var _this = _super.call(this, def) || this;\r\n        // Solver shared\r\n        _this.m_linearOffset = new b2Math_1.b2Vec2();\r\n        _this.m_angularOffset = 0;\r\n        _this.m_linearImpulse = new b2Math_1.b2Vec2();\r\n        _this.m_angularImpulse = 0;\r\n        _this.m_maxForce = 0;\r\n        _this.m_maxTorque = 0;\r\n        _this.m_correctionFactor = 0.3;\r\n        // Solver temp\r\n        _this.m_indexA = 0;\r\n        _this.m_indexB = 0;\r\n        _this.m_rA = new b2Math_1.b2Vec2();\r\n        _this.m_rB = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterA = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterB = new b2Math_1.b2Vec2();\r\n        _this.m_linearError = new b2Math_1.b2Vec2();\r\n        _this.m_angularError = 0;\r\n        _this.m_invMassA = 0;\r\n        _this.m_invMassB = 0;\r\n        _this.m_invIA = 0;\r\n        _this.m_invIB = 0;\r\n        _this.m_linearMass = new b2Math_1.b2Mat22();\r\n        _this.m_angularMass = 0;\r\n        _this.m_qA = new b2Math_1.b2Rot();\r\n        _this.m_qB = new b2Math_1.b2Rot();\r\n        _this.m_K = new b2Math_1.b2Mat22();\r\n        _this.m_linearOffset.Copy(b2Settings_1.b2Maybe(def.linearOffset, b2Math_1.b2Vec2.ZERO));\r\n        _this.m_linearImpulse.SetZero();\r\n        _this.m_maxForce = b2Settings_1.b2Maybe(def.maxForce, 0);\r\n        _this.m_maxTorque = b2Settings_1.b2Maybe(def.maxTorque, 0);\r\n        _this.m_correctionFactor = b2Settings_1.b2Maybe(def.correctionFactor, 0.3);\r\n        return _this;\r\n    }\r\n    b2MotorJoint.prototype.GetAnchorA = function (out) {\r\n        var pos = this.m_bodyA.GetPosition();\r\n        out.x = pos.x;\r\n        out.y = pos.y;\r\n        return out;\r\n    };\r\n    b2MotorJoint.prototype.GetAnchorB = function (out) {\r\n        var pos = this.m_bodyB.GetPosition();\r\n        out.x = pos.x;\r\n        out.y = pos.y;\r\n        return out;\r\n    };\r\n    b2MotorJoint.prototype.GetReactionForce = function (inv_dt, out) {\r\n        // return inv_dt * m_linearImpulse;\r\n        return b2Math_1.b2Vec2.MulSV(inv_dt, this.m_linearImpulse, out);\r\n    };\r\n    b2MotorJoint.prototype.GetReactionTorque = function (inv_dt) {\r\n        return inv_dt * this.m_angularImpulse;\r\n    };\r\n    b2MotorJoint.prototype.SetLinearOffset = function (linearOffset) {\r\n        if (!b2Math_1.b2Vec2.IsEqualToV(linearOffset, this.m_linearOffset)) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_linearOffset.Copy(linearOffset);\r\n        }\r\n    };\r\n    b2MotorJoint.prototype.GetLinearOffset = function () {\r\n        return this.m_linearOffset;\r\n    };\r\n    b2MotorJoint.prototype.SetAngularOffset = function (angularOffset) {\r\n        if (angularOffset !== this.m_angularOffset) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_angularOffset = angularOffset;\r\n        }\r\n    };\r\n    b2MotorJoint.prototype.GetAngularOffset = function () {\r\n        return this.m_angularOffset;\r\n    };\r\n    b2MotorJoint.prototype.SetMaxForce = function (force) {\r\n        // DEBUG: b2Assert(b2IsValid(force) && force >= 0);\r\n        this.m_maxForce = force;\r\n    };\r\n    b2MotorJoint.prototype.GetMaxForce = function () {\r\n        return this.m_maxForce;\r\n    };\r\n    b2MotorJoint.prototype.SetMaxTorque = function (torque) {\r\n        // DEBUG: b2Assert(b2IsValid(torque) && torque >= 0);\r\n        this.m_maxTorque = torque;\r\n    };\r\n    b2MotorJoint.prototype.GetMaxTorque = function () {\r\n        return this.m_maxTorque;\r\n    };\r\n    b2MotorJoint.prototype.InitVelocityConstraints = function (data) {\r\n        this.m_indexA = this.m_bodyA.m_islandIndex;\r\n        this.m_indexB = this.m_bodyB.m_islandIndex;\r\n        this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n        this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n        this.m_invMassA = this.m_bodyA.m_invMass;\r\n        this.m_invMassB = this.m_bodyB.m_invMass;\r\n        this.m_invIA = this.m_bodyA.m_invI;\r\n        this.m_invIB = this.m_bodyB.m_invI;\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        // Compute the effective mass matrix.\r\n        // this.m_rA = b2Mul(qA, m_linearOffset - this.m_localCenterA);\r\n        var rA = b2Math_1.b2Rot.MulRV(qA, b2Math_1.b2Vec2.SubVV(this.m_linearOffset, this.m_localCenterA, b2Math_1.b2Vec2.s_t0), this.m_rA);\r\n        // this.m_rB = b2Mul(qB, -this.m_localCenterB);\r\n        var rB = b2Math_1.b2Rot.MulRV(qB, b2Math_1.b2Vec2.NegV(this.m_localCenterB, b2Math_1.b2Vec2.s_t0), this.m_rB);\r\n        // J = [-I -r1_skew I r2_skew]\r\n        // r_skew = [-ry; rx]\r\n        // Matlab\r\n        // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n        //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n        //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        // Upper 2 by 2 of K for point to point\r\n        var K = this.m_K;\r\n        K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n        K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n        K.ey.x = K.ex.y;\r\n        K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n        // this.m_linearMass = K.GetInverse();\r\n        K.GetInverse(this.m_linearMass);\r\n        this.m_angularMass = iA + iB;\r\n        if (this.m_angularMass > 0) {\r\n            this.m_angularMass = 1 / this.m_angularMass;\r\n        }\r\n        // this.m_linearError = cB + rB - cA - rA;\r\n        b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVV(cB, rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVV(cA, rA, b2Math_1.b2Vec2.s_t1), this.m_linearError);\r\n        this.m_angularError = aB - aA - this.m_angularOffset;\r\n        if (data.step.warmStarting) {\r\n            // Scale impulses to support a variable time step.\r\n            // this.m_linearImpulse *= data.step.dtRatio;\r\n            this.m_linearImpulse.SelfMul(data.step.dtRatio);\r\n            this.m_angularImpulse *= data.step.dtRatio;\r\n            // b2Vec2 P(this.m_linearImpulse.x, this.m_linearImpulse.y);\r\n            var P = this.m_linearImpulse;\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * (b2Math_1.b2Vec2.CrossVV(rA, P) + this.m_angularImpulse);\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * (b2Math_1.b2Vec2.CrossVV(rB, P) + this.m_angularImpulse);\r\n        }\r\n        else {\r\n            this.m_linearImpulse.SetZero();\r\n            this.m_angularImpulse = 0;\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA; // vA is a reference\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB; // vB is a reference\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2MotorJoint.prototype.SolveVelocityConstraints = function (data) {\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        var h = data.step.dt;\r\n        var inv_h = data.step.inv_dt;\r\n        // Solve angular friction\r\n        {\r\n            var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\r\n            var impulse = -this.m_angularMass * Cdot;\r\n            var oldImpulse = this.m_angularImpulse;\r\n            var maxImpulse = h * this.m_maxTorque;\r\n            this.m_angularImpulse = b2Math_1.b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\r\n            impulse = this.m_angularImpulse - oldImpulse;\r\n            wA -= iA * impulse;\r\n            wB += iB * impulse;\r\n        }\r\n        // Solve linear friction\r\n        {\r\n            var rA = this.m_rA;\r\n            var rB = this.m_rB;\r\n            // b2Vec2 Cdot = vB + b2Vec2.CrossSV(wB, rB) - vA - b2Vec2.CrossSV(wA, rA) + inv_h * this.m_correctionFactor * this.m_linearError;\r\n            var Cdot_v2 = b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVV(vB, b2Math_1.b2Vec2.CrossSV(wB, rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVV(vA, b2Math_1.b2Vec2.CrossSV(wA, rA, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t2), b2Math_1.b2Vec2.MulSV(inv_h * this.m_correctionFactor, this.m_linearError, b2Math_1.b2Vec2.s_t3), b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2);\r\n            // b2Vec2 impulse = -b2Mul(this.m_linearMass, Cdot);\r\n            var impulse_v2 = b2Math_1.b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2MotorJoint.SolveVelocityConstraints_s_impulse_v2).SelfNeg();\r\n            // b2Vec2 oldImpulse = this.m_linearImpulse;\r\n            var oldImpulse_v2 = b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);\r\n            // this.m_linearImpulse += impulse;\r\n            this.m_linearImpulse.SelfAdd(impulse_v2);\r\n            var maxImpulse = h * this.m_maxForce;\r\n            if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {\r\n                this.m_linearImpulse.Normalize();\r\n                // this.m_linearImpulse *= maxImpulse;\r\n                this.m_linearImpulse.SelfMul(maxImpulse);\r\n            }\r\n            // impulse = this.m_linearImpulse - oldImpulse;\r\n            b2Math_1.b2Vec2.SubVV(this.m_linearImpulse, oldImpulse_v2, impulse_v2);\r\n            // vA -= mA * impulse;\r\n            vA.SelfMulSub(mA, impulse_v2);\r\n            // wA -= iA * b2Vec2.CrossVV(rA, impulse);\r\n            wA -= iA * b2Math_1.b2Vec2.CrossVV(rA, impulse_v2);\r\n            // vB += mB * impulse;\r\n            vB.SelfMulAdd(mB, impulse_v2);\r\n            // wB += iB * b2Vec2.CrossVV(rB, impulse);\r\n            wB += iB * b2Math_1.b2Vec2.CrossVV(rB, impulse_v2);\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA; // vA is a reference\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB; // vB is a reference\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2MotorJoint.prototype.SolvePositionConstraints = function (data) {\r\n        return true;\r\n    };\r\n    b2MotorJoint.prototype.Dump = function (log) {\r\n        var indexA = this.m_bodyA.m_islandIndex;\r\n        var indexB = this.m_bodyB.m_islandIndex;\r\n        log(\"  const jd: b2MotorJointDef = new b2MotorJointDef();\\n\");\r\n        log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n        log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n        log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.linearOffset.Set(%.15f, %.15f);\\n\", this.m_linearOffset.x, this.m_linearOffset.y);\r\n        log(\"  jd.angularOffset = %.15f;\\n\", this.m_angularOffset);\r\n        log(\"  jd.maxForce = %.15f;\\n\", this.m_maxForce);\r\n        log(\"  jd.maxTorque = %.15f;\\n\", this.m_maxTorque);\r\n        log(\"  jd.correctionFactor = %.15f;\\n\", this.m_correctionFactor);\r\n        log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n    };\r\n    b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Math_1.b2Vec2();\r\n    b2MotorJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Math_1.b2Vec2();\r\n    b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2 = new b2Math_1.b2Vec2();\r\n    return b2MotorJoint;\r\n}(b2Joint_1.b2Joint));\r\nexports.b2MotorJoint = b2MotorJoint;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2MotorJoint.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Joints/b2MotorJoint.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2012 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\n// DEBUG: import { b2IsValid } from \"../../Common/b2Math\";\r\nimport { b2Maybe } from \"../../Common/b2Settings\";\r\nimport { b2Clamp, b2Vec2, b2Mat22, b2Rot, XY } from \"../../Common/b2Math\";\r\nimport { b2Body } from \"../b2Body\";\r\nimport { b2Joint, b2JointDef, b2JointType, b2IJointDef } from \"./b2Joint\";\r\nimport { b2SolverData } from \"../b2TimeStep\";\r\n\r\n// Point-to-point constraint\r\n// Cdot = v2 - v1\r\n//      = v2 + cross(w2, r2) - v1 - cross(w1, r1)\r\n// J = [-I -r1_skew I r2_skew ]\r\n// Identity used:\r\n// w k % (rx i + ry j) = w * (-ry i + rx j)\r\n//\r\n// r1 = offset - c1\r\n// r2 = -c2\r\n\r\n// Angle constraint\r\n// Cdot = w2 - w1\r\n// J = [0 0 -1 0 0 1]\r\n// K = invI1 + invI2\r\n\r\nexport interface b2IMotorJointDef extends b2IJointDef {\r\n  linearOffset?: XY;\r\n\r\n  angularOffset?: number;\r\n\r\n  maxForce?: number;\r\n\r\n  maxTorque?: number;\r\n\r\n  correctionFactor?: number;\r\n}\r\n\r\nexport class b2MotorJointDef extends b2JointDef implements b2IMotorJointDef {\r\n  public readonly linearOffset: b2Vec2 = new b2Vec2(0, 0);\r\n\r\n  public angularOffset: number = 0;\r\n\r\n  public maxForce: number = 1;\r\n\r\n  public maxTorque: number = 1;\r\n\r\n  public correctionFactor: number = 0.3;\r\n\r\n  constructor() {\r\n    super(b2JointType.e_motorJoint);\r\n  }\r\n\r\n  public Initialize(bA: b2Body, bB: b2Body): void {\r\n    this.bodyA = bA;\r\n    this.bodyB = bB;\r\n    // b2Vec2 xB = bodyB->GetPosition();\r\n    // linearOffset = bodyA->GetLocalPoint(xB);\r\n    this.bodyA.GetLocalPoint(this.bodyB.GetPosition(), this.linearOffset);\r\n\r\n    const angleA: number = this.bodyA.GetAngle();\r\n    const angleB: number = this.bodyB.GetAngle();\r\n    this.angularOffset = angleB - angleA;\r\n  }\r\n}\r\n\r\nexport class b2MotorJoint extends b2Joint {\r\n  // Solver shared\r\n  public readonly m_linearOffset: b2Vec2 = new b2Vec2();\r\n  public m_angularOffset: number = 0;\r\n  public readonly m_linearImpulse: b2Vec2 = new b2Vec2();\r\n  public m_angularImpulse: number = 0;\r\n  public m_maxForce: number = 0;\r\n  public m_maxTorque: number = 0;\r\n  public m_correctionFactor: number = 0.3;\r\n\r\n  // Solver temp\r\n  public m_indexA: number = 0;\r\n  public m_indexB: number = 0;\r\n  public readonly m_rA: b2Vec2 = new b2Vec2();\r\n  public readonly m_rB: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterB: b2Vec2 = new b2Vec2();\r\n  public readonly m_linearError: b2Vec2 = new b2Vec2();\r\n  public m_angularError: number = 0;\r\n  public m_invMassA: number = 0;\r\n  public m_invMassB: number = 0;\r\n  public m_invIA: number = 0;\r\n  public m_invIB: number = 0;\r\n  public readonly m_linearMass: b2Mat22 = new b2Mat22();\r\n  public m_angularMass: number = 0;\r\n\r\n  public readonly m_qA: b2Rot = new b2Rot();\r\n  public readonly m_qB: b2Rot = new b2Rot();\r\n  public readonly m_K: b2Mat22 = new b2Mat22();\r\n\r\n  constructor(def: b2IMotorJointDef) {\r\n    super(def);\r\n\r\n    this.m_linearOffset.Copy(b2Maybe(def.linearOffset, b2Vec2.ZERO));\r\n    this.m_linearImpulse.SetZero();\r\n    this.m_maxForce = b2Maybe(def.maxForce, 0);\r\n    this.m_maxTorque = b2Maybe(def.maxTorque, 0);\r\n    this.m_correctionFactor = b2Maybe(def.correctionFactor, 0.3);\r\n  }\r\n\r\n  public GetAnchorA<T extends XY>(out: T): T {\r\n    const pos: Readonly<b2Vec2> = this.m_bodyA.GetPosition();\r\n    out.x = pos.x;\r\n    out.y = pos.y;\r\n    return out;\r\n  }\r\n  public GetAnchorB<T extends XY>(out: T): T {\r\n    const pos: Readonly<b2Vec2> = this.m_bodyB.GetPosition();\r\n    out.x = pos.x;\r\n    out.y = pos.y;\r\n    return out;\r\n  }\r\n\r\n  public GetReactionForce<T extends XY>(inv_dt: number, out: T): T {\r\n    // return inv_dt * m_linearImpulse;\r\n    return b2Vec2.MulSV(inv_dt, this.m_linearImpulse, out);\r\n  }\r\n\r\n  public GetReactionTorque(inv_dt: number): number {\r\n    return inv_dt * this.m_angularImpulse;\r\n  }\r\n\r\n  public SetLinearOffset(linearOffset: b2Vec2): void {\r\n    if (!b2Vec2.IsEqualToV(linearOffset, this.m_linearOffset)) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_linearOffset.Copy(linearOffset);\r\n    }\r\n  }\r\n  public GetLinearOffset() {\r\n    return this.m_linearOffset;\r\n  }\r\n\r\n  public SetAngularOffset(angularOffset: number): void {\r\n    if (angularOffset !== this.m_angularOffset) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_angularOffset = angularOffset;\r\n    }\r\n  }\r\n  public GetAngularOffset() {\r\n    return this.m_angularOffset;\r\n  }\r\n\r\n  public SetMaxForce(force: number): void {\r\n    // DEBUG: b2Assert(b2IsValid(force) && force >= 0);\r\n    this.m_maxForce = force;\r\n  }\r\n\r\n  public GetMaxForce() {\r\n    return this.m_maxForce;\r\n  }\r\n\r\n  public SetMaxTorque(torque: number): void {\r\n    // DEBUG: b2Assert(b2IsValid(torque) && torque >= 0);\r\n    this.m_maxTorque = torque;\r\n  }\r\n\r\n  public GetMaxTorque() {\r\n    return this.m_maxTorque;\r\n  }\r\n\r\n  public InitVelocityConstraints(data: b2SolverData): void {\r\n    this.m_indexA = this.m_bodyA.m_islandIndex;\r\n    this.m_indexB = this.m_bodyB.m_islandIndex;\r\n    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n    this.m_invMassA = this.m_bodyA.m_invMass;\r\n    this.m_invMassB = this.m_bodyB.m_invMass;\r\n    this.m_invIA = this.m_bodyA.m_invI;\r\n    this.m_invIB = this.m_bodyB.m_invI;\r\n\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    const aA: number = data.positions[this.m_indexA].a;\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    const aB: number = data.positions[this.m_indexB].a;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    // Compute the effective mass matrix.\r\n    // this.m_rA = b2Mul(qA, m_linearOffset - this.m_localCenterA);\r\n    const rA: b2Vec2 = b2Rot.MulRV(qA, b2Vec2.SubVV(this.m_linearOffset, this.m_localCenterA, b2Vec2.s_t0), this.m_rA);\r\n    // this.m_rB = b2Mul(qB, -this.m_localCenterB);\r\n    const rB: b2Vec2 = b2Rot.MulRV(qB, b2Vec2.NegV(this.m_localCenterB, b2Vec2.s_t0), this.m_rB);\r\n\r\n    // J = [-I -r1_skew I r2_skew]\r\n    // r_skew = [-ry; rx]\r\n\r\n    // Matlab\r\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n    //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n    //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    // Upper 2 by 2 of K for point to point\r\n    const K: b2Mat22 = this.m_K;\r\n    K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n    K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n    K.ey.x = K.ex.y;\r\n    K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n\r\n    // this.m_linearMass = K.GetInverse();\r\n    K.GetInverse(this.m_linearMass);\r\n\r\n    this.m_angularMass = iA + iB;\r\n    if (this.m_angularMass > 0) {\r\n      this.m_angularMass = 1 / this.m_angularMass;\r\n    }\r\n\r\n    // this.m_linearError = cB + rB - cA - rA;\r\n    b2Vec2.SubVV(\r\n      b2Vec2.AddVV(cB, rB, b2Vec2.s_t0),\r\n      b2Vec2.AddVV(cA, rA, b2Vec2.s_t1),\r\n      this.m_linearError);\r\n    this.m_angularError = aB - aA - this.m_angularOffset;\r\n\r\n    if (data.step.warmStarting) {\r\n      // Scale impulses to support a variable time step.\r\n      // this.m_linearImpulse *= data.step.dtRatio;\r\n      this.m_linearImpulse.SelfMul(data.step.dtRatio);\r\n      this.m_angularImpulse *= data.step.dtRatio;\r\n\r\n      // b2Vec2 P(this.m_linearImpulse.x, this.m_linearImpulse.y);\r\n      const P: b2Vec2 = this.m_linearImpulse;\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * (b2Vec2.CrossVV(rA, P) + this.m_angularImpulse);\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * (b2Vec2.CrossVV(rB, P) + this.m_angularImpulse);\r\n    } else {\r\n      this.m_linearImpulse.SetZero();\r\n      this.m_angularImpulse = 0;\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA; // vA is a reference\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB; // vB is a reference\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolveVelocityConstraints_s_Cdot_v2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_impulse_v2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_oldImpulse_v2 = new b2Vec2();\r\n  public SolveVelocityConstraints(data: b2SolverData): void {\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    const h: number = data.step.dt;\r\n    const inv_h: number = data.step.inv_dt;\r\n\r\n    // Solve angular friction\r\n    {\r\n      const Cdot: number = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\r\n      let impulse: number = -this.m_angularMass * Cdot;\r\n\r\n      const oldImpulse: number = this.m_angularImpulse;\r\n      const maxImpulse: number = h * this.m_maxTorque;\r\n      this.m_angularImpulse = b2Clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\r\n      impulse = this.m_angularImpulse - oldImpulse;\r\n\r\n      wA -= iA * impulse;\r\n      wB += iB * impulse;\r\n    }\r\n\r\n    // Solve linear friction\r\n    {\r\n      const rA = this.m_rA;\r\n      const rB = this.m_rB;\r\n\r\n      // b2Vec2 Cdot = vB + b2Vec2.CrossSV(wB, rB) - vA - b2Vec2.CrossSV(wA, rA) + inv_h * this.m_correctionFactor * this.m_linearError;\r\n      const Cdot_v2 =\r\n        b2Vec2.AddVV(\r\n          b2Vec2.SubVV(\r\n            b2Vec2.AddVV(vB, b2Vec2.CrossSV(wB, rB, b2Vec2.s_t0), b2Vec2.s_t0),\r\n            b2Vec2.AddVV(vA, b2Vec2.CrossSV(wA, rA, b2Vec2.s_t1), b2Vec2.s_t1), b2Vec2.s_t2),\r\n          b2Vec2.MulSV(inv_h * this.m_correctionFactor, this.m_linearError, b2Vec2.s_t3),\r\n          b2MotorJoint.SolveVelocityConstraints_s_Cdot_v2);\r\n\r\n      // b2Vec2 impulse = -b2Mul(this.m_linearMass, Cdot);\r\n      const impulse_v2: b2Vec2 = b2Mat22.MulMV(this.m_linearMass, Cdot_v2, b2MotorJoint.SolveVelocityConstraints_s_impulse_v2).SelfNeg();\r\n      // b2Vec2 oldImpulse = this.m_linearImpulse;\r\n      const oldImpulse_v2 = b2MotorJoint.SolveVelocityConstraints_s_oldImpulse_v2.Copy(this.m_linearImpulse);\r\n      // this.m_linearImpulse += impulse;\r\n      this.m_linearImpulse.SelfAdd(impulse_v2);\r\n\r\n      const maxImpulse: number = h * this.m_maxForce;\r\n\r\n      if (this.m_linearImpulse.LengthSquared() > maxImpulse * maxImpulse) {\r\n        this.m_linearImpulse.Normalize();\r\n        // this.m_linearImpulse *= maxImpulse;\r\n        this.m_linearImpulse.SelfMul(maxImpulse);\r\n      }\r\n\r\n      // impulse = this.m_linearImpulse - oldImpulse;\r\n      b2Vec2.SubVV(this.m_linearImpulse, oldImpulse_v2, impulse_v2);\r\n\r\n      // vA -= mA * impulse;\r\n      vA.SelfMulSub(mA, impulse_v2);\r\n      // wA -= iA * b2Vec2.CrossVV(rA, impulse);\r\n      wA -= iA * b2Vec2.CrossVV(rA, impulse_v2);\r\n\r\n      // vB += mB * impulse;\r\n      vB.SelfMulAdd(mB, impulse_v2);\r\n      // wB += iB * b2Vec2.CrossVV(rB, impulse);\r\n      wB += iB * b2Vec2.CrossVV(rB, impulse_v2);\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA; // vA is a reference\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB; // vB is a reference\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  public SolvePositionConstraints(data: b2SolverData): boolean {\r\n    return true;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void) {\r\n    const indexA = this.m_bodyA.m_islandIndex;\r\n    const indexB = this.m_bodyB.m_islandIndex;\r\n\r\n    log(\"  const jd: b2MotorJointDef = new b2MotorJointDef();\\n\");\r\n\r\n    log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n    log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n    log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n\r\n    log(\"  jd.linearOffset.Set(%.15f, %.15f);\\n\", this.m_linearOffset.x, this.m_linearOffset.y);\r\n    log(\"  jd.angularOffset = %.15f;\\n\", this.m_angularOffset);\r\n    log(\"  jd.maxForce = %.15f;\\n\", this.m_maxForce);\r\n    log(\"  jd.maxTorque = %.15f;\\n\", this.m_maxTorque);\r\n    log(\"  jd.correctionFactor = %.15f;\\n\", this.m_correctionFactor);\r\n    log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n  }\r\n}\r\n"]}},"error":null,"hash":"1f0141f5886939de95d881fdd83a8653","cacheData":{"env":{}}}