{"id":"../node_modules/box2d.package.ts/Collision/Shapes/b2EdgeShape.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":31,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2EdgeShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":32,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2EdgeShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Shape","loc":{"line":33,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2EdgeShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Shape_1 = require(\"./b2Shape\");\r\n/// A line segment (edge) shape. These can be connected in chains or loops\r\n/// to other edge shapes. The connectivity information is used to ensure\r\n/// correct contact normals.\r\nvar b2EdgeShape = /** @class */ (function (_super) {\r\n    __extends(b2EdgeShape, _super);\r\n    function b2EdgeShape() {\r\n        var _this = _super.call(this, b2Shape_1.b2ShapeType.e_edgeShape, b2Settings_1.b2_polygonRadius) || this;\r\n        _this.m_vertex1 = new b2Math_1.b2Vec2();\r\n        _this.m_vertex2 = new b2Math_1.b2Vec2();\r\n        _this.m_vertex0 = new b2Math_1.b2Vec2();\r\n        _this.m_vertex3 = new b2Math_1.b2Vec2();\r\n        _this.m_hasVertex0 = false;\r\n        _this.m_hasVertex3 = false;\r\n        return _this;\r\n    }\r\n    /// Set this as an isolated edge.\r\n    b2EdgeShape.prototype.Set = function (v1, v2) {\r\n        this.m_vertex1.Copy(v1);\r\n        this.m_vertex2.Copy(v2);\r\n        this.m_hasVertex0 = false;\r\n        this.m_hasVertex3 = false;\r\n        return this;\r\n    };\r\n    /// Implement b2Shape.\r\n    b2EdgeShape.prototype.Clone = function () {\r\n        return new b2EdgeShape().Copy(this);\r\n    };\r\n    b2EdgeShape.prototype.Copy = function (other) {\r\n        _super.prototype.Copy.call(this, other);\r\n        // DEBUG: b2Assert(other instanceof b2EdgeShape);\r\n        this.m_vertex1.Copy(other.m_vertex1);\r\n        this.m_vertex2.Copy(other.m_vertex2);\r\n        this.m_vertex0.Copy(other.m_vertex0);\r\n        this.m_vertex3.Copy(other.m_vertex3);\r\n        this.m_hasVertex0 = other.m_hasVertex0;\r\n        this.m_hasVertex3 = other.m_hasVertex3;\r\n        return this;\r\n    };\r\n    /// @see b2Shape::GetChildCount\r\n    b2EdgeShape.prototype.GetChildCount = function () {\r\n        return 1;\r\n    };\r\n    /// @see b2Shape::TestPoint\r\n    b2EdgeShape.prototype.TestPoint = function (xf, p) {\r\n        return false;\r\n    };\r\n    b2EdgeShape.prototype.ComputeDistance = function (xf, p, normal, childIndex) {\r\n        var v1 = b2Math_1.b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeDistance_s_v1);\r\n        var v2 = b2Math_1.b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeDistance_s_v2);\r\n        var d = b2Math_1.b2Vec2.SubVV(p, v1, b2EdgeShape.ComputeDistance_s_d);\r\n        var s = b2Math_1.b2Vec2.SubVV(v2, v1, b2EdgeShape.ComputeDistance_s_s);\r\n        var ds = b2Math_1.b2Vec2.DotVV(d, s);\r\n        if (ds > 0) {\r\n            var s2 = b2Math_1.b2Vec2.DotVV(s, s);\r\n            if (ds > s2) {\r\n                b2Math_1.b2Vec2.SubVV(p, v2, d);\r\n            }\r\n            else {\r\n                d.SelfMulSub(ds / s2, s);\r\n            }\r\n        }\r\n        normal.Copy(d);\r\n        return normal.Normalize();\r\n    };\r\n    b2EdgeShape.prototype.RayCast = function (output, input, xf, childIndex) {\r\n        // Put the ray into the edge's frame of reference.\r\n        var p1 = b2Math_1.b2Transform.MulTXV(xf, input.p1, b2EdgeShape.RayCast_s_p1);\r\n        var p2 = b2Math_1.b2Transform.MulTXV(xf, input.p2, b2EdgeShape.RayCast_s_p2);\r\n        var d = b2Math_1.b2Vec2.SubVV(p2, p1, b2EdgeShape.RayCast_s_d);\r\n        var v1 = this.m_vertex1;\r\n        var v2 = this.m_vertex2;\r\n        var e = b2Math_1.b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_e);\r\n        var normal = output.normal.Set(e.y, -e.x).SelfNormalize();\r\n        // q = p1 + t * d\r\n        // dot(normal, q - v1) = 0\r\n        // dot(normal, p1 - v1) + t * dot(normal, d) = 0\r\n        var numerator = b2Math_1.b2Vec2.DotVV(normal, b2Math_1.b2Vec2.SubVV(v1, p1, b2Math_1.b2Vec2.s_t0));\r\n        var denominator = b2Math_1.b2Vec2.DotVV(normal, d);\r\n        if (denominator === 0) {\r\n            return false;\r\n        }\r\n        var t = numerator / denominator;\r\n        if (t < 0 || input.maxFraction < t) {\r\n            return false;\r\n        }\r\n        var q = b2Math_1.b2Vec2.AddVMulSV(p1, t, d, b2EdgeShape.RayCast_s_q);\r\n        // q = v1 + s * r\r\n        // s = dot(q - v1, r) / dot(r, r)\r\n        var r = b2Math_1.b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_r);\r\n        var rr = b2Math_1.b2Vec2.DotVV(r, r);\r\n        if (rr === 0) {\r\n            return false;\r\n        }\r\n        var s = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(q, v1, b2Math_1.b2Vec2.s_t0), r) / rr;\r\n        if (s < 0 || 1 < s) {\r\n            return false;\r\n        }\r\n        output.fraction = t;\r\n        b2Math_1.b2Rot.MulRV(xf.q, output.normal, output.normal);\r\n        if (numerator > 0) {\r\n            output.normal.SelfNeg();\r\n        }\r\n        return true;\r\n    };\r\n    b2EdgeShape.prototype.ComputeAABB = function (aabb, xf, childIndex) {\r\n        var v1 = b2Math_1.b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeAABB_s_v1);\r\n        var v2 = b2Math_1.b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeAABB_s_v2);\r\n        b2Math_1.b2Vec2.MinV(v1, v2, aabb.lowerBound);\r\n        b2Math_1.b2Vec2.MaxV(v1, v2, aabb.upperBound);\r\n        var r = this.m_radius;\r\n        aabb.lowerBound.SelfSubXY(r, r);\r\n        aabb.upperBound.SelfAddXY(r, r);\r\n    };\r\n    /// @see b2Shape::ComputeMass\r\n    b2EdgeShape.prototype.ComputeMass = function (massData, density) {\r\n        massData.mass = 0;\r\n        b2Math_1.b2Vec2.MidVV(this.m_vertex1, this.m_vertex2, massData.center);\r\n        massData.I = 0;\r\n    };\r\n    b2EdgeShape.prototype.SetupDistanceProxy = function (proxy, index) {\r\n        proxy.m_vertices = proxy.m_buffer;\r\n        proxy.m_vertices[0].Copy(this.m_vertex1);\r\n        proxy.m_vertices[1].Copy(this.m_vertex2);\r\n        proxy.m_count = 2;\r\n        proxy.m_radius = this.m_radius;\r\n    };\r\n    b2EdgeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {\r\n        c.SetZero();\r\n        return 0;\r\n    };\r\n    b2EdgeShape.prototype.Dump = function (log) {\r\n        log(\"    const shape: b2EdgeShape = new b2EdgeShape();\\n\");\r\n        log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n        log(\"    shape.m_vertex0.Set(%.15f, %.15f);\\n\", this.m_vertex0.x, this.m_vertex0.y);\r\n        log(\"    shape.m_vertex1.Set(%.15f, %.15f);\\n\", this.m_vertex1.x, this.m_vertex1.y);\r\n        log(\"    shape.m_vertex2.Set(%.15f, %.15f);\\n\", this.m_vertex2.x, this.m_vertex2.y);\r\n        log(\"    shape.m_vertex3.Set(%.15f, %.15f);\\n\", this.m_vertex3.x, this.m_vertex3.y);\r\n        log(\"    shape.m_hasVertex0 = %s;\\n\", this.m_hasVertex0);\r\n        log(\"    shape.m_hasVertex3 = %s;\\n\", this.m_hasVertex3);\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    /// @see b2Shape::ComputeDistance\r\n    b2EdgeShape.ComputeDistance_s_v1 = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.ComputeDistance_s_v2 = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.ComputeDistance_s_d = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.ComputeDistance_s_s = new b2Math_1.b2Vec2();\r\n    // #endif\r\n    /// Implement b2Shape.\r\n    // p = p1 + t * d\r\n    // v = v1 + s * e\r\n    // p1 + t * d = v1 + s * e\r\n    // s * e - t * d = p1 - v1\r\n    b2EdgeShape.RayCast_s_p1 = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.RayCast_s_p2 = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.RayCast_s_d = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.RayCast_s_e = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.RayCast_s_q = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.RayCast_s_r = new b2Math_1.b2Vec2();\r\n    /// @see b2Shape::ComputeAABB\r\n    b2EdgeShape.ComputeAABB_s_v1 = new b2Math_1.b2Vec2();\r\n    b2EdgeShape.ComputeAABB_s_v2 = new b2Math_1.b2Vec2();\r\n    return b2EdgeShape;\r\n}(b2Shape_1.b2Shape));\r\nexports.b2EdgeShape = b2EdgeShape;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2EdgeShape.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/Shapes/b2EdgeShape.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nimport { b2_polygonRadius } from \"../../Common/b2Settings\";\r\nimport { b2Vec2, b2Rot, b2Transform, XY } from \"../../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../b2Collision\";\r\nimport { b2DistanceProxy } from \"../b2Distance\";\r\nimport { b2MassData } from \"./b2Shape\";\r\nimport { b2Shape, b2ShapeType } from \"./b2Shape\";\r\n\r\n/// A line segment (edge) shape. These can be connected in chains or loops\r\n/// to other edge shapes. The connectivity information is used to ensure\r\n/// correct contact normals.\r\nexport class b2EdgeShape extends b2Shape {\r\n  public readonly m_vertex1: b2Vec2 = new b2Vec2();\r\n  public readonly m_vertex2: b2Vec2 = new b2Vec2();\r\n  public readonly m_vertex0: b2Vec2 = new b2Vec2();\r\n  public readonly m_vertex3: b2Vec2 = new b2Vec2();\r\n  public m_hasVertex0: boolean = false;\r\n  public m_hasVertex3: boolean = false;\r\n\r\n  constructor() {\r\n    super(b2ShapeType.e_edgeShape, b2_polygonRadius);\r\n  }\r\n\r\n  /// Set this as an isolated edge.\r\n  public Set(v1: XY, v2: XY): b2EdgeShape {\r\n    this.m_vertex1.Copy(v1);\r\n    this.m_vertex2.Copy(v2);\r\n    this.m_hasVertex0 = false;\r\n    this.m_hasVertex3 = false;\r\n    return this;\r\n  }\r\n\r\n  /// Implement b2Shape.\r\n  public Clone(): b2EdgeShape {\r\n    return new b2EdgeShape().Copy(this);\r\n  }\r\n\r\n  public Copy(other: b2EdgeShape): b2EdgeShape {\r\n    super.Copy(other);\r\n\r\n    // DEBUG: b2Assert(other instanceof b2EdgeShape);\r\n\r\n    this.m_vertex1.Copy(other.m_vertex1);\r\n    this.m_vertex2.Copy(other.m_vertex2);\r\n    this.m_vertex0.Copy(other.m_vertex0);\r\n    this.m_vertex3.Copy(other.m_vertex3);\r\n    this.m_hasVertex0 = other.m_hasVertex0;\r\n    this.m_hasVertex3 = other.m_hasVertex3;\r\n\r\n    return this;\r\n  }\r\n\r\n  /// @see b2Shape::GetChildCount\r\n  public GetChildCount(): number {\r\n    return 1;\r\n  }\r\n\r\n  /// @see b2Shape::TestPoint\r\n  public TestPoint(xf: b2Transform, p: XY): boolean {\r\n    return false;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  /// @see b2Shape::ComputeDistance\r\n  private static ComputeDistance_s_v1 = new b2Vec2();\r\n  private static ComputeDistance_s_v2 = new b2Vec2();\r\n  private static ComputeDistance_s_d = new b2Vec2();\r\n  private static ComputeDistance_s_s = new b2Vec2();\r\n  public ComputeDistance(xf: b2Transform, p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    const v1 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeDistance_s_v1);\r\n    const v2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeDistance_s_v2);\r\n\r\n    const d = b2Vec2.SubVV(p, v1, b2EdgeShape.ComputeDistance_s_d);\r\n    const s = b2Vec2.SubVV(v2, v1, b2EdgeShape.ComputeDistance_s_s);\r\n    const ds = b2Vec2.DotVV(d, s);\r\n    if (ds > 0) {\r\n      const s2 = b2Vec2.DotVV(s, s);\r\n      if (ds > s2) {\r\n        b2Vec2.SubVV(p, v2, d);\r\n      } else {\r\n        d.SelfMulSub(ds / s2, s);\r\n      }\r\n    }\r\n    normal.Copy(d);\r\n    return normal.Normalize();\r\n  }\r\n  // #endif\r\n\r\n  /// Implement b2Shape.\r\n  // p = p1 + t * d\r\n  // v = v1 + s * e\r\n  // p1 + t * d = v1 + s * e\r\n  // s * e - t * d = p1 - v1\r\n  private static RayCast_s_p1 = new b2Vec2();\r\n  private static RayCast_s_p2 = new b2Vec2();\r\n  private static RayCast_s_d = new b2Vec2();\r\n  private static RayCast_s_e = new b2Vec2();\r\n  private static RayCast_s_q = new b2Vec2();\r\n  private static RayCast_s_r = new b2Vec2();\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, xf: b2Transform, childIndex: number): boolean {\r\n    // Put the ray into the edge's frame of reference.\r\n    const p1: b2Vec2 = b2Transform.MulTXV(xf, input.p1, b2EdgeShape.RayCast_s_p1);\r\n    const p2: b2Vec2 = b2Transform.MulTXV(xf, input.p2, b2EdgeShape.RayCast_s_p2);\r\n    const d: b2Vec2 = b2Vec2.SubVV(p2, p1, b2EdgeShape.RayCast_s_d);\r\n\r\n    const v1: b2Vec2 = this.m_vertex1;\r\n    const v2: b2Vec2 = this.m_vertex2;\r\n    const e: b2Vec2 = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_e);\r\n    const normal: b2Vec2 = output.normal.Set(e.y, -e.x).SelfNormalize();\r\n\r\n    // q = p1 + t * d\r\n    // dot(normal, q - v1) = 0\r\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\r\n    const numerator: number = b2Vec2.DotVV(normal, b2Vec2.SubVV(v1, p1, b2Vec2.s_t0));\r\n    const denominator: number = b2Vec2.DotVV(normal, d);\r\n\r\n    if (denominator === 0) {\r\n      return false;\r\n    }\r\n\r\n    const t: number = numerator / denominator;\r\n    if (t < 0 || input.maxFraction < t) {\r\n      return false;\r\n    }\r\n\r\n    const q: b2Vec2 = b2Vec2.AddVMulSV(p1, t, d, b2EdgeShape.RayCast_s_q);\r\n\r\n    // q = v1 + s * r\r\n    // s = dot(q - v1, r) / dot(r, r)\r\n    const r: b2Vec2 = b2Vec2.SubVV(v2, v1, b2EdgeShape.RayCast_s_r);\r\n    const rr: number = b2Vec2.DotVV(r, r);\r\n    if (rr === 0) {\r\n      return false;\r\n    }\r\n\r\n    const s: number = b2Vec2.DotVV(b2Vec2.SubVV(q, v1, b2Vec2.s_t0), r) / rr;\r\n    if (s < 0 || 1 < s) {\r\n      return false;\r\n    }\r\n\r\n    output.fraction = t;\r\n    b2Rot.MulRV(xf.q, output.normal, output.normal);\r\n    if (numerator > 0) {\r\n      output.normal.SelfNeg();\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /// @see b2Shape::ComputeAABB\r\n  private static ComputeAABB_s_v1 = new b2Vec2();\r\n  private static ComputeAABB_s_v2 = new b2Vec2();\r\n  public ComputeAABB(aabb: b2AABB, xf: b2Transform, childIndex: number): void {\r\n    const v1: b2Vec2 = b2Transform.MulXV(xf, this.m_vertex1, b2EdgeShape.ComputeAABB_s_v1);\r\n    const v2: b2Vec2 = b2Transform.MulXV(xf, this.m_vertex2, b2EdgeShape.ComputeAABB_s_v2);\r\n\r\n    b2Vec2.MinV(v1, v2, aabb.lowerBound);\r\n    b2Vec2.MaxV(v1, v2, aabb.upperBound);\r\n\r\n    const r: number = this.m_radius;\r\n    aabb.lowerBound.SelfSubXY(r, r);\r\n    aabb.upperBound.SelfAddXY(r, r);\r\n  }\r\n\r\n  /// @see b2Shape::ComputeMass\r\n  public ComputeMass(massData: b2MassData, density: number): void {\r\n    massData.mass = 0;\r\n    b2Vec2.MidVV(this.m_vertex1, this.m_vertex2, massData.center);\r\n    massData.I = 0;\r\n  }\r\n\r\n  public SetupDistanceProxy(proxy: b2DistanceProxy, index: number): void {\r\n    proxy.m_vertices = proxy.m_buffer;\r\n    proxy.m_vertices[0].Copy(this.m_vertex1);\r\n    proxy.m_vertices[1].Copy(this.m_vertex2);\r\n    proxy.m_count = 2;\r\n    proxy.m_radius = this.m_radius;\r\n  }\r\n\r\n  public ComputeSubmergedArea(normal: b2Vec2, offset: number, xf: b2Transform, c: b2Vec2): number {\r\n    c.SetZero();\r\n    return 0;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    log(\"    const shape: b2EdgeShape = new b2EdgeShape();\\n\");\r\n    log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n    log(\"    shape.m_vertex0.Set(%.15f, %.15f);\\n\", this.m_vertex0.x, this.m_vertex0.y);\r\n    log(\"    shape.m_vertex1.Set(%.15f, %.15f);\\n\", this.m_vertex1.x, this.m_vertex1.y);\r\n    log(\"    shape.m_vertex2.Set(%.15f, %.15f);\\n\", this.m_vertex2.x, this.m_vertex2.y);\r\n    log(\"    shape.m_vertex3.Set(%.15f, %.15f);\\n\", this.m_vertex3.x, this.m_vertex3.y);\r\n    log(\"    shape.m_hasVertex0 = %s;\\n\", this.m_hasVertex0);\r\n    log(\"    shape.m_hasVertex3 = %s;\\n\", this.m_hasVertex3);\r\n  }\r\n}\r\n"]}},"error":null,"hash":"3e331ebd71f4ccd85dd1bf5a51fadad1","cacheData":{"env":{}}}