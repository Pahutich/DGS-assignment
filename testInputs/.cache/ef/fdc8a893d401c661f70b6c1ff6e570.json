{"id":"../node_modules/box2d.package.ts/Dynamics/Contacts/b2Contact.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":20,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2Contact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":21,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2Contact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../../Collision/b2Collision","loc":{"line":23,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2Contact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"../../Collision/b2TimeOfImpact","loc":{"line":24,"column":31},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2Contact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Collision_1 = require(\"../../Collision/b2Collision\");\r\nvar b2Collision_2 = require(\"../../Collision/b2Collision\");\r\nvar b2TimeOfImpact_1 = require(\"../../Collision/b2TimeOfImpact\");\r\n/// Friction mixing law. The idea is to allow either fixture to drive the friction to zero.\r\n/// For example, anything slides on ice.\r\nfunction b2MixFriction(friction1, friction2) {\r\n    return b2Math_1.b2Sqrt(friction1 * friction2);\r\n}\r\nexports.b2MixFriction = b2MixFriction;\r\n/// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.\r\n/// For example, a superball bounces on anything.\r\nfunction b2MixRestitution(restitution1, restitution2) {\r\n    return restitution1 > restitution2 ? restitution1 : restitution2;\r\n}\r\nexports.b2MixRestitution = b2MixRestitution;\r\nvar b2ContactEdge = /** @class */ (function () {\r\n    function b2ContactEdge(contact) {\r\n        this._other = null; ///< provides quick access to the other body attached.\r\n        this.prev = null; ///< the previous contact edge in the body's contact list\r\n        this.next = null; ///< the next contact edge in the body's contact list\r\n        this.contact = contact;\r\n    }\r\n    Object.defineProperty(b2ContactEdge.prototype, \"other\", {\r\n        get: function () {\r\n            if (this._other === null) {\r\n                throw new Error();\r\n            }\r\n            return this._other;\r\n        },\r\n        set: function (value) {\r\n            if (this._other !== null) {\r\n                throw new Error();\r\n            }\r\n            this._other = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    b2ContactEdge.prototype.Reset = function () {\r\n        this._other = null;\r\n        this.prev = null;\r\n        this.next = null;\r\n    };\r\n    return b2ContactEdge;\r\n}());\r\nexports.b2ContactEdge = b2ContactEdge;\r\nvar b2Contact = /** @class */ (function () {\r\n    function b2Contact() {\r\n        this.m_islandFlag = false; /// Used when crawling contact graph when forming islands.\r\n        this.m_touchingFlag = false; /// Set when the shapes are touching.\r\n        this.m_enabledFlag = false; /// This contact can be disabled (by user)\r\n        this.m_filterFlag = false; /// This contact needs filtering because a fixture filter was changed.\r\n        this.m_bulletHitFlag = false; /// This bullet contact had a TOI event\r\n        this.m_toiFlag = false; /// This contact has a valid TOI in m_toi\r\n        this.m_prev = null;\r\n        this.m_next = null;\r\n        this.m_nodeA = new b2ContactEdge(this);\r\n        this.m_nodeB = new b2ContactEdge(this);\r\n        this.m_indexA = 0;\r\n        this.m_indexB = 0;\r\n        this.m_manifold = new b2Collision_1.b2Manifold(); // TODO: readonly\r\n        this.m_toiCount = 0;\r\n        this.m_toi = 0;\r\n        this.m_friction = 0;\r\n        this.m_restitution = 0;\r\n        this.m_tangentSpeed = 0;\r\n        this.m_oldManifold = new b2Collision_1.b2Manifold(); // TODO: readonly\r\n    }\r\n    b2Contact.prototype.GetManifold = function () {\r\n        return this.m_manifold;\r\n    };\r\n    b2Contact.prototype.GetWorldManifold = function (worldManifold) {\r\n        var bodyA = this.m_fixtureA.GetBody();\r\n        var bodyB = this.m_fixtureB.GetBody();\r\n        var shapeA = this.GetShapeA();\r\n        var shapeB = this.GetShapeB();\r\n        worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);\r\n    };\r\n    b2Contact.prototype.IsTouching = function () {\r\n        return this.m_touchingFlag;\r\n    };\r\n    b2Contact.prototype.SetEnabled = function (flag) {\r\n        this.m_enabledFlag = flag;\r\n    };\r\n    b2Contact.prototype.IsEnabled = function () {\r\n        return this.m_enabledFlag;\r\n    };\r\n    b2Contact.prototype.GetNext = function () {\r\n        return this.m_next;\r\n    };\r\n    b2Contact.prototype.GetFixtureA = function () {\r\n        return this.m_fixtureA;\r\n    };\r\n    b2Contact.prototype.GetChildIndexA = function () {\r\n        return this.m_indexA;\r\n    };\r\n    b2Contact.prototype.GetShapeA = function () {\r\n        return this.m_fixtureA.GetShape();\r\n    };\r\n    b2Contact.prototype.GetFixtureB = function () {\r\n        return this.m_fixtureB;\r\n    };\r\n    b2Contact.prototype.GetChildIndexB = function () {\r\n        return this.m_indexB;\r\n    };\r\n    b2Contact.prototype.GetShapeB = function () {\r\n        return this.m_fixtureB.GetShape();\r\n    };\r\n    b2Contact.prototype.FlagForFiltering = function () {\r\n        this.m_filterFlag = true;\r\n    };\r\n    b2Contact.prototype.SetFriction = function (friction) {\r\n        this.m_friction = friction;\r\n    };\r\n    b2Contact.prototype.GetFriction = function () {\r\n        return this.m_friction;\r\n    };\r\n    b2Contact.prototype.ResetFriction = function () {\r\n        this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n    };\r\n    b2Contact.prototype.SetRestitution = function (restitution) {\r\n        this.m_restitution = restitution;\r\n    };\r\n    b2Contact.prototype.GetRestitution = function () {\r\n        return this.m_restitution;\r\n    };\r\n    b2Contact.prototype.ResetRestitution = function () {\r\n        this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n    };\r\n    b2Contact.prototype.SetTangentSpeed = function (speed) {\r\n        this.m_tangentSpeed = speed;\r\n    };\r\n    b2Contact.prototype.GetTangentSpeed = function () {\r\n        return this.m_tangentSpeed;\r\n    };\r\n    b2Contact.prototype.Reset = function (fixtureA, indexA, fixtureB, indexB) {\r\n        this.m_islandFlag = false;\r\n        this.m_touchingFlag = false;\r\n        this.m_enabledFlag = true;\r\n        this.m_filterFlag = false;\r\n        this.m_bulletHitFlag = false;\r\n        this.m_toiFlag = false;\r\n        this.m_fixtureA = fixtureA;\r\n        this.m_fixtureB = fixtureB;\r\n        this.m_indexA = indexA;\r\n        this.m_indexB = indexB;\r\n        this.m_manifold.pointCount = 0;\r\n        this.m_prev = null;\r\n        this.m_next = null;\r\n        this.m_nodeA.Reset();\r\n        this.m_nodeB.Reset();\r\n        this.m_toiCount = 0;\r\n        this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n        this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n    };\r\n    b2Contact.prototype.Update = function (listener) {\r\n        var tManifold = this.m_oldManifold;\r\n        this.m_oldManifold = this.m_manifold;\r\n        this.m_manifold = tManifold;\r\n        // Re-enable this contact.\r\n        this.m_enabledFlag = true;\r\n        var touching = false;\r\n        var wasTouching = this.m_touchingFlag;\r\n        var sensorA = this.m_fixtureA.IsSensor();\r\n        var sensorB = this.m_fixtureB.IsSensor();\r\n        var sensor = sensorA || sensorB;\r\n        var bodyA = this.m_fixtureA.GetBody();\r\n        var bodyB = this.m_fixtureB.GetBody();\r\n        var xfA = bodyA.GetTransform();\r\n        var xfB = bodyB.GetTransform();\r\n        // Is this contact a sensor?\r\n        if (sensor) {\r\n            var shapeA = this.GetShapeA();\r\n            var shapeB = this.GetShapeB();\r\n            touching = b2Collision_2.b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\r\n            // Sensors don't generate manifolds.\r\n            this.m_manifold.pointCount = 0;\r\n        }\r\n        else {\r\n            this.Evaluate(this.m_manifold, xfA, xfB);\r\n            touching = this.m_manifold.pointCount > 0;\r\n            // Match old contact ids to new contact ids and copy the\r\n            // stored impulses to warm start the solver.\r\n            for (var i = 0; i < this.m_manifold.pointCount; ++i) {\r\n                var mp2 = this.m_manifold.points[i];\r\n                mp2.normalImpulse = 0;\r\n                mp2.tangentImpulse = 0;\r\n                var id2 = mp2.id;\r\n                for (var j = 0; j < this.m_oldManifold.pointCount; ++j) {\r\n                    var mp1 = this.m_oldManifold.points[j];\r\n                    if (mp1.id.key === id2.key) {\r\n                        mp2.normalImpulse = mp1.normalImpulse;\r\n                        mp2.tangentImpulse = mp1.tangentImpulse;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if (touching !== wasTouching) {\r\n                bodyA.SetAwake(true);\r\n                bodyB.SetAwake(true);\r\n            }\r\n        }\r\n        this.m_touchingFlag = touching;\r\n        if (!wasTouching && touching && listener) {\r\n            listener.BeginContact(this);\r\n        }\r\n        if (wasTouching && !touching && listener) {\r\n            listener.EndContact(this);\r\n        }\r\n        if (!sensor && touching && listener) {\r\n            listener.PreSolve(this, this.m_oldManifold);\r\n        }\r\n    };\r\n    b2Contact.prototype.ComputeTOI = function (sweepA, sweepB) {\r\n        var input = b2Contact.ComputeTOI_s_input;\r\n        input.proxyA.SetShape(this.GetShapeA(), this.m_indexA);\r\n        input.proxyB.SetShape(this.GetShapeB(), this.m_indexB);\r\n        input.sweepA.Copy(sweepA);\r\n        input.sweepB.Copy(sweepB);\r\n        input.tMax = b2Settings_1.b2_linearSlop;\r\n        var output = b2Contact.ComputeTOI_s_output;\r\n        b2TimeOfImpact_1.b2TimeOfImpact(output, input);\r\n        return output.t;\r\n    };\r\n    b2Contact.ComputeTOI_s_input = new b2TimeOfImpact_1.b2TOIInput();\r\n    b2Contact.ComputeTOI_s_output = new b2TimeOfImpact_1.b2TOIOutput();\r\n    return b2Contact;\r\n}());\r\nexports.b2Contact = b2Contact;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Contact.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Contacts/b2Contact.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2_linearSlop } from \"../../Common/b2Settings\";\r\nimport { b2Sqrt, b2Transform, b2Sweep } from \"../../Common/b2Math\";\r\nimport { b2Manifold, b2WorldManifold, b2ManifoldPoint, b2ContactID } from \"../../Collision/b2Collision\";\r\nimport { b2TestOverlapShape } from \"../../Collision/b2Collision\";\r\nimport { b2TimeOfImpact, b2TOIInput, b2TOIOutput } from \"../../Collision/b2TimeOfImpact\";\r\nimport { b2Body } from \"../b2Body\";\r\nimport { b2Fixture } from \"../b2Fixture\";\r\nimport { b2Shape } from \"../../Collision/Shapes/b2Shape\";\r\nimport { b2ContactListener } from \"../b2WorldCallbacks\";\r\n\r\n/// Friction mixing law. The idea is to allow either fixture to drive the friction to zero.\r\n/// For example, anything slides on ice.\r\nexport function b2MixFriction(friction1: number, friction2: number): number {\r\n  return b2Sqrt(friction1 * friction2);\r\n}\r\n\r\n/// Restitution mixing law. The idea is allow for anything to bounce off an inelastic surface.\r\n/// For example, a superball bounces on anything.\r\nexport function b2MixRestitution(restitution1: number, restitution2: number): number {\r\n  return restitution1 > restitution2 ? restitution1 : restitution2;\r\n}\r\n\r\nexport class b2ContactEdge {\r\n  private _other: b2Body | null = null; ///< provides quick access to the other body attached.\r\n  public get other(): b2Body {\r\n    if (this._other === null) { throw new Error(); }\r\n    return this._other;\r\n  }\r\n  public set other(value: b2Body) {\r\n    if (this._other !== null) { throw new Error(); }\r\n    this._other = value;\r\n  }\r\n  public readonly contact: b2Contact; ///< the contact\r\n  public prev: b2ContactEdge | null = null; ///< the previous contact edge in the body's contact list\r\n  public next: b2ContactEdge | null = null; ///< the next contact edge in the body's contact list\r\n  constructor(contact: b2Contact) {\r\n    this.contact = contact;\r\n  }\r\n  public Reset(): void {\r\n    this._other = null;\r\n    this.prev = null;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nexport abstract class b2Contact<A extends b2Shape = b2Shape, B extends b2Shape = b2Shape> {\r\n  public m_islandFlag: boolean = false; /// Used when crawling contact graph when forming islands.\r\n  public m_touchingFlag: boolean = false; /// Set when the shapes are touching.\r\n  public m_enabledFlag: boolean = false; /// This contact can be disabled (by user)\r\n  public m_filterFlag: boolean = false; /// This contact needs filtering because a fixture filter was changed.\r\n  public m_bulletHitFlag: boolean = false; /// This bullet contact had a TOI event\r\n  public m_toiFlag: boolean = false; /// This contact has a valid TOI in m_toi\r\n\r\n  public m_prev: b2Contact | null = null;\r\n  public m_next: b2Contact | null = null;\r\n\r\n  public readonly m_nodeA: b2ContactEdge = new b2ContactEdge(this);\r\n  public readonly m_nodeB: b2ContactEdge = new b2ContactEdge(this);\r\n\r\n  public m_fixtureA!: b2Fixture;\r\n  public m_fixtureB!: b2Fixture;\r\n\r\n  public m_indexA: number = 0;\r\n  public m_indexB: number = 0;\r\n\r\n  public m_manifold: b2Manifold = new b2Manifold(); // TODO: readonly\r\n\r\n  public m_toiCount: number = 0;\r\n  public m_toi: number = 0;\r\n\r\n  public m_friction: number = 0;\r\n  public m_restitution: number = 0;\r\n\r\n  public m_tangentSpeed: number = 0;\r\n\r\n  public m_oldManifold: b2Manifold = new b2Manifold(); // TODO: readonly\r\n\r\n  public GetManifold() {\r\n    return this.m_manifold;\r\n  }\r\n\r\n  public GetWorldManifold(worldManifold: b2WorldManifold): void {\r\n    const bodyA: b2Body = this.m_fixtureA.GetBody();\r\n    const bodyB: b2Body = this.m_fixtureB.GetBody();\r\n    const shapeA: A = this.GetShapeA();\r\n    const shapeB: B = this.GetShapeB();\r\n    worldManifold.Initialize(this.m_manifold, bodyA.GetTransform(), shapeA.m_radius, bodyB.GetTransform(), shapeB.m_radius);\r\n  }\r\n\r\n  public IsTouching(): boolean {\r\n    return this.m_touchingFlag;\r\n  }\r\n\r\n  public SetEnabled(flag: boolean): void {\r\n    this.m_enabledFlag = flag;\r\n  }\r\n\r\n  public IsEnabled(): boolean {\r\n    return this.m_enabledFlag;\r\n  }\r\n\r\n  public GetNext(): b2Contact | null {\r\n    return this.m_next;\r\n  }\r\n\r\n  public GetFixtureA(): b2Fixture {\r\n    return this.m_fixtureA;\r\n  }\r\n\r\n  public GetChildIndexA(): number {\r\n    return this.m_indexA;\r\n  }\r\n\r\n  public GetShapeA(): A {\r\n    return this.m_fixtureA.GetShape() as A;\r\n  }\r\n\r\n  public GetFixtureB(): b2Fixture {\r\n    return this.m_fixtureB;\r\n  }\r\n\r\n  public GetChildIndexB(): number {\r\n    return this.m_indexB;\r\n  }\r\n\r\n  public GetShapeB(): B {\r\n    return this.m_fixtureB.GetShape() as B;\r\n  }\r\n\r\n  public abstract Evaluate(manifold: b2Manifold, xfA: b2Transform, xfB: b2Transform): void;\r\n\r\n  public FlagForFiltering(): void {\r\n    this.m_filterFlag = true;\r\n  }\r\n\r\n  public SetFriction(friction: number): void {\r\n    this.m_friction = friction;\r\n  }\r\n\r\n  public GetFriction(): number {\r\n    return this.m_friction;\r\n  }\r\n\r\n  public ResetFriction(): void {\r\n    this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n  }\r\n\r\n  public SetRestitution(restitution: number): void {\r\n    this.m_restitution = restitution;\r\n  }\r\n\r\n  public GetRestitution(): number {\r\n    return this.m_restitution;\r\n  }\r\n\r\n  public ResetRestitution(): void {\r\n    this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n  }\r\n\r\n  public SetTangentSpeed(speed: number): void {\r\n    this.m_tangentSpeed = speed;\r\n  }\r\n\r\n  public GetTangentSpeed(): number {\r\n    return this.m_tangentSpeed;\r\n  }\r\n\r\n  public Reset(fixtureA: b2Fixture, indexA: number, fixtureB: b2Fixture, indexB: number): void {\r\n    this.m_islandFlag = false;\r\n    this.m_touchingFlag = false;\r\n    this.m_enabledFlag = true;\r\n    this.m_filterFlag = false;\r\n    this.m_bulletHitFlag = false;\r\n    this.m_toiFlag = false;\r\n\r\n    this.m_fixtureA = fixtureA;\r\n    this.m_fixtureB = fixtureB;\r\n\r\n    this.m_indexA = indexA;\r\n    this.m_indexB = indexB;\r\n\r\n    this.m_manifold.pointCount = 0;\r\n\r\n    this.m_prev = null;\r\n    this.m_next = null;\r\n\r\n    this.m_nodeA.Reset();\r\n    this.m_nodeB.Reset();\r\n\r\n    this.m_toiCount = 0;\r\n\r\n    this.m_friction = b2MixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\r\n    this.m_restitution = b2MixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\r\n  }\r\n\r\n  public Update(listener: b2ContactListener): void {\r\n    const tManifold: b2Manifold = this.m_oldManifold;\r\n    this.m_oldManifold = this.m_manifold;\r\n    this.m_manifold = tManifold;\r\n\r\n    // Re-enable this contact.\r\n    this.m_enabledFlag = true;\r\n\r\n    let touching: boolean = false;\r\n    const wasTouching: boolean = this.m_touchingFlag;\r\n\r\n    const sensorA: boolean = this.m_fixtureA.IsSensor();\r\n    const sensorB: boolean = this.m_fixtureB.IsSensor();\r\n    const sensor: boolean = sensorA || sensorB;\r\n\r\n    const bodyA: b2Body = this.m_fixtureA.GetBody();\r\n    const bodyB: b2Body = this.m_fixtureB.GetBody();\r\n    const xfA: b2Transform = bodyA.GetTransform();\r\n    const xfB: b2Transform = bodyB.GetTransform();\r\n\r\n    // Is this contact a sensor?\r\n    if (sensor) {\r\n      const shapeA: A = this.GetShapeA();\r\n      const shapeB: B = this.GetShapeB();\r\n      touching = b2TestOverlapShape(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\r\n\r\n      // Sensors don't generate manifolds.\r\n      this.m_manifold.pointCount = 0;\r\n    } else {\r\n      this.Evaluate(this.m_manifold, xfA, xfB);\r\n      touching = this.m_manifold.pointCount > 0;\r\n\r\n      // Match old contact ids to new contact ids and copy the\r\n      // stored impulses to warm start the solver.\r\n      for (let i: number = 0; i < this.m_manifold.pointCount; ++i) {\r\n        const mp2: b2ManifoldPoint = this.m_manifold.points[i];\r\n        mp2.normalImpulse = 0;\r\n        mp2.tangentImpulse = 0;\r\n        const id2: b2ContactID = mp2.id;\r\n\r\n        for (let j: number = 0; j < this.m_oldManifold.pointCount; ++j) {\r\n          const mp1: b2ManifoldPoint = this.m_oldManifold.points[j];\r\n\r\n          if (mp1.id.key === id2.key) {\r\n            mp2.normalImpulse = mp1.normalImpulse;\r\n            mp2.tangentImpulse = mp1.tangentImpulse;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (touching !== wasTouching) {\r\n        bodyA.SetAwake(true);\r\n        bodyB.SetAwake(true);\r\n      }\r\n    }\r\n\r\n    this.m_touchingFlag = touching;\r\n\r\n    if (!wasTouching && touching && listener) {\r\n      listener.BeginContact(this);\r\n    }\r\n\r\n    if (wasTouching && !touching && listener) {\r\n      listener.EndContact(this);\r\n    }\r\n\r\n    if (!sensor && touching && listener) {\r\n      listener.PreSolve(this, this.m_oldManifold);\r\n    }\r\n  }\r\n\r\n  private static ComputeTOI_s_input = new b2TOIInput();\r\n  private static ComputeTOI_s_output = new b2TOIOutput();\r\n  public ComputeTOI(sweepA: b2Sweep, sweepB: b2Sweep): number {\r\n    const input: b2TOIInput = b2Contact.ComputeTOI_s_input;\r\n    input.proxyA.SetShape(this.GetShapeA(), this.m_indexA);\r\n    input.proxyB.SetShape(this.GetShapeB(), this.m_indexB);\r\n    input.sweepA.Copy(sweepA);\r\n    input.sweepB.Copy(sweepB);\r\n    input.tMax = b2_linearSlop;\r\n\r\n    const output: b2TOIOutput = b2Contact.ComputeTOI_s_output;\r\n\r\n    b2TimeOfImpact(output, input);\r\n\r\n    return output.t;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"37e786fd364dd753599b58d3b3748028","cacheData":{"env":{}}}