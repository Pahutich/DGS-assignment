{"id":"../node_modules/box2d.package.ts/Dynamics/b2World.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":48,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2Timer","loc":{"line":23,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Timer.ts"},{"name":"../Common/b2Draw","loc":{"line":24,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Draw.ts"},{"name":"../Collision/b2Collision","loc":{"line":25,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"../Collision/b2TimeOfImpact","loc":{"line":26,"column":31},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts"},{"name":"../Collision/Shapes/b2Shape","loc":{"line":27,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"},{"name":"./Joints/b2Joint","loc":{"line":28,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2Joint.ts"},{"name":"./Joints/b2AreaJoint","loc":{"line":29,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2AreaJoint.ts"},{"name":"./Joints/b2DistanceJoint","loc":{"line":30,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2DistanceJoint.ts"},{"name":"./Joints/b2FrictionJoint","loc":{"line":31,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2FrictionJoint.ts"},{"name":"./Joints/b2GearJoint","loc":{"line":32,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2GearJoint.ts"},{"name":"./Joints/b2MotorJoint","loc":{"line":33,"column":29},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2MotorJoint.ts"},{"name":"./Joints/b2MouseJoint","loc":{"line":34,"column":29},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2MouseJoint.ts"},{"name":"./Joints/b2PrismaticJoint","loc":{"line":35,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2PrismaticJoint.ts"},{"name":"./Joints/b2PulleyJoint","loc":{"line":36,"column":30},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2PulleyJoint.ts"},{"name":"./Joints/b2RevoluteJoint","loc":{"line":37,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2RevoluteJoint.ts"},{"name":"./Joints/b2RopeJoint","loc":{"line":38,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2RopeJoint.ts"},{"name":"./Joints/b2WeldJoint","loc":{"line":39,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2WeldJoint.ts"},{"name":"./Joints/b2WheelJoint","loc":{"line":40,"column":29},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2WheelJoint.ts"},{"name":"./b2Body","loc":{"line":41,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts"},{"name":"./b2ContactManager","loc":{"line":42,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts"},{"name":"./b2Island","loc":{"line":43,"column":25},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts"},{"name":"./b2TimeStep","loc":{"line":44,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2TimeStep.ts"},{"name":"./b2WorldCallbacks","loc":{"line":46,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts"},{"name":"../Particle/b2Particle","loc":{"line":49,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2Particle.ts"},{"name":"../Particle/b2ParticleSystem","loc":{"line":50,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2World.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Timer_1 = require(\"../Common/b2Timer\");\r\nvar b2Draw_1 = require(\"../Common/b2Draw\");\r\nvar b2Collision_1 = require(\"../Collision/b2Collision\");\r\nvar b2TimeOfImpact_1 = require(\"../Collision/b2TimeOfImpact\");\r\nvar b2Shape_1 = require(\"../Collision/Shapes/b2Shape\");\r\nvar b2Joint_1 = require(\"./Joints/b2Joint\");\r\nvar b2AreaJoint_1 = require(\"./Joints/b2AreaJoint\");\r\nvar b2DistanceJoint_1 = require(\"./Joints/b2DistanceJoint\");\r\nvar b2FrictionJoint_1 = require(\"./Joints/b2FrictionJoint\");\r\nvar b2GearJoint_1 = require(\"./Joints/b2GearJoint\");\r\nvar b2MotorJoint_1 = require(\"./Joints/b2MotorJoint\");\r\nvar b2MouseJoint_1 = require(\"./Joints/b2MouseJoint\");\r\nvar b2PrismaticJoint_1 = require(\"./Joints/b2PrismaticJoint\");\r\nvar b2PulleyJoint_1 = require(\"./Joints/b2PulleyJoint\");\r\nvar b2RevoluteJoint_1 = require(\"./Joints/b2RevoluteJoint\");\r\nvar b2RopeJoint_1 = require(\"./Joints/b2RopeJoint\");\r\nvar b2WeldJoint_1 = require(\"./Joints/b2WeldJoint\");\r\nvar b2WheelJoint_1 = require(\"./Joints/b2WheelJoint\");\r\nvar b2Body_1 = require(\"./b2Body\");\r\nvar b2ContactManager_1 = require(\"./b2ContactManager\");\r\nvar b2Island_1 = require(\"./b2Island\");\r\nvar b2TimeStep_1 = require(\"./b2TimeStep\");\r\nvar b2WorldCallbacks_1 = require(\"./b2WorldCallbacks\");\r\nvar b2WorldCallbacks_2 = require(\"./b2WorldCallbacks\");\r\n// #if B2_ENABLE_PARTICLE\r\nvar b2Settings_2 = require(\"../Common/b2Settings\");\r\nvar b2Particle_1 = require(\"../Particle/b2Particle\");\r\nvar b2ParticleSystem_1 = require(\"../Particle/b2ParticleSystem\");\r\n// #endif\r\n/// The world class manages all physics entities, dynamic simulation,\r\n/// and asynchronous queries. The world also contains efficient memory\r\n/// management facilities.\r\nvar b2World = /** @class */ (function () {\r\n    // #endif\r\n    /// Construct a world object.\r\n    /// @param gravity the world gravity vector.\r\n    function b2World(gravity, scale) {\r\n        this.m_newFixture = false;\r\n        this.m_locked = false;\r\n        this.m_clearForces = true;\r\n        this.m_contactManager = new b2ContactManager_1.b2ContactManager();\r\n        this.m_bodyList = null;\r\n        this.m_jointList = null;\r\n        // #if B2_ENABLE_PARTICLE\r\n        this.m_particleSystemList = null;\r\n        // #endif\r\n        this.m_bodyCount = 0;\r\n        this.m_jointCount = 0;\r\n        this.m_gravity = new b2Math_1.b2Vec2();\r\n        this.m_allowSleep = true;\r\n        this.m_destructionListener = null;\r\n        this.m_debugDraw = null;\r\n        // This is used to compute the time step ratio to\r\n        // support a variable time step.\r\n        this.m_inv_dt0 = 0;\r\n        // These are for debugging the solver.\r\n        this.m_warmStarting = true;\r\n        this.m_continuousPhysics = true;\r\n        this.m_subStepping = false;\r\n        this.m_stepComplete = true;\r\n        this.m_profile = new b2TimeStep_1.b2Profile();\r\n        this.m_island = new b2Island_1.b2Island();\r\n        this.s_stack = [];\r\n        // #if B2_ENABLE_CONTROLLER\r\n        this.m_controllerList = null;\r\n        this.m_controllerCount = 0;\r\n        this.pixiToBox2D = [];\r\n        this.box2DToPixi = [];\r\n        this.pixiToBox2DScale = [];\r\n        this.box2DToPixiScale = [];\r\n        this.m_gravity.Copy(gravity);\r\n        // this.pixiToBox2D[0] = [1, 0, 0];\r\n        // this.pixiToBox2D[1] = [0, 1, 0];\r\n        // this.pixiToBox2D[2] = [-translation.x * 0.5, -translation.y * 0.5, 1];\r\n        // this.box2DToPixi[0] = [1, 0, 0];\r\n        // this.box2DToPixi[1] = [0, -1, 0];\r\n        // this.box2DToPixi[2] = [translation.x * 0.5, translation.y * 0.5, 1];\r\n    }\r\n    /// Register a destruction listener. The listener is owned by you and must\r\n    /// remain in scope.\r\n    b2World.prototype.SetDestructionListener = function (listener) {\r\n        this.m_destructionListener = listener;\r\n    };\r\n    // public PixelToWorldVector(position: Pixi.IPoint) {\r\n    //   let converterVec = new b2Vec2(position.x, position.y);\r\n    //   let matrix = this.pixiToBox2D;\r\n    //   let convertedVec = this.MultiMatrixToVector(converterVec, matrix);\r\n    //   return convertedVec;\r\n    // }\r\n    // public WorldToPixelVector(position: b2Vec2) {\r\n    //   let converterVec = new b2Vec2(position.x, position.y);\r\n    //   let matrix = this.box2DToPixi;\r\n    //   converterVec = this.MultiMatrixToVector(converterVec, matrix);\r\n    //   let convertedVec = new Pixi.Point(converterVec.x, converterVec.y);\r\n    //   return convertedVec;\r\n    // }\r\n    // private MultiMatrixToVector(vector: b2Vec2, martix: number[][]) {\r\n    //   let tempMartix: number[][] = [];\r\n    //   tempMartix[0] = [vector.x, vector.y, 1];\r\n    //   tempMartix = this.MultiMatrix(martix, tempMartix);\r\n    //   return new b2Vec2(tempMartix[0][0], tempMartix[0][1]);\r\n    // }\r\n    // public MultiMatrix(martix: number[][], otherMartix: number[][]) {\r\n    //   let tempMartix: number[][] = [];\r\n    //   let colloms = otherMartix[0].length;\r\n    //   let rows = otherMartix.length;\r\n    //   for (let rowIndex = 0; rowIndex < rows; rowIndex++) {\r\n    //     let row: number[] = [];\r\n    //     for (let collomIndex = 0; collomIndex < colloms; collomIndex++) {\r\n    //       let collom: number = 0;\r\n    //       for (let multiIndex = 0; multiIndex < colloms; multiIndex++) {\r\n    //         let a = martix[multiIndex][collomIndex];\r\n    //         let b = otherMartix[rowIndex][multiIndex];\r\n    //         collom += a * b;\r\n    //       }\r\n    //       row.push(collom);\r\n    //     }\r\n    //     tempMartix.push(row);\r\n    //   }\r\n    //   return tempMartix;\r\n    // }\r\n    // private InverseMatrix(matrix: number[][]) {\r\n    //   //if the matrix isn't square: exit (error)\r\n    //   if (matrix.length !== matrix[0].length) {\r\n    //     return;\r\n    //   }\r\n    //   //create the identity matrix (I), and a copy (C) of the original\r\n    //   var i = 0,\r\n    //     ii = 0,\r\n    //     j = 0,\r\n    //     dim = matrix.length,\r\n    //     e = 0,\r\n    //     t = 0;\r\n    //   var identifier = [],\r\n    //     copy = [];\r\n    //   for (i = 0; i < dim; i += 1) {\r\n    //     // Create the row\r\n    //     identifier[identifier.length] = [];\r\n    //     copy[copy.length] = [];\r\n    //     for (j = 0; j < dim; j += 1) {\r\n    //       //if we're on the diagonal, put a 1 (for identity)\r\n    //       if (i == j) {\r\n    //         identifier[i][j] = 1;\r\n    //       } else {\r\n    //         identifier[i][j] = 0;\r\n    //       }\r\n    //       // Also, make the copy of the original\r\n    //       copy[i][j] = matrix[i][j];\r\n    //     }\r\n    //   }\r\n    //   // Perform elementary row operations\r\n    //   for (i = 0; i < dim; i += 1) {\r\n    //     // get the element e on the diagonal\r\n    //     e = copy[i][i];\r\n    //     // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n    //     if (e == 0) {\r\n    //       //look through every row below the i'th row\r\n    //       for (ii = i + 1; ii < dim; ii += 1) {\r\n    //         //if the ii'th row has a non-0 in the i'th col\r\n    //         if (copy[ii][i] != 0) {\r\n    //           //it would make the diagonal have a non-0 so swap it\r\n    //           for (j = 0; j < dim; j++) {\r\n    //             e = copy[i][j]; //temp store i'th row\r\n    //             copy[i][j] = copy[ii][j]; //replace i'th row by ii'th\r\n    //             copy[ii][j] = e; //repace ii'th by temp\r\n    //             e = identifier[i][j]; //temp store i'th row\r\n    //             identifier[i][j] = identifier[ii][j]; //replace i'th row by ii'th\r\n    //             identifier[ii][j] = e; //repace ii'th by temp\r\n    //           }\r\n    //           //don't bother checking other rows since we've swapped\r\n    //           break;\r\n    //         }\r\n    //       }\r\n    //       //get the new diagonal\r\n    //       e = copy[i][i];\r\n    //       //if it's still 0, not invertable (error)\r\n    //       if (e == 0) {\r\n    //         return;\r\n    //       }\r\n    //     }\r\n    //     // Scale this row down by e (so we have a 1 on the diagonal)\r\n    //     for (j = 0; j < dim; j++) {\r\n    //       copy[i][j] = copy[i][j] / e; //apply to original matrix\r\n    //       identifier[i][j] = identifier[i][j] / e; //apply to identity\r\n    //     }\r\n    //     // Subtract this row (scaled appropriately for each row) from ALL of\r\n    //     // the other rows so that there will be 0's in this column in the\r\n    //     // rows above and below this one\r\n    //     for (ii = 0; ii < dim; ii++) {\r\n    //       // Only apply to other rows (we want a 1 on the diagonal)\r\n    //       if (ii == i) {\r\n    //         continue;\r\n    //       }\r\n    //       // We want to change this element to 0\r\n    //       e = copy[ii][i];\r\n    //       // Subtract (the row above(or below) scaled by e) from (the\r\n    //       // current row) but start at the i'th column and assume all the\r\n    //       // stuff left of diagonal is 0 (which it should be if we made this\r\n    //       // algorithm correctly)\r\n    //       for (j = 0; j < dim; j++) {\r\n    //         copy[ii][j] -= e * copy[i][j]; //apply to original matrix\r\n    //         identifier[ii][j] -= e * identifier[i][j]; //apply to identity\r\n    //       }\r\n    //     }\r\n    //   }\r\n    //   //we've done all operations, C should be the identity\r\n    //   //matrix I should be the inverse:\r\n    //   return identifier;\r\n    // }\r\n    b2World.prototype.createCopy = function (matrix) {\r\n        var dim = matrix.length, copy = [];\r\n        for (var i = 0; i < dim; i += 1) {\r\n            copy[copy.length] = [];\r\n            for (var j = 0; j < dim; j += 1) {\r\n                copy[i][j] = matrix[i][j];\r\n            }\r\n        }\r\n        return copy;\r\n    };\r\n    b2World.prototype.LogMatrix = function (matrix) {\r\n        for (var i = 0; i < matrix.length; i++) {\r\n            var element = matrix[i];\r\n            var log = \"[\";\r\n            for (var j = 0; j < element.length; j++) {\r\n                log += element[j];\r\n                if (j < element.length - 1)\r\n                    log += \",\";\r\n            }\r\n            log += \"]\";\r\n            console.log(log);\r\n        }\r\n    };\r\n    /// Register a contact filter to provide specific control over collision.\r\n    /// Otherwise the default filter is used (b2_defaultFilter). The listener is\r\n    /// owned by you and must remain in scope.\r\n    b2World.prototype.SetContactFilter = function (filter) {\r\n        this.m_contactManager.m_contactFilter = filter;\r\n    };\r\n    /// Register a contact event listener. The listener is owned by you and must\r\n    /// remain in scope.\r\n    b2World.prototype.SetContactListener = function (listener) {\r\n        this.m_contactManager.m_contactListener = listener;\r\n    };\r\n    /// Register a routine for debug drawing. The debug draw functions are called\r\n    /// inside with b2World::DrawDebugData method. The debug draw object is owned\r\n    /// by you and must remain in scope.\r\n    b2World.prototype.SetDebugDraw = function (debugDraw) {\r\n        this.m_debugDraw = debugDraw;\r\n    };\r\n    /// Create a rigid body given a definition. No reference to the definition\r\n    /// is retained.\r\n    /// @warning This function is locked during callbacks.\r\n    b2World.prototype.CreateBody = function (def) {\r\n        if (def === void 0) { def = {}; }\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var b = new b2Body_1.b2Body(def, this);\r\n        // Add to world doubly linked list.\r\n        b.m_prev = null;\r\n        b.m_next = this.m_bodyList;\r\n        if (this.m_bodyList) {\r\n            this.m_bodyList.m_prev = b;\r\n        }\r\n        this.m_bodyList = b;\r\n        ++this.m_bodyCount;\r\n        return b;\r\n    };\r\n    /// Destroy a rigid body given a definition. No reference to the definition\r\n    /// is retained. This function is locked during callbacks.\r\n    /// @warning This automatically deletes all associated shapes and joints.\r\n    /// @warning This function is locked during callbacks.\r\n    b2World.prototype.DestroyBody = function (b) {\r\n        // DEBUG: b2Assert(this.m_bodyCount > 0);\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        // Delete the attached joints.\r\n        var je = b.m_jointList;\r\n        while (je) {\r\n            var je0 = je;\r\n            je = je.next;\r\n            if (this.m_destructionListener) {\r\n                this.m_destructionListener.SayGoodbyeJoint(je0.joint);\r\n            }\r\n            this.DestroyJoint(je0.joint);\r\n            b.m_jointList = je;\r\n        }\r\n        b.m_jointList = null;\r\n        // #if B2_ENABLE_CONTROLLER\r\n        // @see b2Controller list\r\n        var coe = b.m_controllerList;\r\n        while (coe) {\r\n            var coe0 = coe;\r\n            coe = coe.nextController;\r\n            coe0.controller.RemoveBody(b);\r\n        }\r\n        // #endif\r\n        // Delete the attached contacts.\r\n        var ce = b.m_contactList;\r\n        while (ce) {\r\n            var ce0 = ce;\r\n            ce = ce.next;\r\n            this.m_contactManager.Destroy(ce0.contact);\r\n        }\r\n        b.m_contactList = null;\r\n        // Delete the attached fixtures. This destroys broad-phase proxies.\r\n        var f = b.m_fixtureList;\r\n        while (f) {\r\n            var f0 = f;\r\n            f = f.m_next;\r\n            if (this.m_destructionListener) {\r\n                this.m_destructionListener.SayGoodbyeFixture(f0);\r\n            }\r\n            f0.DestroyProxies();\r\n            f0.Reset();\r\n            b.m_fixtureList = f;\r\n            b.m_fixtureCount -= 1;\r\n        }\r\n        b.m_fixtureList = null;\r\n        b.m_fixtureCount = 0;\r\n        // Remove world body list.\r\n        if (b.m_prev) {\r\n            b.m_prev.m_next = b.m_next;\r\n        }\r\n        if (b.m_next) {\r\n            b.m_next.m_prev = b.m_prev;\r\n        }\r\n        if (b === this.m_bodyList) {\r\n            this.m_bodyList = b.m_next;\r\n        }\r\n        --this.m_bodyCount;\r\n    };\r\n    b2World._Joint_Create = function (def) {\r\n        switch (def.type) {\r\n            case b2Joint_1.b2JointType.e_distanceJoint:\r\n                return new b2DistanceJoint_1.b2DistanceJoint(def);\r\n            case b2Joint_1.b2JointType.e_mouseJoint:\r\n                return new b2MouseJoint_1.b2MouseJoint(def);\r\n            case b2Joint_1.b2JointType.e_prismaticJoint:\r\n                return new b2PrismaticJoint_1.b2PrismaticJoint(def);\r\n            case b2Joint_1.b2JointType.e_revoluteJoint:\r\n                return new b2RevoluteJoint_1.b2RevoluteJoint(def);\r\n            case b2Joint_1.b2JointType.e_pulleyJoint:\r\n                return new b2PulleyJoint_1.b2PulleyJoint(def);\r\n            case b2Joint_1.b2JointType.e_gearJoint:\r\n                return new b2GearJoint_1.b2GearJoint(def);\r\n            case b2Joint_1.b2JointType.e_wheelJoint:\r\n                return new b2WheelJoint_1.b2WheelJoint(def);\r\n            case b2Joint_1.b2JointType.e_weldJoint:\r\n                return new b2WeldJoint_1.b2WeldJoint(def);\r\n            case b2Joint_1.b2JointType.e_frictionJoint:\r\n                return new b2FrictionJoint_1.b2FrictionJoint(def);\r\n            case b2Joint_1.b2JointType.e_ropeJoint:\r\n                return new b2RopeJoint_1.b2RopeJoint(def);\r\n            case b2Joint_1.b2JointType.e_motorJoint:\r\n                return new b2MotorJoint_1.b2MotorJoint(def);\r\n            case b2Joint_1.b2JointType.e_areaJoint:\r\n                return new b2AreaJoint_1.b2AreaJoint(def);\r\n        }\r\n        throw new Error();\r\n    };\r\n    b2World._Joint_Destroy = function (joint) { };\r\n    b2World.prototype.CreateJoint = function (def) {\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var j = b2World._Joint_Create(def);\r\n        // Connect to the world list.\r\n        j.m_prev = null;\r\n        j.m_next = this.m_jointList;\r\n        if (this.m_jointList) {\r\n            this.m_jointList.m_prev = j;\r\n        }\r\n        this.m_jointList = j;\r\n        ++this.m_jointCount;\r\n        // Connect to the bodies' doubly linked lists.\r\n        // j.m_edgeA.other = j.m_bodyB; // done in b2Joint constructor\r\n        j.m_edgeA.prev = null;\r\n        j.m_edgeA.next = j.m_bodyA.m_jointList;\r\n        if (j.m_bodyA.m_jointList) {\r\n            j.m_bodyA.m_jointList.prev = j.m_edgeA;\r\n        }\r\n        j.m_bodyA.m_jointList = j.m_edgeA;\r\n        // j.m_edgeB.other = j.m_bodyA; // done in b2Joint constructor\r\n        j.m_edgeB.prev = null;\r\n        j.m_edgeB.next = j.m_bodyB.m_jointList;\r\n        if (j.m_bodyB.m_jointList) {\r\n            j.m_bodyB.m_jointList.prev = j.m_edgeB;\r\n        }\r\n        j.m_bodyB.m_jointList = j.m_edgeB;\r\n        var bodyA = j.m_bodyA;\r\n        var bodyB = j.m_bodyB;\r\n        var collideConnected = j.m_collideConnected;\r\n        // If the joint prevents collisions, then flag any contacts for filtering.\r\n        if (!collideConnected) {\r\n            var edge = bodyB.GetContactList();\r\n            while (edge) {\r\n                if (edge.other === bodyA) {\r\n                    // Flag the contact for filtering at the next time step (where either\r\n                    // body is awake).\r\n                    edge.contact.FlagForFiltering();\r\n                }\r\n                edge = edge.next;\r\n            }\r\n        }\r\n        // Note: creating a joint doesn't wake the bodies.\r\n        return j;\r\n    };\r\n    /// Destroy a joint. This may cause the connected bodies to begin colliding.\r\n    /// @warning This function is locked during callbacks.\r\n    b2World.prototype.DestroyJoint = function (j) {\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        // Remove from the doubly linked list.\r\n        if (j.m_prev) {\r\n            j.m_prev.m_next = j.m_next;\r\n        }\r\n        if (j.m_next) {\r\n            j.m_next.m_prev = j.m_prev;\r\n        }\r\n        if (j === this.m_jointList) {\r\n            this.m_jointList = j.m_next;\r\n        }\r\n        // Disconnect from island graph.\r\n        var bodyA = j.m_bodyA;\r\n        var bodyB = j.m_bodyB;\r\n        var collideConnected = j.m_collideConnected;\r\n        // Wake up connected bodies.\r\n        bodyA.SetAwake(true);\r\n        bodyB.SetAwake(true);\r\n        // Remove from body 1.\r\n        if (j.m_edgeA.prev) {\r\n            j.m_edgeA.prev.next = j.m_edgeA.next;\r\n        }\r\n        if (j.m_edgeA.next) {\r\n            j.m_edgeA.next.prev = j.m_edgeA.prev;\r\n        }\r\n        if (j.m_edgeA === bodyA.m_jointList) {\r\n            bodyA.m_jointList = j.m_edgeA.next;\r\n        }\r\n        j.m_edgeA.Reset();\r\n        // Remove from body 2\r\n        if (j.m_edgeB.prev) {\r\n            j.m_edgeB.prev.next = j.m_edgeB.next;\r\n        }\r\n        if (j.m_edgeB.next) {\r\n            j.m_edgeB.next.prev = j.m_edgeB.prev;\r\n        }\r\n        if (j.m_edgeB === bodyB.m_jointList) {\r\n            bodyB.m_jointList = j.m_edgeB.next;\r\n        }\r\n        j.m_edgeB.Reset();\r\n        b2World._Joint_Destroy(j);\r\n        // DEBUG: b2Assert(this.m_jointCount > 0);\r\n        --this.m_jointCount;\r\n        // If the joint prevents collisions, then flag any contacts for filtering.\r\n        if (!collideConnected) {\r\n            var edge = bodyB.GetContactList();\r\n            while (edge) {\r\n                if (edge.other === bodyA) {\r\n                    // Flag the contact for filtering at the next time step (where either\r\n                    // body is awake).\r\n                    edge.contact.FlagForFiltering();\r\n                }\r\n                edge = edge.next;\r\n            }\r\n        }\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2World.prototype.CreateParticleSystem = function (def) {\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var p = new b2ParticleSystem_1.b2ParticleSystem(def, this);\r\n        // Add to world doubly linked list.\r\n        p.m_prev = null;\r\n        p.m_next = this.m_particleSystemList;\r\n        if (this.m_particleSystemList) {\r\n            this.m_particleSystemList.m_prev = p;\r\n        }\r\n        this.m_particleSystemList = p;\r\n        return p;\r\n    };\r\n    b2World.prototype.DestroyParticleSystem = function (p) {\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        // Remove world particleSystem list.\r\n        if (p.m_prev) {\r\n            p.m_prev.m_next = p.m_next;\r\n        }\r\n        if (p.m_next) {\r\n            p.m_next.m_prev = p.m_prev;\r\n        }\r\n        if (p === this.m_particleSystemList) {\r\n            this.m_particleSystemList = p.m_next;\r\n        }\r\n    };\r\n    b2World.prototype.CalculateReasonableParticleIterations = function (timeStep) {\r\n        if (this.m_particleSystemList === null) {\r\n            return 1;\r\n        }\r\n        function GetSmallestRadius(world) {\r\n            var smallestRadius = b2Settings_2.b2_maxFloat;\r\n            for (var system = world.GetParticleSystemList(); system !== null; system = system.m_next) {\r\n                smallestRadius = b2Math_1.b2Min(smallestRadius, system.GetRadius());\r\n            }\r\n            return smallestRadius;\r\n        }\r\n        // Use the smallest radius, since that represents the worst-case.\r\n        return b2Particle_1.b2CalculateParticleIterations(this.m_gravity.Length(), GetSmallestRadius(this), timeStep);\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2World.prototype.Step = function (dt, velocityIterations, positionIterations, particleIterations) {\r\n        if (particleIterations === void 0) { particleIterations = this.CalculateReasonableParticleIterations(dt); }\r\n        // #else\r\n        // public Step(dt: number, velocityIterations: number, positionIterations: number): void {\r\n        // #endif\r\n        var stepTimer = b2World.Step_s_stepTimer.Reset();\r\n        // If new fixtures were added, we need to find the new contacts.\r\n        if (this.m_newFixture) {\r\n            this.m_contactManager.FindNewContacts();\r\n            this.m_newFixture = false;\r\n        }\r\n        this.m_locked = true;\r\n        var step = b2World.Step_s_step;\r\n        step.dt = dt;\r\n        step.velocityIterations = velocityIterations;\r\n        step.positionIterations = positionIterations;\r\n        // #if B2_ENABLE_PARTICLE\r\n        step.particleIterations = particleIterations;\r\n        // #endif\r\n        if (dt > 0) {\r\n            step.inv_dt = 1 / dt;\r\n        }\r\n        else {\r\n            step.inv_dt = 0;\r\n        }\r\n        step.dtRatio = this.m_inv_dt0 * dt;\r\n        step.warmStarting = this.m_warmStarting;\r\n        // Update contacts. This is where some contacts are destroyed.\r\n        var timer = b2World.Step_s_timer.Reset();\r\n        this.m_contactManager.Collide();\r\n        this.m_profile.collide = timer.GetMilliseconds();\r\n        // Integrate velocities, solve velocity constraints, and integrate positions.\r\n        if (this.m_stepComplete && step.dt > 0) {\r\n            var timer_1 = b2World.Step_s_timer.Reset();\r\n            // #if B2_ENABLE_PARTICLE\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                p.Solve(step); // Particle Simulation\r\n            }\r\n            // #endif\r\n            this.Solve(step);\r\n            this.m_profile.solve = timer_1.GetMilliseconds();\r\n        }\r\n        // Handle TOI events.\r\n        if (this.m_continuousPhysics && step.dt > 0) {\r\n            var timer_2 = b2World.Step_s_timer.Reset();\r\n            this.SolveTOI(step);\r\n            this.m_profile.solveTOI = timer_2.GetMilliseconds();\r\n        }\r\n        if (step.dt > 0) {\r\n            this.m_inv_dt0 = step.inv_dt;\r\n        }\r\n        if (this.m_clearForces) {\r\n            this.ClearForces();\r\n        }\r\n        this.m_locked = false;\r\n        this.m_profile.step = stepTimer.GetMilliseconds();\r\n    };\r\n    /// Manually clear the force buffer on all bodies. By default, forces are cleared automatically\r\n    /// after each call to Step. The default behavior is modified by calling SetAutoClearForces.\r\n    /// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain\r\n    /// a fixed sized time step under a variable frame-rate.\r\n    /// When you perform sub-stepping you will disable auto clearing of forces and instead call\r\n    /// ClearForces after all sub-steps are complete in one pass of your game loop.\r\n    /// @see SetAutoClearForces\r\n    b2World.prototype.ClearForces = function () {\r\n        for (var body = this.m_bodyList; body; body = body.m_next) {\r\n            body.m_force.SetZero();\r\n            body.m_torque = 0;\r\n        }\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2World.prototype.DrawParticleSystem = function (system) {\r\n        if (this.m_debugDraw === null) {\r\n            return;\r\n        }\r\n        var particleCount = system.GetParticleCount();\r\n        if (particleCount) {\r\n            var radius = system.GetRadius();\r\n            var positionBuffer = system.GetPositionBuffer();\r\n            if (system.m_colorBuffer.data) {\r\n                var colorBuffer = system.GetColorBuffer();\r\n                this.m_debugDraw.DrawParticles(positionBuffer, radius, colorBuffer, particleCount);\r\n            }\r\n            else {\r\n                this.m_debugDraw.DrawParticles(positionBuffer, radius, null, particleCount);\r\n            }\r\n        }\r\n    };\r\n    b2World.prototype.DrawDebugData = function () {\r\n        if (this.m_debugDraw === null) {\r\n            return;\r\n        }\r\n        var flags = this.m_debugDraw.GetFlags();\r\n        var color = b2World.DrawDebugData_s_color.SetRGB(0, 0, 0);\r\n        if (flags & b2Draw_1.b2DrawFlags.e_shapeBit) {\r\n            for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                var xf = b.m_xf;\r\n                this.m_debugDraw.PushTransform(xf);\r\n                for (var f = b.GetFixtureList(); f; f = f.m_next) {\r\n                    if (!b.IsActive()) {\r\n                        color.SetRGB(0.5, 0.5, 0.3);\r\n                        this.DrawShape(f, color);\r\n                    }\r\n                    else if (b.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                        color.SetRGB(0.5, 0.9, 0.5);\r\n                        this.DrawShape(f, color);\r\n                    }\r\n                    else if (b.GetType() === b2Body_1.b2BodyType.b2_kinematicBody) {\r\n                        color.SetRGB(0.5, 0.5, 0.9);\r\n                        this.DrawShape(f, color);\r\n                    }\r\n                    else if (!b.IsAwake()) {\r\n                        color.SetRGB(0.6, 0.6, 0.6);\r\n                        this.DrawShape(f, color);\r\n                    }\r\n                    else {\r\n                        color.SetRGB(0.9, 0.7, 0.7);\r\n                        this.DrawShape(f, color);\r\n                    }\r\n                }\r\n                this.m_debugDraw.PopTransform(xf);\r\n            }\r\n        }\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (flags & b2Draw_1.b2DrawFlags.e_particleBit) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                this.DrawParticleSystem(p);\r\n            }\r\n        }\r\n        // #endif\r\n        if (flags & b2Draw_1.b2DrawFlags.e_jointBit) {\r\n            for (var j = this.m_jointList; j; j = j.m_next) {\r\n                this.DrawJoint(j);\r\n            }\r\n        }\r\n        /*\r\n        if (flags & b2DrawFlags.e_pairBit) {\r\n          color.SetRGB(0.3, 0.9, 0.9);\r\n          for (let contact = this.m_contactManager.m_contactList; contact; contact = contact.m_next) {\r\n            const fixtureA = contact.GetFixtureA();\r\n            const fixtureB = contact.GetFixtureB();\r\n    \r\n            const cA = fixtureA.GetAABB().GetCenter();\r\n            const cB = fixtureB.GetAABB().GetCenter();\r\n    \r\n            this.m_debugDraw.DrawSegment(cA, cB, color);\r\n          }\r\n        }\r\n        */\r\n        if (flags & b2Draw_1.b2DrawFlags.e_aabbBit) {\r\n            color.SetRGB(0.9, 0.3, 0.9);\r\n            var vs = b2World.DrawDebugData_s_vs;\r\n            for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                if (!b.IsActive()) {\r\n                    continue;\r\n                }\r\n                for (var f = b.GetFixtureList(); f; f = f.m_next) {\r\n                    for (var i = 0; i < f.m_proxyCount; ++i) {\r\n                        var proxy = f.m_proxies[i];\r\n                        var aabb = proxy.treeNode.aabb;\r\n                        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);\r\n                        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);\r\n                        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);\r\n                        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);\r\n                        this.m_debugDraw.DrawPolygon(vs, 4, color);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (flags & b2Draw_1.b2DrawFlags.e_centerOfMassBit) {\r\n            for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                var xf = b2World.DrawDebugData_s_xf;\r\n                xf.q.Copy(b.m_xf.q);\r\n                xf.p.Copy(b.GetWorldCenter());\r\n                this.m_debugDraw.DrawTransform(xf);\r\n            }\r\n        }\r\n        // #if B2_ENABLE_CONTROLLER\r\n        // @see b2Controller list\r\n        if (flags & b2Draw_1.b2DrawFlags.e_controllerBit) {\r\n            for (var c = this.m_controllerList; c; c = c.m_next) {\r\n                c.Draw(this.m_debugDraw);\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.QueryAABB = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (args[0] instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            this._QueryAABB(args[0], args[1]);\r\n        }\r\n        else {\r\n            this._QueryAABB(null, args[0], args[1]);\r\n        }\r\n    };\r\n    b2World.prototype._QueryAABB = function (callback, aabb, fn) {\r\n        this.m_contactManager.m_broadPhase.Query(aabb, function (proxy) {\r\n            var fixture_proxy = proxy.userData;\r\n            // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n            var fixture = fixture_proxy.fixture;\r\n            if (callback) {\r\n                return callback.ReportFixture(fixture);\r\n            }\r\n            else if (fn) {\r\n                return fn(fixture);\r\n            }\r\n            return true;\r\n        });\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (callback instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                if (callback.ShouldQueryParticleSystem(p)) {\r\n                    p.QueryAABB(callback, aabb);\r\n                }\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.QueryAllAABB = function (aabb, out) {\r\n        if (out === void 0) { out = []; }\r\n        this.QueryAABB(aabb, function (fixture) {\r\n            out.push(fixture);\r\n            return true;\r\n        });\r\n        return out;\r\n    };\r\n    b2World.prototype.QueryPointAABB = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (args[0] instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            this._QueryPointAABB(args[0], args[1]);\r\n        }\r\n        else {\r\n            this._QueryPointAABB(null, args[0], args[1]);\r\n        }\r\n    };\r\n    b2World.prototype._QueryPointAABB = function (callback, point, fn) {\r\n        this.m_contactManager.m_broadPhase.QueryPoint(point, function (proxy) {\r\n            var fixture_proxy = proxy.userData;\r\n            // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n            var fixture = fixture_proxy.fixture;\r\n            if (callback) {\r\n                return callback.ReportFixture(fixture);\r\n            }\r\n            else if (fn) {\r\n                return fn(fixture);\r\n            }\r\n            return true;\r\n        });\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (callback instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                if (callback.ShouldQueryParticleSystem(p)) {\r\n                    p.QueryPointAABB(callback, point);\r\n                }\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.QueryAllPointAABB = function (point, out) {\r\n        if (out === void 0) { out = []; }\r\n        this.QueryPointAABB(point, function (fixture) {\r\n            out.push(fixture);\r\n            return true;\r\n        });\r\n        return out;\r\n    };\r\n    b2World.prototype.QueryFixtureShape = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (args[0] instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            this._QueryFixtureShape(args[0], args[1], args[2], args[3]);\r\n        }\r\n        else {\r\n            this._QueryFixtureShape(null, args[0], args[1], args[2], args[3]);\r\n        }\r\n    };\r\n    b2World.prototype._QueryFixtureShape = function (callback, shape, index, transform, fn) {\r\n        var aabb = b2World.QueryFixtureShape_s_aabb;\r\n        shape.ComputeAABB(aabb, transform, index);\r\n        this.m_contactManager.m_broadPhase.Query(aabb, function (proxy) {\r\n            var fixture_proxy = proxy.userData;\r\n            // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n            var fixture = fixture_proxy.fixture;\r\n            if (b2Collision_1.b2TestOverlapShape(shape, index, fixture.GetShape(), fixture_proxy.childIndex, transform, fixture.GetBody().GetTransform())) {\r\n                if (callback) {\r\n                    return callback.ReportFixture(fixture);\r\n                }\r\n                else if (fn) {\r\n                    return fn(fixture);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (callback instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                if (callback.ShouldQueryParticleSystem(p)) {\r\n                    p.QueryAABB(callback, aabb);\r\n                }\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.QueryAllFixtureShape = function (shape, index, transform, out) {\r\n        if (out === void 0) { out = []; }\r\n        this.QueryFixtureShape(shape, index, transform, function (fixture) {\r\n            out.push(fixture);\r\n            return true;\r\n        });\r\n        return out;\r\n    };\r\n    b2World.prototype.QueryFixturePoint = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (args[0] instanceof b2WorldCallbacks_1.b2QueryCallback) {\r\n            this._QueryFixturePoint(args[0], args[1]);\r\n        }\r\n        else {\r\n            this._QueryFixturePoint(null, args[0], args[1]);\r\n        }\r\n    };\r\n    b2World.prototype._QueryFixturePoint = function (callback, point, fn) {\r\n        this.m_contactManager.m_broadPhase.QueryPoint(point, function (proxy) {\r\n            var fixture_proxy = proxy.userData;\r\n            // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n            var fixture = fixture_proxy.fixture;\r\n            if (fixture.TestPoint(point)) {\r\n                if (callback) {\r\n                    return callback.ReportFixture(fixture);\r\n                }\r\n                else if (fn) {\r\n                    return fn(fixture);\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (callback) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                if (callback.ShouldQueryParticleSystem(p)) {\r\n                    p.QueryPointAABB(callback, point);\r\n                }\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.QueryAllFixturePoint = function (point, out) {\r\n        if (out === void 0) { out = []; }\r\n        this.QueryFixturePoint(point, function (fixture) {\r\n            out.push(fixture);\r\n            return true;\r\n        });\r\n        return out;\r\n    };\r\n    b2World.prototype.RayCast = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (args[0] instanceof b2WorldCallbacks_2.b2RayCastCallback) {\r\n            this._RayCast(args[0], args[1], args[2]);\r\n        }\r\n        else {\r\n            this._RayCast(null, args[0], args[1], args[2]);\r\n        }\r\n    };\r\n    b2World.prototype._RayCast = function (callback, point1, point2, fn) {\r\n        var input = b2World.RayCast_s_input;\r\n        input.maxFraction = 1;\r\n        input.p1.Copy(point1);\r\n        input.p2.Copy(point2);\r\n        this.m_contactManager.m_broadPhase.RayCast(input, function (input, proxy) {\r\n            var fixture_proxy = proxy.userData;\r\n            // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n            var fixture = fixture_proxy.fixture;\r\n            var index = fixture_proxy.childIndex;\r\n            var output = b2World.RayCast_s_output;\r\n            var hit = fixture.RayCast(output, input, index);\r\n            if (hit) {\r\n                var fraction = output.fraction;\r\n                var point = b2World.RayCast_s_point;\r\n                point.Set((1 - fraction) * point1.x + fraction * point2.x, (1 - fraction) * point1.y + fraction * point2.y);\r\n                if (callback) {\r\n                    return callback.ReportFixture(fixture, point, output.normal, fraction);\r\n                }\r\n                else if (fn) {\r\n                    return fn(fixture, point, output.normal, fraction);\r\n                }\r\n            }\r\n            return input.maxFraction;\r\n        });\r\n        // #if B2_ENABLE_PARTICLE\r\n        if (callback) {\r\n            for (var p = this.m_particleSystemList; p; p = p.m_next) {\r\n                if (callback.ShouldQueryParticleSystem(p)) {\r\n                    p.RayCast(callback, point1, point2);\r\n                }\r\n            }\r\n        }\r\n        // #endif\r\n    };\r\n    b2World.prototype.RayCastOne = function (point1, point2) {\r\n        var result = null;\r\n        var min_fraction = 1;\r\n        this.RayCast(point1, point2, function (fixture, point, normal, fraction) {\r\n            if (fraction < min_fraction) {\r\n                min_fraction = fraction;\r\n                result = fixture;\r\n            }\r\n            return min_fraction;\r\n        });\r\n        return result;\r\n    };\r\n    b2World.prototype.RayCastAll = function (point1, point2, out) {\r\n        if (out === void 0) { out = []; }\r\n        this.RayCast(point1, point2, function (fixture, point, normal, fraction) {\r\n            out.push(fixture);\r\n            return 1;\r\n        });\r\n        return out;\r\n    };\r\n    /// Get the world body list. With the returned body, use b2Body::GetNext to get\r\n    /// the next body in the world list. A NULL body indicates the end of the list.\r\n    /// @return the head of the world body list.\r\n    b2World.prototype.GetBodyList = function () {\r\n        return this.m_bodyList;\r\n    };\r\n    /// Get the world joint list. With the returned joint, use b2Joint::GetNext to get\r\n    /// the next joint in the world list. A NULL joint indicates the end of the list.\r\n    /// @return the head of the world joint list.\r\n    b2World.prototype.GetJointList = function () {\r\n        return this.m_jointList;\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    b2World.prototype.GetParticleSystemList = function () {\r\n        return this.m_particleSystemList;\r\n    };\r\n    // #endif\r\n    /// Get the world contact list. With the returned contact, use b2Contact::GetNext to get\r\n    /// the next contact in the world list. A NULL contact indicates the end of the list.\r\n    /// @return the head of the world contact list.\r\n    /// @warning contacts are created and destroyed in the middle of a time step.\r\n    /// Use b2ContactListener to avoid missing contacts.\r\n    b2World.prototype.GetContactList = function () {\r\n        return this.m_contactManager.m_contactList;\r\n    };\r\n    /// Enable/disable sleep.\r\n    b2World.prototype.SetAllowSleeping = function (flag) {\r\n        if (flag === this.m_allowSleep) {\r\n            return;\r\n        }\r\n        this.m_allowSleep = flag;\r\n        if (!this.m_allowSleep) {\r\n            for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                b.SetAwake(true);\r\n            }\r\n        }\r\n    };\r\n    b2World.prototype.GetAllowSleeping = function () {\r\n        return this.m_allowSleep;\r\n    };\r\n    /// Enable/disable warm starting. For testing.\r\n    b2World.prototype.SetWarmStarting = function (flag) {\r\n        this.m_warmStarting = flag;\r\n    };\r\n    b2World.prototype.GetWarmStarting = function () {\r\n        return this.m_warmStarting;\r\n    };\r\n    /// Enable/disable continuous physics. For testing.\r\n    b2World.prototype.SetContinuousPhysics = function (flag) {\r\n        this.m_continuousPhysics = flag;\r\n    };\r\n    b2World.prototype.GetContinuousPhysics = function () {\r\n        return this.m_continuousPhysics;\r\n    };\r\n    /// Enable/disable single stepped continuous physics. For testing.\r\n    b2World.prototype.SetSubStepping = function (flag) {\r\n        this.m_subStepping = flag;\r\n    };\r\n    b2World.prototype.GetSubStepping = function () {\r\n        return this.m_subStepping;\r\n    };\r\n    /// Get the number of broad-phase proxies.\r\n    b2World.prototype.GetProxyCount = function () {\r\n        return this.m_contactManager.m_broadPhase.GetProxyCount();\r\n    };\r\n    /// Get the number of bodies.\r\n    b2World.prototype.GetBodyCount = function () {\r\n        return this.m_bodyCount;\r\n    };\r\n    /// Get the number of joints.\r\n    b2World.prototype.GetJointCount = function () {\r\n        return this.m_jointCount;\r\n    };\r\n    /// Get the number of contacts (each may have 0 or more contact points).\r\n    b2World.prototype.GetContactCount = function () {\r\n        return this.m_contactManager.m_contactCount;\r\n    };\r\n    /// Get the height of the dynamic tree.\r\n    b2World.prototype.GetTreeHeight = function () {\r\n        return this.m_contactManager.m_broadPhase.GetTreeHeight();\r\n    };\r\n    /// Get the balance of the dynamic tree.\r\n    b2World.prototype.GetTreeBalance = function () {\r\n        return this.m_contactManager.m_broadPhase.GetTreeBalance();\r\n    };\r\n    /// Get the quality metric of the dynamic tree. The smaller the better.\r\n    /// The minimum is 1.\r\n    b2World.prototype.GetTreeQuality = function () {\r\n        return this.m_contactManager.m_broadPhase.GetTreeQuality();\r\n    };\r\n    /// Change the global gravity vector.\r\n    b2World.prototype.SetGravity = function (gravity, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (!b2Math_1.b2Vec2.IsEqualToV(this.m_gravity, gravity)) {\r\n            this.m_gravity.Copy(gravity);\r\n            if (wake) {\r\n                for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                    b.SetAwake(true);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /// Get the global gravity vector.\r\n    b2World.prototype.GetGravity = function () {\r\n        return this.m_gravity;\r\n    };\r\n    /// Is the world locked (in the middle of a time step).\r\n    b2World.prototype.IsLocked = function () {\r\n        return this.m_locked;\r\n    };\r\n    /// Set flag to control automatic clearing of forces after each time step.\r\n    b2World.prototype.SetAutoClearForces = function (flag) {\r\n        this.m_clearForces = flag;\r\n    };\r\n    /// Get the flag that controls automatic clearing of forces after each time step.\r\n    b2World.prototype.GetAutoClearForces = function () {\r\n        return this.m_clearForces;\r\n    };\r\n    /// Shift the world origin. Useful for large worlds.\r\n    /// The body shift formula is: position -= newOrigin\r\n    /// @param newOrigin the new origin with respect to the old origin\r\n    b2World.prototype.ShiftOrigin = function (newOrigin) {\r\n        if (this.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        for (var b = this.m_bodyList; b; b = b.m_next) {\r\n            b.m_xf.p.SelfSub(newOrigin);\r\n            b.m_sweep.c0.SelfSub(newOrigin);\r\n            b.m_sweep.c.SelfSub(newOrigin);\r\n        }\r\n        for (var j = this.m_jointList; j; j = j.m_next) {\r\n            j.ShiftOrigin(newOrigin);\r\n        }\r\n        this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);\r\n    };\r\n    /// Get the contact manager for testing.\r\n    b2World.prototype.GetContactManager = function () {\r\n        return this.m_contactManager;\r\n    };\r\n    /// Get the current profile.\r\n    b2World.prototype.GetProfile = function () {\r\n        return this.m_profile;\r\n    };\r\n    /// Dump the world into the log file.\r\n    /// @warning this should be called outside of a time step.\r\n    b2World.prototype.Dump = function (log) {\r\n        if (this.m_locked) {\r\n            return;\r\n        }\r\n        log(\"const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\\n\", this.m_gravity.x, this.m_gravity.y);\r\n        log(\"this.m_world.SetGravity(g);\\n\");\r\n        log(\"const bodies: b2Body[] = [];\\n\");\r\n        log(\"const joints: b2Joint[] = [];\\n\");\r\n        var i = 0;\r\n        for (var b = this.m_bodyList; b; b = b.m_next) {\r\n            b.m_islandIndex = i;\r\n            b.Dump(log);\r\n            ++i;\r\n        }\r\n        i = 0;\r\n        for (var j = this.m_jointList; j; j = j.m_next) {\r\n            j.m_index = i;\r\n            ++i;\r\n        }\r\n        // First pass on joints, skip gear joints.\r\n        for (var j = this.m_jointList; j; j = j.m_next) {\r\n            if (j.m_type === b2Joint_1.b2JointType.e_gearJoint) {\r\n                continue;\r\n            }\r\n            log(\"{\\n\");\r\n            j.Dump(log);\r\n            log(\"}\\n\");\r\n        }\r\n        // Second pass on joints, only gear joints.\r\n        for (var j = this.m_jointList; j; j = j.m_next) {\r\n            if (j.m_type !== b2Joint_1.b2JointType.e_gearJoint) {\r\n                continue;\r\n            }\r\n            log(\"{\\n\");\r\n            j.Dump(log);\r\n            log(\"}\\n\");\r\n        }\r\n    };\r\n    b2World.prototype.DrawJoint = function (joint) {\r\n        if (this.m_debugDraw === null) {\r\n            return;\r\n        }\r\n        var bodyA = joint.GetBodyA();\r\n        var bodyB = joint.GetBodyB();\r\n        var xf1 = bodyA.m_xf;\r\n        var xf2 = bodyB.m_xf;\r\n        var x1 = xf1.p;\r\n        var x2 = xf2.p;\r\n        var p1 = joint.GetAnchorA(b2World.DrawJoint_s_p1);\r\n        var p2 = joint.GetAnchorB(b2World.DrawJoint_s_p2);\r\n        var color = b2World.DrawJoint_s_color.SetRGB(0.5, 0.8, 0.8);\r\n        switch (joint.m_type) {\r\n            case b2Joint_1.b2JointType.e_distanceJoint:\r\n                this.m_debugDraw.DrawSegment(p1, p2, color);\r\n                break;\r\n            case b2Joint_1.b2JointType.e_pulleyJoint: {\r\n                var pulley = joint;\r\n                var s1 = pulley.GetGroundAnchorA();\r\n                var s2 = pulley.GetGroundAnchorB();\r\n                this.m_debugDraw.DrawSegment(s1, p1, color);\r\n                this.m_debugDraw.DrawSegment(s2, p2, color);\r\n                this.m_debugDraw.DrawSegment(s1, s2, color);\r\n                break;\r\n            }\r\n            case b2Joint_1.b2JointType.e_mouseJoint: {\r\n                var c = b2World.DrawJoint_s_c;\r\n                c.Set(0.0, 1.0, 0.0);\r\n                this.m_debugDraw.DrawPoint(p1, 4.0, c);\r\n                this.m_debugDraw.DrawPoint(p2, 4.0, c);\r\n                c.Set(0.8, 0.8, 0.8);\r\n                this.m_debugDraw.DrawSegment(p1, p2, c);\r\n                break;\r\n            }\r\n            default:\r\n                this.m_debugDraw.DrawSegment(x1, p1, color);\r\n                this.m_debugDraw.DrawSegment(p1, p2, color);\r\n                this.m_debugDraw.DrawSegment(x2, p2, color);\r\n        }\r\n    };\r\n    b2World.prototype.DrawShape = function (fixture, color) {\r\n        if (this.m_debugDraw === null) {\r\n            return;\r\n        }\r\n        var shape = fixture.GetShape();\r\n        switch (shape.m_type) {\r\n            case b2Shape_1.b2ShapeType.e_circleShape: {\r\n                var circle = shape;\r\n                var center = circle.m_p;\r\n                var radius = circle.m_radius;\r\n                var axis = b2Math_1.b2Vec2.UNITX;\r\n                this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);\r\n                break;\r\n            }\r\n            case b2Shape_1.b2ShapeType.e_edgeShape: {\r\n                var edge = shape;\r\n                var v1 = edge.m_vertex1;\r\n                var v2 = edge.m_vertex2;\r\n                this.m_debugDraw.DrawSegment(v1, v2, color);\r\n                break;\r\n            }\r\n            case b2Shape_1.b2ShapeType.e_chainShape: {\r\n                var chain = shape;\r\n                var count = chain.m_count;\r\n                var vertices = chain.m_vertices;\r\n                var ghostColor = b2World.DrawShape_s_ghostColor.SetRGBA(0.75 * color.r, 0.75 * color.g, 0.75 * color.b, color.a);\r\n                var v1 = vertices[0];\r\n                this.m_debugDraw.DrawPoint(v1, 4.0, color);\r\n                if (chain.m_hasPrevVertex) {\r\n                    var vp = chain.m_prevVertex;\r\n                    this.m_debugDraw.DrawSegment(vp, v1, ghostColor);\r\n                    this.m_debugDraw.DrawCircle(vp, 0.1, ghostColor);\r\n                }\r\n                for (var i = 1; i < count; ++i) {\r\n                    var v2 = vertices[i];\r\n                    this.m_debugDraw.DrawSegment(v1, v2, color);\r\n                    this.m_debugDraw.DrawPoint(v2, 4.0, color);\r\n                    v1 = v2;\r\n                }\r\n                if (chain.m_hasNextVertex) {\r\n                    var vn = chain.m_nextVertex;\r\n                    this.m_debugDraw.DrawSegment(vn, v1, ghostColor);\r\n                    this.m_debugDraw.DrawCircle(vn, 0.1, ghostColor);\r\n                }\r\n                break;\r\n            }\r\n            case b2Shape_1.b2ShapeType.e_polygonShape: {\r\n                var poly = shape;\r\n                var vertexCount = poly.m_count;\r\n                var vertices = poly.m_vertices;\r\n                this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    b2World.prototype.Solve = function (step) {\r\n        // #if B2_ENABLE_PARTICLE\r\n        // update previous transforms\r\n        for (var b = this.m_bodyList; b; b = b.m_next) {\r\n            b.m_xf0.Copy(b.m_xf);\r\n        }\r\n        // #endif\r\n        // #if B2_ENABLE_CONTROLLER\r\n        // @see b2Controller list\r\n        for (var controller = this.m_controllerList; controller; controller = controller.m_next) {\r\n            controller.Step(step);\r\n        }\r\n        // #endif\r\n        this.m_profile.solveInit = 0;\r\n        this.m_profile.solveVelocity = 0;\r\n        this.m_profile.solvePosition = 0;\r\n        // Size the island for the worst case.\r\n        var island = this.m_island;\r\n        island.Initialize(this.m_bodyCount, this.m_contactManager.m_contactCount, this.m_jointCount, this.m_contactManager.m_contactListener);\r\n        // Clear all the island flags.\r\n        for (var b = this.m_bodyList; b; b = b.m_next) {\r\n            b.m_islandFlag = false;\r\n        }\r\n        for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {\r\n            c.m_islandFlag = false;\r\n        }\r\n        for (var j = this.m_jointList; j; j = j.m_next) {\r\n            j.m_islandFlag = false;\r\n        }\r\n        // Build and simulate all awake islands.\r\n        // DEBUG: const stackSize: number = this.m_bodyCount;\r\n        var stack = this.s_stack;\r\n        for (var seed = this.m_bodyList; seed; seed = seed.m_next) {\r\n            if (seed.m_islandFlag) {\r\n                continue;\r\n            }\r\n            if (!seed.IsAwake() || !seed.IsActive()) {\r\n                continue;\r\n            }\r\n            // The seed can be dynamic or kinematic.\r\n            if (seed.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                continue;\r\n            }\r\n            // Reset island and stack.\r\n            island.Clear();\r\n            var stackCount = 0;\r\n            stack[stackCount++] = seed;\r\n            seed.m_islandFlag = true;\r\n            // Perform a depth first search (DFS) on the constraint graph.\r\n            while (stackCount > 0) {\r\n                // Grab the next body off the stack and add it to the island.\r\n                var b = stack[--stackCount];\r\n                if (!b) {\r\n                    throw new Error();\r\n                }\r\n                // DEBUG: b2Assert(b.IsActive());\r\n                island.AddBody(b);\r\n                // Make sure the body is awake. (without resetting sleep timer).\r\n                b.m_awakeFlag = true;\r\n                // To keep islands as small as possible, we don't\r\n                // propagate islands across static bodies.\r\n                if (b.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                    continue;\r\n                }\r\n                // Search all contacts connected to this body.\r\n                for (var ce = b.m_contactList; ce; ce = ce.next) {\r\n                    var contact = ce.contact;\r\n                    // Has this contact already been added to an island?\r\n                    if (contact.m_islandFlag) {\r\n                        continue;\r\n                    }\r\n                    // Is this contact solid and touching?\r\n                    if (!contact.IsEnabled() || !contact.IsTouching()) {\r\n                        continue;\r\n                    }\r\n                    // Skip sensors.\r\n                    var sensorA = contact.m_fixtureA.m_isSensor;\r\n                    var sensorB = contact.m_fixtureB.m_isSensor;\r\n                    if (sensorA || sensorB) {\r\n                        continue;\r\n                    }\r\n                    island.AddContact(contact);\r\n                    contact.m_islandFlag = true;\r\n                    var other = ce.other;\r\n                    // Was the other body already added to this island?\r\n                    if (other.m_islandFlag) {\r\n                        continue;\r\n                    }\r\n                    // DEBUG: b2Assert(stackCount < stackSize);\r\n                    stack[stackCount++] = other;\r\n                    other.m_islandFlag = true;\r\n                }\r\n                // Search all joints connect to this body.\r\n                for (var je = b.m_jointList; je; je = je.next) {\r\n                    if (je.joint.m_islandFlag) {\r\n                        continue;\r\n                    }\r\n                    var other = je.other;\r\n                    // Don't simulate joints connected to inactive bodies.\r\n                    if (!other.IsActive()) {\r\n                        continue;\r\n                    }\r\n                    island.AddJoint(je.joint);\r\n                    je.joint.m_islandFlag = true;\r\n                    if (other.m_islandFlag) {\r\n                        continue;\r\n                    }\r\n                    // DEBUG: b2Assert(stackCount < stackSize);\r\n                    stack[stackCount++] = other;\r\n                    other.m_islandFlag = true;\r\n                }\r\n            }\r\n            var profile = new b2TimeStep_1.b2Profile();\r\n            island.Solve(profile, step, this.m_gravity, this.m_allowSleep);\r\n            this.m_profile.solveInit += profile.solveInit;\r\n            this.m_profile.solveVelocity += profile.solveVelocity;\r\n            this.m_profile.solvePosition += profile.solvePosition;\r\n            // Post solve cleanup.\r\n            for (var i = 0; i < island.m_bodyCount; ++i) {\r\n                // Allow static bodies to participate in other islands.\r\n                var b = island.m_bodies[i];\r\n                if (b.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                    b.m_islandFlag = false;\r\n                }\r\n            }\r\n        }\r\n        for (var i = 0; i < stack.length; ++i) {\r\n            if (!stack[i]) {\r\n                break;\r\n            }\r\n            stack[i] = null;\r\n        }\r\n        var timer = new b2Timer_1.b2Timer();\r\n        // Synchronize fixtures, check for out of range bodies.\r\n        for (var b = this.m_bodyList; b; b = b.m_next) {\r\n            // If a body was not in an island then it did not move.\r\n            if (!b.m_islandFlag) {\r\n                continue;\r\n            }\r\n            if (b.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                continue;\r\n            }\r\n            // Update fixtures (for broad-phase).\r\n            b.SynchronizeFixtures();\r\n        }\r\n        // Look for new contacts.\r\n        this.m_contactManager.FindNewContacts();\r\n        this.m_profile.broadphase = timer.GetMilliseconds();\r\n    };\r\n    b2World.prototype.SolveTOI = function (step) {\r\n        var island = this.m_island;\r\n        island.Initialize(2 * b2Settings_1.b2_maxTOIContacts, b2Settings_1.b2_maxTOIContacts, 0, this.m_contactManager.m_contactListener);\r\n        if (this.m_stepComplete) {\r\n            for (var b = this.m_bodyList; b; b = b.m_next) {\r\n                b.m_islandFlag = false;\r\n                b.m_sweep.alpha0 = 0;\r\n            }\r\n            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {\r\n                // Invalidate TOI\r\n                c.m_toiFlag = false;\r\n                c.m_islandFlag = false;\r\n                c.m_toiCount = 0;\r\n                c.m_toi = 1;\r\n            }\r\n        }\r\n        // Find TOI events and solve them.\r\n        for (;;) {\r\n            // Find the first TOI.\r\n            var minContact = null;\r\n            var minAlpha = 1;\r\n            for (var c = this.m_contactManager.m_contactList; c; c = c.m_next) {\r\n                // Is this contact disabled?\r\n                if (!c.IsEnabled()) {\r\n                    continue;\r\n                }\r\n                // Prevent excessive sub-stepping.\r\n                if (c.m_toiCount > b2Settings_1.b2_maxSubSteps) {\r\n                    continue;\r\n                }\r\n                var alpha = 1;\r\n                if (c.m_toiFlag) {\r\n                    // This contact has a valid cached TOI.\r\n                    alpha = c.m_toi;\r\n                }\r\n                else {\r\n                    var fA_1 = c.GetFixtureA();\r\n                    var fB_1 = c.GetFixtureB();\r\n                    // Is there a sensor?\r\n                    if (fA_1.IsSensor() || fB_1.IsSensor()) {\r\n                        continue;\r\n                    }\r\n                    var bA_1 = fA_1.GetBody();\r\n                    var bB_1 = fB_1.GetBody();\r\n                    var typeA = bA_1.m_type;\r\n                    var typeB = bB_1.m_type;\r\n                    // DEBUG: b2Assert(typeA !== b2BodyType.b2_staticBody || typeB !== b2BodyType.b2_staticBody);\r\n                    var activeA = bA_1.IsAwake() && typeA !== b2Body_1.b2BodyType.b2_staticBody;\r\n                    var activeB = bB_1.IsAwake() && typeB !== b2Body_1.b2BodyType.b2_staticBody;\r\n                    // Is at least one body active (awake and dynamic or kinematic)?\r\n                    if (!activeA && !activeB) {\r\n                        continue;\r\n                    }\r\n                    var collideA = bA_1.IsBullet() || typeA !== b2Body_1.b2BodyType.b2_dynamicBody;\r\n                    var collideB = bB_1.IsBullet() || typeB !== b2Body_1.b2BodyType.b2_dynamicBody;\r\n                    // Are these two non-bullet dynamic bodies?\r\n                    if (!collideA && !collideB) {\r\n                        continue;\r\n                    }\r\n                    // Compute the TOI for this contact.\r\n                    // Put the sweeps onto the same time interval.\r\n                    var alpha0 = bA_1.m_sweep.alpha0;\r\n                    if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\r\n                        alpha0 = bB_1.m_sweep.alpha0;\r\n                        bA_1.m_sweep.Advance(alpha0);\r\n                    }\r\n                    else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\r\n                        alpha0 = bA_1.m_sweep.alpha0;\r\n                        bB_1.m_sweep.Advance(alpha0);\r\n                    }\r\n                    // DEBUG: b2Assert(alpha0 < 1);\r\n                    var indexA = c.GetChildIndexA();\r\n                    var indexB = c.GetChildIndexB();\r\n                    // Compute the time of impact in interval [0, minTOI]\r\n                    var input = b2World.SolveTOI_s_toi_input;\r\n                    input.proxyA.SetShape(fA_1.GetShape(), indexA);\r\n                    input.proxyB.SetShape(fB_1.GetShape(), indexB);\r\n                    input.sweepA.Copy(bA_1.m_sweep);\r\n                    input.sweepB.Copy(bB_1.m_sweep);\r\n                    input.tMax = 1;\r\n                    var output = b2World.SolveTOI_s_toi_output;\r\n                    b2TimeOfImpact_1.b2TimeOfImpact(output, input);\r\n                    // Beta is the fraction of the remaining portion of the .\r\n                    var beta = output.t;\r\n                    if (output.state === b2TimeOfImpact_1.b2TOIOutputState.e_touching) {\r\n                        alpha = b2Math_1.b2Min(alpha0 + (1 - alpha0) * beta, 1);\r\n                    }\r\n                    else {\r\n                        alpha = 1;\r\n                    }\r\n                    c.m_toi = alpha;\r\n                    c.m_toiFlag = true;\r\n                }\r\n                if (alpha < minAlpha) {\r\n                    // This is the minimum TOI found so far.\r\n                    minContact = c;\r\n                    minAlpha = alpha;\r\n                }\r\n            }\r\n            if (minContact === null || 1 - 10 * b2Settings_1.b2_epsilon < minAlpha) {\r\n                // No more TOI events. Done!\r\n                this.m_stepComplete = true;\r\n                break;\r\n            }\r\n            // Advance the bodies to the TOI.\r\n            var fA = minContact.GetFixtureA();\r\n            var fB = minContact.GetFixtureB();\r\n            var bA = fA.GetBody();\r\n            var bB = fB.GetBody();\r\n            var backup1 = b2World.SolveTOI_s_backup1.Copy(bA.m_sweep);\r\n            var backup2 = b2World.SolveTOI_s_backup2.Copy(bB.m_sweep);\r\n            bA.Advance(minAlpha);\r\n            bB.Advance(minAlpha);\r\n            // The TOI contact likely has some new contact points.\r\n            minContact.Update(this.m_contactManager.m_contactListener);\r\n            minContact.m_toiFlag = false;\r\n            ++minContact.m_toiCount;\r\n            // Is the contact solid?\r\n            if (!minContact.IsEnabled() || !minContact.IsTouching()) {\r\n                // Restore the sweeps.\r\n                minContact.SetEnabled(false);\r\n                bA.m_sweep.Copy(backup1);\r\n                bB.m_sweep.Copy(backup2);\r\n                bA.SynchronizeTransform();\r\n                bB.SynchronizeTransform();\r\n                continue;\r\n            }\r\n            bA.SetAwake(true);\r\n            bB.SetAwake(true);\r\n            // Build the island\r\n            island.Clear();\r\n            island.AddBody(bA);\r\n            island.AddBody(bB);\r\n            island.AddContact(minContact);\r\n            bA.m_islandFlag = true;\r\n            bB.m_islandFlag = true;\r\n            minContact.m_islandFlag = true;\r\n            // Get contacts on bodyA and bodyB.\r\n            // const bodies: b2Body[] = [bA, bB];\r\n            for (var i = 0; i < 2; ++i) {\r\n                var body = i === 0 ? bA : bB; // bodies[i];\r\n                if (body.m_type === b2Body_1.b2BodyType.b2_dynamicBody) {\r\n                    for (var ce = body.m_contactList; ce; ce = ce.next) {\r\n                        if (island.m_bodyCount === island.m_bodyCapacity) {\r\n                            break;\r\n                        }\r\n                        if (island.m_contactCount === island.m_contactCapacity) {\r\n                            break;\r\n                        }\r\n                        var contact = ce.contact;\r\n                        // Has this contact already been added to the island?\r\n                        if (contact.m_islandFlag) {\r\n                            continue;\r\n                        }\r\n                        // Only add static, kinematic, or bullet bodies.\r\n                        var other = ce.other;\r\n                        if (other.m_type === b2Body_1.b2BodyType.b2_dynamicBody &&\r\n                            !body.IsBullet() &&\r\n                            !other.IsBullet()) {\r\n                            continue;\r\n                        }\r\n                        // Skip sensors.\r\n                        var sensorA = contact.m_fixtureA.m_isSensor;\r\n                        var sensorB = contact.m_fixtureB.m_isSensor;\r\n                        if (sensorA || sensorB) {\r\n                            continue;\r\n                        }\r\n                        // Tentatively advance the body to the TOI.\r\n                        var backup = b2World.SolveTOI_s_backup.Copy(other.m_sweep);\r\n                        if (!other.m_islandFlag) {\r\n                            other.Advance(minAlpha);\r\n                        }\r\n                        // Update the contact points\r\n                        contact.Update(this.m_contactManager.m_contactListener);\r\n                        // Was the contact disabled by the user?\r\n                        if (!contact.IsEnabled()) {\r\n                            other.m_sweep.Copy(backup);\r\n                            other.SynchronizeTransform();\r\n                            continue;\r\n                        }\r\n                        // Are there contact points?\r\n                        if (!contact.IsTouching()) {\r\n                            other.m_sweep.Copy(backup);\r\n                            other.SynchronizeTransform();\r\n                            continue;\r\n                        }\r\n                        // Add the contact to the island\r\n                        contact.m_islandFlag = true;\r\n                        island.AddContact(contact);\r\n                        // Has the other body already been added to the island?\r\n                        if (other.m_islandFlag) {\r\n                            continue;\r\n                        }\r\n                        // Add the other body to the island.\r\n                        other.m_islandFlag = true;\r\n                        if (other.m_type !== b2Body_1.b2BodyType.b2_staticBody) {\r\n                            other.SetAwake(true);\r\n                        }\r\n                        island.AddBody(other);\r\n                    }\r\n                }\r\n            }\r\n            var subStep = b2World.SolveTOI_s_subStep;\r\n            subStep.dt = (1 - minAlpha) * step.dt;\r\n            subStep.inv_dt = 1 / subStep.dt;\r\n            subStep.dtRatio = 1;\r\n            subStep.positionIterations = 20;\r\n            subStep.velocityIterations = step.velocityIterations;\r\n            // #if B2_ENABLE_PARTICLE\r\n            subStep.particleIterations = step.particleIterations;\r\n            // #endif\r\n            subStep.warmStarting = false;\r\n            island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\r\n            // Reset island flags and synchronize broad-phase proxies.\r\n            for (var i = 0; i < island.m_bodyCount; ++i) {\r\n                var body = island.m_bodies[i];\r\n                body.m_islandFlag = false;\r\n                if (body.m_type !== b2Body_1.b2BodyType.b2_dynamicBody) {\r\n                    continue;\r\n                }\r\n                body.SynchronizeFixtures();\r\n                // Invalidate all contact TOIs on this displaced body.\r\n                for (var ce = body.m_contactList; ce; ce = ce.next) {\r\n                    ce.contact.m_toiFlag = false;\r\n                    ce.contact.m_islandFlag = false;\r\n                }\r\n            }\r\n            // Commit fixture proxy movements to the broad-phase so that new contacts are created.\r\n            // Also, some contacts can be destroyed.\r\n            this.m_contactManager.FindNewContacts();\r\n            if (this.m_subStepping) {\r\n                this.m_stepComplete = false;\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    // #if B2_ENABLE_CONTROLLER\r\n    b2World.prototype.AddController = function (controller) {\r\n        // b2Assert(controller.m_world === null, \"Controller can only be a member of one world\");\r\n        // controller.m_world = this;\r\n        controller.m_next = this.m_controllerList;\r\n        controller.m_prev = null;\r\n        if (this.m_controllerList) {\r\n            this.m_controllerList.m_prev = controller;\r\n        }\r\n        this.m_controllerList = controller;\r\n        ++this.m_controllerCount;\r\n        return controller;\r\n    };\r\n    b2World.prototype.RemoveController = function (controller) {\r\n        // b2Assert(controller.m_world === this, \"Controller is not a member of this world\");\r\n        if (controller.m_prev) {\r\n            controller.m_prev.m_next = controller.m_next;\r\n        }\r\n        if (controller.m_next) {\r\n            controller.m_next.m_prev = controller.m_prev;\r\n        }\r\n        if (this.m_controllerList === controller) {\r\n            this.m_controllerList = controller.m_next;\r\n        }\r\n        --this.m_controllerCount;\r\n        controller.m_prev = null;\r\n        controller.m_next = null;\r\n        // delete controller.m_world; // = null;\r\n        return controller;\r\n    };\r\n    // #endif\r\n    /// Take a time step. This performs collision detection, integration,\r\n    /// and constraint solution.\r\n    /// @param timeStep the amount of time to simulate, this should not vary.\r\n    /// @param velocityIterations for the velocity constraint solver.\r\n    /// @param positionIterations for the position constraint solver.\r\n    b2World.Step_s_step = new b2TimeStep_1.b2TimeStep();\r\n    b2World.Step_s_stepTimer = new b2Timer_1.b2Timer();\r\n    b2World.Step_s_timer = new b2Timer_1.b2Timer();\r\n    // #endif\r\n    /// Call this to draw shapes and other debug draw data.\r\n    b2World.DrawDebugData_s_color = new b2Draw_1.b2Color(0, 0, 0);\r\n    b2World.DrawDebugData_s_vs = b2Math_1.b2Vec2.MakeArray(4);\r\n    b2World.DrawDebugData_s_xf = new b2Math_1.b2Transform();\r\n    b2World.QueryFixtureShape_s_aabb = new b2Collision_1.b2AABB();\r\n    b2World.RayCast_s_input = new b2Collision_1.b2RayCastInput();\r\n    b2World.RayCast_s_output = new b2Collision_1.b2RayCastOutput();\r\n    b2World.RayCast_s_point = new b2Math_1.b2Vec2();\r\n    b2World.DrawJoint_s_p1 = new b2Math_1.b2Vec2();\r\n    b2World.DrawJoint_s_p2 = new b2Math_1.b2Vec2();\r\n    b2World.DrawJoint_s_color = new b2Draw_1.b2Color(0.5, 0.8, 0.8);\r\n    b2World.DrawJoint_s_c = new b2Draw_1.b2Color();\r\n    b2World.DrawShape_s_ghostColor = new b2Draw_1.b2Color();\r\n    b2World.SolveTOI_s_subStep = new b2TimeStep_1.b2TimeStep();\r\n    b2World.SolveTOI_s_backup = new b2Math_1.b2Sweep();\r\n    b2World.SolveTOI_s_backup1 = new b2Math_1.b2Sweep();\r\n    b2World.SolveTOI_s_backup2 = new b2Math_1.b2Sweep();\r\n    b2World.SolveTOI_s_toi_input = new b2TimeOfImpact_1.b2TOIInput();\r\n    b2World.SolveTOI_s_toi_output = new b2TimeOfImpact_1.b2TOIOutput();\r\n    return b2World;\r\n}());\r\nexports.b2World = b2World;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2World.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2World.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport {\r\n  b2_epsilon,\r\n  b2_maxSubSteps,\r\n  b2_maxTOIContacts\r\n} from \"../Common/b2Settings\";\r\nimport { b2Min, b2Vec2, b2Transform, b2Sweep, XY } from \"../Common/b2Math\";\r\nimport { b2Timer } from \"../Common/b2Timer\";\r\nimport { b2Color, b2Draw, b2DrawFlags } from \"../Common/b2Draw\";\r\nimport {\r\n  b2AABB,\r\n  b2RayCastInput,\r\n  b2RayCastOutput,\r\n  b2TestOverlapShape\r\n} from \"../Collision/b2Collision\";\r\nimport { b2TreeNode } from \"../Collision/b2DynamicTree\";\r\nimport {\r\n  b2TimeOfImpact,\r\n  b2TOIInput,\r\n  b2TOIOutput,\r\n  b2TOIOutputState\r\n} from \"../Collision/b2TimeOfImpact\";\r\nimport { b2Shape, b2ShapeType } from \"../Collision/Shapes/b2Shape\";\r\nimport { b2ChainShape } from \"../Collision/Shapes/b2ChainShape\";\r\nimport { b2CircleShape } from \"../Collision/Shapes/b2CircleShape\";\r\nimport { b2EdgeShape } from \"../Collision/Shapes/b2EdgeShape\";\r\nimport { b2PolygonShape } from \"../Collision/Shapes/b2PolygonShape\";\r\nimport { b2Contact, b2ContactEdge } from \"./Contacts/b2Contact\";\r\nimport {\r\n  b2Joint,\r\n  b2IJointDef,\r\n  b2JointType,\r\n  b2JointEdge\r\n} from \"./Joints/b2Joint\";\r\nimport { b2AreaJoint, b2IAreaJointDef } from \"./Joints/b2AreaJoint\";\r\nimport { b2DistanceJoint, b2IDistanceJointDef } from \"./Joints/b2DistanceJoint\";\r\nimport { b2FrictionJoint, b2IFrictionJointDef } from \"./Joints/b2FrictionJoint\";\r\nimport { b2GearJoint, b2IGearJointDef } from \"./Joints/b2GearJoint\";\r\nimport { b2MotorJoint, b2IMotorJointDef } from \"./Joints/b2MotorJoint\";\r\nimport { b2MouseJoint, b2IMouseJointDef } from \"./Joints/b2MouseJoint\";\r\nimport {\r\n  b2PrismaticJoint,\r\n  b2IPrismaticJointDef\r\n} from \"./Joints/b2PrismaticJoint\";\r\nimport { b2PulleyJoint, b2IPulleyJointDef } from \"./Joints/b2PulleyJoint\";\r\nimport { b2RevoluteJoint, b2IRevoluteJointDef } from \"./Joints/b2RevoluteJoint\";\r\nimport { b2RopeJoint, b2IRopeJointDef } from \"./Joints/b2RopeJoint\";\r\nimport { b2WeldJoint, b2IWeldJointDef } from \"./Joints/b2WeldJoint\";\r\nimport { b2WheelJoint, b2IWheelJointDef } from \"./Joints/b2WheelJoint\";\r\nimport { b2Body, b2IBodyDef, b2BodyType } from \"./b2Body\";\r\nimport { b2ContactManager } from \"./b2ContactManager\";\r\nimport { b2Fixture, b2FixtureProxy } from \"./b2Fixture\";\r\nimport { b2Island } from \"./b2Island\";\r\nimport { b2Profile, b2TimeStep } from \"./b2TimeStep\";\r\nimport { b2ContactFilter } from \"./b2WorldCallbacks\";\r\nimport { b2ContactListener } from \"./b2WorldCallbacks\";\r\nimport { b2DestructionListener } from \"./b2WorldCallbacks\";\r\nimport { b2QueryCallback, b2QueryCallbackFunction } from \"./b2WorldCallbacks\";\r\nimport {\r\n  b2RayCastCallback,\r\n  b2RayCastCallbackFunction\r\n} from \"./b2WorldCallbacks\";\r\n// #if B2_ENABLE_PARTICLE\r\nimport { b2_maxFloat } from \"../Common/b2Settings\";\r\nimport { b2CalculateParticleIterations } from \"../Particle/b2Particle\";\r\nimport {\r\n  b2ParticleSystemDef,\r\n  b2ParticleSystem\r\n} from \"../Particle/b2ParticleSystem\";\r\n// #endif\r\n// #if B2_ENABLE_CONTROLLER\r\nimport { b2Controller, b2ControllerEdge } from \"../Controllers/b2Controller\";\r\n// #endif\r\n\r\n/// The world class manages all physics entities, dynamic simulation,\r\n/// and asynchronous queries. The world also contains efficient memory\r\n/// management facilities.\r\nexport class b2World {\r\n  public m_newFixture: boolean = false;\r\n  public m_locked: boolean = false;\r\n  public m_clearForces: boolean = true;\r\n\r\n  public readonly m_contactManager: b2ContactManager = new b2ContactManager();\r\n\r\n  public m_bodyList: b2Body | null = null;\r\n  public m_jointList: b2Joint | null = null;\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public m_particleSystemList: b2ParticleSystem | null = null;\r\n  // #endif\r\n\r\n  public m_bodyCount: number = 0;\r\n  public m_jointCount: number = 0;\r\n\r\n  public readonly m_gravity: b2Vec2 = new b2Vec2();\r\n  public m_allowSleep: boolean = true;\r\n\r\n  public m_destructionListener: b2DestructionListener | null = null;\r\n  public m_debugDraw: b2Draw | null = null;\r\n\r\n  // This is used to compute the time step ratio to\r\n  // support a variable time step.\r\n  public m_inv_dt0: number = 0;\r\n\r\n  // These are for debugging the solver.\r\n  public m_warmStarting: boolean = true;\r\n  public m_continuousPhysics: boolean = true;\r\n  public m_subStepping: boolean = false;\r\n\r\n  public m_stepComplete: boolean = true;\r\n\r\n  public readonly m_profile: b2Profile = new b2Profile();\r\n\r\n  public readonly m_island: b2Island = new b2Island();\r\n\r\n  public readonly s_stack: Array<b2Body | null> = [];\r\n\r\n  // #if B2_ENABLE_CONTROLLER\r\n  public m_controllerList: b2Controller | null = null;\r\n  public m_controllerCount: number = 0;\r\n  private pixiToBox2D: number[][] = [];\r\n  private box2DToPixi: number[][] = [];\r\n  private pixiToBox2DScale: number[][] = [];\r\n  private box2DToPixiScale: number[][] = [];\r\n  // #endif\r\n\r\n  /// Construct a world object.\r\n  /// @param gravity the world gravity vector.\r\n  constructor(gravity: XY, scale: number) {\r\n    this.m_gravity.Copy(gravity);\r\n\r\n    // this.pixiToBox2D[0] = [1, 0, 0];\r\n    // this.pixiToBox2D[1] = [0, 1, 0];\r\n    // this.pixiToBox2D[2] = [-translation.x * 0.5, -translation.y * 0.5, 1];\r\n\r\n    // this.box2DToPixi[0] = [1, 0, 0];\r\n    // this.box2DToPixi[1] = [0, -1, 0];\r\n    // this.box2DToPixi[2] = [translation.x * 0.5, translation.y * 0.5, 1];\r\n  }\r\n\r\n  /// Register a destruction listener. The listener is owned by you and must\r\n  /// remain in scope.\r\n  public SetDestructionListener(listener: b2DestructionListener | null): void {\r\n    this.m_destructionListener = listener;\r\n  }\r\n\r\n  // public PixelToWorldVector(position: Pixi.IPoint) {\r\n  //   let converterVec = new b2Vec2(position.x, position.y);\r\n  //   let matrix = this.pixiToBox2D;\r\n  //   let convertedVec = this.MultiMatrixToVector(converterVec, matrix);\r\n  //   return convertedVec;\r\n  // }\r\n\r\n  // public WorldToPixelVector(position: b2Vec2) {\r\n  //   let converterVec = new b2Vec2(position.x, position.y);\r\n  //   let matrix = this.box2DToPixi;\r\n  //   converterVec = this.MultiMatrixToVector(converterVec, matrix);\r\n  //   let convertedVec = new Pixi.Point(converterVec.x, converterVec.y);\r\n  //   return convertedVec;\r\n  // }\r\n\r\n  // private MultiMatrixToVector(vector: b2Vec2, martix: number[][]) {\r\n  //   let tempMartix: number[][] = [];\r\n  //   tempMartix[0] = [vector.x, vector.y, 1];\r\n  //   tempMartix = this.MultiMatrix(martix, tempMartix);\r\n  //   return new b2Vec2(tempMartix[0][0], tempMartix[0][1]);\r\n  // }\r\n\r\n  // public MultiMatrix(martix: number[][], otherMartix: number[][]) {\r\n  //   let tempMartix: number[][] = [];\r\n  //   let colloms = otherMartix[0].length;\r\n  //   let rows = otherMartix.length;\r\n\r\n  //   for (let rowIndex = 0; rowIndex < rows; rowIndex++) {\r\n  //     let row: number[] = [];\r\n  //     for (let collomIndex = 0; collomIndex < colloms; collomIndex++) {\r\n  //       let collom: number = 0;\r\n  //       for (let multiIndex = 0; multiIndex < colloms; multiIndex++) {\r\n  //         let a = martix[multiIndex][collomIndex];\r\n  //         let b = otherMartix[rowIndex][multiIndex];\r\n  //         collom += a * b;\r\n  //       }\r\n  //       row.push(collom);\r\n  //     }\r\n  //     tempMartix.push(row);\r\n  //   }\r\n  //   return tempMartix;\r\n  // }\r\n\r\n  // private InverseMatrix(matrix: number[][]) {\r\n  //   //if the matrix isn't square: exit (error)\r\n  //   if (matrix.length !== matrix[0].length) {\r\n  //     return;\r\n  //   }\r\n\r\n  //   //create the identity matrix (I), and a copy (C) of the original\r\n  //   var i = 0,\r\n  //     ii = 0,\r\n  //     j = 0,\r\n  //     dim = matrix.length,\r\n  //     e = 0,\r\n  //     t = 0;\r\n  //   var identifier = [],\r\n  //     copy = [];\r\n  //   for (i = 0; i < dim; i += 1) {\r\n  //     // Create the row\r\n  //     identifier[identifier.length] = [];\r\n  //     copy[copy.length] = [];\r\n  //     for (j = 0; j < dim; j += 1) {\r\n  //       //if we're on the diagonal, put a 1 (for identity)\r\n  //       if (i == j) {\r\n  //         identifier[i][j] = 1;\r\n  //       } else {\r\n  //         identifier[i][j] = 0;\r\n  //       }\r\n\r\n  //       // Also, make the copy of the original\r\n  //       copy[i][j] = matrix[i][j];\r\n  //     }\r\n  //   }\r\n\r\n  //   // Perform elementary row operations\r\n  //   for (i = 0; i < dim; i += 1) {\r\n  //     // get the element e on the diagonal\r\n  //     e = copy[i][i];\r\n\r\n  //     // if we have a 0 on the diagonal (we'll need to swap with a lower row)\r\n  //     if (e == 0) {\r\n  //       //look through every row below the i'th row\r\n  //       for (ii = i + 1; ii < dim; ii += 1) {\r\n  //         //if the ii'th row has a non-0 in the i'th col\r\n  //         if (copy[ii][i] != 0) {\r\n  //           //it would make the diagonal have a non-0 so swap it\r\n  //           for (j = 0; j < dim; j++) {\r\n  //             e = copy[i][j]; //temp store i'th row\r\n  //             copy[i][j] = copy[ii][j]; //replace i'th row by ii'th\r\n  //             copy[ii][j] = e; //repace ii'th by temp\r\n  //             e = identifier[i][j]; //temp store i'th row\r\n  //             identifier[i][j] = identifier[ii][j]; //replace i'th row by ii'th\r\n  //             identifier[ii][j] = e; //repace ii'th by temp\r\n  //           }\r\n  //           //don't bother checking other rows since we've swapped\r\n  //           break;\r\n  //         }\r\n  //       }\r\n  //       //get the new diagonal\r\n  //       e = copy[i][i];\r\n  //       //if it's still 0, not invertable (error)\r\n  //       if (e == 0) {\r\n  //         return;\r\n  //       }\r\n  //     }\r\n\r\n  //     // Scale this row down by e (so we have a 1 on the diagonal)\r\n  //     for (j = 0; j < dim; j++) {\r\n  //       copy[i][j] = copy[i][j] / e; //apply to original matrix\r\n  //       identifier[i][j] = identifier[i][j] / e; //apply to identity\r\n  //     }\r\n\r\n  //     // Subtract this row (scaled appropriately for each row) from ALL of\r\n  //     // the other rows so that there will be 0's in this column in the\r\n  //     // rows above and below this one\r\n  //     for (ii = 0; ii < dim; ii++) {\r\n  //       // Only apply to other rows (we want a 1 on the diagonal)\r\n  //       if (ii == i) {\r\n  //         continue;\r\n  //       }\r\n\r\n  //       // We want to change this element to 0\r\n  //       e = copy[ii][i];\r\n\r\n  //       // Subtract (the row above(or below) scaled by e) from (the\r\n  //       // current row) but start at the i'th column and assume all the\r\n  //       // stuff left of diagonal is 0 (which it should be if we made this\r\n  //       // algorithm correctly)\r\n  //       for (j = 0; j < dim; j++) {\r\n  //         copy[ii][j] -= e * copy[i][j]; //apply to original matrix\r\n  //         identifier[ii][j] -= e * identifier[i][j]; //apply to identity\r\n  //       }\r\n  //     }\r\n  //   }\r\n\r\n  //   //we've done all operations, C should be the identity\r\n  //   //matrix I should be the inverse:\r\n  //   return identifier;\r\n  // }\r\n\r\n  private createCopy(matrix) {\r\n    let dim = matrix.length,\r\n      copy = [];\r\n    for (let i = 0; i < dim; i += 1) {\r\n      copy[copy.length] = [];\r\n      for (let j = 0; j < dim; j += 1) {\r\n        copy[i][j] = matrix[i][j];\r\n      }\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  private LogMatrix(matrix: number[][]) {\r\n    for (let i = 0; i < matrix.length; i++) {\r\n      const element = matrix[i];\r\n      let log: string = \"[\";\r\n      for (let j = 0; j < element.length; j++) {\r\n        log += element[j];\r\n        if (j < element.length - 1) log += \",\";\r\n      }\r\n      log += \"]\";\r\n      console.log(log);\r\n    }\r\n  }\r\n\r\n  /// Register a contact filter to provide specific control over collision.\r\n  /// Otherwise the default filter is used (b2_defaultFilter). The listener is\r\n  /// owned by you and must remain in scope.\r\n  public SetContactFilter(filter: b2ContactFilter): void {\r\n    this.m_contactManager.m_contactFilter = filter;\r\n  }\r\n\r\n  /// Register a contact event listener. The listener is owned by you and must\r\n  /// remain in scope.\r\n  public SetContactListener(listener: b2ContactListener): void {\r\n    this.m_contactManager.m_contactListener = listener;\r\n  }\r\n\r\n  /// Register a routine for debug drawing. The debug draw functions are called\r\n  /// inside with b2World::DrawDebugData method. The debug draw object is owned\r\n  /// by you and must remain in scope.\r\n  public SetDebugDraw(debugDraw: b2Draw | null): void {\r\n    this.m_debugDraw = debugDraw;\r\n  }\r\n\r\n  /// Create a rigid body given a definition. No reference to the definition\r\n  /// is retained.\r\n  /// @warning This function is locked during callbacks.\r\n  public CreateBody(def: b2IBodyDef = {}): b2Body {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    const b: b2Body = new b2Body(def, this);\r\n\r\n    // Add to world doubly linked list.\r\n    b.m_prev = null;\r\n    b.m_next = this.m_bodyList;\r\n    if (this.m_bodyList) {\r\n      this.m_bodyList.m_prev = b;\r\n    }\r\n    this.m_bodyList = b;\r\n    ++this.m_bodyCount;\r\n\r\n    return b;\r\n  }\r\n\r\n  /// Destroy a rigid body given a definition. No reference to the definition\r\n  /// is retained. This function is locked during callbacks.\r\n  /// @warning This automatically deletes all associated shapes and joints.\r\n  /// @warning This function is locked during callbacks.\r\n  public DestroyBody(b: b2Body): void {\r\n    // DEBUG: b2Assert(this.m_bodyCount > 0);\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    // Delete the attached joints.\r\n    let je: b2JointEdge | null = b.m_jointList;\r\n    while (je) {\r\n      const je0: b2JointEdge = je;\r\n      je = je.next;\r\n\r\n      if (this.m_destructionListener) {\r\n        this.m_destructionListener.SayGoodbyeJoint(je0.joint);\r\n      }\r\n\r\n      this.DestroyJoint(je0.joint);\r\n\r\n      b.m_jointList = je;\r\n    }\r\n    b.m_jointList = null;\r\n\r\n    // #if B2_ENABLE_CONTROLLER\r\n    // @see b2Controller list\r\n    let coe: b2ControllerEdge | null = b.m_controllerList;\r\n    while (coe) {\r\n      const coe0: b2ControllerEdge = coe;\r\n      coe = coe.nextController;\r\n      coe0.controller.RemoveBody(b);\r\n    }\r\n    // #endif\r\n\r\n    // Delete the attached contacts.\r\n    let ce: b2ContactEdge | null = b.m_contactList;\r\n    while (ce) {\r\n      const ce0: b2ContactEdge = ce;\r\n      ce = ce.next;\r\n      this.m_contactManager.Destroy(ce0.contact);\r\n    }\r\n    b.m_contactList = null;\r\n\r\n    // Delete the attached fixtures. This destroys broad-phase proxies.\r\n    let f: b2Fixture | null = b.m_fixtureList;\r\n    while (f) {\r\n      const f0: b2Fixture = f;\r\n      f = f.m_next;\r\n\r\n      if (this.m_destructionListener) {\r\n        this.m_destructionListener.SayGoodbyeFixture(f0);\r\n      }\r\n\r\n      f0.DestroyProxies();\r\n      f0.Reset();\r\n\r\n      b.m_fixtureList = f;\r\n      b.m_fixtureCount -= 1;\r\n    }\r\n    b.m_fixtureList = null;\r\n    b.m_fixtureCount = 0;\r\n\r\n    // Remove world body list.\r\n    if (b.m_prev) {\r\n      b.m_prev.m_next = b.m_next;\r\n    }\r\n\r\n    if (b.m_next) {\r\n      b.m_next.m_prev = b.m_prev;\r\n    }\r\n\r\n    if (b === this.m_bodyList) {\r\n      this.m_bodyList = b.m_next;\r\n    }\r\n\r\n    --this.m_bodyCount;\r\n  }\r\n\r\n  private static _Joint_Create(def: b2IJointDef): b2Joint {\r\n    switch (def.type) {\r\n      case b2JointType.e_distanceJoint:\r\n        return new b2DistanceJoint(def as b2IDistanceJointDef);\r\n      case b2JointType.e_mouseJoint:\r\n        return new b2MouseJoint(def as b2IMouseJointDef);\r\n      case b2JointType.e_prismaticJoint:\r\n        return new b2PrismaticJoint(def as b2IPrismaticJointDef);\r\n      case b2JointType.e_revoluteJoint:\r\n        return new b2RevoluteJoint(def as b2IRevoluteJointDef);\r\n      case b2JointType.e_pulleyJoint:\r\n        return new b2PulleyJoint(def as b2IPulleyJointDef);\r\n      case b2JointType.e_gearJoint:\r\n        return new b2GearJoint(def as b2IGearJointDef);\r\n      case b2JointType.e_wheelJoint:\r\n        return new b2WheelJoint(def as b2IWheelJointDef);\r\n      case b2JointType.e_weldJoint:\r\n        return new b2WeldJoint(def as b2IWeldJointDef);\r\n      case b2JointType.e_frictionJoint:\r\n        return new b2FrictionJoint(def as b2IFrictionJointDef);\r\n      case b2JointType.e_ropeJoint:\r\n        return new b2RopeJoint(def as b2IRopeJointDef);\r\n      case b2JointType.e_motorJoint:\r\n        return new b2MotorJoint(def as b2IMotorJointDef);\r\n      case b2JointType.e_areaJoint:\r\n        return new b2AreaJoint(def as b2IAreaJointDef);\r\n    }\r\n    throw new Error();\r\n  }\r\n\r\n  private static _Joint_Destroy(joint: b2Joint): void {}\r\n\r\n  /// Create a joint to constrain bodies together. No reference to the definition\r\n  /// is retained. This may cause the connected bodies to cease colliding.\r\n  /// @warning This function is locked during callbacks.\r\n  public CreateJoint(def: b2IAreaJointDef): b2AreaJoint;\r\n  public CreateJoint(def: b2IDistanceJointDef): b2DistanceJoint;\r\n  public CreateJoint(def: b2IFrictionJointDef): b2FrictionJoint;\r\n  public CreateJoint(def: b2IGearJointDef): b2GearJoint;\r\n  public CreateJoint(def: b2IMotorJointDef): b2MotorJoint;\r\n  public CreateJoint(def: b2IMouseJointDef): b2MouseJoint;\r\n  public CreateJoint(def: b2IPrismaticJointDef): b2PrismaticJoint;\r\n  public CreateJoint(def: b2IPulleyJointDef): b2PulleyJoint;\r\n  public CreateJoint(def: b2IRevoluteJointDef): b2RevoluteJoint;\r\n  public CreateJoint(def: b2IRopeJointDef): b2RopeJoint;\r\n  public CreateJoint(def: b2IWeldJointDef): b2WeldJoint;\r\n  public CreateJoint(def: b2IWheelJointDef): b2WheelJoint;\r\n  public CreateJoint(def: b2IJointDef): b2Joint {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    const j: b2Joint = b2World._Joint_Create(def);\r\n\r\n    // Connect to the world list.\r\n    j.m_prev = null;\r\n    j.m_next = this.m_jointList;\r\n    if (this.m_jointList) {\r\n      this.m_jointList.m_prev = j;\r\n    }\r\n    this.m_jointList = j;\r\n    ++this.m_jointCount;\r\n\r\n    // Connect to the bodies' doubly linked lists.\r\n    // j.m_edgeA.other = j.m_bodyB; // done in b2Joint constructor\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = j.m_bodyA.m_jointList;\r\n    if (j.m_bodyA.m_jointList) {\r\n      j.m_bodyA.m_jointList.prev = j.m_edgeA;\r\n    }\r\n    j.m_bodyA.m_jointList = j.m_edgeA;\r\n\r\n    // j.m_edgeB.other = j.m_bodyA; // done in b2Joint constructor\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = j.m_bodyB.m_jointList;\r\n    if (j.m_bodyB.m_jointList) {\r\n      j.m_bodyB.m_jointList.prev = j.m_edgeB;\r\n    }\r\n    j.m_bodyB.m_jointList = j.m_edgeB;\r\n\r\n    const bodyA: b2Body = j.m_bodyA;\r\n    const bodyB: b2Body = j.m_bodyB;\r\n    const collideConnected: boolean = j.m_collideConnected;\r\n\r\n    // If the joint prevents collisions, then flag any contacts for filtering.\r\n    if (!collideConnected) {\r\n      let edge: b2ContactEdge | null = bodyB.GetContactList();\r\n      while (edge) {\r\n        if (edge.other === bodyA) {\r\n          // Flag the contact for filtering at the next time step (where either\r\n          // body is awake).\r\n          edge.contact.FlagForFiltering();\r\n        }\r\n\r\n        edge = edge.next;\r\n      }\r\n    }\r\n\r\n    // Note: creating a joint doesn't wake the bodies.\r\n\r\n    return j;\r\n  }\r\n\r\n  /// Destroy a joint. This may cause the connected bodies to begin colliding.\r\n  /// @warning This function is locked during callbacks.\r\n  public DestroyJoint(j: b2Joint): void {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    // Remove from the doubly linked list.\r\n    if (j.m_prev) {\r\n      j.m_prev.m_next = j.m_next;\r\n    }\r\n\r\n    if (j.m_next) {\r\n      j.m_next.m_prev = j.m_prev;\r\n    }\r\n\r\n    if (j === this.m_jointList) {\r\n      this.m_jointList = j.m_next;\r\n    }\r\n\r\n    // Disconnect from island graph.\r\n    const bodyA: b2Body = j.m_bodyA;\r\n    const bodyB: b2Body = j.m_bodyB;\r\n    const collideConnected: boolean = j.m_collideConnected;\r\n\r\n    // Wake up connected bodies.\r\n    bodyA.SetAwake(true);\r\n    bodyB.SetAwake(true);\r\n\r\n    // Remove from body 1.\r\n    if (j.m_edgeA.prev) {\r\n      j.m_edgeA.prev.next = j.m_edgeA.next;\r\n    }\r\n\r\n    if (j.m_edgeA.next) {\r\n      j.m_edgeA.next.prev = j.m_edgeA.prev;\r\n    }\r\n\r\n    if (j.m_edgeA === bodyA.m_jointList) {\r\n      bodyA.m_jointList = j.m_edgeA.next;\r\n    }\r\n\r\n    j.m_edgeA.Reset();\r\n\r\n    // Remove from body 2\r\n    if (j.m_edgeB.prev) {\r\n      j.m_edgeB.prev.next = j.m_edgeB.next;\r\n    }\r\n\r\n    if (j.m_edgeB.next) {\r\n      j.m_edgeB.next.prev = j.m_edgeB.prev;\r\n    }\r\n\r\n    if (j.m_edgeB === bodyB.m_jointList) {\r\n      bodyB.m_jointList = j.m_edgeB.next;\r\n    }\r\n\r\n    j.m_edgeB.Reset();\r\n\r\n    b2World._Joint_Destroy(j);\r\n\r\n    // DEBUG: b2Assert(this.m_jointCount > 0);\r\n    --this.m_jointCount;\r\n\r\n    // If the joint prevents collisions, then flag any contacts for filtering.\r\n    if (!collideConnected) {\r\n      let edge: b2ContactEdge | null = bodyB.GetContactList();\r\n      while (edge) {\r\n        if (edge.other === bodyA) {\r\n          // Flag the contact for filtering at the next time step (where either\r\n          // body is awake).\r\n          edge.contact.FlagForFiltering();\r\n        }\r\n\r\n        edge = edge.next;\r\n      }\r\n    }\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n\r\n  public CreateParticleSystem(def: b2ParticleSystemDef): b2ParticleSystem {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    const p = new b2ParticleSystem(def, this);\r\n\r\n    // Add to world doubly linked list.\r\n    p.m_prev = null;\r\n    p.m_next = this.m_particleSystemList;\r\n    if (this.m_particleSystemList) {\r\n      this.m_particleSystemList.m_prev = p;\r\n    }\r\n    this.m_particleSystemList = p;\r\n\r\n    return p;\r\n  }\r\n\r\n  public DestroyParticleSystem(p: b2ParticleSystem): void {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    // Remove world particleSystem list.\r\n    if (p.m_prev) {\r\n      p.m_prev.m_next = p.m_next;\r\n    }\r\n\r\n    if (p.m_next) {\r\n      p.m_next.m_prev = p.m_prev;\r\n    }\r\n\r\n    if (p === this.m_particleSystemList) {\r\n      this.m_particleSystemList = p.m_next;\r\n    }\r\n  }\r\n\r\n  public CalculateReasonableParticleIterations(timeStep: number): number {\r\n    if (this.m_particleSystemList === null) {\r\n      return 1;\r\n    }\r\n\r\n    function GetSmallestRadius(world: b2World): number {\r\n      let smallestRadius = b2_maxFloat;\r\n      for (\r\n        let system = world.GetParticleSystemList();\r\n        system !== null;\r\n        system = system.m_next\r\n      ) {\r\n        smallestRadius = b2Min(smallestRadius, system.GetRadius());\r\n      }\r\n      return smallestRadius;\r\n    }\r\n\r\n    // Use the smallest radius, since that represents the worst-case.\r\n    return b2CalculateParticleIterations(\r\n      this.m_gravity.Length(),\r\n      GetSmallestRadius(this),\r\n      timeStep\r\n    );\r\n  }\r\n\r\n  // #endif\r\n\r\n  /// Take a time step. This performs collision detection, integration,\r\n  /// and constraint solution.\r\n  /// @param timeStep the amount of time to simulate, this should not vary.\r\n  /// @param velocityIterations for the velocity constraint solver.\r\n  /// @param positionIterations for the position constraint solver.\r\n  private static Step_s_step = new b2TimeStep();\r\n  private static Step_s_stepTimer = new b2Timer();\r\n  private static Step_s_timer = new b2Timer();\r\n  // #if B2_ENABLE_PARTICLE\r\n  public Step(\r\n    dt: number,\r\n    velocityIterations: number,\r\n    positionIterations: number,\r\n    particleIterations: number = this.CalculateReasonableParticleIterations(dt)\r\n  ): void {\r\n    // #else\r\n    // public Step(dt: number, velocityIterations: number, positionIterations: number): void {\r\n    // #endif\r\n    const stepTimer: b2Timer = b2World.Step_s_stepTimer.Reset();\r\n\r\n    // If new fixtures were added, we need to find the new contacts.\r\n    if (this.m_newFixture) {\r\n      this.m_contactManager.FindNewContacts();\r\n      this.m_newFixture = false;\r\n    }\r\n\r\n    this.m_locked = true;\r\n\r\n    const step: b2TimeStep = b2World.Step_s_step;\r\n    step.dt = dt;\r\n    step.velocityIterations = velocityIterations;\r\n    step.positionIterations = positionIterations;\r\n    // #if B2_ENABLE_PARTICLE\r\n    step.particleIterations = particleIterations;\r\n    // #endif\r\n    if (dt > 0) {\r\n      step.inv_dt = 1 / dt;\r\n    } else {\r\n      step.inv_dt = 0;\r\n    }\r\n\r\n    step.dtRatio = this.m_inv_dt0 * dt;\r\n\r\n    step.warmStarting = this.m_warmStarting;\r\n\r\n    // Update contacts. This is where some contacts are destroyed.\r\n    const timer: b2Timer = b2World.Step_s_timer.Reset();\r\n    this.m_contactManager.Collide();\r\n    this.m_profile.collide = timer.GetMilliseconds();\r\n\r\n    // Integrate velocities, solve velocity constraints, and integrate positions.\r\n    if (this.m_stepComplete && step.dt > 0) {\r\n      const timer: b2Timer = b2World.Step_s_timer.Reset();\r\n      // #if B2_ENABLE_PARTICLE\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        p.Solve(step); // Particle Simulation\r\n      }\r\n      // #endif\r\n      this.Solve(step);\r\n      this.m_profile.solve = timer.GetMilliseconds();\r\n    }\r\n\r\n    // Handle TOI events.\r\n    if (this.m_continuousPhysics && step.dt > 0) {\r\n      const timer: b2Timer = b2World.Step_s_timer.Reset();\r\n      this.SolveTOI(step);\r\n      this.m_profile.solveTOI = timer.GetMilliseconds();\r\n    }\r\n\r\n    if (step.dt > 0) {\r\n      this.m_inv_dt0 = step.inv_dt;\r\n    }\r\n\r\n    if (this.m_clearForces) {\r\n      this.ClearForces();\r\n    }\r\n\r\n    this.m_locked = false;\r\n\r\n    this.m_profile.step = stepTimer.GetMilliseconds();\r\n  }\r\n\r\n  /// Manually clear the force buffer on all bodies. By default, forces are cleared automatically\r\n  /// after each call to Step. The default behavior is modified by calling SetAutoClearForces.\r\n  /// The purpose of this function is to support sub-stepping. Sub-stepping is often used to maintain\r\n  /// a fixed sized time step under a variable frame-rate.\r\n  /// When you perform sub-stepping you will disable auto clearing of forces and instead call\r\n  /// ClearForces after all sub-steps are complete in one pass of your game loop.\r\n  /// @see SetAutoClearForces\r\n  public ClearForces(): void {\r\n    for (let body = this.m_bodyList; body; body = body.m_next) {\r\n      body.m_force.SetZero();\r\n      body.m_torque = 0;\r\n    }\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n\r\n  public DrawParticleSystem(system: b2ParticleSystem): void {\r\n    if (this.m_debugDraw === null) {\r\n      return;\r\n    }\r\n    const particleCount = system.GetParticleCount();\r\n    if (particleCount) {\r\n      const radius = system.GetRadius();\r\n      const positionBuffer = system.GetPositionBuffer();\r\n      if (system.m_colorBuffer.data) {\r\n        const colorBuffer = system.GetColorBuffer();\r\n        this.m_debugDraw.DrawParticles(\r\n          positionBuffer,\r\n          radius,\r\n          colorBuffer,\r\n          particleCount\r\n        );\r\n      } else {\r\n        this.m_debugDraw.DrawParticles(\r\n          positionBuffer,\r\n          radius,\r\n          null,\r\n          particleCount\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  // #endif\r\n\r\n  /// Call this to draw shapes and other debug draw data.\r\n  private static DrawDebugData_s_color = new b2Color(0, 0, 0);\r\n  private static DrawDebugData_s_vs = b2Vec2.MakeArray(4);\r\n  private static DrawDebugData_s_xf = new b2Transform();\r\n  public DrawDebugData(): void {\r\n    if (this.m_debugDraw === null) {\r\n      return;\r\n    }\r\n\r\n    const flags: number = this.m_debugDraw.GetFlags();\r\n    const color: b2Color = b2World.DrawDebugData_s_color.SetRGB(0, 0, 0);\r\n\r\n    if (flags & b2DrawFlags.e_shapeBit) {\r\n      for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n        const xf: b2Transform = b.m_xf;\r\n\r\n        this.m_debugDraw.PushTransform(xf);\r\n\r\n        for (let f: b2Fixture | null = b.GetFixtureList(); f; f = f.m_next) {\r\n          if (!b.IsActive()) {\r\n            color.SetRGB(0.5, 0.5, 0.3);\r\n            this.DrawShape(f, color);\r\n          } else if (b.GetType() === b2BodyType.b2_staticBody) {\r\n            color.SetRGB(0.5, 0.9, 0.5);\r\n            this.DrawShape(f, color);\r\n          } else if (b.GetType() === b2BodyType.b2_kinematicBody) {\r\n            color.SetRGB(0.5, 0.5, 0.9);\r\n            this.DrawShape(f, color);\r\n          } else if (!b.IsAwake()) {\r\n            color.SetRGB(0.6, 0.6, 0.6);\r\n            this.DrawShape(f, color);\r\n          } else {\r\n            color.SetRGB(0.9, 0.7, 0.7);\r\n            this.DrawShape(f, color);\r\n          }\r\n        }\r\n\r\n        this.m_debugDraw.PopTransform(xf);\r\n      }\r\n    }\r\n\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (flags & b2DrawFlags.e_particleBit) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        this.DrawParticleSystem(p);\r\n      }\r\n    }\r\n    // #endif\r\n\r\n    if (flags & b2DrawFlags.e_jointBit) {\r\n      for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n        this.DrawJoint(j);\r\n      }\r\n    }\r\n\r\n    /*\r\n    if (flags & b2DrawFlags.e_pairBit) {\r\n      color.SetRGB(0.3, 0.9, 0.9);\r\n      for (let contact = this.m_contactManager.m_contactList; contact; contact = contact.m_next) {\r\n        const fixtureA = contact.GetFixtureA();\r\n        const fixtureB = contact.GetFixtureB();\r\n\r\n        const cA = fixtureA.GetAABB().GetCenter();\r\n        const cB = fixtureB.GetAABB().GetCenter();\r\n\r\n        this.m_debugDraw.DrawSegment(cA, cB, color);\r\n      }\r\n    }\r\n    */\r\n\r\n    if (flags & b2DrawFlags.e_aabbBit) {\r\n      color.SetRGB(0.9, 0.3, 0.9);\r\n      const vs: b2Vec2[] = b2World.DrawDebugData_s_vs;\r\n\r\n      for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n        if (!b.IsActive()) {\r\n          continue;\r\n        }\r\n\r\n        for (let f: b2Fixture | null = b.GetFixtureList(); f; f = f.m_next) {\r\n          for (let i: number = 0; i < f.m_proxyCount; ++i) {\r\n            const proxy: b2FixtureProxy = f.m_proxies[i];\r\n\r\n            const aabb: b2AABB = proxy.treeNode.aabb;\r\n            vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);\r\n            vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);\r\n            vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);\r\n            vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);\r\n\r\n            this.m_debugDraw.DrawPolygon(vs, 4, color);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (flags & b2DrawFlags.e_centerOfMassBit) {\r\n      for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n        const xf: b2Transform = b2World.DrawDebugData_s_xf;\r\n        xf.q.Copy(b.m_xf.q);\r\n        xf.p.Copy(b.GetWorldCenter());\r\n        this.m_debugDraw.DrawTransform(xf);\r\n      }\r\n    }\r\n\r\n    // #if B2_ENABLE_CONTROLLER\r\n    // @see b2Controller list\r\n    if (flags & b2DrawFlags.e_controllerBit) {\r\n      for (let c = this.m_controllerList; c; c = c.m_next) {\r\n        c.Draw(this.m_debugDraw);\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  /// Query the world for all fixtures that potentially overlap the\r\n  /// provided AABB.\r\n  /// @param callback a user implemented callback class.\r\n  /// @param aabb the query box.\r\n  public QueryAABB(callback: b2QueryCallback, aabb: b2AABB): void;\r\n  public QueryAABB(aabb: b2AABB, fn: b2QueryCallbackFunction): void;\r\n  public QueryAABB(...args: any[]): void {\r\n    if (args[0] instanceof b2QueryCallback) {\r\n      this._QueryAABB(args[0], args[1]);\r\n    } else {\r\n      this._QueryAABB(null, args[0], args[1]);\r\n    }\r\n  }\r\n  private _QueryAABB(\r\n    callback: b2QueryCallback | null,\r\n    aabb: b2AABB,\r\n    fn?: b2QueryCallbackFunction\r\n  ): void {\r\n    this.m_contactManager.m_broadPhase.Query(\r\n      aabb,\r\n      (proxy: b2TreeNode<b2FixtureProxy>): boolean => {\r\n        const fixture_proxy: b2FixtureProxy = proxy.userData;\r\n        // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n        const fixture: b2Fixture = fixture_proxy.fixture;\r\n        if (callback) {\r\n          return callback.ReportFixture(fixture);\r\n        } else if (fn) {\r\n          return fn(fixture);\r\n        }\r\n        return true;\r\n      }\r\n    );\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (callback instanceof b2QueryCallback) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        if (callback.ShouldQueryParticleSystem(p)) {\r\n          p.QueryAABB(callback, aabb);\r\n        }\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  public QueryAllAABB(aabb: b2AABB, out: b2Fixture[] = []): b2Fixture[] {\r\n    this.QueryAABB(aabb, (fixture: b2Fixture): boolean => {\r\n      out.push(fixture);\r\n      return true;\r\n    });\r\n    return out;\r\n  }\r\n\r\n  /// Query the world for all fixtures that potentially overlap the\r\n  /// provided point.\r\n  /// @param callback a user implemented callback class.\r\n  /// @param point the query point.\r\n  public QueryPointAABB(callback: b2QueryCallback, point: XY): void;\r\n  public QueryPointAABB(point: XY, fn: b2QueryCallbackFunction): void;\r\n  public QueryPointAABB(...args: any[]): void {\r\n    if (args[0] instanceof b2QueryCallback) {\r\n      this._QueryPointAABB(args[0], args[1]);\r\n    } else {\r\n      this._QueryPointAABB(null, args[0], args[1]);\r\n    }\r\n  }\r\n  private _QueryPointAABB(\r\n    callback: b2QueryCallback | null,\r\n    point: XY,\r\n    fn?: b2QueryCallbackFunction\r\n  ): void {\r\n    this.m_contactManager.m_broadPhase.QueryPoint(\r\n      point,\r\n      (proxy: b2TreeNode<b2FixtureProxy>): boolean => {\r\n        const fixture_proxy: b2FixtureProxy = proxy.userData;\r\n        // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n        const fixture: b2Fixture = fixture_proxy.fixture;\r\n        if (callback) {\r\n          return callback.ReportFixture(fixture);\r\n        } else if (fn) {\r\n          return fn(fixture);\r\n        }\r\n        return true;\r\n      }\r\n    );\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (callback instanceof b2QueryCallback) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        if (callback.ShouldQueryParticleSystem(p)) {\r\n          p.QueryPointAABB(callback, point);\r\n        }\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  public QueryAllPointAABB(point: XY, out: b2Fixture[] = []): b2Fixture[] {\r\n    this.QueryPointAABB(point, (fixture: b2Fixture): boolean => {\r\n      out.push(fixture);\r\n      return true;\r\n    });\r\n    return out;\r\n  }\r\n\r\n  public QueryFixtureShape(\r\n    callback: b2QueryCallback,\r\n    shape: b2Shape,\r\n    index: number,\r\n    transform: b2Transform\r\n  ): void;\r\n  public QueryFixtureShape(\r\n    shape: b2Shape,\r\n    index: number,\r\n    transform: b2Transform,\r\n    fn: b2QueryCallbackFunction\r\n  ): void;\r\n  public QueryFixtureShape(...args: any[]): void {\r\n    if (args[0] instanceof b2QueryCallback) {\r\n      this._QueryFixtureShape(args[0], args[1], args[2], args[3]);\r\n    } else {\r\n      this._QueryFixtureShape(null, args[0], args[1], args[2], args[3]);\r\n    }\r\n  }\r\n  private static QueryFixtureShape_s_aabb = new b2AABB();\r\n  private _QueryFixtureShape(\r\n    callback: b2QueryCallback | null,\r\n    shape: b2Shape,\r\n    index: number,\r\n    transform: b2Transform,\r\n    fn?: b2QueryCallbackFunction\r\n  ): void {\r\n    const aabb: b2AABB = b2World.QueryFixtureShape_s_aabb;\r\n    shape.ComputeAABB(aabb, transform, index);\r\n    this.m_contactManager.m_broadPhase.Query(\r\n      aabb,\r\n      (proxy: b2TreeNode<b2FixtureProxy>): boolean => {\r\n        const fixture_proxy: b2FixtureProxy = proxy.userData;\r\n        // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n        const fixture: b2Fixture = fixture_proxy.fixture;\r\n        if (\r\n          b2TestOverlapShape(\r\n            shape,\r\n            index,\r\n            fixture.GetShape(),\r\n            fixture_proxy.childIndex,\r\n            transform,\r\n            fixture.GetBody().GetTransform()\r\n          )\r\n        ) {\r\n          if (callback) {\r\n            return callback.ReportFixture(fixture);\r\n          } else if (fn) {\r\n            return fn(fixture);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    );\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (callback instanceof b2QueryCallback) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        if (callback.ShouldQueryParticleSystem(p)) {\r\n          p.QueryAABB(callback, aabb);\r\n        }\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  public QueryAllFixtureShape(\r\n    shape: b2Shape,\r\n    index: number,\r\n    transform: b2Transform,\r\n    out: b2Fixture[] = []\r\n  ): b2Fixture[] {\r\n    this.QueryFixtureShape(\r\n      shape,\r\n      index,\r\n      transform,\r\n      (fixture: b2Fixture): boolean => {\r\n        out.push(fixture);\r\n        return true;\r\n      }\r\n    );\r\n    return out;\r\n  }\r\n\r\n  public QueryFixturePoint(callback: b2QueryCallback, point: XY): void;\r\n  public QueryFixturePoint(point: XY, fn: b2QueryCallbackFunction): void;\r\n  public QueryFixturePoint(...args: any[]): void {\r\n    if (args[0] instanceof b2QueryCallback) {\r\n      this._QueryFixturePoint(args[0], args[1]);\r\n    } else {\r\n      this._QueryFixturePoint(null, args[0], args[1]);\r\n    }\r\n  }\r\n  private _QueryFixturePoint(\r\n    callback: b2QueryCallback | null,\r\n    point: XY,\r\n    fn?: b2QueryCallbackFunction\r\n  ): void {\r\n    this.m_contactManager.m_broadPhase.QueryPoint(\r\n      point,\r\n      (proxy: b2TreeNode<b2FixtureProxy>): boolean => {\r\n        const fixture_proxy: b2FixtureProxy = proxy.userData;\r\n        // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n        const fixture: b2Fixture = fixture_proxy.fixture;\r\n        if (fixture.TestPoint(point)) {\r\n          if (callback) {\r\n            return callback.ReportFixture(fixture);\r\n          } else if (fn) {\r\n            return fn(fixture);\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    );\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (callback) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        if (callback.ShouldQueryParticleSystem(p)) {\r\n          p.QueryPointAABB(callback, point);\r\n        }\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  public QueryAllFixturePoint(point: XY, out: b2Fixture[] = []): b2Fixture[] {\r\n    this.QueryFixturePoint(point, (fixture: b2Fixture): boolean => {\r\n      out.push(fixture);\r\n      return true;\r\n    });\r\n    return out;\r\n  }\r\n\r\n  /// Ray-cast the world for all fixtures in the path of the ray. Your callback\r\n  /// controls whether you get the closest point, any point, or n-points.\r\n  /// The ray-cast ignores shapes that contain the starting point.\r\n  /// @param callback a user implemented callback class.\r\n  /// @param point1 the ray starting point\r\n  /// @param point2 the ray ending point\r\n  public RayCast(callback: b2RayCastCallback, point1: XY, point2: XY): void;\r\n  public RayCast(point1: XY, point2: XY, fn: b2RayCastCallbackFunction): void;\r\n  public RayCast(...args: any[]): void {\r\n    if (args[0] instanceof b2RayCastCallback) {\r\n      this._RayCast(args[0], args[1], args[2]);\r\n    } else {\r\n      this._RayCast(null, args[0], args[1], args[2]);\r\n    }\r\n  }\r\n  private static RayCast_s_input = new b2RayCastInput();\r\n  private static RayCast_s_output = new b2RayCastOutput();\r\n  private static RayCast_s_point = new b2Vec2();\r\n  private _RayCast(\r\n    callback: b2RayCastCallback | null,\r\n    point1: XY,\r\n    point2: XY,\r\n    fn?: b2RayCastCallbackFunction\r\n  ): void {\r\n    const input: b2RayCastInput = b2World.RayCast_s_input;\r\n    input.maxFraction = 1;\r\n    input.p1.Copy(point1);\r\n    input.p2.Copy(point2);\r\n    this.m_contactManager.m_broadPhase.RayCast(\r\n      input,\r\n      (input: b2RayCastInput, proxy: b2TreeNode<b2FixtureProxy>): number => {\r\n        const fixture_proxy: b2FixtureProxy = proxy.userData;\r\n        // DEBUG: b2Assert(fixture_proxy instanceof b2FixtureProxy);\r\n        const fixture: b2Fixture = fixture_proxy.fixture;\r\n        const index: number = fixture_proxy.childIndex;\r\n        const output: b2RayCastOutput = b2World.RayCast_s_output;\r\n        const hit: boolean = fixture.RayCast(output, input, index);\r\n        if (hit) {\r\n          const fraction: number = output.fraction;\r\n          const point: b2Vec2 = b2World.RayCast_s_point;\r\n          point.Set(\r\n            (1 - fraction) * point1.x + fraction * point2.x,\r\n            (1 - fraction) * point1.y + fraction * point2.y\r\n          );\r\n          if (callback) {\r\n            return callback.ReportFixture(\r\n              fixture,\r\n              point,\r\n              output.normal,\r\n              fraction\r\n            );\r\n          } else if (fn) {\r\n            return fn(fixture, point, output.normal, fraction);\r\n          }\r\n        }\r\n        return input.maxFraction;\r\n      }\r\n    );\r\n    // #if B2_ENABLE_PARTICLE\r\n    if (callback) {\r\n      for (let p = this.m_particleSystemList; p; p = p.m_next) {\r\n        if (callback.ShouldQueryParticleSystem(p)) {\r\n          p.RayCast(callback, point1, point2);\r\n        }\r\n      }\r\n    }\r\n    // #endif\r\n  }\r\n\r\n  public RayCastOne(point1: XY, point2: XY): b2Fixture | null {\r\n    let result: b2Fixture | null = null;\r\n    let min_fraction: number = 1;\r\n    this.RayCast(\r\n      point1,\r\n      point2,\r\n      (\r\n        fixture: b2Fixture,\r\n        point: b2Vec2,\r\n        normal: b2Vec2,\r\n        fraction: number\r\n      ): number => {\r\n        if (fraction < min_fraction) {\r\n          min_fraction = fraction;\r\n          result = fixture;\r\n        }\r\n        return min_fraction;\r\n      }\r\n    );\r\n    return result;\r\n  }\r\n\r\n  public RayCastAll(\r\n    point1: XY,\r\n    point2: XY,\r\n    out: b2Fixture[] = []\r\n  ): b2Fixture[] {\r\n    this.RayCast(\r\n      point1,\r\n      point2,\r\n      (\r\n        fixture: b2Fixture,\r\n        point: b2Vec2,\r\n        normal: b2Vec2,\r\n        fraction: number\r\n      ): number => {\r\n        out.push(fixture);\r\n        return 1;\r\n      }\r\n    );\r\n    return out;\r\n  }\r\n\r\n  /// Get the world body list. With the returned body, use b2Body::GetNext to get\r\n  /// the next body in the world list. A NULL body indicates the end of the list.\r\n  /// @return the head of the world body list.\r\n  public GetBodyList(): b2Body | null {\r\n    return this.m_bodyList;\r\n  }\r\n\r\n  /// Get the world joint list. With the returned joint, use b2Joint::GetNext to get\r\n  /// the next joint in the world list. A NULL joint indicates the end of the list.\r\n  /// @return the head of the world joint list.\r\n  public GetJointList(): b2Joint | null {\r\n    return this.m_jointList;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  public GetParticleSystemList(): b2ParticleSystem | null {\r\n    return this.m_particleSystemList;\r\n  }\r\n  // #endif\r\n\r\n  /// Get the world contact list. With the returned contact, use b2Contact::GetNext to get\r\n  /// the next contact in the world list. A NULL contact indicates the end of the list.\r\n  /// @return the head of the world contact list.\r\n  /// @warning contacts are created and destroyed in the middle of a time step.\r\n  /// Use b2ContactListener to avoid missing contacts.\r\n  public GetContactList(): b2Contact | null {\r\n    return this.m_contactManager.m_contactList;\r\n  }\r\n\r\n  /// Enable/disable sleep.\r\n  public SetAllowSleeping(flag: boolean): void {\r\n    if (flag === this.m_allowSleep) {\r\n      return;\r\n    }\r\n\r\n    this.m_allowSleep = flag;\r\n    if (!this.m_allowSleep) {\r\n      for (let b = this.m_bodyList; b; b = b.m_next) {\r\n        b.SetAwake(true);\r\n      }\r\n    }\r\n  }\r\n\r\n  public GetAllowSleeping(): boolean {\r\n    return this.m_allowSleep;\r\n  }\r\n\r\n  /// Enable/disable warm starting. For testing.\r\n  public SetWarmStarting(flag: boolean): void {\r\n    this.m_warmStarting = flag;\r\n  }\r\n\r\n  public GetWarmStarting(): boolean {\r\n    return this.m_warmStarting;\r\n  }\r\n\r\n  /// Enable/disable continuous physics. For testing.\r\n  public SetContinuousPhysics(flag: boolean): void {\r\n    this.m_continuousPhysics = flag;\r\n  }\r\n\r\n  public GetContinuousPhysics(): boolean {\r\n    return this.m_continuousPhysics;\r\n  }\r\n\r\n  /// Enable/disable single stepped continuous physics. For testing.\r\n  public SetSubStepping(flag: boolean): void {\r\n    this.m_subStepping = flag;\r\n  }\r\n\r\n  public GetSubStepping(): boolean {\r\n    return this.m_subStepping;\r\n  }\r\n\r\n  /// Get the number of broad-phase proxies.\r\n  public GetProxyCount(): number {\r\n    return this.m_contactManager.m_broadPhase.GetProxyCount();\r\n  }\r\n\r\n  /// Get the number of bodies.\r\n  public GetBodyCount(): number {\r\n    return this.m_bodyCount;\r\n  }\r\n\r\n  /// Get the number of joints.\r\n  public GetJointCount(): number {\r\n    return this.m_jointCount;\r\n  }\r\n\r\n  /// Get the number of contacts (each may have 0 or more contact points).\r\n  public GetContactCount(): number {\r\n    return this.m_contactManager.m_contactCount;\r\n  }\r\n\r\n  /// Get the height of the dynamic tree.\r\n  public GetTreeHeight(): number {\r\n    return this.m_contactManager.m_broadPhase.GetTreeHeight();\r\n  }\r\n\r\n  /// Get the balance of the dynamic tree.\r\n  public GetTreeBalance(): number {\r\n    return this.m_contactManager.m_broadPhase.GetTreeBalance();\r\n  }\r\n\r\n  /// Get the quality metric of the dynamic tree. The smaller the better.\r\n  /// The minimum is 1.\r\n  public GetTreeQuality(): number {\r\n    return this.m_contactManager.m_broadPhase.GetTreeQuality();\r\n  }\r\n\r\n  /// Change the global gravity vector.\r\n  public SetGravity(gravity: XY, wake: boolean = true) {\r\n    if (!b2Vec2.IsEqualToV(this.m_gravity, gravity)) {\r\n      this.m_gravity.Copy(gravity);\r\n\r\n      if (wake) {\r\n        for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n          b.SetAwake(true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// Get the global gravity vector.\r\n  public GetGravity(): Readonly<b2Vec2> {\r\n    return this.m_gravity;\r\n  }\r\n\r\n  /// Is the world locked (in the middle of a time step).\r\n  public IsLocked(): boolean {\r\n    return this.m_locked;\r\n  }\r\n\r\n  /// Set flag to control automatic clearing of forces after each time step.\r\n  public SetAutoClearForces(flag: boolean): void {\r\n    this.m_clearForces = flag;\r\n  }\r\n\r\n  /// Get the flag that controls automatic clearing of forces after each time step.\r\n  public GetAutoClearForces(): boolean {\r\n    return this.m_clearForces;\r\n  }\r\n\r\n  /// Shift the world origin. Useful for large worlds.\r\n  /// The body shift formula is: position -= newOrigin\r\n  /// @param newOrigin the new origin with respect to the old origin\r\n  public ShiftOrigin(newOrigin: XY): void {\r\n    if (this.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n      b.m_xf.p.SelfSub(newOrigin);\r\n      b.m_sweep.c0.SelfSub(newOrigin);\r\n      b.m_sweep.c.SelfSub(newOrigin);\r\n    }\r\n\r\n    for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n      j.ShiftOrigin(newOrigin);\r\n    }\r\n\r\n    this.m_contactManager.m_broadPhase.ShiftOrigin(newOrigin);\r\n  }\r\n\r\n  /// Get the contact manager for testing.\r\n  public GetContactManager(): b2ContactManager {\r\n    return this.m_contactManager;\r\n  }\r\n\r\n  /// Get the current profile.\r\n  public GetProfile(): b2Profile {\r\n    return this.m_profile;\r\n  }\r\n\r\n  /// Dump the world into the log file.\r\n  /// @warning this should be called outside of a time step.\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    if (this.m_locked) {\r\n      return;\r\n    }\r\n\r\n    log(\r\n      \"const g: b2Vec2 = new b2Vec2(%.15f, %.15f);\\n\",\r\n      this.m_gravity.x,\r\n      this.m_gravity.y\r\n    );\r\n    log(\"this.m_world.SetGravity(g);\\n\");\r\n\r\n    log(\"const bodies: b2Body[] = [];\\n\");\r\n    log(\"const joints: b2Joint[] = [];\\n\");\r\n    let i: number = 0;\r\n    for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n      b.m_islandIndex = i;\r\n      b.Dump(log);\r\n      ++i;\r\n    }\r\n\r\n    i = 0;\r\n    for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n      j.m_index = i;\r\n      ++i;\r\n    }\r\n\r\n    // First pass on joints, skip gear joints.\r\n    for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n      if (j.m_type === b2JointType.e_gearJoint) {\r\n        continue;\r\n      }\r\n\r\n      log(\"{\\n\");\r\n      j.Dump(log);\r\n      log(\"}\\n\");\r\n    }\r\n\r\n    // Second pass on joints, only gear joints.\r\n    for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n      if (j.m_type !== b2JointType.e_gearJoint) {\r\n        continue;\r\n      }\r\n\r\n      log(\"{\\n\");\r\n      j.Dump(log);\r\n      log(\"}\\n\");\r\n    }\r\n  }\r\n\r\n  private static DrawJoint_s_p1: b2Vec2 = new b2Vec2();\r\n  private static DrawJoint_s_p2: b2Vec2 = new b2Vec2();\r\n  private static DrawJoint_s_color: b2Color = new b2Color(0.5, 0.8, 0.8);\r\n  private static DrawJoint_s_c: b2Color = new b2Color();\r\n  public DrawJoint(joint: b2Joint): void {\r\n    if (this.m_debugDraw === null) {\r\n      return;\r\n    }\r\n    const bodyA: b2Body = joint.GetBodyA();\r\n    const bodyB: b2Body = joint.GetBodyB();\r\n    const xf1: b2Transform = bodyA.m_xf;\r\n    const xf2: b2Transform = bodyB.m_xf;\r\n    const x1: b2Vec2 = xf1.p;\r\n    const x2: b2Vec2 = xf2.p;\r\n    const p1: b2Vec2 = joint.GetAnchorA(b2World.DrawJoint_s_p1);\r\n    const p2: b2Vec2 = joint.GetAnchorB(b2World.DrawJoint_s_p2);\r\n\r\n    const color: b2Color = b2World.DrawJoint_s_color.SetRGB(0.5, 0.8, 0.8);\r\n\r\n    switch (joint.m_type) {\r\n      case b2JointType.e_distanceJoint:\r\n        this.m_debugDraw.DrawSegment(p1, p2, color);\r\n        break;\r\n\r\n      case b2JointType.e_pulleyJoint: {\r\n        const pulley: b2PulleyJoint = joint as b2PulleyJoint;\r\n        const s1: b2Vec2 = pulley.GetGroundAnchorA();\r\n        const s2: b2Vec2 = pulley.GetGroundAnchorB();\r\n        this.m_debugDraw.DrawSegment(s1, p1, color);\r\n        this.m_debugDraw.DrawSegment(s2, p2, color);\r\n        this.m_debugDraw.DrawSegment(s1, s2, color);\r\n        break;\r\n      }\r\n\r\n      case b2JointType.e_mouseJoint: {\r\n        const c = b2World.DrawJoint_s_c;\r\n        c.Set(0.0, 1.0, 0.0);\r\n        this.m_debugDraw.DrawPoint(p1, 4.0, c);\r\n        this.m_debugDraw.DrawPoint(p2, 4.0, c);\r\n\r\n        c.Set(0.8, 0.8, 0.8);\r\n        this.m_debugDraw.DrawSegment(p1, p2, c);\r\n        break;\r\n      }\r\n\r\n      default:\r\n        this.m_debugDraw.DrawSegment(x1, p1, color);\r\n        this.m_debugDraw.DrawSegment(p1, p2, color);\r\n        this.m_debugDraw.DrawSegment(x2, p2, color);\r\n    }\r\n  }\r\n\r\n  private static DrawShape_s_ghostColor: b2Color = new b2Color();\r\n  public DrawShape(fixture: b2Fixture, color: b2Color): void {\r\n    if (this.m_debugDraw === null) {\r\n      return;\r\n    }\r\n    const shape: b2Shape = fixture.GetShape();\r\n\r\n    switch (shape.m_type) {\r\n      case b2ShapeType.e_circleShape: {\r\n        const circle: b2CircleShape = shape as b2CircleShape;\r\n        const center: b2Vec2 = circle.m_p;\r\n        const radius: number = circle.m_radius;\r\n        const axis: b2Vec2 = b2Vec2.UNITX;\r\n        this.m_debugDraw.DrawSolidCircle(center, radius, axis, color);\r\n        break;\r\n      }\r\n\r\n      case b2ShapeType.e_edgeShape: {\r\n        const edge: b2EdgeShape = shape as b2EdgeShape;\r\n        const v1: b2Vec2 = edge.m_vertex1;\r\n        const v2: b2Vec2 = edge.m_vertex2;\r\n        this.m_debugDraw.DrawSegment(v1, v2, color);\r\n        break;\r\n      }\r\n\r\n      case b2ShapeType.e_chainShape: {\r\n        const chain: b2ChainShape = shape as b2ChainShape;\r\n        const count: number = chain.m_count;\r\n        const vertices: b2Vec2[] = chain.m_vertices;\r\n        const ghostColor: b2Color = b2World.DrawShape_s_ghostColor.SetRGBA(\r\n          0.75 * color.r,\r\n          0.75 * color.g,\r\n          0.75 * color.b,\r\n          color.a\r\n        );\r\n        let v1: b2Vec2 = vertices[0];\r\n        this.m_debugDraw.DrawPoint(v1, 4.0, color);\r\n\r\n        if (chain.m_hasPrevVertex) {\r\n          const vp = chain.m_prevVertex;\r\n          this.m_debugDraw.DrawSegment(vp, v1, ghostColor);\r\n          this.m_debugDraw.DrawCircle(vp, 0.1, ghostColor);\r\n        }\r\n\r\n        for (let i: number = 1; i < count; ++i) {\r\n          const v2: b2Vec2 = vertices[i];\r\n          this.m_debugDraw.DrawSegment(v1, v2, color);\r\n          this.m_debugDraw.DrawPoint(v2, 4.0, color);\r\n          v1 = v2;\r\n        }\r\n\r\n        if (chain.m_hasNextVertex) {\r\n          const vn = chain.m_nextVertex;\r\n          this.m_debugDraw.DrawSegment(vn, v1, ghostColor);\r\n          this.m_debugDraw.DrawCircle(vn, 0.1, ghostColor);\r\n        }\r\n        break;\r\n      }\r\n\r\n      case b2ShapeType.e_polygonShape: {\r\n        const poly: b2PolygonShape = shape as b2PolygonShape;\r\n        const vertexCount: number = poly.m_count;\r\n        const vertices: b2Vec2[] = poly.m_vertices;\r\n        this.m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  public Solve(step: b2TimeStep): void {\r\n    // #if B2_ENABLE_PARTICLE\r\n    // update previous transforms\r\n    for (let b = this.m_bodyList; b; b = b.m_next) {\r\n      b.m_xf0.Copy(b.m_xf);\r\n    }\r\n    // #endif\r\n\r\n    // #if B2_ENABLE_CONTROLLER\r\n    // @see b2Controller list\r\n    for (\r\n      let controller = this.m_controllerList;\r\n      controller;\r\n      controller = controller.m_next\r\n    ) {\r\n      controller.Step(step);\r\n    }\r\n    // #endif\r\n\r\n    this.m_profile.solveInit = 0;\r\n    this.m_profile.solveVelocity = 0;\r\n    this.m_profile.solvePosition = 0;\r\n\r\n    // Size the island for the worst case.\r\n    const island: b2Island = this.m_island;\r\n    island.Initialize(\r\n      this.m_bodyCount,\r\n      this.m_contactManager.m_contactCount,\r\n      this.m_jointCount,\r\n      this.m_contactManager.m_contactListener\r\n    );\r\n\r\n    // Clear all the island flags.\r\n    for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n      b.m_islandFlag = false;\r\n    }\r\n    for (\r\n      let c: b2Contact | null = this.m_contactManager.m_contactList;\r\n      c;\r\n      c = c.m_next\r\n    ) {\r\n      c.m_islandFlag = false;\r\n    }\r\n    for (let j: b2Joint | null = this.m_jointList; j; j = j.m_next) {\r\n      j.m_islandFlag = false;\r\n    }\r\n\r\n    // Build and simulate all awake islands.\r\n    // DEBUG: const stackSize: number = this.m_bodyCount;\r\n    const stack: Array<b2Body | null> = this.s_stack;\r\n    for (let seed: b2Body | null = this.m_bodyList; seed; seed = seed.m_next) {\r\n      if (seed.m_islandFlag) {\r\n        continue;\r\n      }\r\n\r\n      if (!seed.IsAwake() || !seed.IsActive()) {\r\n        continue;\r\n      }\r\n\r\n      // The seed can be dynamic or kinematic.\r\n      if (seed.GetType() === b2BodyType.b2_staticBody) {\r\n        continue;\r\n      }\r\n\r\n      // Reset island and stack.\r\n      island.Clear();\r\n      let stackCount: number = 0;\r\n      stack[stackCount++] = seed;\r\n      seed.m_islandFlag = true;\r\n\r\n      // Perform a depth first search (DFS) on the constraint graph.\r\n      while (stackCount > 0) {\r\n        // Grab the next body off the stack and add it to the island.\r\n        const b: b2Body | null = stack[--stackCount];\r\n        if (!b) {\r\n          throw new Error();\r\n        }\r\n        // DEBUG: b2Assert(b.IsActive());\r\n        island.AddBody(b);\r\n\r\n        // Make sure the body is awake. (without resetting sleep timer).\r\n        b.m_awakeFlag = true;\r\n\r\n        // To keep islands as small as possible, we don't\r\n        // propagate islands across static bodies.\r\n        if (b.GetType() === b2BodyType.b2_staticBody) {\r\n          continue;\r\n        }\r\n\r\n        // Search all contacts connected to this body.\r\n        for (let ce: b2ContactEdge | null = b.m_contactList; ce; ce = ce.next) {\r\n          const contact: b2Contact = ce.contact;\r\n\r\n          // Has this contact already been added to an island?\r\n          if (contact.m_islandFlag) {\r\n            continue;\r\n          }\r\n\r\n          // Is this contact solid and touching?\r\n          if (!contact.IsEnabled() || !contact.IsTouching()) {\r\n            continue;\r\n          }\r\n\r\n          // Skip sensors.\r\n          const sensorA: boolean = contact.m_fixtureA.m_isSensor;\r\n          const sensorB: boolean = contact.m_fixtureB.m_isSensor;\r\n          if (sensorA || sensorB) {\r\n            continue;\r\n          }\r\n\r\n          island.AddContact(contact);\r\n          contact.m_islandFlag = true;\r\n\r\n          const other: b2Body = ce.other;\r\n\r\n          // Was the other body already added to this island?\r\n          if (other.m_islandFlag) {\r\n            continue;\r\n          }\r\n\r\n          // DEBUG: b2Assert(stackCount < stackSize);\r\n          stack[stackCount++] = other;\r\n          other.m_islandFlag = true;\r\n        }\r\n\r\n        // Search all joints connect to this body.\r\n        for (let je: b2JointEdge | null = b.m_jointList; je; je = je.next) {\r\n          if (je.joint.m_islandFlag) {\r\n            continue;\r\n          }\r\n\r\n          const other: b2Body = je.other;\r\n\r\n          // Don't simulate joints connected to inactive bodies.\r\n          if (!other.IsActive()) {\r\n            continue;\r\n          }\r\n\r\n          island.AddJoint(je.joint);\r\n          je.joint.m_islandFlag = true;\r\n\r\n          if (other.m_islandFlag) {\r\n            continue;\r\n          }\r\n\r\n          // DEBUG: b2Assert(stackCount < stackSize);\r\n          stack[stackCount++] = other;\r\n          other.m_islandFlag = true;\r\n        }\r\n      }\r\n\r\n      const profile: b2Profile = new b2Profile();\r\n      island.Solve(profile, step, this.m_gravity, this.m_allowSleep);\r\n      this.m_profile.solveInit += profile.solveInit;\r\n      this.m_profile.solveVelocity += profile.solveVelocity;\r\n      this.m_profile.solvePosition += profile.solvePosition;\r\n\r\n      // Post solve cleanup.\r\n      for (let i: number = 0; i < island.m_bodyCount; ++i) {\r\n        // Allow static bodies to participate in other islands.\r\n        const b: b2Body = island.m_bodies[i];\r\n        if (b.GetType() === b2BodyType.b2_staticBody) {\r\n          b.m_islandFlag = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i: number = 0; i < stack.length; ++i) {\r\n      if (!stack[i]) {\r\n        break;\r\n      }\r\n      stack[i] = null;\r\n    }\r\n\r\n    const timer: b2Timer = new b2Timer();\r\n\r\n    // Synchronize fixtures, check for out of range bodies.\r\n    for (let b = this.m_bodyList; b; b = b.m_next) {\r\n      // If a body was not in an island then it did not move.\r\n      if (!b.m_islandFlag) {\r\n        continue;\r\n      }\r\n\r\n      if (b.GetType() === b2BodyType.b2_staticBody) {\r\n        continue;\r\n      }\r\n\r\n      // Update fixtures (for broad-phase).\r\n      b.SynchronizeFixtures();\r\n    }\r\n\r\n    // Look for new contacts.\r\n    this.m_contactManager.FindNewContacts();\r\n    this.m_profile.broadphase = timer.GetMilliseconds();\r\n  }\r\n\r\n  private static SolveTOI_s_subStep = new b2TimeStep();\r\n  private static SolveTOI_s_backup = new b2Sweep();\r\n  private static SolveTOI_s_backup1 = new b2Sweep();\r\n  private static SolveTOI_s_backup2 = new b2Sweep();\r\n  private static SolveTOI_s_toi_input = new b2TOIInput();\r\n  private static SolveTOI_s_toi_output = new b2TOIOutput();\r\n  public SolveTOI(step: b2TimeStep): void {\r\n    const island: b2Island = this.m_island;\r\n    island.Initialize(\r\n      2 * b2_maxTOIContacts,\r\n      b2_maxTOIContacts,\r\n      0,\r\n      this.m_contactManager.m_contactListener\r\n    );\r\n\r\n    if (this.m_stepComplete) {\r\n      for (let b: b2Body | null = this.m_bodyList; b; b = b.m_next) {\r\n        b.m_islandFlag = false;\r\n        b.m_sweep.alpha0 = 0;\r\n      }\r\n\r\n      for (\r\n        let c: b2Contact | null = this.m_contactManager.m_contactList;\r\n        c;\r\n        c = c.m_next\r\n      ) {\r\n        // Invalidate TOI\r\n        c.m_toiFlag = false;\r\n        c.m_islandFlag = false;\r\n        c.m_toiCount = 0;\r\n        c.m_toi = 1;\r\n      }\r\n    }\r\n\r\n    // Find TOI events and solve them.\r\n    for (;;) {\r\n      // Find the first TOI.\r\n      let minContact: b2Contact | null = null;\r\n      let minAlpha: number = 1;\r\n\r\n      for (\r\n        let c: b2Contact | null = this.m_contactManager.m_contactList;\r\n        c;\r\n        c = c.m_next\r\n      ) {\r\n        // Is this contact disabled?\r\n        if (!c.IsEnabled()) {\r\n          continue;\r\n        }\r\n\r\n        // Prevent excessive sub-stepping.\r\n        if (c.m_toiCount > b2_maxSubSteps) {\r\n          continue;\r\n        }\r\n\r\n        let alpha: number = 1;\r\n        if (c.m_toiFlag) {\r\n          // This contact has a valid cached TOI.\r\n          alpha = c.m_toi;\r\n        } else {\r\n          const fA: b2Fixture = c.GetFixtureA();\r\n          const fB: b2Fixture = c.GetFixtureB();\r\n\r\n          // Is there a sensor?\r\n          if (fA.IsSensor() || fB.IsSensor()) {\r\n            continue;\r\n          }\r\n\r\n          const bA: b2Body = fA.GetBody();\r\n          const bB: b2Body = fB.GetBody();\r\n\r\n          const typeA: b2BodyType = bA.m_type;\r\n          const typeB: b2BodyType = bB.m_type;\r\n          // DEBUG: b2Assert(typeA !== b2BodyType.b2_staticBody || typeB !== b2BodyType.b2_staticBody);\r\n\r\n          const activeA: boolean =\r\n            bA.IsAwake() && typeA !== b2BodyType.b2_staticBody;\r\n          const activeB: boolean =\r\n            bB.IsAwake() && typeB !== b2BodyType.b2_staticBody;\r\n\r\n          // Is at least one body active (awake and dynamic or kinematic)?\r\n          if (!activeA && !activeB) {\r\n            continue;\r\n          }\r\n\r\n          const collideA: boolean =\r\n            bA.IsBullet() || typeA !== b2BodyType.b2_dynamicBody;\r\n          const collideB: boolean =\r\n            bB.IsBullet() || typeB !== b2BodyType.b2_dynamicBody;\r\n\r\n          // Are these two non-bullet dynamic bodies?\r\n          if (!collideA && !collideB) {\r\n            continue;\r\n          }\r\n\r\n          // Compute the TOI for this contact.\r\n          // Put the sweeps onto the same time interval.\r\n          let alpha0: number = bA.m_sweep.alpha0;\r\n\r\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\r\n            alpha0 = bB.m_sweep.alpha0;\r\n            bA.m_sweep.Advance(alpha0);\r\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\r\n            alpha0 = bA.m_sweep.alpha0;\r\n            bB.m_sweep.Advance(alpha0);\r\n          }\r\n\r\n          // DEBUG: b2Assert(alpha0 < 1);\r\n\r\n          const indexA: number = c.GetChildIndexA();\r\n          const indexB: number = c.GetChildIndexB();\r\n\r\n          // Compute the time of impact in interval [0, minTOI]\r\n          const input: b2TOIInput = b2World.SolveTOI_s_toi_input;\r\n          input.proxyA.SetShape(fA.GetShape(), indexA);\r\n          input.proxyB.SetShape(fB.GetShape(), indexB);\r\n          input.sweepA.Copy(bA.m_sweep);\r\n          input.sweepB.Copy(bB.m_sweep);\r\n          input.tMax = 1;\r\n\r\n          const output: b2TOIOutput = b2World.SolveTOI_s_toi_output;\r\n          b2TimeOfImpact(output, input);\r\n\r\n          // Beta is the fraction of the remaining portion of the .\r\n          const beta: number = output.t;\r\n          if (output.state === b2TOIOutputState.e_touching) {\r\n            alpha = b2Min(alpha0 + (1 - alpha0) * beta, 1);\r\n          } else {\r\n            alpha = 1;\r\n          }\r\n\r\n          c.m_toi = alpha;\r\n          c.m_toiFlag = true;\r\n        }\r\n\r\n        if (alpha < minAlpha) {\r\n          // This is the minimum TOI found so far.\r\n          minContact = c;\r\n          minAlpha = alpha;\r\n        }\r\n      }\r\n\r\n      if (minContact === null || 1 - 10 * b2_epsilon < minAlpha) {\r\n        // No more TOI events. Done!\r\n        this.m_stepComplete = true;\r\n        break;\r\n      }\r\n\r\n      // Advance the bodies to the TOI.\r\n      const fA: b2Fixture = minContact.GetFixtureA();\r\n      const fB: b2Fixture = minContact.GetFixtureB();\r\n      const bA: b2Body = fA.GetBody();\r\n      const bB: b2Body = fB.GetBody();\r\n\r\n      const backup1: b2Sweep = b2World.SolveTOI_s_backup1.Copy(bA.m_sweep);\r\n      const backup2: b2Sweep = b2World.SolveTOI_s_backup2.Copy(bB.m_sweep);\r\n\r\n      bA.Advance(minAlpha);\r\n      bB.Advance(minAlpha);\r\n\r\n      // The TOI contact likely has some new contact points.\r\n      minContact.Update(this.m_contactManager.m_contactListener);\r\n      minContact.m_toiFlag = false;\r\n      ++minContact.m_toiCount;\r\n\r\n      // Is the contact solid?\r\n      if (!minContact.IsEnabled() || !minContact.IsTouching()) {\r\n        // Restore the sweeps.\r\n        minContact.SetEnabled(false);\r\n        bA.m_sweep.Copy(backup1);\r\n        bB.m_sweep.Copy(backup2);\r\n        bA.SynchronizeTransform();\r\n        bB.SynchronizeTransform();\r\n        continue;\r\n      }\r\n\r\n      bA.SetAwake(true);\r\n      bB.SetAwake(true);\r\n\r\n      // Build the island\r\n      island.Clear();\r\n      island.AddBody(bA);\r\n      island.AddBody(bB);\r\n      island.AddContact(minContact);\r\n\r\n      bA.m_islandFlag = true;\r\n      bB.m_islandFlag = true;\r\n      minContact.m_islandFlag = true;\r\n\r\n      // Get contacts on bodyA and bodyB.\r\n      // const bodies: b2Body[] = [bA, bB];\r\n      for (let i: number = 0; i < 2; ++i) {\r\n        const body: b2Body = i === 0 ? bA : bB; // bodies[i];\r\n        if (body.m_type === b2BodyType.b2_dynamicBody) {\r\n          for (\r\n            let ce: b2ContactEdge | null = body.m_contactList;\r\n            ce;\r\n            ce = ce.next\r\n          ) {\r\n            if (island.m_bodyCount === island.m_bodyCapacity) {\r\n              break;\r\n            }\r\n\r\n            if (island.m_contactCount === island.m_contactCapacity) {\r\n              break;\r\n            }\r\n\r\n            const contact: b2Contact = ce.contact;\r\n\r\n            // Has this contact already been added to the island?\r\n            if (contact.m_islandFlag) {\r\n              continue;\r\n            }\r\n\r\n            // Only add static, kinematic, or bullet bodies.\r\n            const other: b2Body = ce.other;\r\n            if (\r\n              other.m_type === b2BodyType.b2_dynamicBody &&\r\n              !body.IsBullet() &&\r\n              !other.IsBullet()\r\n            ) {\r\n              continue;\r\n            }\r\n\r\n            // Skip sensors.\r\n            const sensorA: boolean = contact.m_fixtureA.m_isSensor;\r\n            const sensorB: boolean = contact.m_fixtureB.m_isSensor;\r\n            if (sensorA || sensorB) {\r\n              continue;\r\n            }\r\n\r\n            // Tentatively advance the body to the TOI.\r\n            const backup: b2Sweep = b2World.SolveTOI_s_backup.Copy(\r\n              other.m_sweep\r\n            );\r\n            if (!other.m_islandFlag) {\r\n              other.Advance(minAlpha);\r\n            }\r\n\r\n            // Update the contact points\r\n            contact.Update(this.m_contactManager.m_contactListener);\r\n\r\n            // Was the contact disabled by the user?\r\n            if (!contact.IsEnabled()) {\r\n              other.m_sweep.Copy(backup);\r\n              other.SynchronizeTransform();\r\n              continue;\r\n            }\r\n\r\n            // Are there contact points?\r\n            if (!contact.IsTouching()) {\r\n              other.m_sweep.Copy(backup);\r\n              other.SynchronizeTransform();\r\n              continue;\r\n            }\r\n\r\n            // Add the contact to the island\r\n            contact.m_islandFlag = true;\r\n            island.AddContact(contact);\r\n\r\n            // Has the other body already been added to the island?\r\n            if (other.m_islandFlag) {\r\n              continue;\r\n            }\r\n\r\n            // Add the other body to the island.\r\n            other.m_islandFlag = true;\r\n\r\n            if (other.m_type !== b2BodyType.b2_staticBody) {\r\n              other.SetAwake(true);\r\n            }\r\n\r\n            island.AddBody(other);\r\n          }\r\n        }\r\n      }\r\n\r\n      const subStep: b2TimeStep = b2World.SolveTOI_s_subStep;\r\n      subStep.dt = (1 - minAlpha) * step.dt;\r\n      subStep.inv_dt = 1 / subStep.dt;\r\n      subStep.dtRatio = 1;\r\n      subStep.positionIterations = 20;\r\n      subStep.velocityIterations = step.velocityIterations;\r\n      // #if B2_ENABLE_PARTICLE\r\n      subStep.particleIterations = step.particleIterations;\r\n      // #endif\r\n      subStep.warmStarting = false;\r\n      island.SolveTOI(subStep, bA.m_islandIndex, bB.m_islandIndex);\r\n\r\n      // Reset island flags and synchronize broad-phase proxies.\r\n      for (let i: number = 0; i < island.m_bodyCount; ++i) {\r\n        const body: b2Body = island.m_bodies[i];\r\n        body.m_islandFlag = false;\r\n\r\n        if (body.m_type !== b2BodyType.b2_dynamicBody) {\r\n          continue;\r\n        }\r\n\r\n        body.SynchronizeFixtures();\r\n\r\n        // Invalidate all contact TOIs on this displaced body.\r\n        for (\r\n          let ce: b2ContactEdge | null = body.m_contactList;\r\n          ce;\r\n          ce = ce.next\r\n        ) {\r\n          ce.contact.m_toiFlag = false;\r\n          ce.contact.m_islandFlag = false;\r\n        }\r\n      }\r\n\r\n      // Commit fixture proxy movements to the broad-phase so that new contacts are created.\r\n      // Also, some contacts can be destroyed.\r\n      this.m_contactManager.FindNewContacts();\r\n\r\n      if (this.m_subStepping) {\r\n        this.m_stepComplete = false;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // #if B2_ENABLE_CONTROLLER\r\n  public AddController(controller: b2Controller): b2Controller {\r\n    // b2Assert(controller.m_world === null, \"Controller can only be a member of one world\");\r\n    // controller.m_world = this;\r\n    controller.m_next = this.m_controllerList;\r\n    controller.m_prev = null;\r\n    if (this.m_controllerList) {\r\n      this.m_controllerList.m_prev = controller;\r\n    }\r\n    this.m_controllerList = controller;\r\n    ++this.m_controllerCount;\r\n    return controller;\r\n  }\r\n\r\n  public RemoveController(controller: b2Controller): b2Controller {\r\n    // b2Assert(controller.m_world === this, \"Controller is not a member of this world\");\r\n    if (controller.m_prev) {\r\n      controller.m_prev.m_next = controller.m_next;\r\n    }\r\n    if (controller.m_next) {\r\n      controller.m_next.m_prev = controller.m_prev;\r\n    }\r\n    if (this.m_controllerList === controller) {\r\n      this.m_controllerList = controller.m_next;\r\n    }\r\n    --this.m_controllerCount;\r\n    controller.m_prev = null;\r\n    controller.m_next = null;\r\n    // delete controller.m_world; // = null;\r\n    return controller;\r\n  }\r\n  // #endif\r\n}\r\n"]}},"error":null,"hash":"856cee2ee2a35aba5956bf682594c0a7","cacheData":{"env":{}}}