{"id":"../node_modules/box2d.package.ts/Particle/b2ParticleSystem.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":33,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":34,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2Draw","loc":{"line":35,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Draw.ts"},{"name":"../Collision/b2Collision","loc":{"line":36,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"../Collision/Shapes/b2Shape","loc":{"line":37,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"},{"name":"../Collision/Shapes/b2EdgeShape","loc":{"line":38,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2EdgeShape.ts"},{"name":"../Dynamics/b2TimeStep","loc":{"line":39,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2TimeStep.ts"},{"name":"../Dynamics/b2WorldCallbacks","loc":{"line":40,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts"},{"name":"./b2Particle","loc":{"line":41,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2Particle.ts"},{"name":"./b2ParticleGroup","loc":{"line":42,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleGroup.ts"},{"name":"./b2VoronoiDiagram","loc":{"line":43,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2ParticleSystem.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Particle\\b2VoronoiDiagram.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n * Copyright (c) 2013 Google, Inc.\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// #if B2_ENABLE_PARTICLE\r\n// DEBUG: import { b2Assert, b2_maxParticleIndex } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Settings_2 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Draw_1 = require(\"../Common/b2Draw\");\r\nvar b2Collision_1 = require(\"../Collision/b2Collision\");\r\nvar b2Shape_1 = require(\"../Collision/Shapes/b2Shape\");\r\nvar b2EdgeShape_1 = require(\"../Collision/Shapes/b2EdgeShape\");\r\nvar b2TimeStep_1 = require(\"../Dynamics/b2TimeStep\");\r\nvar b2WorldCallbacks_1 = require(\"../Dynamics/b2WorldCallbacks\");\r\nvar b2Particle_1 = require(\"./b2Particle\");\r\nvar b2ParticleGroup_1 = require(\"./b2ParticleGroup\");\r\nvar b2VoronoiDiagram_1 = require(\"./b2VoronoiDiagram\");\r\nfunction std_iter_swap(array, a, b) {\r\n    var tmp = array[a];\r\n    array[a] = array[b];\r\n    array[b] = tmp;\r\n}\r\nfunction default_compare(a, b) { return a < b; }\r\nfunction std_sort(array, first, len, cmp) {\r\n    if (first === void 0) { first = 0; }\r\n    if (len === void 0) { len = array.length - first; }\r\n    if (cmp === void 0) { cmp = default_compare; }\r\n    var left = first;\r\n    var stack = [];\r\n    var pos = 0;\r\n    for (;;) { /* outer loop */\r\n        for (; left + 1 < len; len++) { /* sort left to len-1 */\r\n            var pivot = array[left + Math.floor(Math.random() * (len - left))]; /* pick random pivot */\r\n            stack[pos++] = len; /* sort right part later */\r\n            for (var right = left - 1;;) { /* inner loop: partitioning */\r\n                while (cmp(array[++right], pivot)) { } /* look for greater element */\r\n                while (cmp(pivot, array[--len])) { } /* look for smaller element */\r\n                if (right >= len) {\r\n                    break;\r\n                } /* partition point found? */\r\n                std_iter_swap(array, right, len); /* the only swap */\r\n            } /* partitioned, continue left part */\r\n        }\r\n        if (pos === 0) {\r\n            break;\r\n        } /* stack empty? */\r\n        left = len; /* left to right is sorted */\r\n        len = stack[--pos]; /* get next range to sort */\r\n    }\r\n    return array;\r\n}\r\nfunction std_stable_sort(array, first, len, cmp) {\r\n    if (first === void 0) { first = 0; }\r\n    if (len === void 0) { len = array.length - first; }\r\n    if (cmp === void 0) { cmp = default_compare; }\r\n    return std_sort(array, first, len, cmp);\r\n}\r\nfunction std_remove_if(array, predicate, length) {\r\n    if (length === void 0) { length = array.length; }\r\n    var l = 0;\r\n    for (var c = 0; c < length; ++c) {\r\n        // if we can be collapsed, keep l where it is.\r\n        if (predicate(array[c])) {\r\n            continue;\r\n        }\r\n        // this node can't be collapsed; push it back as far as we can.\r\n        if (c === l) {\r\n            ++l;\r\n            continue; // quick exit if we're already in the right spot\r\n        }\r\n        // array[l++] = array[c];\r\n        std_iter_swap(array, l++, c);\r\n    }\r\n    return l;\r\n}\r\nfunction std_lower_bound(array, first, last, val, cmp) {\r\n    var count = last - first;\r\n    while (count > 0) {\r\n        var step = Math.floor(count / 2);\r\n        var it = first + step;\r\n        if (cmp(array[it], val)) {\r\n            first = ++it;\r\n            count -= step + 1;\r\n        }\r\n        else {\r\n            count = step;\r\n        }\r\n    }\r\n    return first;\r\n}\r\nfunction std_upper_bound(array, first, last, val, cmp) {\r\n    var count = last - first;\r\n    while (count > 0) {\r\n        var step = Math.floor(count / 2);\r\n        var it = first + step;\r\n        if (!cmp(val, array[it])) {\r\n            first = ++it;\r\n            count -= step + 1;\r\n        }\r\n        else {\r\n            count = step;\r\n        }\r\n    }\r\n    return first;\r\n}\r\nfunction std_rotate(array, first, n_first, last) {\r\n    var next = n_first;\r\n    while (first !== next) {\r\n        std_iter_swap(array, first++, next++);\r\n        if (next === last) {\r\n            next = n_first;\r\n        }\r\n        else if (first === n_first) {\r\n            n_first = next;\r\n        }\r\n    }\r\n}\r\nfunction std_unique(array, first, last, cmp) {\r\n    if (first === last) {\r\n        return last;\r\n    }\r\n    var result = first;\r\n    while (++first !== last) {\r\n        if (!cmp(array[result], array[first])) {\r\n            ///array[++result] = array[first];\r\n            std_iter_swap(array, ++result, first);\r\n        }\r\n    }\r\n    return ++result;\r\n}\r\nvar b2GrowableBuffer = /** @class */ (function () {\r\n    function b2GrowableBuffer(allocator) {\r\n        this.data = [];\r\n        this.count = 0;\r\n        this.capacity = 0;\r\n        this.allocator = allocator;\r\n    }\r\n    b2GrowableBuffer.prototype.Append = function () {\r\n        if (this.count >= this.capacity) {\r\n            this.Grow();\r\n        }\r\n        return this.count++;\r\n    };\r\n    b2GrowableBuffer.prototype.Reserve = function (newCapacity) {\r\n        if (this.capacity >= newCapacity) {\r\n            return;\r\n        }\r\n        // DEBUG: b2Assert(this.capacity === this.data.length);\r\n        for (var i = this.capacity; i < newCapacity; ++i) {\r\n            this.data[i] = this.allocator();\r\n        }\r\n        this.capacity = newCapacity;\r\n    };\r\n    b2GrowableBuffer.prototype.Grow = function () {\r\n        // Double the capacity.\r\n        var newCapacity = this.capacity ? 2 * this.capacity : b2Settings_1.b2_minParticleSystemBufferCapacity;\r\n        // DEBUG: b2Assert(newCapacity > this.capacity);\r\n        this.Reserve(newCapacity);\r\n    };\r\n    b2GrowableBuffer.prototype.Free = function () {\r\n        if (this.data.length === 0) {\r\n            return;\r\n        }\r\n        this.data = [];\r\n        this.capacity = 0;\r\n        this.count = 0;\r\n    };\r\n    b2GrowableBuffer.prototype.Shorten = function (newEnd) {\r\n        // DEBUG: b2Assert(false);\r\n    };\r\n    b2GrowableBuffer.prototype.Data = function () {\r\n        return this.data;\r\n    };\r\n    b2GrowableBuffer.prototype.GetCount = function () {\r\n        return this.count;\r\n    };\r\n    b2GrowableBuffer.prototype.SetCount = function (newCount) {\r\n        // DEBUG: b2Assert(0 <= newCount && newCount <= this.capacity);\r\n        this.count = newCount;\r\n    };\r\n    b2GrowableBuffer.prototype.GetCapacity = function () {\r\n        return this.capacity;\r\n    };\r\n    b2GrowableBuffer.prototype.RemoveIf = function (pred) {\r\n        // DEBUG: let count = 0;\r\n        // DEBUG: for (let i = 0; i < this.count; ++i) {\r\n        // DEBUG:   if (!pred(this.data[i])) {\r\n        // DEBUG:     count++;\r\n        // DEBUG:   }\r\n        // DEBUG: }\r\n        this.count = std_remove_if(this.data, pred, this.count);\r\n        // DEBUG: b2Assert(count === this.count);\r\n    };\r\n    b2GrowableBuffer.prototype.Unique = function (pred) {\r\n        this.count = std_unique(this.data, 0, this.count, pred);\r\n    };\r\n    return b2GrowableBuffer;\r\n}());\r\nexports.b2GrowableBuffer = b2GrowableBuffer;\r\nvar b2FixtureParticleQueryCallback = /** @class */ (function (_super) {\r\n    __extends(b2FixtureParticleQueryCallback, _super);\r\n    function b2FixtureParticleQueryCallback(system) {\r\n        var _this = _super.call(this) || this;\r\n        _this.m_system = system;\r\n        return _this;\r\n    }\r\n    b2FixtureParticleQueryCallback.prototype.ShouldQueryParticleSystem = function (system) {\r\n        // Skip reporting particles.\r\n        return false;\r\n    };\r\n    b2FixtureParticleQueryCallback.prototype.ReportFixture = function (fixture) {\r\n        if (fixture.IsSensor()) {\r\n            return true;\r\n        }\r\n        var shape = fixture.GetShape();\r\n        var childCount = shape.GetChildCount();\r\n        for (var childIndex = 0; childIndex < childCount; childIndex++) {\r\n            var aabb = fixture.GetAABB(childIndex);\r\n            var enumerator = this.m_system.GetInsideBoundsEnumerator(aabb);\r\n            var index = void 0;\r\n            while ((index = enumerator.GetNext()) >= 0) {\r\n                this.ReportFixtureAndParticle(fixture, childIndex, index);\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    b2FixtureParticleQueryCallback.prototype.ReportParticle = function (system, index) {\r\n        return false;\r\n    };\r\n    b2FixtureParticleQueryCallback.prototype.ReportFixtureAndParticle = function (fixture, childIndex, index) {\r\n        // DEBUG: b2Assert(false); // pure virtual\r\n    };\r\n    return b2FixtureParticleQueryCallback;\r\n}(b2WorldCallbacks_1.b2QueryCallback));\r\nexports.b2FixtureParticleQueryCallback = b2FixtureParticleQueryCallback;\r\nvar b2ParticleContact = /** @class */ (function () {\r\n    function b2ParticleContact() {\r\n        this.indexA = 0;\r\n        this.indexB = 0;\r\n        this.weight = 0;\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.flags = 0;\r\n    }\r\n    b2ParticleContact.prototype.SetIndices = function (a, b) {\r\n        // DEBUG: b2Assert(a <= b2_maxParticleIndex && b <= b2_maxParticleIndex);\r\n        this.indexA = a;\r\n        this.indexB = b;\r\n    };\r\n    b2ParticleContact.prototype.SetWeight = function (w) {\r\n        this.weight = w;\r\n    };\r\n    b2ParticleContact.prototype.SetNormal = function (n) {\r\n        this.normal.Copy(n);\r\n    };\r\n    b2ParticleContact.prototype.SetFlags = function (f) {\r\n        this.flags = f;\r\n    };\r\n    b2ParticleContact.prototype.GetIndexA = function () {\r\n        return this.indexA;\r\n    };\r\n    b2ParticleContact.prototype.GetIndexB = function () {\r\n        return this.indexB;\r\n    };\r\n    b2ParticleContact.prototype.GetWeight = function () {\r\n        return this.weight;\r\n    };\r\n    b2ParticleContact.prototype.GetNormal = function () {\r\n        return this.normal;\r\n    };\r\n    b2ParticleContact.prototype.GetFlags = function () {\r\n        return this.flags;\r\n    };\r\n    b2ParticleContact.prototype.IsEqual = function (rhs) {\r\n        return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && this.weight === rhs.weight && this.normal.x === rhs.normal.x && this.normal.y === rhs.normal.y;\r\n    };\r\n    b2ParticleContact.prototype.IsNotEqual = function (rhs) {\r\n        return !this.IsEqual(rhs);\r\n    };\r\n    b2ParticleContact.prototype.ApproximatelyEqual = function (rhs) {\r\n        var MAX_WEIGHT_DIFF = 0.01; // Weight 0 ~ 1, so about 1%\r\n        var MAX_NORMAL_DIFF_SQ = 0.01 * 0.01; // Normal length = 1, so 1%\r\n        return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && b2Math_1.b2Abs(this.weight - rhs.weight) < MAX_WEIGHT_DIFF && b2Math_1.b2Vec2.DistanceSquaredVV(this.normal, rhs.normal) < MAX_NORMAL_DIFF_SQ;\r\n    };\r\n    return b2ParticleContact;\r\n}());\r\nexports.b2ParticleContact = b2ParticleContact;\r\nvar b2ParticleBodyContact = /** @class */ (function () {\r\n    function b2ParticleBodyContact() {\r\n        this.index = 0; // Index of the particle making contact.\r\n        this.weight = 0.0; // Weight of the contact. A value between 0.0f and 1.0f.\r\n        this.normal = new b2Math_1.b2Vec2(); // The normalized direction from the particle to the body.\r\n        this.mass = 0.0; // The effective mass used in calculating force.\r\n    }\r\n    return b2ParticleBodyContact;\r\n}());\r\nexports.b2ParticleBodyContact = b2ParticleBodyContact;\r\nvar b2ParticlePair = /** @class */ (function () {\r\n    function b2ParticlePair() {\r\n        this.indexA = 0; // Indices of the respective particles making pair.\r\n        this.indexB = 0;\r\n        this.flags = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.\r\n        this.strength = 0.0; // The strength of cohesion among the particles.\r\n        this.distance = 0.0; // The initial distance of the particles.\r\n    }\r\n    return b2ParticlePair;\r\n}());\r\nexports.b2ParticlePair = b2ParticlePair;\r\nvar b2ParticleTriad = /** @class */ (function () {\r\n    function b2ParticleTriad() {\r\n        this.indexA = 0; // Indices of the respective particles making triad.\r\n        this.indexB = 0;\r\n        this.indexC = 0;\r\n        this.flags = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.\r\n        this.strength = 0.0; // The strength of cohesion among the particles.\r\n        this.pa = new b2Math_1.b2Vec2(0.0, 0.0); // Values used for calculation.\r\n        this.pb = new b2Math_1.b2Vec2(0.0, 0.0);\r\n        this.pc = new b2Math_1.b2Vec2(0.0, 0.0);\r\n        this.ka = 0.0;\r\n        this.kb = 0.0;\r\n        this.kc = 0.0;\r\n        this.s = 0.0;\r\n    }\r\n    return b2ParticleTriad;\r\n}());\r\nexports.b2ParticleTriad = b2ParticleTriad;\r\nvar b2ParticleSystemDef = /** @class */ (function () {\r\n    function b2ParticleSystemDef() {\r\n        // Initialize physical coefficients to the maximum values that\r\n        // maintain numerical stability.\r\n        /**\r\n         * Enable strict Particle/Body contact check.\r\n         * See SetStrictContactCheck for details.\r\n         */\r\n        this.strictContactCheck = false;\r\n        /**\r\n         * Set the particle density.\r\n         * See SetDensity for details.\r\n         */\r\n        this.density = 1.0;\r\n        /**\r\n         * Change the particle gravity scale. Adjusts the effect of the\r\n         * global gravity vector on particles. Default value is 1.0f.\r\n         */\r\n        this.gravityScale = 1.0;\r\n        /**\r\n         * Particles behave as circles with this radius. In Box2D units.\r\n         */\r\n        this.radius = 1.0;\r\n        /**\r\n         * Set the maximum number of particles.\r\n         * By default, there is no maximum. The particle buffers can\r\n         * continue to grow while b2World's block allocator still has\r\n         * memory.\r\n         * See SetMaxParticleCount for details.\r\n         */\r\n        this.maxCount = 0;\r\n        /**\r\n         * Increases pressure in response to compression\r\n         * Smaller values allow more compression\r\n         */\r\n        this.pressureStrength = 0.005;\r\n        /**\r\n         * Reduces velocity along the collision normal\r\n         * Smaller value reduces less\r\n         */\r\n        this.dampingStrength = 1.0;\r\n        /**\r\n         * Restores shape of elastic particle groups\r\n         * Larger values increase elastic particle velocity\r\n         */\r\n        this.elasticStrength = 0.25;\r\n        /**\r\n         * Restores length of spring particle groups\r\n         * Larger values increase spring particle velocity\r\n         */\r\n        this.springStrength = 0.25;\r\n        /**\r\n         * Reduces relative velocity of viscous particles\r\n         * Larger values slow down viscous particles more\r\n         */\r\n        this.viscousStrength = 0.25;\r\n        /**\r\n         * Produces pressure on tensile particles\r\n         * 0~0.2. Larger values increase the amount of surface tension.\r\n         */\r\n        this.surfaceTensionPressureStrength = 0.2;\r\n        /**\r\n         * Smoothes outline of tensile particles\r\n         * 0~0.2. Larger values result in rounder, smoother,\r\n         * water-drop-like clusters of particles.\r\n         */\r\n        this.surfaceTensionNormalStrength = 0.2;\r\n        /**\r\n         * Produces additional pressure on repulsive particles\r\n         * Larger values repulse more\r\n         * Negative values mean attraction. The range where particles\r\n         * behave stably is about -0.2 to 2.0.\r\n         */\r\n        this.repulsiveStrength = 1.0;\r\n        /**\r\n         * Produces repulsion between powder particles\r\n         * Larger values repulse more\r\n         */\r\n        this.powderStrength = 0.5;\r\n        /**\r\n         * Pushes particles out of solid particle group\r\n         * Larger values repulse more\r\n         */\r\n        this.ejectionStrength = 0.5;\r\n        /**\r\n         * Produces static pressure\r\n         * Larger values increase the pressure on neighboring partilces\r\n         * For a description of static pressure, see\r\n         * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics\r\n         */\r\n        this.staticPressureStrength = 0.2;\r\n        /**\r\n         * Reduces instability in static pressure calculation\r\n         * Larger values make stabilize static pressure with fewer\r\n         * iterations\r\n         */\r\n        this.staticPressureRelaxation = 0.2;\r\n        /**\r\n         * Computes static pressure more precisely\r\n         * See SetStaticPressureIterations for details\r\n         */\r\n        this.staticPressureIterations = 8;\r\n        /**\r\n         * Determines how fast colors are mixed\r\n         * 1.0f ==> mixed immediately\r\n         * 0.5f ==> mixed half way each simulation step (see\r\n         * b2World::Step())\r\n         */\r\n        this.colorMixingStrength = 0.5;\r\n        /**\r\n         * Whether to destroy particles by age when no more particles\r\n         * can be created.  See #b2ParticleSystem::SetDestructionByAge()\r\n         * for more information.\r\n         */\r\n        this.destroyByAge = true;\r\n        /**\r\n         * Granularity of particle lifetimes in seconds.  By default\r\n         * this is set to (1.0f / 60.0f) seconds.  b2ParticleSystem uses\r\n         * a 32-bit signed value to track particle lifetimes so the\r\n         * maximum lifetime of a particle is (2^32 - 1) / (1.0f /\r\n         * lifetimeGranularity) seconds. With the value set to 1/60 the\r\n         * maximum lifetime or age of a particle is 2.27 years.\r\n         */\r\n        this.lifetimeGranularity = 1.0 / 60.0;\r\n    }\r\n    b2ParticleSystemDef.prototype.Copy = function (def) {\r\n        this.strictContactCheck = def.strictContactCheck;\r\n        this.density = def.density;\r\n        this.gravityScale = def.gravityScale;\r\n        this.radius = def.radius;\r\n        this.maxCount = def.maxCount;\r\n        this.pressureStrength = def.pressureStrength;\r\n        this.dampingStrength = def.dampingStrength;\r\n        this.elasticStrength = def.elasticStrength;\r\n        this.springStrength = def.springStrength;\r\n        this.viscousStrength = def.viscousStrength;\r\n        this.surfaceTensionPressureStrength = def.surfaceTensionPressureStrength;\r\n        this.surfaceTensionNormalStrength = def.surfaceTensionNormalStrength;\r\n        this.repulsiveStrength = def.repulsiveStrength;\r\n        this.powderStrength = def.powderStrength;\r\n        this.ejectionStrength = def.ejectionStrength;\r\n        this.staticPressureStrength = def.staticPressureStrength;\r\n        this.staticPressureRelaxation = def.staticPressureRelaxation;\r\n        this.staticPressureIterations = def.staticPressureIterations;\r\n        this.colorMixingStrength = def.colorMixingStrength;\r\n        this.destroyByAge = def.destroyByAge;\r\n        this.lifetimeGranularity = def.lifetimeGranularity;\r\n        return this;\r\n    };\r\n    b2ParticleSystemDef.prototype.Clone = function () {\r\n        return new b2ParticleSystemDef().Copy(this);\r\n    };\r\n    return b2ParticleSystemDef;\r\n}());\r\nexports.b2ParticleSystemDef = b2ParticleSystemDef;\r\nvar b2ParticleSystem = /** @class */ (function () {\r\n    function b2ParticleSystem(def, world) {\r\n        this.m_paused = false;\r\n        this.m_timestamp = 0;\r\n        this.m_allParticleFlags = 0;\r\n        this.m_needsUpdateAllParticleFlags = false;\r\n        this.m_allGroupFlags = 0;\r\n        this.m_needsUpdateAllGroupFlags = false;\r\n        this.m_hasForce = false;\r\n        this.m_iterationIndex = 0;\r\n        this.m_inverseDensity = 0.0;\r\n        this.m_particleDiameter = 0.0;\r\n        this.m_inverseDiameter = 0.0;\r\n        this.m_squaredDiameter = 0.0;\r\n        this.m_count = 0;\r\n        this.m_internalAllocatedCapacity = 0;\r\n        /**\r\n         * Allocator for b2ParticleHandle instances.\r\n         */\r\n        ///m_handleAllocator: any = null;\r\n        /**\r\n         * Maps particle indicies to handles.\r\n         */\r\n        this.m_handleIndexBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_flagsBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_positionBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_velocityBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_forceBuffer = [];\r\n        /**\r\n         * this.m_weightBuffer is populated in ComputeWeight and used in\r\n         * ComputeDepth(), SolveStaticPressure() and SolvePressure().\r\n         */\r\n        this.m_weightBuffer = [];\r\n        /**\r\n         * When any particles have the flag b2_staticPressureParticle,\r\n         * this.m_staticPressureBuffer is first allocated and used in\r\n         * SolveStaticPressure() and SolvePressure().  It will be\r\n         * reallocated on subsequent CreateParticle() calls.\r\n         */\r\n        this.m_staticPressureBuffer = [];\r\n        /**\r\n         * this.m_accumulationBuffer is used in many functions as a temporary\r\n         * buffer for scalar values.\r\n         */\r\n        this.m_accumulationBuffer = [];\r\n        /**\r\n         * When any particles have the flag b2_tensileParticle,\r\n         * this.m_accumulation2Buffer is first allocated and used in\r\n         * SolveTensile() as a temporary buffer for vector values.  It\r\n         * will be reallocated on subsequent CreateParticle() calls.\r\n         */\r\n        this.m_accumulation2Buffer = [];\r\n        /**\r\n         * When any particle groups have the flag b2_solidParticleGroup,\r\n         * this.m_depthBuffer is first allocated and populated in\r\n         * ComputeDepth() and used in SolveSolid(). It will be\r\n         * reallocated on subsequent CreateParticle() calls.\r\n         */\r\n        this.m_depthBuffer = [];\r\n        this.m_colorBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_groupBuffer = [];\r\n        this.m_userDataBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        /**\r\n         * Stuck particle detection parameters and record keeping\r\n         */\r\n        this.m_stuckThreshold = 0;\r\n        this.m_lastBodyContactStepBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_bodyContactCountBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_consecutiveContactStepsBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        this.m_stuckParticleBuffer = new b2GrowableBuffer(function () { return 0; });\r\n        this.m_proxyBuffer = new b2GrowableBuffer(function () { return new b2ParticleSystem_Proxy(); });\r\n        this.m_contactBuffer = new b2GrowableBuffer(function () { return new b2ParticleContact(); });\r\n        this.m_bodyContactBuffer = new b2GrowableBuffer(function () { return new b2ParticleBodyContact(); });\r\n        this.m_pairBuffer = new b2GrowableBuffer(function () { return new b2ParticlePair(); });\r\n        this.m_triadBuffer = new b2GrowableBuffer(function () { return new b2ParticleTriad(); });\r\n        /**\r\n         * Time each particle should be destroyed relative to the last\r\n         * time this.m_timeElapsed was initialized.  Each unit of time\r\n         * corresponds to b2ParticleSystemDef::lifetimeGranularity\r\n         * seconds.\r\n         */\r\n        this.m_expirationTimeBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        /**\r\n         * List of particle indices sorted by expiration time.\r\n         */\r\n        this.m_indexByExpirationTimeBuffer = new b2ParticleSystem_UserOverridableBuffer();\r\n        /**\r\n         * Time elapsed in 32:32 fixed point.  Each non-fractional unit\r\n         * of time corresponds to\r\n         * b2ParticleSystemDef::lifetimeGranularity seconds.\r\n         */\r\n        this.m_timeElapsed = 0;\r\n        /**\r\n         * Whether the expiration time buffer has been modified and\r\n         * needs to be resorted.\r\n         */\r\n        this.m_expirationTimeBufferRequiresSorting = false;\r\n        this.m_groupCount = 0;\r\n        this.m_groupList = null;\r\n        this.m_def = new b2ParticleSystemDef();\r\n        this.m_prev = null;\r\n        this.m_next = null;\r\n        this.UpdateBodyContacts_callback = null;\r\n        this.SolveCollision_callback = null;\r\n        this.SetStrictContactCheck(def.strictContactCheck);\r\n        this.SetDensity(def.density);\r\n        this.SetGravityScale(def.gravityScale);\r\n        this.SetRadius(def.radius);\r\n        this.SetMaxParticleCount(def.maxCount);\r\n        // DEBUG: b2Assert(def.lifetimeGranularity > 0.0);\r\n        this.m_def = def.Clone();\r\n        this.m_world = world;\r\n        this.SetDestructionByAge(this.m_def.destroyByAge);\r\n    }\r\n    b2ParticleSystem.computeTag = function (x, y) {\r\n        ///return ((uint32)(y + yOffset) << yShift) + (uint32)(xScale * x + xOffset);\r\n        return ((((y + b2ParticleSystem.yOffset) >>> 0) << b2ParticleSystem.yShift) + ((b2ParticleSystem.xScale * x + b2ParticleSystem.xOffset) >>> 0)) >>> 0;\r\n    };\r\n    b2ParticleSystem.computeRelativeTag = function (tag, x, y) {\r\n        ///return tag + (y << yShift) + (x << xShift);\r\n        return (tag + (y << b2ParticleSystem.yShift) + (x << b2ParticleSystem.xShift)) >>> 0;\r\n    };\r\n    b2ParticleSystem.prototype.Drop = function () {\r\n        while (this.m_groupList) {\r\n            this.DestroyParticleGroup(this.m_groupList);\r\n        }\r\n        this.FreeUserOverridableBuffer(this.m_handleIndexBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_flagsBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_positionBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_velocityBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_colorBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_userDataBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer);\r\n        this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer);\r\n        this.FreeBuffer(this.m_forceBuffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_weightBuffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_staticPressureBuffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_accumulationBuffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_accumulation2Buffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_depthBuffer, this.m_internalAllocatedCapacity);\r\n        this.FreeBuffer(this.m_groupBuffer, this.m_internalAllocatedCapacity);\r\n    };\r\n    /**\r\n     * Create a particle whose properties have been defined.\r\n     *\r\n     * No reference to the definition is retained.\r\n     *\r\n     * A simulation step must occur before it's possible to interact\r\n     * with a newly created particle.  For example,\r\n     * DestroyParticleInShape() will not destroy a particle until\r\n     * b2World::Step() has been called.\r\n     *\r\n     * warning: This function is locked during callbacks.\r\n     */\r\n    b2ParticleSystem.prototype.CreateParticle = function (def) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        if (this.m_count >= this.m_internalAllocatedCapacity) {\r\n            // Double the particle capacity.\r\n            var capacity = this.m_count ? 2 * this.m_count : b2Settings_1.b2_minParticleSystemBufferCapacity;\r\n            this.ReallocateInternalAllocatedBuffers(capacity);\r\n        }\r\n        if (this.m_count >= this.m_internalAllocatedCapacity) {\r\n            // If the oldest particle should be destroyed...\r\n            if (this.m_def.destroyByAge) {\r\n                this.DestroyOldestParticle(0, false);\r\n                // Need to destroy this particle *now* so that it's possible to\r\n                // create a new particle.\r\n                this.SolveZombie();\r\n            }\r\n            else {\r\n                return b2Settings_1.b2_invalidParticleIndex;\r\n            }\r\n        }\r\n        var index = this.m_count++;\r\n        this.m_flagsBuffer.data[index] = 0;\r\n        if (this.m_lastBodyContactStepBuffer.data) {\r\n            this.m_lastBodyContactStepBuffer.data[index] = 0;\r\n        }\r\n        if (this.m_bodyContactCountBuffer.data) {\r\n            this.m_bodyContactCountBuffer.data[index] = 0;\r\n        }\r\n        if (this.m_consecutiveContactStepsBuffer.data) {\r\n            this.m_consecutiveContactStepsBuffer.data[index] = 0;\r\n        }\r\n        this.m_positionBuffer.data[index] = (this.m_positionBuffer.data[index] || new b2Math_1.b2Vec2()).Copy(b2Settings_1.b2Maybe(def.position, b2Math_1.b2Vec2.ZERO));\r\n        this.m_velocityBuffer.data[index] = (this.m_velocityBuffer.data[index] || new b2Math_1.b2Vec2()).Copy(b2Settings_1.b2Maybe(def.velocity, b2Math_1.b2Vec2.ZERO));\r\n        this.m_weightBuffer[index] = 0;\r\n        this.m_forceBuffer[index] = (this.m_forceBuffer[index] || new b2Math_1.b2Vec2()).SetZero();\r\n        if (this.m_staticPressureBuffer) {\r\n            this.m_staticPressureBuffer[index] = 0;\r\n        }\r\n        if (this.m_depthBuffer) {\r\n            this.m_depthBuffer[index] = 0;\r\n        }\r\n        var color = new b2Draw_1.b2Color().Copy(b2Settings_1.b2Maybe(def.color, b2Draw_1.b2Color.ZERO));\r\n        if (this.m_colorBuffer.data || !color.IsZero()) {\r\n            this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n            this.m_colorBuffer.data[index] = (this.m_colorBuffer.data[index] || new b2Draw_1.b2Color()).Copy(color);\r\n        }\r\n        if (this.m_userDataBuffer.data || def.userData) {\r\n            this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);\r\n            this.m_userDataBuffer.data[index] = def.userData;\r\n        }\r\n        if (this.m_handleIndexBuffer.data) {\r\n            this.m_handleIndexBuffer.data[index] = null;\r\n        }\r\n        ///Proxy& proxy = m_proxyBuffer.Append();\r\n        var proxy = this.m_proxyBuffer.data[this.m_proxyBuffer.Append()];\r\n        // If particle lifetimes are enabled or the lifetime is set in the particle\r\n        // definition, initialize the lifetime.\r\n        var lifetime = b2Settings_1.b2Maybe(def.lifetime, 0.0);\r\n        var finiteLifetime = lifetime > 0.0;\r\n        if (this.m_expirationTimeBuffer.data || finiteLifetime) {\r\n            this.SetParticleLifetime(index, finiteLifetime ? lifetime :\r\n                this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed()));\r\n            // Add a reference to the newly added particle to the end of the\r\n            // queue.\r\n            this.m_indexByExpirationTimeBuffer.data[index] = index;\r\n        }\r\n        proxy.index = index;\r\n        var group = b2Settings_1.b2Maybe(def.group, null);\r\n        this.m_groupBuffer[index] = group;\r\n        if (group) {\r\n            if (group.m_firstIndex < group.m_lastIndex) {\r\n                // Move particles in the group just before the new particle.\r\n                this.RotateBuffer(group.m_firstIndex, group.m_lastIndex, index);\r\n                // DEBUG: b2Assert(group.m_lastIndex === index);\r\n                // Update the index range of the group to contain the new particle.\r\n                group.m_lastIndex = index + 1;\r\n            }\r\n            else {\r\n                // If the group is empty, reset the index range to contain only the\r\n                // new particle.\r\n                group.m_firstIndex = index;\r\n                group.m_lastIndex = index + 1;\r\n            }\r\n        }\r\n        this.SetParticleFlags(index, b2Settings_1.b2Maybe(def.flags, 0));\r\n        return index;\r\n    };\r\n    /**\r\n     * Retrieve a handle to the particle at the specified index.\r\n     *\r\n     * Please see #b2ParticleHandle for why you might want a handle.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleHandleFromIndex = function (index) {\r\n        // DEBUG: b2Assert(index >= 0 && index < this.GetParticleCount() && index !== b2_invalidParticleIndex);\r\n        this.m_handleIndexBuffer.data = this.RequestBuffer(this.m_handleIndexBuffer.data);\r\n        var handle = this.m_handleIndexBuffer.data[index];\r\n        if (handle) {\r\n            return handle;\r\n        }\r\n        // Create a handle.\r\n        ///handle = m_handleAllocator.Allocate();\r\n        handle = new b2Particle_1.b2ParticleHandle();\r\n        // DEBUG: b2Assert(handle !== null);\r\n        handle.SetIndex(index);\r\n        this.m_handleIndexBuffer.data[index] = handle;\r\n        return handle;\r\n    };\r\n    /**\r\n     * Destroy a particle.\r\n     *\r\n     * The particle is removed after the next simulation step (see\r\n     * b2World::Step()).\r\n     *\r\n     * @param index Index of the particle to destroy.\r\n     * @param callDestructionListener Whether to call the\r\n     *      destruction listener just before the particle is\r\n     *      destroyed.\r\n     */\r\n    b2ParticleSystem.prototype.DestroyParticle = function (index, callDestructionListener) {\r\n        if (callDestructionListener === void 0) { callDestructionListener = false; }\r\n        var flags = b2Particle_1.b2ParticleFlag.b2_zombieParticle;\r\n        if (callDestructionListener) {\r\n            flags |= b2Particle_1.b2ParticleFlag.b2_destructionListenerParticle;\r\n        }\r\n        this.SetParticleFlags(index, this.m_flagsBuffer.data[index] | flags);\r\n    };\r\n    /**\r\n     * Destroy the Nth oldest particle in the system.\r\n     *\r\n     * The particle is removed after the next b2World::Step().\r\n     *\r\n     * @param index Index of the Nth oldest particle to\r\n     *      destroy, 0 will destroy the oldest particle in the\r\n     *      system, 1 will destroy the next oldest particle etc.\r\n     * @param callDestructionListener Whether to call the\r\n     *      destruction listener just before the particle is\r\n     *      destroyed.\r\n     */\r\n    b2ParticleSystem.prototype.DestroyOldestParticle = function (index, callDestructionListener) {\r\n        if (callDestructionListener === void 0) { callDestructionListener = false; }\r\n        var particleCount = this.GetParticleCount();\r\n        // DEBUG: b2Assert(index >= 0 && index < particleCount);\r\n        // Make sure particle lifetime tracking is enabled.\r\n        // DEBUG: b2Assert(this.m_indexByExpirationTimeBuffer.data !== null);\r\n        // Destroy the oldest particle (preferring to destroy finite\r\n        // lifetime particles first) to free a slot in the buffer.\r\n        var oldestFiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[particleCount - (index + 1)];\r\n        var oldestInfiniteLifetimeParticle = this.m_indexByExpirationTimeBuffer.data[index];\r\n        this.DestroyParticle(this.m_expirationTimeBuffer.data[oldestFiniteLifetimeParticle] > 0.0 ?\r\n            oldestFiniteLifetimeParticle : oldestInfiniteLifetimeParticle, callDestructionListener);\r\n    };\r\n    /**\r\n     * Destroy particles inside a shape.\r\n     *\r\n     * warning: This function is locked during callbacks.\r\n     *\r\n     * In addition, this function immediately destroys particles in\r\n     * the shape in constrast to DestroyParticle() which defers the\r\n     * destruction until the next simulation step.\r\n     *\r\n     * @return Number of particles destroyed.\r\n     * @param shape Shape which encloses particles\r\n     *      that should be destroyed.\r\n     * @param xf Transform applied to the shape.\r\n     * @param callDestructionListener Whether to call the\r\n     *      world b2DestructionListener for each particle\r\n     *      destroyed.\r\n     */\r\n    b2ParticleSystem.prototype.DestroyParticlesInShape = function (shape, xf, callDestructionListener) {\r\n        if (callDestructionListener === void 0) { callDestructionListener = false; }\r\n        var s_aabb = b2ParticleSystem.DestroyParticlesInShape_s_aabb;\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var callback = new b2ParticleSystem_DestroyParticlesInShapeCallback(this, shape, xf, callDestructionListener);\r\n        var aabb = s_aabb;\r\n        shape.ComputeAABB(aabb, xf, 0);\r\n        this.m_world.QueryAABB(callback, aabb);\r\n        return callback.Destroyed();\r\n    };\r\n    /**\r\n     * Create a particle group whose properties have been defined.\r\n     *\r\n     * No reference to the definition is retained.\r\n     *\r\n     * warning: This function is locked during callbacks.\r\n     */\r\n    b2ParticleSystem.prototype.CreateParticleGroup = function (groupDef) {\r\n        var s_transform = b2ParticleSystem.CreateParticleGroup_s_transform;\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var transform = s_transform;\r\n        transform.SetPositionAngle(b2Settings_1.b2Maybe(groupDef.position, b2Math_1.b2Vec2.ZERO), b2Settings_1.b2Maybe(groupDef.angle, 0));\r\n        var firstIndex = this.m_count;\r\n        if (groupDef.shape) {\r\n            this.CreateParticlesWithShapeForGroup(groupDef.shape, groupDef, transform);\r\n        }\r\n        if (groupDef.shapes) {\r\n            this.CreateParticlesWithShapesForGroup(groupDef.shapes, b2Settings_1.b2Maybe(groupDef.shapeCount, groupDef.shapes.length), groupDef, transform);\r\n        }\r\n        if (groupDef.positionData) {\r\n            var count = b2Settings_1.b2Maybe(groupDef.particleCount, groupDef.positionData.length);\r\n            for (var i = 0; i < count; i++) {\r\n                var p = groupDef.positionData[i];\r\n                this.CreateParticleForGroup(groupDef, transform, p);\r\n            }\r\n        }\r\n        var lastIndex = this.m_count;\r\n        var group = new b2ParticleGroup_1.b2ParticleGroup(this);\r\n        group.m_firstIndex = firstIndex;\r\n        group.m_lastIndex = lastIndex;\r\n        group.m_strength = b2Settings_1.b2Maybe(groupDef.strength, 1);\r\n        group.m_userData = groupDef.userData;\r\n        group.m_transform.Copy(transform);\r\n        group.m_prev = null;\r\n        group.m_next = this.m_groupList;\r\n        if (this.m_groupList) {\r\n            this.m_groupList.m_prev = group;\r\n        }\r\n        this.m_groupList = group;\r\n        ++this.m_groupCount;\r\n        for (var i = firstIndex; i < lastIndex; i++) {\r\n            this.m_groupBuffer[i] = group;\r\n        }\r\n        this.SetGroupFlags(group, b2Settings_1.b2Maybe(groupDef.groupFlags, 0));\r\n        // Create pairs and triads between particles in the group.\r\n        var filter = new b2ParticleSystem_ConnectionFilter();\r\n        this.UpdateContacts(true);\r\n        this.UpdatePairsAndTriads(firstIndex, lastIndex, filter);\r\n        if (groupDef.group) {\r\n            this.JoinParticleGroups(groupDef.group, group);\r\n            group = groupDef.group;\r\n        }\r\n        return group;\r\n    };\r\n    /**\r\n     * Join two particle groups.\r\n     *\r\n     * warning: This function is locked during callbacks.\r\n     *\r\n     * @param groupA the first group. Expands to encompass the second group.\r\n     * @param groupB the second group. It is destroyed.\r\n     */\r\n    b2ParticleSystem.prototype.JoinParticleGroups = function (groupA, groupB) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        // DEBUG: b2Assert(groupA !== groupB);\r\n        this.RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, this.m_count);\r\n        // DEBUG: b2Assert(groupB.m_lastIndex === this.m_count);\r\n        this.RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);\r\n        // DEBUG: b2Assert(groupA.m_lastIndex === groupB.m_firstIndex);\r\n        // Create pairs and triads connecting groupA and groupB.\r\n        var filter = new b2ParticleSystem_JoinParticleGroupsFilter(groupB.m_firstIndex);\r\n        this.UpdateContacts(true);\r\n        this.UpdatePairsAndTriads(groupA.m_firstIndex, groupB.m_lastIndex, filter);\r\n        for (var i = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) {\r\n            this.m_groupBuffer[i] = groupA;\r\n        }\r\n        var groupFlags = groupA.m_groupFlags | groupB.m_groupFlags;\r\n        this.SetGroupFlags(groupA, groupFlags);\r\n        groupA.m_lastIndex = groupB.m_lastIndex;\r\n        groupB.m_firstIndex = groupB.m_lastIndex;\r\n        this.DestroyParticleGroup(groupB);\r\n    };\r\n    /**\r\n     * Split particle group into multiple disconnected groups.\r\n     *\r\n     * warning: This function is locked during callbacks.\r\n     *\r\n     * @param group the group to be split.\r\n     */\r\n    b2ParticleSystem.prototype.SplitParticleGroup = function (group) {\r\n        this.UpdateContacts(true);\r\n        var particleCount = group.GetParticleCount();\r\n        // We create several linked lists. Each list represents a set of connected particles.\r\n        var nodeBuffer = b2Settings_1.b2MakeArray(particleCount, function (index) { return new b2ParticleSystem_ParticleListNode(); });\r\n        b2ParticleSystem.InitializeParticleLists(group, nodeBuffer);\r\n        this.MergeParticleListsInContact(group, nodeBuffer);\r\n        var survivingList = b2ParticleSystem.FindLongestParticleList(group, nodeBuffer);\r\n        this.MergeZombieParticleListNodes(group, nodeBuffer, survivingList);\r\n        this.CreateParticleGroupsFromParticleList(group, nodeBuffer, survivingList);\r\n        this.UpdatePairsAndTriadsWithParticleList(group, nodeBuffer);\r\n    };\r\n    /**\r\n     * Get the world particle group list. With the returned group,\r\n     * use b2ParticleGroup::GetNext to get the next group in the\r\n     * world list.\r\n     *\r\n     * A null group indicates the end of the list.\r\n     *\r\n     * @return the head of the world particle group list.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleGroupList = function () {\r\n        return this.m_groupList;\r\n    };\r\n    /**\r\n     * Get the number of particle groups.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleGroupCount = function () {\r\n        return this.m_groupCount;\r\n    };\r\n    /**\r\n     * Get the number of particles.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleCount = function () {\r\n        return this.m_count;\r\n    };\r\n    /**\r\n     * Get the maximum number of particles.\r\n     */\r\n    b2ParticleSystem.prototype.GetMaxParticleCount = function () {\r\n        return this.m_def.maxCount;\r\n    };\r\n    /**\r\n     * Set the maximum number of particles.\r\n     *\r\n     * A value of 0 means there is no maximum. The particle buffers\r\n     * can continue to grow while b2World's block allocator still\r\n     * has memory.\r\n     *\r\n     * Note: If you try to CreateParticle() with more than this\r\n     * count, b2_invalidParticleIndex is returned unless\r\n     * SetDestructionByAge() is used to enable the destruction of\r\n     * the oldest particles in the system.\r\n     */\r\n    b2ParticleSystem.prototype.SetMaxParticleCount = function (count) {\r\n        // DEBUG: b2Assert(this.m_count <= count);\r\n        this.m_def.maxCount = count;\r\n    };\r\n    /**\r\n     * Get all existing particle flags.\r\n     */\r\n    b2ParticleSystem.prototype.GetAllParticleFlags = function () {\r\n        return this.m_allParticleFlags;\r\n    };\r\n    /**\r\n     * Get all existing particle group flags.\r\n     */\r\n    b2ParticleSystem.prototype.GetAllGroupFlags = function () {\r\n        return this.m_allGroupFlags;\r\n    };\r\n    /**\r\n     * Pause or unpause the particle system. When paused,\r\n     * b2World::Step() skips over this particle system. All\r\n     * b2ParticleSystem function calls still work.\r\n     *\r\n     * @param paused paused is true to pause, false to un-pause.\r\n     */\r\n    b2ParticleSystem.prototype.SetPaused = function (paused) {\r\n        this.m_paused = paused;\r\n    };\r\n    /**\r\n     * Initially, true, then, the last value passed into\r\n     * SetPaused().\r\n     *\r\n     * @return true if the particle system is being updated in b2World::Step().\r\n     */\r\n    b2ParticleSystem.prototype.GetPaused = function () {\r\n        return this.m_paused;\r\n    };\r\n    /**\r\n     * Change the particle density.\r\n     *\r\n     * Particle density affects the mass of the particles, which in\r\n     * turn affects how the particles interact with b2Bodies. Note\r\n     * that the density does not affect how the particles interact\r\n     * with each other.\r\n     */\r\n    b2ParticleSystem.prototype.SetDensity = function (density) {\r\n        this.m_def.density = density;\r\n        this.m_inverseDensity = 1 / this.m_def.density;\r\n    };\r\n    /**\r\n     * Get the particle density.\r\n     */\r\n    b2ParticleSystem.prototype.GetDensity = function () {\r\n        return this.m_def.density;\r\n    };\r\n    /**\r\n     * Change the particle gravity scale. Adjusts the effect of the\r\n     * global gravity vector on particles.\r\n     */\r\n    b2ParticleSystem.prototype.SetGravityScale = function (gravityScale) {\r\n        this.m_def.gravityScale = gravityScale;\r\n    };\r\n    /**\r\n     * Get the particle gravity scale.\r\n     */\r\n    b2ParticleSystem.prototype.GetGravityScale = function () {\r\n        return this.m_def.gravityScale;\r\n    };\r\n    /**\r\n     * Damping is used to reduce the velocity of particles. The\r\n     * damping parameter can be larger than 1.0f but the damping\r\n     * effect becomes sensitive to the time step when the damping\r\n     * parameter is large.\r\n     */\r\n    b2ParticleSystem.prototype.SetDamping = function (damping) {\r\n        this.m_def.dampingStrength = damping;\r\n    };\r\n    /**\r\n     * Get damping for particles\r\n     */\r\n    b2ParticleSystem.prototype.GetDamping = function () {\r\n        return this.m_def.dampingStrength;\r\n    };\r\n    /**\r\n     * Change the number of iterations when calculating the static\r\n     * pressure of particles. By default, 8 iterations. You can\r\n     * reduce the number of iterations down to 1 in some situations,\r\n     * but this may cause instabilities when many particles come\r\n     * together. If you see particles popping away from each other\r\n     * like popcorn, you may have to increase the number of\r\n     * iterations.\r\n     *\r\n     * For a description of static pressure, see\r\n     * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics\r\n     */\r\n    b2ParticleSystem.prototype.SetStaticPressureIterations = function (iterations) {\r\n        this.m_def.staticPressureIterations = iterations;\r\n    };\r\n    /**\r\n     * Get the number of iterations for static pressure of\r\n     * particles.\r\n     */\r\n    b2ParticleSystem.prototype.GetStaticPressureIterations = function () {\r\n        return this.m_def.staticPressureIterations;\r\n    };\r\n    /**\r\n     * Change the particle radius.\r\n     *\r\n     * You should set this only once, on world start.\r\n     * If you change the radius during execution, existing particles\r\n     * may explode, shrink, or behave unexpectedly.\r\n     */\r\n    b2ParticleSystem.prototype.SetRadius = function (radius) {\r\n        this.m_particleDiameter = 2 * radius;\r\n        this.m_squaredDiameter = this.m_particleDiameter * this.m_particleDiameter;\r\n        this.m_inverseDiameter = 1 / this.m_particleDiameter;\r\n    };\r\n    /**\r\n     * Get the particle radius.\r\n     */\r\n    b2ParticleSystem.prototype.GetRadius = function () {\r\n        return this.m_particleDiameter / 2;\r\n    };\r\n    /**\r\n     * Get the position of each particle\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle positions array.\r\n     */\r\n    b2ParticleSystem.prototype.GetPositionBuffer = function () {\r\n        return this.m_positionBuffer.data;\r\n    };\r\n    /**\r\n     * Get the velocity of each particle\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle velocities array.\r\n     */\r\n    b2ParticleSystem.prototype.GetVelocityBuffer = function () {\r\n        return this.m_velocityBuffer.data;\r\n    };\r\n    /**\r\n     * Get the color of each particle\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle colors array.\r\n     */\r\n    b2ParticleSystem.prototype.GetColorBuffer = function () {\r\n        this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n        return this.m_colorBuffer.data;\r\n    };\r\n    /**\r\n     * Get the particle-group of each particle.\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle group array.\r\n     */\r\n    b2ParticleSystem.prototype.GetGroupBuffer = function () {\r\n        return this.m_groupBuffer;\r\n    };\r\n    /**\r\n     * Get the weight of each particle\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle positions array.\r\n     */\r\n    b2ParticleSystem.prototype.GetWeightBuffer = function () {\r\n        return this.m_weightBuffer;\r\n    };\r\n    /**\r\n     * Get the user-specified data of each particle.\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle user-data array.\r\n     */\r\n    b2ParticleSystem.prototype.GetUserDataBuffer = function () {\r\n        this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);\r\n        return this.m_userDataBuffer.data;\r\n    };\r\n    /**\r\n     * Get the flags for each particle. See the b2ParticleFlag enum.\r\n     *\r\n     * Array is length GetParticleCount()\r\n     *\r\n     * @return the pointer to the head of the particle-flags array.\r\n     */\r\n    b2ParticleSystem.prototype.GetFlagsBuffer = function () {\r\n        return this.m_flagsBuffer.data;\r\n    };\r\n    /**\r\n     * Set flags for a particle. See the b2ParticleFlag enum.\r\n     */\r\n    b2ParticleSystem.prototype.SetParticleFlags = function (index, newFlags) {\r\n        var oldFlags = this.m_flagsBuffer.data[index];\r\n        if (oldFlags & ~newFlags) {\r\n            // If any flags might be removed\r\n            this.m_needsUpdateAllParticleFlags = true;\r\n        }\r\n        if (~this.m_allParticleFlags & newFlags) {\r\n            // If any flags were added\r\n            if (newFlags & b2Particle_1.b2ParticleFlag.b2_tensileParticle) {\r\n                this.m_accumulation2Buffer = this.RequestBuffer(this.m_accumulation2Buffer);\r\n            }\r\n            if (newFlags & b2Particle_1.b2ParticleFlag.b2_colorMixingParticle) {\r\n                this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n            }\r\n            this.m_allParticleFlags |= newFlags;\r\n        }\r\n        this.m_flagsBuffer.data[index] = newFlags;\r\n    };\r\n    /**\r\n     * Get flags for a particle. See the b2ParticleFlag enum.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleFlags = function (index) {\r\n        return this.m_flagsBuffer.data[index];\r\n    };\r\n    /**\r\n     * Set an external buffer for particle data.\r\n     *\r\n     * Normally, the b2World's block allocator is used for particle\r\n     * data. However, sometimes you may have an OpenGL or Java\r\n     * buffer for particle data. To avoid data duplication, you may\r\n     * supply this external buffer.\r\n     *\r\n     * Note that, when b2World's block allocator is used, the\r\n     * particle data buffers can grow as required. However, when\r\n     * external buffers are used, the maximum number of particles is\r\n     * clamped to the size of the smallest external buffer.\r\n     *\r\n     * @param buffer a pointer to a block of memory.\r\n     * @param capacity the number of values in the block.\r\n     */\r\n    b2ParticleSystem.prototype.SetFlagsBuffer = function (buffer) {\r\n        this.SetUserOverridableBuffer(this.m_flagsBuffer, buffer);\r\n    };\r\n    b2ParticleSystem.prototype.SetPositionBuffer = function (buffer) {\r\n        if (buffer instanceof Float32Array) {\r\n            if (buffer.length % 2 !== 0) {\r\n                throw new Error();\r\n            }\r\n            var count = buffer.length / 2;\r\n            var array = new Array(count);\r\n            for (var i = 0; i < count; ++i) {\r\n                array[i] = new b2Math_1.b2Vec2(buffer.subarray(i * 2, i * 2 + 2));\r\n            }\r\n            buffer = array;\r\n        }\r\n        this.SetUserOverridableBuffer(this.m_positionBuffer, buffer);\r\n    };\r\n    b2ParticleSystem.prototype.SetVelocityBuffer = function (buffer) {\r\n        if (buffer instanceof Float32Array) {\r\n            if (buffer.length % 2 !== 0) {\r\n                throw new Error();\r\n            }\r\n            var count = buffer.length / 2;\r\n            var array = new Array(count);\r\n            for (var i = 0; i < count; ++i) {\r\n                array[i] = new b2Math_1.b2Vec2(buffer.subarray(i * 2, i * 2 + 2));\r\n            }\r\n            buffer = array;\r\n        }\r\n        this.SetUserOverridableBuffer(this.m_velocityBuffer, buffer);\r\n    };\r\n    b2ParticleSystem.prototype.SetColorBuffer = function (buffer) {\r\n        if (buffer instanceof Float32Array) {\r\n            if (buffer.length % 4 !== 0) {\r\n                throw new Error();\r\n            }\r\n            var count = buffer.length / 4;\r\n            var array = new Array(count);\r\n            for (var i = 0; i < count; ++i) {\r\n                array[i] = new b2Draw_1.b2Color(buffer.subarray(i * 4, i * 4 + 4));\r\n            }\r\n            buffer = array;\r\n        }\r\n        this.SetUserOverridableBuffer(this.m_colorBuffer, buffer);\r\n    };\r\n    b2ParticleSystem.prototype.SetUserDataBuffer = function (buffer) {\r\n        this.SetUserOverridableBuffer(this.m_userDataBuffer, buffer);\r\n    };\r\n    /**\r\n     * Get contacts between particles\r\n     * Contact data can be used for many reasons, for example to\r\n     * trigger rendering or audio effects.\r\n     */\r\n    b2ParticleSystem.prototype.GetContacts = function () {\r\n        return this.m_contactBuffer.data;\r\n    };\r\n    b2ParticleSystem.prototype.GetContactCount = function () {\r\n        return this.m_contactBuffer.count;\r\n    };\r\n    /**\r\n     * Get contacts between particles and bodies\r\n     *\r\n     * Contact data can be used for many reasons, for example to\r\n     * trigger rendering or audio effects.\r\n     */\r\n    b2ParticleSystem.prototype.GetBodyContacts = function () {\r\n        return this.m_bodyContactBuffer.data;\r\n    };\r\n    b2ParticleSystem.prototype.GetBodyContactCount = function () {\r\n        return this.m_bodyContactBuffer.count;\r\n    };\r\n    /**\r\n     * Get array of particle pairs. The particles in a pair:\r\n     *   (1) are contacting,\r\n     *   (2) are in the same particle group,\r\n     *   (3) are part of a rigid particle group, or are spring, elastic,\r\n     *       or wall particles.\r\n     *   (4) have at least one particle that is a spring or barrier\r\n     *       particle (i.e. one of the types in k_pairFlags),\r\n     *   (5) have at least one particle that returns true for\r\n     *       ConnectionFilter::IsNecessary,\r\n     *   (6) are not zombie particles.\r\n     *\r\n     * Essentially, this is an array of spring or barrier particles\r\n     * that are interacting. The array is sorted by b2ParticlePair's\r\n     * indexA, and then indexB. There are no duplicate entries.\r\n     */\r\n    b2ParticleSystem.prototype.GetPairs = function () {\r\n        return this.m_pairBuffer.data;\r\n    };\r\n    b2ParticleSystem.prototype.GetPairCount = function () {\r\n        return this.m_pairBuffer.count;\r\n    };\r\n    /**\r\n     * Get array of particle triads. The particles in a triad:\r\n     *   (1) are in the same particle group,\r\n     *   (2) are in a Voronoi triangle together,\r\n     *   (3) are within b2_maxTriadDistance particle diameters of each\r\n     *       other,\r\n     *   (4) return true for ConnectionFilter::ShouldCreateTriad\r\n     *   (5) have at least one particle of type elastic (i.e. one of the\r\n     *       types in k_triadFlags),\r\n     *   (6) are part of a rigid particle group, or are spring, elastic,\r\n     *       or wall particles.\r\n     *   (7) are not zombie particles.\r\n     *\r\n     * Essentially, this is an array of elastic particles that are\r\n     * interacting. The array is sorted by b2ParticleTriad's indexA,\r\n     * then indexB, then indexC. There are no duplicate entries.\r\n     */\r\n    b2ParticleSystem.prototype.GetTriads = function () {\r\n        return this.m_triadBuffer.data;\r\n    };\r\n    b2ParticleSystem.prototype.GetTriadCount = function () {\r\n        return this.m_triadBuffer.count;\r\n    };\r\n    /**\r\n     * Set an optional threshold for the maximum number of\r\n     * consecutive particle iterations that a particle may contact\r\n     * multiple bodies before it is considered a candidate for being\r\n     * \"stuck\". Setting to zero or less disables.\r\n     */\r\n    b2ParticleSystem.prototype.SetStuckThreshold = function (steps) {\r\n        this.m_stuckThreshold = steps;\r\n        if (steps > 0) {\r\n            this.m_lastBodyContactStepBuffer.data = this.RequestBuffer(this.m_lastBodyContactStepBuffer.data);\r\n            this.m_bodyContactCountBuffer.data = this.RequestBuffer(this.m_bodyContactCountBuffer.data);\r\n            this.m_consecutiveContactStepsBuffer.data = this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data);\r\n        }\r\n    };\r\n    /**\r\n     * Get potentially stuck particles from the last step; the user\r\n     * must decide if they are stuck or not, and if so, delete or\r\n     * move them\r\n     */\r\n    b2ParticleSystem.prototype.GetStuckCandidates = function () {\r\n        ///return m_stuckParticleBuffer.Data();\r\n        return this.m_stuckParticleBuffer.Data();\r\n    };\r\n    /**\r\n     * Get the number of stuck particle candidates from the last\r\n     * step.\r\n     */\r\n    b2ParticleSystem.prototype.GetStuckCandidateCount = function () {\r\n        ///return m_stuckParticleBuffer.GetCount();\r\n        return this.m_stuckParticleBuffer.GetCount();\r\n    };\r\n    /**\r\n     * Compute the kinetic energy that can be lost by damping force\r\n     */\r\n    b2ParticleSystem.prototype.ComputeCollisionEnergy = function () {\r\n        var s_v = b2ParticleSystem.ComputeCollisionEnergy_s_v;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var sum_v2 = 0;\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var n = contact.normal;\r\n            ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n            var v = b2Math_1.b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n            var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n            if (vn < 0) {\r\n                sum_v2 += vn * vn;\r\n            }\r\n        }\r\n        return 0.5 * this.GetParticleMass() * sum_v2;\r\n    };\r\n    /**\r\n     * Set strict Particle/Body contact check.\r\n     *\r\n     * This is an option that will help ensure correct behavior if\r\n     * there are corners in the world model where Particle/Body\r\n     * contact is ambiguous. This option scales at n*log(n) of the\r\n     * number of Particle/Body contacts, so it is best to only\r\n     * enable if it is necessary for your geometry. Enable if you\r\n     * see strange particle behavior around b2Body intersections.\r\n     */\r\n    b2ParticleSystem.prototype.SetStrictContactCheck = function (enabled) {\r\n        this.m_def.strictContactCheck = enabled;\r\n    };\r\n    /**\r\n     * Get the status of the strict contact check.\r\n     */\r\n    b2ParticleSystem.prototype.GetStrictContactCheck = function () {\r\n        return this.m_def.strictContactCheck;\r\n    };\r\n    /**\r\n     * Set the lifetime (in seconds) of a particle relative to the\r\n     * current time.  A lifetime of less than or equal to 0.0f\r\n     * results in the particle living forever until it's manually\r\n     * destroyed by the application.\r\n     */\r\n    b2ParticleSystem.prototype.SetParticleLifetime = function (index, lifetime) {\r\n        // DEBUG: b2Assert(this.ValidateParticleIndex(index));\r\n        var initializeExpirationTimes = this.m_indexByExpirationTimeBuffer.data === null;\r\n        this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);\r\n        this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);\r\n        // Initialize the inverse mapping buffer.\r\n        if (initializeExpirationTimes) {\r\n            var particleCount = this.GetParticleCount();\r\n            for (var i = 0; i < particleCount; ++i) {\r\n                this.m_indexByExpirationTimeBuffer.data[i] = i;\r\n            }\r\n        }\r\n        ///const int32 quantizedLifetime = (int32)(lifetime / m_def.lifetimeGranularity);\r\n        var quantizedLifetime = lifetime / this.m_def.lifetimeGranularity;\r\n        // Use a negative lifetime so that it's possible to track which\r\n        // of the infinite lifetime particles are older.\r\n        var newExpirationTime = quantizedLifetime > 0.0 ? this.GetQuantizedTimeElapsed() + quantizedLifetime : quantizedLifetime;\r\n        if (newExpirationTime !== this.m_expirationTimeBuffer.data[index]) {\r\n            this.m_expirationTimeBuffer.data[index] = newExpirationTime;\r\n            this.m_expirationTimeBufferRequiresSorting = true;\r\n        }\r\n    };\r\n    /**\r\n     * Get the lifetime (in seconds) of a particle relative to the\r\n     * current time.  A value > 0.0f is returned if the particle is\r\n     * scheduled to be destroyed in the future, values <= 0.0f\r\n     * indicate the particle has an infinite lifetime.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleLifetime = function (index) {\r\n        // DEBUG: b2Assert(this.ValidateParticleIndex(index));\r\n        return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[index]);\r\n    };\r\n    /**\r\n     * Enable / disable destruction of particles in CreateParticle()\r\n     * when no more particles can be created due to a prior call to\r\n     * SetMaxParticleCount().  When this is enabled, the oldest\r\n     * particle is destroyed in CreateParticle() favoring the\r\n     * destruction of particles with a finite lifetime over\r\n     * particles with infinite lifetimes. This feature is enabled by\r\n     * default when particle lifetimes are tracked.  Explicitly\r\n     * enabling this feature using this function enables particle\r\n     * lifetime tracking.\r\n     */\r\n    b2ParticleSystem.prototype.SetDestructionByAge = function (enable) {\r\n        if (enable) {\r\n            this.GetExpirationTimeBuffer();\r\n        }\r\n        this.m_def.destroyByAge = enable;\r\n    };\r\n    /**\r\n     * Get whether the oldest particle will be destroyed in\r\n     * CreateParticle() when the maximum number of particles are\r\n     * present in the system.\r\n     */\r\n    b2ParticleSystem.prototype.GetDestructionByAge = function () {\r\n        return this.m_def.destroyByAge;\r\n    };\r\n    /**\r\n     * Get the array of particle expiration times indexed by\r\n     * particle index.\r\n     *\r\n     * GetParticleCount() items are in the returned array.\r\n     */\r\n    b2ParticleSystem.prototype.GetExpirationTimeBuffer = function () {\r\n        this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);\r\n        return this.m_expirationTimeBuffer.data;\r\n    };\r\n    /**\r\n     * Convert a expiration time value in returned by\r\n     * GetExpirationTimeBuffer() to a time in seconds relative to\r\n     * the current simulation time.\r\n     */\r\n    b2ParticleSystem.prototype.ExpirationTimeToLifetime = function (expirationTime) {\r\n        return (expirationTime > 0 ?\r\n            expirationTime - this.GetQuantizedTimeElapsed() :\r\n            expirationTime) * this.m_def.lifetimeGranularity;\r\n    };\r\n    /**\r\n     * Get the array of particle indices ordered by reverse\r\n     * lifetime. The oldest particle indexes are at the end of the\r\n     * array with the newest at the start.  Particles with infinite\r\n     * lifetimes (i.e expiration times less than or equal to 0) are\r\n     * placed at the start of the array.\r\n     * ExpirationTimeToLifetime(GetExpirationTimeBuffer()[index]) is\r\n     * equivalent to GetParticleLifetime(index).\r\n     *\r\n     * GetParticleCount() items are in the returned array.\r\n     */\r\n    b2ParticleSystem.prototype.GetIndexByExpirationTimeBuffer = function () {\r\n        // If particles are present, initialize / reinitialize the lifetime buffer.\r\n        if (this.GetParticleCount()) {\r\n            this.SetParticleLifetime(0, this.GetParticleLifetime(0));\r\n        }\r\n        else {\r\n            this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);\r\n        }\r\n        return this.m_indexByExpirationTimeBuffer.data;\r\n    };\r\n    /**\r\n     * Apply an impulse to one particle. This immediately modifies\r\n     * the velocity. Similar to b2Body::ApplyLinearImpulse.\r\n     *\r\n     * @param index the particle that will be modified.\r\n     * @param impulse impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n     */\r\n    b2ParticleSystem.prototype.ParticleApplyLinearImpulse = function (index, impulse) {\r\n        this.ApplyLinearImpulse(index, index + 1, impulse);\r\n    };\r\n    /**\r\n     * Apply an impulse to all particles between 'firstIndex' and\r\n     * 'lastIndex'. This immediately modifies the velocity. Note\r\n     * that the impulse is applied to the total mass of all\r\n     * particles. So, calling ParticleApplyLinearImpulse(0, impulse)\r\n     * and ParticleApplyLinearImpulse(1, impulse) will impart twice\r\n     * as much velocity as calling just ApplyLinearImpulse(0, 1,\r\n     * impulse).\r\n     *\r\n     * @param firstIndex the first particle to be modified.\r\n     * @param lastIndex the last particle to be modified.\r\n     * @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n     */\r\n    b2ParticleSystem.prototype.ApplyLinearImpulse = function (firstIndex, lastIndex, impulse) {\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var numParticles = (lastIndex - firstIndex);\r\n        var totalMass = numParticles * this.GetParticleMass();\r\n        ///const b2Vec2 velocityDelta = impulse / totalMass;\r\n        var velocityDelta = new b2Math_1.b2Vec2().Copy(impulse).SelfMul(1 / totalMass);\r\n        for (var i = firstIndex; i < lastIndex; i++) {\r\n            ///m_velocityBuffer.data[i] += velocityDelta;\r\n            vel_data[i].SelfAdd(velocityDelta);\r\n        }\r\n    };\r\n    b2ParticleSystem.IsSignificantForce = function (force) {\r\n        return force.x !== 0 || force.y !== 0;\r\n    };\r\n    /**\r\n     * Apply a force to the center of a particle.\r\n     *\r\n     * @param index the particle that will be modified.\r\n     * @param force the world force vector, usually in Newtons (N).\r\n     */\r\n    b2ParticleSystem.prototype.ParticleApplyForce = function (index, force) {\r\n        if (b2ParticleSystem.IsSignificantForce(force) &&\r\n            this.ForceCanBeApplied(this.m_flagsBuffer.data[index])) {\r\n            this.PrepareForceBuffer();\r\n            ///m_forceBuffer[index] += force;\r\n            this.m_forceBuffer[index].SelfAdd(force);\r\n        }\r\n    };\r\n    /**\r\n     * Distribute a force across several particles. The particles\r\n     * must not be wall particles. Note that the force is\r\n     * distributed across all the particles, so calling this\r\n     * function for indices 0..N is not the same as calling\r\n     * ParticleApplyForce(i, force) for i in 0..N.\r\n     *\r\n     * @param firstIndex the first particle to be modified.\r\n     * @param lastIndex the last particle to be modified.\r\n     * @param force the world force vector, usually in Newtons (N).\r\n     */\r\n    b2ParticleSystem.prototype.ApplyForce = function (firstIndex, lastIndex, force) {\r\n        // Ensure we're not trying to apply force to particles that can't move,\r\n        // such as wall particles.\r\n        // DEBUG: let flags = 0;\r\n        // DEBUG: for (let i = firstIndex; i < lastIndex; i++) {\r\n        // DEBUG:   flags |= this.m_flagsBuffer.data[i];\r\n        // DEBUG: }\r\n        // DEBUG: b2Assert(this.ForceCanBeApplied(flags));\r\n        // Early out if force does nothing (optimization).\r\n        ///const b2Vec2 distributedForce = force / (float32)(lastIndex - firstIndex);\r\n        var distributedForce = new b2Math_1.b2Vec2().Copy(force).SelfMul(1 / (lastIndex - firstIndex));\r\n        if (b2ParticleSystem.IsSignificantForce(distributedForce)) {\r\n            this.PrepareForceBuffer();\r\n            // Distribute the force over all the particles.\r\n            for (var i = firstIndex; i < lastIndex; i++) {\r\n                ///m_forceBuffer[i] += distributedForce;\r\n                this.m_forceBuffer[i].SelfAdd(distributedForce);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Get the next particle-system in the world's particle-system\r\n     * list.\r\n     */\r\n    b2ParticleSystem.prototype.GetNext = function () {\r\n        return this.m_next;\r\n    };\r\n    /**\r\n     * Query the particle system for all particles that potentially\r\n     * overlap the provided AABB.\r\n     * b2QueryCallback::ShouldQueryParticleSystem is ignored.\r\n     *\r\n     * @param callback a user implemented callback class.\r\n     * @param aabb the query box.\r\n     */\r\n    b2ParticleSystem.prototype.QueryAABB = function (callback, aabb) {\r\n        if (this.m_proxyBuffer.count === 0) {\r\n            return;\r\n        }\r\n        var beginProxy = 0;\r\n        var endProxy = this.m_proxyBuffer.count;\r\n        var firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x, this.m_inverseDiameter * aabb.lowerBound.y), b2ParticleSystem_Proxy.CompareProxyTag);\r\n        var lastProxy = std_upper_bound(this.m_proxyBuffer.data, firstProxy, endProxy, b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x, this.m_inverseDiameter * aabb.upperBound.y), b2ParticleSystem_Proxy.CompareTagProxy);\r\n        var pos_data = this.m_positionBuffer.data;\r\n        for (var k = firstProxy; k < lastProxy; ++k) {\r\n            var proxy = this.m_proxyBuffer.data[k];\r\n            var i = proxy.index;\r\n            var p = pos_data[i];\r\n            if (aabb.lowerBound.x < p.x && p.x < aabb.upperBound.x &&\r\n                aabb.lowerBound.y < p.y && p.y < aabb.upperBound.y) {\r\n                if (!callback.ReportParticle(this, i)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Query the particle system for all particles that potentially\r\n     * overlap the provided shape's AABB. Calls QueryAABB\r\n     * internally. b2QueryCallback::ShouldQueryParticleSystem is\r\n     * ignored.\r\n     *\r\n     * @param callback a user implemented callback class.\r\n     * @param shape the query shape\r\n     * @param xf the transform of the AABB\r\n     * @param childIndex\r\n     */\r\n    b2ParticleSystem.prototype.QueryShapeAABB = function (callback, shape, xf, childIndex) {\r\n        if (childIndex === void 0) { childIndex = 0; }\r\n        var s_aabb = b2ParticleSystem.QueryShapeAABB_s_aabb;\r\n        var aabb = s_aabb;\r\n        shape.ComputeAABB(aabb, xf, childIndex);\r\n        this.QueryAABB(callback, aabb);\r\n    };\r\n    b2ParticleSystem.prototype.QueryPointAABB = function (callback, point, slop) {\r\n        if (slop === void 0) { slop = b2Settings_1.b2_linearSlop; }\r\n        var s_aabb = b2ParticleSystem.QueryPointAABB_s_aabb;\r\n        var aabb = s_aabb;\r\n        aabb.lowerBound.Set(point.x - slop, point.y - slop);\r\n        aabb.upperBound.Set(point.x + slop, point.y + slop);\r\n        this.QueryAABB(callback, aabb);\r\n    };\r\n    /**\r\n     * Ray-cast the particle system for all particles in the path of\r\n     * the ray. Your callback controls whether you get the closest\r\n     * point, any point, or n-points. The ray-cast ignores particles\r\n     * that contain the starting point.\r\n     * b2RayCastCallback::ShouldQueryParticleSystem is ignored.\r\n     *\r\n     * @param callback a user implemented callback class.\r\n     * @param point1 the ray starting point\r\n     * @param point2 the ray ending point\r\n     */\r\n    b2ParticleSystem.prototype.RayCast = function (callback, point1, point2) {\r\n        var s_aabb = b2ParticleSystem.RayCast_s_aabb;\r\n        var s_p = b2ParticleSystem.RayCast_s_p;\r\n        var s_v = b2ParticleSystem.RayCast_s_v;\r\n        var s_n = b2ParticleSystem.RayCast_s_n;\r\n        var s_point = b2ParticleSystem.RayCast_s_point;\r\n        if (this.m_proxyBuffer.count === 0) {\r\n            return;\r\n        }\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var aabb = s_aabb;\r\n        b2Math_1.b2Vec2.MinV(point1, point2, aabb.lowerBound);\r\n        b2Math_1.b2Vec2.MaxV(point1, point2, aabb.upperBound);\r\n        var fraction = 1;\r\n        // solving the following equation:\r\n        // ((1-t)*point1+t*point2-position)^2=diameter^2\r\n        // where t is a potential fraction\r\n        ///b2Vec2 v = point2 - point1;\r\n        var v = b2Math_1.b2Vec2.SubVV(point2, point1, s_v);\r\n        var v2 = b2Math_1.b2Vec2.DotVV(v, v);\r\n        var enumerator = this.GetInsideBoundsEnumerator(aabb);\r\n        var i;\r\n        while ((i = enumerator.GetNext()) >= 0) {\r\n            ///b2Vec2 p = point1 - m_positionBuffer.data[i];\r\n            var p = b2Math_1.b2Vec2.SubVV(point1, pos_data[i], s_p);\r\n            var pv = b2Math_1.b2Vec2.DotVV(p, v);\r\n            var p2 = b2Math_1.b2Vec2.DotVV(p, p);\r\n            var determinant = pv * pv - v2 * (p2 - this.m_squaredDiameter);\r\n            if (determinant >= 0) {\r\n                var sqrtDeterminant = b2Math_1.b2Sqrt(determinant);\r\n                // find a solution between 0 and fraction\r\n                var t = (-pv - sqrtDeterminant) / v2;\r\n                if (t > fraction) {\r\n                    continue;\r\n                }\r\n                if (t < 0) {\r\n                    t = (-pv + sqrtDeterminant) / v2;\r\n                    if (t < 0 || t > fraction) {\r\n                        continue;\r\n                    }\r\n                }\r\n                ///b2Vec2 n = p + t * v;\r\n                var n = b2Math_1.b2Vec2.AddVMulSV(p, t, v, s_n);\r\n                n.Normalize();\r\n                ///float32 f = callback.ReportParticle(this, i, point1 + t * v, n, t);\r\n                var f = callback.ReportParticle(this, i, b2Math_1.b2Vec2.AddVMulSV(point1, t, v, s_point), n, t);\r\n                fraction = b2Math_1.b2Min(fraction, f);\r\n                if (fraction <= 0) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Compute the axis-aligned bounding box for all particles\r\n     * contained within this particle system.\r\n     * @param aabb Returns the axis-aligned bounding box of the system.\r\n     */\r\n    b2ParticleSystem.prototype.ComputeAABB = function (aabb) {\r\n        var particleCount = this.GetParticleCount();\r\n        // DEBUG: b2Assert(aabb !== null);\r\n        aabb.lowerBound.x = +b2Settings_1.b2_maxFloat;\r\n        aabb.lowerBound.y = +b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.x = -b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.y = -b2Settings_1.b2_maxFloat;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        for (var i = 0; i < particleCount; i++) {\r\n            var p = pos_data[i];\r\n            b2Math_1.b2Vec2.MinV(aabb.lowerBound, p, aabb.lowerBound);\r\n            b2Math_1.b2Vec2.MaxV(aabb.upperBound, p, aabb.upperBound);\r\n        }\r\n        aabb.lowerBound.x -= this.m_particleDiameter;\r\n        aabb.lowerBound.y -= this.m_particleDiameter;\r\n        aabb.upperBound.x += this.m_particleDiameter;\r\n        aabb.upperBound.y += this.m_particleDiameter;\r\n    };\r\n    b2ParticleSystem.prototype.FreeBuffer = function (b, capacity) {\r\n        if (b === null) {\r\n            return;\r\n        }\r\n        b.length = 0;\r\n    };\r\n    b2ParticleSystem.prototype.FreeUserOverridableBuffer = function (b) {\r\n        if (b.userSuppliedCapacity === 0) {\r\n            this.FreeBuffer(b.data, this.m_internalAllocatedCapacity);\r\n        }\r\n    };\r\n    /**\r\n     * Reallocate a buffer\r\n     */\r\n    b2ParticleSystem.prototype.ReallocateBuffer3 = function (oldBuffer, oldCapacity, newCapacity) {\r\n        // b2Assert(newCapacity > oldCapacity);\r\n        if (newCapacity <= oldCapacity) {\r\n            throw new Error();\r\n        }\r\n        var newBuffer = (oldBuffer) ? oldBuffer.slice() : [];\r\n        newBuffer.length = newCapacity;\r\n        return newBuffer;\r\n    };\r\n    /**\r\n     * Reallocate a buffer\r\n     */\r\n    b2ParticleSystem.prototype.ReallocateBuffer5 = function (buffer, userSuppliedCapacity, oldCapacity, newCapacity, deferred) {\r\n        // b2Assert(newCapacity > oldCapacity);\r\n        if (newCapacity <= oldCapacity) {\r\n            throw new Error();\r\n        }\r\n        // A 'deferred' buffer is reallocated only if it is not NULL.\r\n        // If 'userSuppliedCapacity' is not zero, buffer is user supplied and must\r\n        // be kept.\r\n        // b2Assert(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity);\r\n        if (!(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity)) {\r\n            throw new Error();\r\n        }\r\n        if ((!deferred || buffer) && !userSuppliedCapacity) {\r\n            buffer = this.ReallocateBuffer3(buffer, oldCapacity, newCapacity);\r\n        }\r\n        return buffer; // TODO: fix this\r\n    };\r\n    /**\r\n     * Reallocate a buffer\r\n     */\r\n    b2ParticleSystem.prototype.ReallocateBuffer4 = function (buffer, oldCapacity, newCapacity, deferred) {\r\n        // DEBUG: b2Assert(newCapacity > oldCapacity);\r\n        return this.ReallocateBuffer5(buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);\r\n    };\r\n    b2ParticleSystem.prototype.RequestBuffer = function (buffer) {\r\n        if (!buffer) {\r\n            if (this.m_internalAllocatedCapacity === 0) {\r\n                this.ReallocateInternalAllocatedBuffers(b2Settings_1.b2_minParticleSystemBufferCapacity);\r\n            }\r\n            buffer = [];\r\n            buffer.length = this.m_internalAllocatedCapacity;\r\n        }\r\n        return buffer;\r\n    };\r\n    /**\r\n     * Reallocate the handle / index map and schedule the allocation\r\n     * of a new pool for handle allocation.\r\n     */\r\n    b2ParticleSystem.prototype.ReallocateHandleBuffers = function (newCapacity) {\r\n        // DEBUG: b2Assert(newCapacity > this.m_internalAllocatedCapacity);\r\n        // Reallocate a new handle / index map buffer, copying old handle pointers\r\n        // is fine since they're kept around.\r\n        this.m_handleIndexBuffer.data = this.ReallocateBuffer4(this.m_handleIndexBuffer, this.m_internalAllocatedCapacity, newCapacity, true);\r\n        // Set the size of the next handle allocation.\r\n        ///this.m_handleAllocator.SetItemsPerSlab(newCapacity - this.m_internalAllocatedCapacity);\r\n    };\r\n    b2ParticleSystem.prototype.ReallocateInternalAllocatedBuffers = function (capacity) {\r\n        function LimitCapacity(capacity, maxCount) {\r\n            return maxCount && capacity > maxCount ? maxCount : capacity;\r\n        }\r\n        // Don't increase capacity beyond the smallest user-supplied buffer size.\r\n        capacity = LimitCapacity(capacity, this.m_def.maxCount);\r\n        capacity = LimitCapacity(capacity, this.m_flagsBuffer.userSuppliedCapacity);\r\n        capacity = LimitCapacity(capacity, this.m_positionBuffer.userSuppliedCapacity);\r\n        capacity = LimitCapacity(capacity, this.m_velocityBuffer.userSuppliedCapacity);\r\n        capacity = LimitCapacity(capacity, this.m_colorBuffer.userSuppliedCapacity);\r\n        capacity = LimitCapacity(capacity, this.m_userDataBuffer.userSuppliedCapacity);\r\n        if (this.m_internalAllocatedCapacity < capacity) {\r\n            this.ReallocateHandleBuffers(capacity);\r\n            this.m_flagsBuffer.data = this.ReallocateBuffer4(this.m_flagsBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n            // Conditionally defer these as they are optional if the feature is\r\n            // not enabled.\r\n            var stuck = this.m_stuckThreshold > 0;\r\n            this.m_lastBodyContactStepBuffer.data = this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n            this.m_bodyContactCountBuffer.data = this.ReallocateBuffer4(this.m_bodyContactCountBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n            this.m_consecutiveContactStepsBuffer.data = this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n            this.m_positionBuffer.data = this.ReallocateBuffer4(this.m_positionBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_velocityBuffer.data = this.ReallocateBuffer4(this.m_velocityBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_forceBuffer = this.ReallocateBuffer5(this.m_forceBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_weightBuffer = this.ReallocateBuffer5(this.m_weightBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_staticPressureBuffer = this.ReallocateBuffer5(this.m_staticPressureBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_accumulationBuffer = this.ReallocateBuffer5(this.m_accumulationBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_accumulation2Buffer = this.ReallocateBuffer5(this.m_accumulation2Buffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_depthBuffer = this.ReallocateBuffer5(this.m_depthBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_colorBuffer.data = this.ReallocateBuffer4(this.m_colorBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_groupBuffer = this.ReallocateBuffer5(this.m_groupBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_userDataBuffer.data = this.ReallocateBuffer4(this.m_userDataBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_expirationTimeBuffer.data = this.ReallocateBuffer4(this.m_expirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n            this.m_indexByExpirationTimeBuffer.data = this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n            this.m_internalAllocatedCapacity = capacity;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticleForGroup = function (groupDef, xf, p) {\r\n        var particleDef = new b2Particle_1.b2ParticleDef();\r\n        particleDef.flags = b2Settings_1.b2Maybe(groupDef.flags, 0);\r\n        ///particleDef.position = b2Mul(xf, p);\r\n        b2Math_1.b2Transform.MulXV(xf, p, particleDef.position);\r\n        ///particleDef.velocity =\r\n        ///  groupDef.linearVelocity +\r\n        ///  b2Cross(groupDef.angularVelocity,\r\n        ///      particleDef.position - groupDef.position);\r\n        b2Math_1.b2Vec2.AddVV(b2Settings_1.b2Maybe(groupDef.linearVelocity, b2Math_1.b2Vec2.ZERO), b2Math_1.b2Vec2.CrossSV(b2Settings_1.b2Maybe(groupDef.angularVelocity, 0), b2Math_1.b2Vec2.SubVV(particleDef.position, b2Settings_1.b2Maybe(groupDef.position, b2Math_1.b2Vec2.ZERO), b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.s_t0), particleDef.velocity);\r\n        particleDef.color.Copy(b2Settings_1.b2Maybe(groupDef.color, b2Draw_1.b2Color.ZERO));\r\n        particleDef.lifetime = b2Settings_1.b2Maybe(groupDef.lifetime, 0);\r\n        particleDef.userData = groupDef.userData;\r\n        this.CreateParticle(particleDef);\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticlesStrokeShapeForGroup = function (shape, groupDef, xf) {\r\n        var s_edge = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge;\r\n        var s_d = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d;\r\n        var s_p = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p;\r\n        var stride = b2Settings_1.b2Maybe(groupDef.stride, 0);\r\n        if (stride === 0) {\r\n            stride = this.GetParticleStride();\r\n        }\r\n        var positionOnEdge = 0;\r\n        var childCount = shape.GetChildCount();\r\n        for (var childIndex = 0; childIndex < childCount; childIndex++) {\r\n            var edge = null;\r\n            if (shape.GetType() === b2Shape_1.b2ShapeType.e_edgeShape) {\r\n                edge = shape;\r\n            }\r\n            else {\r\n                // DEBUG: b2Assert(shape.GetType() === b2ShapeType.e_chainShape);\r\n                edge = s_edge;\r\n                shape.GetChildEdge(edge, childIndex);\r\n            }\r\n            var d = b2Math_1.b2Vec2.SubVV(edge.m_vertex2, edge.m_vertex1, s_d);\r\n            var edgeLength = d.Length();\r\n            while (positionOnEdge < edgeLength) {\r\n                ///b2Vec2 p = edge.m_vertex1 + positionOnEdge / edgeLength * d;\r\n                var p = b2Math_1.b2Vec2.AddVMulSV(edge.m_vertex1, positionOnEdge / edgeLength, d, s_p);\r\n                this.CreateParticleForGroup(groupDef, xf, p);\r\n                positionOnEdge += stride;\r\n            }\r\n            positionOnEdge -= edgeLength;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticlesFillShapeForGroup = function (shape, groupDef, xf) {\r\n        var s_aabb = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb;\r\n        var s_p = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p;\r\n        var stride = b2Settings_1.b2Maybe(groupDef.stride, 0);\r\n        if (stride === 0) {\r\n            stride = this.GetParticleStride();\r\n        }\r\n        ///b2Transform identity;\r\n        /// identity.SetIdentity();\r\n        var identity = b2Math_1.b2Transform.IDENTITY;\r\n        var aabb = s_aabb;\r\n        // DEBUG: b2Assert(shape.GetChildCount() === 1);\r\n        shape.ComputeAABB(aabb, identity, 0);\r\n        for (var y = Math.floor(aabb.lowerBound.y / stride) * stride; y < aabb.upperBound.y; y += stride) {\r\n            for (var x = Math.floor(aabb.lowerBound.x / stride) * stride; x < aabb.upperBound.x; x += stride) {\r\n                var p = s_p.Set(x, y);\r\n                if (shape.TestPoint(identity, p)) {\r\n                    this.CreateParticleForGroup(groupDef, xf, p);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticlesWithShapeForGroup = function (shape, groupDef, xf) {\r\n        switch (shape.GetType()) {\r\n            case b2Shape_1.b2ShapeType.e_edgeShape:\r\n            case b2Shape_1.b2ShapeType.e_chainShape:\r\n                this.CreateParticlesStrokeShapeForGroup(shape, groupDef, xf);\r\n                break;\r\n            case b2Shape_1.b2ShapeType.e_polygonShape:\r\n            case b2Shape_1.b2ShapeType.e_circleShape:\r\n                this.CreateParticlesFillShapeForGroup(shape, groupDef, xf);\r\n                break;\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                break;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticlesWithShapesForGroup = function (shapes, shapeCount, groupDef, xf) {\r\n        var compositeShape = new b2ParticleSystem_CompositeShape(shapes, shapeCount);\r\n        this.CreateParticlesFillShapeForGroup(compositeShape, groupDef, xf);\r\n    };\r\n    b2ParticleSystem.prototype.CloneParticle = function (oldIndex, group) {\r\n        var def = new b2Particle_1.b2ParticleDef();\r\n        def.flags = this.m_flagsBuffer.data[oldIndex];\r\n        def.position.Copy(this.m_positionBuffer.data[oldIndex]);\r\n        def.velocity.Copy(this.m_velocityBuffer.data[oldIndex]);\r\n        if (this.m_colorBuffer.data) {\r\n            def.color.Copy(this.m_colorBuffer.data[oldIndex]);\r\n        }\r\n        if (this.m_userDataBuffer.data) {\r\n            def.userData = this.m_userDataBuffer.data[oldIndex];\r\n        }\r\n        def.group = group;\r\n        var newIndex = this.CreateParticle(def);\r\n        if (this.m_handleIndexBuffer.data) {\r\n            var handle = this.m_handleIndexBuffer.data[oldIndex];\r\n            if (handle) {\r\n                handle.SetIndex(newIndex);\r\n            }\r\n            this.m_handleIndexBuffer.data[newIndex] = handle;\r\n            this.m_handleIndexBuffer.data[oldIndex] = null;\r\n        }\r\n        if (this.m_lastBodyContactStepBuffer.data) {\r\n            this.m_lastBodyContactStepBuffer.data[newIndex] =\r\n                this.m_lastBodyContactStepBuffer.data[oldIndex];\r\n        }\r\n        if (this.m_bodyContactCountBuffer.data) {\r\n            this.m_bodyContactCountBuffer.data[newIndex] =\r\n                this.m_bodyContactCountBuffer.data[oldIndex];\r\n        }\r\n        if (this.m_consecutiveContactStepsBuffer.data) {\r\n            this.m_consecutiveContactStepsBuffer.data[newIndex] =\r\n                this.m_consecutiveContactStepsBuffer.data[oldIndex];\r\n        }\r\n        if (this.m_hasForce) {\r\n            this.m_forceBuffer[newIndex].Copy(this.m_forceBuffer[oldIndex]);\r\n        }\r\n        if (this.m_staticPressureBuffer) {\r\n            this.m_staticPressureBuffer[newIndex] = this.m_staticPressureBuffer[oldIndex];\r\n        }\r\n        if (this.m_depthBuffer) {\r\n            this.m_depthBuffer[newIndex] = this.m_depthBuffer[oldIndex];\r\n        }\r\n        if (this.m_expirationTimeBuffer.data) {\r\n            this.m_expirationTimeBuffer.data[newIndex] =\r\n                this.m_expirationTimeBuffer.data[oldIndex];\r\n        }\r\n        return newIndex;\r\n    };\r\n    b2ParticleSystem.prototype.DestroyParticlesInGroup = function (group, callDestructionListener) {\r\n        if (callDestructionListener === void 0) { callDestructionListener = false; }\r\n        for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n            this.DestroyParticle(i, callDestructionListener);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.DestroyParticleGroup = function (group) {\r\n        // DEBUG: b2Assert(this.m_groupCount > 0);\r\n        // DEBUG: b2Assert(group !== null);\r\n        if (this.m_world.m_destructionListener) {\r\n            this.m_world.m_destructionListener.SayGoodbyeParticleGroup(group);\r\n        }\r\n        this.SetGroupFlags(group, 0);\r\n        for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n            this.m_groupBuffer[i] = null;\r\n        }\r\n        if (group.m_prev) {\r\n            group.m_prev.m_next = group.m_next;\r\n        }\r\n        if (group.m_next) {\r\n            group.m_next.m_prev = group.m_prev;\r\n        }\r\n        if (group === this.m_groupList) {\r\n            this.m_groupList = group.m_next;\r\n        }\r\n        --this.m_groupCount;\r\n    };\r\n    b2ParticleSystem.ParticleCanBeConnected = function (flags, group) {\r\n        return ((flags & (b2Particle_1.b2ParticleFlag.b2_wallParticle | b2Particle_1.b2ParticleFlag.b2_springParticle | b2Particle_1.b2ParticleFlag.b2_elasticParticle)) !== 0) ||\r\n            ((group !== null) && ((group.GetGroupFlags() & b2ParticleGroup_1.b2ParticleGroupFlag.b2_rigidParticleGroup) !== 0));\r\n    };\r\n    b2ParticleSystem.prototype.UpdatePairsAndTriads = function (firstIndex, lastIndex, filter) {\r\n        var s_dab = b2ParticleSystem.UpdatePairsAndTriads_s_dab;\r\n        var s_dbc = b2ParticleSystem.UpdatePairsAndTriads_s_dbc;\r\n        var s_dca = b2ParticleSystem.UpdatePairsAndTriads_s_dca;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        // Create pairs or triads.\r\n        // All particles in each pair/triad should satisfy the following:\r\n        // * firstIndex <= index < lastIndex\r\n        // * don't have b2_zombieParticle\r\n        // * ParticleCanBeConnected returns true\r\n        // * ShouldCreatePair/ShouldCreateTriad returns true\r\n        // Any particles in each pair/triad should satisfy the following:\r\n        // * filter.IsNeeded returns true\r\n        // * have one of k_pairFlags/k_triadsFlags\r\n        // DEBUG: b2Assert(firstIndex <= lastIndex);\r\n        var particleFlags = 0;\r\n        for (var i = firstIndex; i < lastIndex; i++) {\r\n            particleFlags |= this.m_flagsBuffer.data[i];\r\n        }\r\n        if (particleFlags & b2ParticleSystem.k_pairFlags) {\r\n            for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n                var contact = this.m_contactBuffer.data[k];\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                var af = this.m_flagsBuffer.data[a];\r\n                var bf = this.m_flagsBuffer.data[b];\r\n                var groupA = this.m_groupBuffer[a];\r\n                var groupB = this.m_groupBuffer[b];\r\n                if (a >= firstIndex && a < lastIndex &&\r\n                    b >= firstIndex && b < lastIndex &&\r\n                    !((af | bf) & b2Particle_1.b2ParticleFlag.b2_zombieParticle) &&\r\n                    ((af | bf) & b2ParticleSystem.k_pairFlags) &&\r\n                    (filter.IsNecessary(a) || filter.IsNecessary(b)) &&\r\n                    b2ParticleSystem.ParticleCanBeConnected(af, groupA) &&\r\n                    b2ParticleSystem.ParticleCanBeConnected(bf, groupB) &&\r\n                    filter.ShouldCreatePair(a, b)) {\r\n                    ///b2ParticlePair& pair = m_pairBuffer.Append();\r\n                    var pair = this.m_pairBuffer.data[this.m_pairBuffer.Append()];\r\n                    pair.indexA = a;\r\n                    pair.indexB = b;\r\n                    pair.flags = contact.flags;\r\n                    pair.strength = b2Math_1.b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1);\r\n                    ///pair.distance = b2Distance(pos_data[a], pos_data[b]); // TODO: this was wrong!\r\n                    pair.distance = b2Math_1.b2Vec2.DistanceVV(pos_data[a], pos_data[b]);\r\n                }\r\n                ///std::stable_sort(m_pairBuffer.Begin(), m_pairBuffer.End(), ComparePairIndices);\r\n                std_stable_sort(this.m_pairBuffer.data, 0, this.m_pairBuffer.count, b2ParticleSystem.ComparePairIndices);\r\n                ///m_pairBuffer.Unique(MatchPairIndices);\r\n                this.m_pairBuffer.Unique(b2ParticleSystem.MatchPairIndices);\r\n            }\r\n        }\r\n        if (particleFlags & b2ParticleSystem.k_triadFlags) {\r\n            var diagram = new b2VoronoiDiagram_1.b2VoronoiDiagram(lastIndex - firstIndex);\r\n            ///let necessary_count = 0;\r\n            for (var i = firstIndex; i < lastIndex; i++) {\r\n                var flags = this.m_flagsBuffer.data[i];\r\n                var group = this.m_groupBuffer[i];\r\n                if (!(flags & b2Particle_1.b2ParticleFlag.b2_zombieParticle) &&\r\n                    b2ParticleSystem.ParticleCanBeConnected(flags, group)) {\r\n                    ///if (filter.IsNecessary(i)) {\r\n                    ///++necessary_count;\r\n                    ///}\r\n                    diagram.AddGenerator(pos_data[i], i, filter.IsNecessary(i));\r\n                }\r\n            }\r\n            ///if (necessary_count === 0) {\r\n            /////debugger;\r\n            ///for (let i = firstIndex; i < lastIndex; i++) {\r\n            ///  filter.IsNecessary(i);\r\n            ///}\r\n            ///}\r\n            var stride = this.GetParticleStride();\r\n            diagram.Generate(stride / 2, stride * 2);\r\n            var system_1 = this;\r\n            var callback = /*UpdateTriadsCallback*/ function (a, b, c) {\r\n                var af = system_1.m_flagsBuffer.data[a];\r\n                var bf = system_1.m_flagsBuffer.data[b];\r\n                var cf = system_1.m_flagsBuffer.data[c];\r\n                if (((af | bf | cf) & b2ParticleSystem.k_triadFlags) &&\r\n                    filter.ShouldCreateTriad(a, b, c)) {\r\n                    var pa = pos_data[a];\r\n                    var pb = pos_data[b];\r\n                    var pc = pos_data[c];\r\n                    var dab = b2Math_1.b2Vec2.SubVV(pa, pb, s_dab);\r\n                    var dbc = b2Math_1.b2Vec2.SubVV(pb, pc, s_dbc);\r\n                    var dca = b2Math_1.b2Vec2.SubVV(pc, pa, s_dca);\r\n                    var maxDistanceSquared = b2Settings_1.b2_maxTriadDistanceSquared * system_1.m_squaredDiameter;\r\n                    if (b2Math_1.b2Vec2.DotVV(dab, dab) > maxDistanceSquared ||\r\n                        b2Math_1.b2Vec2.DotVV(dbc, dbc) > maxDistanceSquared ||\r\n                        b2Math_1.b2Vec2.DotVV(dca, dca) > maxDistanceSquared) {\r\n                        return;\r\n                    }\r\n                    var groupA = system_1.m_groupBuffer[a];\r\n                    var groupB = system_1.m_groupBuffer[b];\r\n                    var groupC = system_1.m_groupBuffer[c];\r\n                    ///b2ParticleTriad& triad = m_system.m_triadBuffer.Append();\r\n                    var triad = system_1.m_triadBuffer.data[system_1.m_triadBuffer.Append()];\r\n                    triad.indexA = a;\r\n                    triad.indexB = b;\r\n                    triad.indexC = c;\r\n                    triad.flags = af | bf | cf;\r\n                    triad.strength = b2Math_1.b2Min(b2Math_1.b2Min(groupA ? groupA.m_strength : 1, groupB ? groupB.m_strength : 1), groupC ? groupC.m_strength : 1);\r\n                    ///let midPoint = b2Vec2.MulSV(1.0 / 3.0, b2Vec2.AddVV(pa, b2Vec2.AddVV(pb, pc, new b2Vec2()), new b2Vec2()), new b2Vec2());\r\n                    var midPoint_x = (pa.x + pb.x + pc.x) / 3.0;\r\n                    var midPoint_y = (pa.y + pb.y + pc.y) / 3.0;\r\n                    ///triad.pa = b2Vec2.SubVV(pa, midPoint, new b2Vec2());\r\n                    triad.pa.x = pa.x - midPoint_x;\r\n                    triad.pa.y = pa.y - midPoint_y;\r\n                    ///triad.pb = b2Vec2.SubVV(pb, midPoint, new b2Vec2());\r\n                    triad.pb.x = pb.x - midPoint_x;\r\n                    triad.pb.y = pb.y - midPoint_y;\r\n                    ///triad.pc = b2Vec2.SubVV(pc, midPoint, new b2Vec2());\r\n                    triad.pc.x = pc.x - midPoint_x;\r\n                    triad.pc.y = pc.y - midPoint_y;\r\n                    triad.ka = -b2Math_1.b2Vec2.DotVV(dca, dab);\r\n                    triad.kb = -b2Math_1.b2Vec2.DotVV(dab, dbc);\r\n                    triad.kc = -b2Math_1.b2Vec2.DotVV(dbc, dca);\r\n                    triad.s = b2Math_1.b2Vec2.CrossVV(pa, pb) + b2Math_1.b2Vec2.CrossVV(pb, pc) + b2Math_1.b2Vec2.CrossVV(pc, pa);\r\n                }\r\n            };\r\n            diagram.GetNodes(callback);\r\n            ///std::stable_sort(m_triadBuffer.Begin(), m_triadBuffer.End(), CompareTriadIndices);\r\n            std_stable_sort(this.m_triadBuffer.data, 0, this.m_triadBuffer.count, b2ParticleSystem.CompareTriadIndices);\r\n            ///m_triadBuffer.Unique(MatchTriadIndices);\r\n            this.m_triadBuffer.Unique(b2ParticleSystem.MatchTriadIndices);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.UpdatePairsAndTriadsWithReactiveParticles = function () {\r\n        var filter = new b2ParticleSystem_ReactiveFilter(this.m_flagsBuffer);\r\n        this.UpdatePairsAndTriads(0, this.m_count, filter);\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            this.m_flagsBuffer.data[i] &= ~b2Particle_1.b2ParticleFlag.b2_reactiveParticle;\r\n        }\r\n        this.m_allParticleFlags &= ~b2Particle_1.b2ParticleFlag.b2_reactiveParticle;\r\n    };\r\n    b2ParticleSystem.ComparePairIndices = function (a, b) {\r\n        var diffA = a.indexA - b.indexA;\r\n        if (diffA !== 0) {\r\n            return diffA < 0;\r\n        }\r\n        return a.indexB < b.indexB;\r\n    };\r\n    b2ParticleSystem.MatchPairIndices = function (a, b) {\r\n        return a.indexA === b.indexA && a.indexB === b.indexB;\r\n    };\r\n    b2ParticleSystem.CompareTriadIndices = function (a, b) {\r\n        var diffA = a.indexA - b.indexA;\r\n        if (diffA !== 0) {\r\n            return diffA < 0;\r\n        }\r\n        var diffB = a.indexB - b.indexB;\r\n        if (diffB !== 0) {\r\n            return diffB < 0;\r\n        }\r\n        return a.indexC < b.indexC;\r\n    };\r\n    b2ParticleSystem.MatchTriadIndices = function (a, b) {\r\n        return a.indexA === b.indexA && a.indexB === b.indexB && a.indexC === b.indexC;\r\n    };\r\n    b2ParticleSystem.InitializeParticleLists = function (group, nodeBuffer) {\r\n        var bufferIndex = group.GetBufferIndex();\r\n        var particleCount = group.GetParticleCount();\r\n        for (var i = 0; i < particleCount; i++) {\r\n            var node = nodeBuffer[i];\r\n            node.list = node;\r\n            node.next = null;\r\n            node.count = 1;\r\n            node.index = i + bufferIndex;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.MergeParticleListsInContact = function (group, nodeBuffer) {\r\n        var bufferIndex = group.GetBufferIndex();\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            /*const b2ParticleContact&*/\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            if (!group.ContainsParticle(a) || !group.ContainsParticle(b)) {\r\n                continue;\r\n            }\r\n            var listA = nodeBuffer[a - bufferIndex].list;\r\n            var listB = nodeBuffer[b - bufferIndex].list;\r\n            if (listA === listB) {\r\n                continue;\r\n            }\r\n            // To minimize the cost of insertion, make sure listA is longer than\r\n            // listB.\r\n            if (listA.count < listB.count) {\r\n                var _tmp = listA;\r\n                listA = listB;\r\n                listB = _tmp; ///b2Swap(listA, listB);\r\n            }\r\n            // DEBUG: b2Assert(listA.count >= listB.count);\r\n            b2ParticleSystem.MergeParticleLists(listA, listB);\r\n        }\r\n    };\r\n    b2ParticleSystem.MergeParticleLists = function (listA, listB) {\r\n        // Insert listB between index 0 and 1 of listA\r\n        // Example:\r\n        //     listA => a1 => a2 => a3 => null\r\n        //     listB => b1 => b2 => null\r\n        // to\r\n        //     listA => listB => b1 => b2 => a1 => a2 => a3 => null\r\n        // DEBUG: b2Assert(listA !== listB);\r\n        for (var b = listB;;) {\r\n            b.list = listA;\r\n            var nextB = b.next;\r\n            if (nextB) {\r\n                b = nextB;\r\n            }\r\n            else {\r\n                b.next = listA.next;\r\n                break;\r\n            }\r\n        }\r\n        listA.next = listB;\r\n        listA.count += listB.count;\r\n        listB.count = 0;\r\n    };\r\n    b2ParticleSystem.FindLongestParticleList = function (group, nodeBuffer) {\r\n        var particleCount = group.GetParticleCount();\r\n        var result = nodeBuffer[0];\r\n        for (var i = 0; i < particleCount; i++) {\r\n            var node = nodeBuffer[i];\r\n            if (result.count < node.count) {\r\n                result = node;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n    b2ParticleSystem.prototype.MergeZombieParticleListNodes = function (group, nodeBuffer, survivingList) {\r\n        var particleCount = group.GetParticleCount();\r\n        for (var i = 0; i < particleCount; i++) {\r\n            var node = nodeBuffer[i];\r\n            if (node !== survivingList &&\r\n                (this.m_flagsBuffer.data[node.index] & b2Particle_1.b2ParticleFlag.b2_zombieParticle)) {\r\n                b2ParticleSystem.MergeParticleListAndNode(survivingList, node);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.MergeParticleListAndNode = function (list, node) {\r\n        // Insert node between index 0 and 1 of list\r\n        // Example:\r\n        //     list => a1 => a2 => a3 => null\r\n        //     node => null\r\n        // to\r\n        //     list => node => a1 => a2 => a3 => null\r\n        // DEBUG: b2Assert(node !== list);\r\n        // DEBUG: b2Assert(node.list === node);\r\n        // DEBUG: b2Assert(node.count === 1);\r\n        node.list = list;\r\n        node.next = list.next;\r\n        list.next = node;\r\n        list.count++;\r\n        node.count = 0;\r\n    };\r\n    b2ParticleSystem.prototype.CreateParticleGroupsFromParticleList = function (group, nodeBuffer, survivingList) {\r\n        var particleCount = group.GetParticleCount();\r\n        var def = new b2ParticleGroup_1.b2ParticleGroupDef();\r\n        def.groupFlags = group.GetGroupFlags();\r\n        def.userData = group.GetUserData();\r\n        for (var i = 0; i < particleCount; i++) {\r\n            var list = nodeBuffer[i];\r\n            if (!list.count || list === survivingList) {\r\n                continue;\r\n            }\r\n            // DEBUG: b2Assert(list.list === list);\r\n            var newGroup = this.CreateParticleGroup(def);\r\n            for (var node = list; node; node = node.next) {\r\n                var oldIndex = node.index;\r\n                // DEBUG: const flags = this.m_flagsBuffer.data[oldIndex];\r\n                // DEBUG: b2Assert(!(flags & b2ParticleFlag.b2_zombieParticle));\r\n                var newIndex = this.CloneParticle(oldIndex, newGroup);\r\n                this.m_flagsBuffer.data[oldIndex] |= b2Particle_1.b2ParticleFlag.b2_zombieParticle;\r\n                node.index = newIndex;\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.UpdatePairsAndTriadsWithParticleList = function (group, nodeBuffer) {\r\n        var bufferIndex = group.GetBufferIndex();\r\n        // Update indices in pairs and triads. If an index belongs to the group,\r\n        // replace it with the corresponding value in nodeBuffer.\r\n        // Note that nodeBuffer is allocated only for the group and the index should\r\n        // be shifted by bufferIndex.\r\n        for (var k = 0; k < this.m_pairBuffer.count; k++) {\r\n            var pair = this.m_pairBuffer.data[k];\r\n            var a = pair.indexA;\r\n            var b = pair.indexB;\r\n            if (group.ContainsParticle(a)) {\r\n                pair.indexA = nodeBuffer[a - bufferIndex].index;\r\n            }\r\n            if (group.ContainsParticle(b)) {\r\n                pair.indexB = nodeBuffer[b - bufferIndex].index;\r\n            }\r\n        }\r\n        for (var k = 0; k < this.m_triadBuffer.count; k++) {\r\n            var triad = this.m_triadBuffer.data[k];\r\n            var a = triad.indexA;\r\n            var b = triad.indexB;\r\n            var c = triad.indexC;\r\n            if (group.ContainsParticle(a)) {\r\n                triad.indexA = nodeBuffer[a - bufferIndex].index;\r\n            }\r\n            if (group.ContainsParticle(b)) {\r\n                triad.indexB = nodeBuffer[b - bufferIndex].index;\r\n            }\r\n            if (group.ContainsParticle(c)) {\r\n                triad.indexC = nodeBuffer[c - bufferIndex].index;\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.ComputeDepth = function () {\r\n        var contactGroups = []; // TODO: static\r\n        var contactGroupsCount = 0;\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var groupA = this.m_groupBuffer[a];\r\n            var groupB = this.m_groupBuffer[b];\r\n            if (groupA && groupA === groupB &&\r\n                (groupA.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth)) {\r\n                contactGroups[contactGroupsCount++] = contact;\r\n            }\r\n        }\r\n        var groupsToUpdate = []; // TODO: static\r\n        var groupsToUpdateCount = 0;\r\n        for (var group = this.m_groupList; group; group = group.GetNext()) {\r\n            if (group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {\r\n                groupsToUpdate[groupsToUpdateCount++] = group;\r\n                this.SetGroupFlags(group, group.m_groupFlags &\r\n                    ~b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);\r\n                for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n                    this.m_accumulationBuffer[i] = 0;\r\n                }\r\n            }\r\n        }\r\n        // Compute sum of weight of contacts except between different groups.\r\n        for (var k = 0; k < contactGroupsCount; k++) {\r\n            var contact = contactGroups[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var w = contact.weight;\r\n            this.m_accumulationBuffer[a] += w;\r\n            this.m_accumulationBuffer[b] += w;\r\n        }\r\n        // DEBUG: b2Assert(this.m_depthBuffer !== null);\r\n        for (var i = 0; i < groupsToUpdateCount; i++) {\r\n            var group = groupsToUpdate[i];\r\n            for (var i_1 = group.m_firstIndex; i_1 < group.m_lastIndex; i_1++) {\r\n                var w = this.m_accumulationBuffer[i_1];\r\n                this.m_depthBuffer[i_1] = w < 0.8 ? 0 : b2Settings_1.b2_maxFloat;\r\n            }\r\n        }\r\n        // The number of iterations is equal to particle number from the deepest\r\n        // particle to the nearest surface particle, and in general it is smaller\r\n        // than sqrt of total particle number.\r\n        ///int32 iterationCount = (int32)b2Sqrt((float)m_count);\r\n        var iterationCount = b2Math_1.b2Sqrt(this.m_count) >> 0;\r\n        for (var t = 0; t < iterationCount; t++) {\r\n            var updated = false;\r\n            for (var k = 0; k < contactGroupsCount; k++) {\r\n                var contact = contactGroups[k];\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                var r = 1 - contact.weight;\r\n                ///float32& ap0 = m_depthBuffer[a];\r\n                var ap0 = this.m_depthBuffer[a];\r\n                ///float32& bp0 = m_depthBuffer[b];\r\n                var bp0 = this.m_depthBuffer[b];\r\n                var ap1 = bp0 + r;\r\n                var bp1 = ap0 + r;\r\n                if (ap0 > ap1) {\r\n                    ///ap0 = ap1;\r\n                    this.m_depthBuffer[a] = ap1;\r\n                    updated = true;\r\n                }\r\n                if (bp0 > bp1) {\r\n                    ///bp0 = bp1;\r\n                    this.m_depthBuffer[b] = bp1;\r\n                    updated = true;\r\n                }\r\n            }\r\n            if (!updated) {\r\n                break;\r\n            }\r\n        }\r\n        for (var i = 0; i < groupsToUpdateCount; i++) {\r\n            var group = groupsToUpdate[i];\r\n            for (var i_2 = group.m_firstIndex; i_2 < group.m_lastIndex; i_2++) {\r\n                if (this.m_depthBuffer[i_2] < b2Settings_1.b2_maxFloat) {\r\n                    this.m_depthBuffer[i_2] *= this.m_particleDiameter;\r\n                }\r\n                else {\r\n                    this.m_depthBuffer[i_2] = 0;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.GetInsideBoundsEnumerator = function (aabb) {\r\n        var lowerTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x - 1, this.m_inverseDiameter * aabb.lowerBound.y - 1);\r\n        var upperTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x + 1, this.m_inverseDiameter * aabb.upperBound.y + 1);\r\n        ///const Proxy* beginProxy = m_proxyBuffer.Begin();\r\n        var beginProxy = 0;\r\n        ///const Proxy* endProxy = m_proxyBuffer.End();\r\n        var endProxy = this.m_proxyBuffer.count;\r\n        ///const Proxy* firstProxy = std::lower_bound(beginProxy, endProxy, lowerTag);\r\n        var firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, lowerTag, b2ParticleSystem_Proxy.CompareProxyTag);\r\n        ///const Proxy* lastProxy = std::upper_bound(firstProxy, endProxy, upperTag);\r\n        var lastProxy = std_upper_bound(this.m_proxyBuffer.data, beginProxy, endProxy, upperTag, b2ParticleSystem_Proxy.CompareTagProxy);\r\n        // DEBUG: b2Assert(beginProxy <= firstProxy);\r\n        // DEBUG: b2Assert(firstProxy <= lastProxy);\r\n        // DEBUG: b2Assert(lastProxy <= endProxy);\r\n        return new b2ParticleSystem_InsideBoundsEnumerator(this, lowerTag, upperTag, firstProxy, lastProxy);\r\n    };\r\n    b2ParticleSystem.prototype.UpdateAllParticleFlags = function () {\r\n        this.m_allParticleFlags = 0;\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            this.m_allParticleFlags |= this.m_flagsBuffer.data[i];\r\n        }\r\n        this.m_needsUpdateAllParticleFlags = false;\r\n    };\r\n    b2ParticleSystem.prototype.UpdateAllGroupFlags = function () {\r\n        this.m_allGroupFlags = 0;\r\n        for (var group = this.m_groupList; group; group = group.GetNext()) {\r\n            this.m_allGroupFlags |= group.m_groupFlags;\r\n        }\r\n        this.m_needsUpdateAllGroupFlags = false;\r\n    };\r\n    b2ParticleSystem.prototype.AddContact = function (a, b, contacts) {\r\n        // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n        var flags_data = this.m_flagsBuffer.data;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        ///b2Vec2 d = m_positionBuffer.data[b] - m_positionBuffer.data[a];\r\n        var d = b2Math_1.b2Vec2.SubVV(pos_data[b], pos_data[a], b2ParticleSystem.AddContact_s_d);\r\n        var distBtParticlesSq = b2Math_1.b2Vec2.DotVV(d, d);\r\n        if (0 < distBtParticlesSq && distBtParticlesSq < this.m_squaredDiameter) {\r\n            var invD = b2Math_1.b2InvSqrt(distBtParticlesSq);\r\n            ///b2ParticleContact& contact = contacts.Append();\r\n            var contact = this.m_contactBuffer.data[this.m_contactBuffer.Append()];\r\n            contact.indexA = a;\r\n            contact.indexB = b;\r\n            contact.flags = flags_data[a] | flags_data[b];\r\n            contact.weight = 1 - distBtParticlesSq * invD * this.m_inverseDiameter;\r\n            contact.normal.x = invD * d.x;\r\n            contact.normal.y = invD * d.y;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.FindContacts_Reference = function (contacts) {\r\n        // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n        var beginProxy = 0;\r\n        var endProxy = this.m_proxyBuffer.count;\r\n        this.m_contactBuffer.count = 0;\r\n        for (var a = beginProxy, c = beginProxy; a < endProxy; a++) {\r\n            var rightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 0);\r\n            for (var b = a + 1; b < endProxy; b++) {\r\n                if (rightTag < this.m_proxyBuffer.data[b].tag) {\r\n                    break;\r\n                }\r\n                this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);\r\n            }\r\n            var bottomLeftTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, -1, 1);\r\n            for (; c < endProxy; c++) {\r\n                if (bottomLeftTag <= this.m_proxyBuffer.data[c].tag) {\r\n                    break;\r\n                }\r\n            }\r\n            var bottomRightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 1);\r\n            for (var b = c; b < endProxy; b++) {\r\n                if (bottomRightTag < this.m_proxyBuffer.data[b].tag) {\r\n                    break;\r\n                }\r\n                this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);\r\n            }\r\n        }\r\n    };\r\n    ///void ReorderForFindContact(FindContactInput* reordered, int alignedCount) const;\r\n    ///void GatherChecksOneParticle(const uint32 bound, const int startIndex, const int particleIndex, int* nextUncheckedIndex, b2GrowableBuffer<FindContactCheck>& checks) const;\r\n    ///void GatherChecks(b2GrowableBuffer<FindContactCheck>& checks) const;\r\n    ///void FindContacts_Simd(b2GrowableBuffer<b2ParticleContact>& contacts) const;\r\n    b2ParticleSystem.prototype.FindContacts = function (contacts) {\r\n        this.FindContacts_Reference(contacts);\r\n    };\r\n    ///static void UpdateProxyTags(const uint32* const tags, b2GrowableBuffer<Proxy>& proxies);\r\n    ///static bool ProxyBufferHasIndex(int32 index, const Proxy* const a, int count);\r\n    ///static int NumProxiesWithSameTag(const Proxy* const a, const Proxy* const b, int count);\r\n    ///static bool AreProxyBuffersTheSame(const b2GrowableBuffer<Proxy>& a, const b2GrowableBuffer<Proxy>& b);\r\n    b2ParticleSystem.prototype.UpdateProxies_Reference = function (proxies) {\r\n        // DEBUG: b2Assert(proxies === this.m_proxyBuffer);\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var inv_diam = this.m_inverseDiameter;\r\n        for (var k = 0; k < this.m_proxyBuffer.count; ++k) {\r\n            var proxy = this.m_proxyBuffer.data[k];\r\n            var i = proxy.index;\r\n            var p = pos_data[i];\r\n            proxy.tag = b2ParticleSystem.computeTag(inv_diam * p.x, inv_diam * p.y);\r\n        }\r\n    };\r\n    ///void UpdateProxies_Simd(b2GrowableBuffer<Proxy>& proxies) const;\r\n    b2ParticleSystem.prototype.UpdateProxies = function (proxies) {\r\n        this.UpdateProxies_Reference(proxies);\r\n    };\r\n    b2ParticleSystem.prototype.SortProxies = function (proxies) {\r\n        // DEBUG: b2Assert(proxies === this.m_proxyBuffer);\r\n        ///std::sort(proxies.Begin(), proxies.End());\r\n        std_sort(this.m_proxyBuffer.data, 0, this.m_proxyBuffer.count, b2ParticleSystem_Proxy.CompareProxyProxy);\r\n    };\r\n    b2ParticleSystem.prototype.FilterContacts = function (contacts) {\r\n        // Optionally filter the contact.\r\n        var contactFilter = this.GetParticleContactFilter();\r\n        if (contactFilter === null) {\r\n            return;\r\n        }\r\n        /// contacts.RemoveIf(b2ParticleContactRemovePredicate(this, contactFilter));\r\n        // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n        var system = this;\r\n        var predicate = function (contact) {\r\n            return ((contact.flags & b2Particle_1.b2ParticleFlag.b2_particleContactFilterParticle) !== 0) && !contactFilter.ShouldCollideParticleParticle(system, contact.indexA, contact.indexB);\r\n        };\r\n        this.m_contactBuffer.RemoveIf(predicate);\r\n    };\r\n    b2ParticleSystem.prototype.NotifyContactListenerPreContact = function (particlePairs) {\r\n        var contactListener = this.GetParticleContactListener();\r\n        if (contactListener === null) {\r\n            return;\r\n        }\r\n        ///particlePairs.Initialize(m_contactBuffer.Begin(), m_contactBuffer.GetCount(), GetFlagsBuffer());\r\n        particlePairs.Initialize(this.m_contactBuffer, this.m_flagsBuffer);\r\n        throw new Error(); // TODO: notify\r\n    };\r\n    b2ParticleSystem.prototype.NotifyContactListenerPostContact = function (particlePairs) {\r\n        var contactListener = this.GetParticleContactListener();\r\n        if (contactListener === null) {\r\n            return;\r\n        }\r\n        // Loop through all new contacts, reporting any new ones, and\r\n        // \"invalidating\" the ones that still exist.\r\n        ///const b2ParticleContact* const endContact = m_contactBuffer.End();\r\n        ///for (b2ParticleContact* contact = m_contactBuffer.Begin(); contact < endContact; ++contact)\r\n        for (var k = 0; k < this.m_contactBuffer.count; ++k) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            ///ParticlePair pair;\r\n            ///pair.first = contact.GetIndexA();\r\n            ///pair.second = contact.GetIndexB();\r\n            ///const int32 itemIndex = particlePairs.Find(pair);\r\n            var itemIndex = -1; // TODO\r\n            if (itemIndex >= 0) {\r\n                // Already touching, ignore this contact.\r\n                particlePairs.Invalidate(itemIndex);\r\n            }\r\n            else {\r\n                // Just started touching, inform the listener.\r\n                contactListener.BeginContactParticleParticle(this, contact);\r\n            }\r\n        }\r\n        // Report particles that are no longer touching.\r\n        // That is, any pairs that were not invalidated above.\r\n        ///const int32 pairCount = particlePairs.GetCount();\r\n        ///const ParticlePair* const pairs = particlePairs.GetBuffer();\r\n        ///const int8* const valid = particlePairs.GetValidBuffer();\r\n        ///for (int32 i = 0; i < pairCount; ++i)\r\n        ///{\r\n        ///  if (valid[i])\r\n        ///  {\r\n        ///    contactListener.EndContactParticleParticle(this, pairs[i].first, pairs[i].second);\r\n        ///  }\r\n        ///}\r\n        throw new Error(); // TODO: notify\r\n    };\r\n    b2ParticleSystem.b2ParticleContactIsZombie = function (contact) {\r\n        return (contact.flags & b2Particle_1.b2ParticleFlag.b2_zombieParticle) === b2Particle_1.b2ParticleFlag.b2_zombieParticle;\r\n    };\r\n    b2ParticleSystem.prototype.UpdateContacts = function (exceptZombie) {\r\n        this.UpdateProxies(this.m_proxyBuffer);\r\n        this.SortProxies(this.m_proxyBuffer);\r\n        var particlePairs = new b2ParticlePairSet(); // TODO: static\r\n        this.NotifyContactListenerPreContact(particlePairs);\r\n        this.FindContacts(this.m_contactBuffer);\r\n        this.FilterContacts(this.m_contactBuffer);\r\n        this.NotifyContactListenerPostContact(particlePairs);\r\n        if (exceptZombie) {\r\n            this.m_contactBuffer.RemoveIf(b2ParticleSystem.b2ParticleContactIsZombie);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.NotifyBodyContactListenerPreContact = function (fixtureSet) {\r\n        var contactListener = this.GetFixtureContactListener();\r\n        if (contactListener === null) {\r\n            return;\r\n        }\r\n        ///fixtureSet.Initialize(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.GetCount(), GetFlagsBuffer());\r\n        fixtureSet.Initialize(this.m_bodyContactBuffer, this.m_flagsBuffer);\r\n        throw new Error(); // TODO: notify\r\n    };\r\n    b2ParticleSystem.prototype.NotifyBodyContactListenerPostContact = function (fixtureSet) {\r\n        var contactListener = this.GetFixtureContactListener();\r\n        if (contactListener === null) {\r\n            return;\r\n        }\r\n        // Loop through all new contacts, reporting any new ones, and\r\n        // \"invalidating\" the ones that still exist.\r\n        ///for (b2ParticleBodyContact* contact = m_bodyContactBuffer.Begin(); contact !== m_bodyContactBuffer.End(); ++contact)\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            // DEBUG: b2Assert(contact !== null);\r\n            ///FixtureParticle fixtureParticleToFind;\r\n            ///fixtureParticleToFind.first = contact.fixture;\r\n            ///fixtureParticleToFind.second = contact.index;\r\n            ///const int32 index = fixtureSet.Find(fixtureParticleToFind);\r\n            var index = -1; // TODO\r\n            if (index >= 0) {\r\n                // Already touching remove this from the set.\r\n                fixtureSet.Invalidate(index);\r\n            }\r\n            else {\r\n                // Just started touching, report it!\r\n                contactListener.BeginContactFixtureParticle(this, contact);\r\n            }\r\n        }\r\n        // If the contact listener is enabled, report all fixtures that are no\r\n        // longer in contact with particles.\r\n        ///const FixtureParticle* const fixtureParticles = fixtureSet.GetBuffer();\r\n        ///const int8* const fixtureParticlesValid = fixtureSet.GetValidBuffer();\r\n        ///const int32 fixtureParticleCount = fixtureSet.GetCount();\r\n        ///for (int32 i = 0; i < fixtureParticleCount; ++i)\r\n        ///{\r\n        ///  if (fixtureParticlesValid[i])\r\n        ///  {\r\n        ///    const FixtureParticle* const fixtureParticle = &fixtureParticles[i];\r\n        ///    contactListener.EndContactFixtureParticle(fixtureParticle.first, this, fixtureParticle.second);\r\n        ///  }\r\n        ///}\r\n        throw new Error(); // TODO: notify\r\n    };\r\n    b2ParticleSystem.prototype.UpdateBodyContacts = function () {\r\n        var s_aabb = b2ParticleSystem.UpdateBodyContacts_s_aabb;\r\n        // If the particle contact listener is enabled, generate a set of\r\n        // fixture / particle contacts.\r\n        var fixtureSet = new b2ParticleSystem_FixtureParticleSet(); // TODO: static\r\n        this.NotifyBodyContactListenerPreContact(fixtureSet);\r\n        if (this.m_stuckThreshold > 0) {\r\n            var particleCount = this.GetParticleCount();\r\n            for (var i = 0; i < particleCount; i++) {\r\n                // Detect stuck particles, see comment in\r\n                // b2ParticleSystem::DetectStuckParticle()\r\n                this.m_bodyContactCountBuffer.data[i] = 0;\r\n                if (this.m_timestamp > (this.m_lastBodyContactStepBuffer.data[i] + 1)) {\r\n                    this.m_consecutiveContactStepsBuffer.data[i] = 0;\r\n                }\r\n            }\r\n        }\r\n        this.m_bodyContactBuffer.SetCount(0);\r\n        this.m_stuckParticleBuffer.SetCount(0);\r\n        var aabb = s_aabb;\r\n        this.ComputeAABB(aabb);\r\n        if (this.UpdateBodyContacts_callback === null) {\r\n            this.UpdateBodyContacts_callback = new b2ParticleSystem_UpdateBodyContactsCallback(this);\r\n        }\r\n        var callback = this.UpdateBodyContacts_callback;\r\n        callback.m_contactFilter = this.GetFixtureContactFilter();\r\n        this.m_world.QueryAABB(callback, aabb);\r\n        if (this.m_def.strictContactCheck) {\r\n            this.RemoveSpuriousBodyContacts();\r\n        }\r\n        this.NotifyBodyContactListenerPostContact(fixtureSet);\r\n    };\r\n    b2ParticleSystem.prototype.Solve = function (step) {\r\n        var s_subStep = b2ParticleSystem.Solve_s_subStep;\r\n        if (this.m_count === 0) {\r\n            return;\r\n        }\r\n        // If particle lifetimes are enabled, destroy particles that are too old.\r\n        if (this.m_expirationTimeBuffer.data) {\r\n            this.SolveLifetimes(step);\r\n        }\r\n        if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_zombieParticle) {\r\n            this.SolveZombie();\r\n        }\r\n        if (this.m_needsUpdateAllParticleFlags) {\r\n            this.UpdateAllParticleFlags();\r\n        }\r\n        if (this.m_needsUpdateAllGroupFlags) {\r\n            this.UpdateAllGroupFlags();\r\n        }\r\n        if (this.m_paused) {\r\n            return;\r\n        }\r\n        for (this.m_iterationIndex = 0; this.m_iterationIndex < step.particleIterations; this.m_iterationIndex++) {\r\n            ++this.m_timestamp;\r\n            var subStep = s_subStep.Copy(step);\r\n            subStep.dt /= step.particleIterations;\r\n            subStep.inv_dt *= step.particleIterations;\r\n            this.UpdateContacts(false);\r\n            this.UpdateBodyContacts();\r\n            this.ComputeWeight();\r\n            if (this.m_allGroupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {\r\n                this.ComputeDepth();\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_reactiveParticle) {\r\n                this.UpdatePairsAndTriadsWithReactiveParticles();\r\n            }\r\n            if (this.m_hasForce) {\r\n                this.SolveForce(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_viscousParticle) {\r\n                this.SolveViscous();\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_repulsiveParticle) {\r\n                this.SolveRepulsive(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_powderParticle) {\r\n                this.SolvePowder(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_tensileParticle) {\r\n                this.SolveTensile(subStep);\r\n            }\r\n            if (this.m_allGroupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n                this.SolveSolid(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_colorMixingParticle) {\r\n                this.SolveColorMixing();\r\n            }\r\n            this.SolveGravity(subStep);\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_staticPressureParticle) {\r\n                this.SolveStaticPressure(subStep);\r\n            }\r\n            this.SolvePressure(subStep);\r\n            this.SolveDamping(subStep);\r\n            if (this.m_allParticleFlags & b2ParticleSystem.k_extraDampingFlags) {\r\n                this.SolveExtraDamping();\r\n            }\r\n            // SolveElastic and SolveSpring refer the current velocities for\r\n            // numerical stability, they should be called as late as possible.\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_elasticParticle) {\r\n                this.SolveElastic(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_springParticle) {\r\n                this.SolveSpring(subStep);\r\n            }\r\n            this.LimitVelocity(subStep);\r\n            if (this.m_allGroupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n                this.SolveRigidDamping();\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_barrierParticle) {\r\n                this.SolveBarrier(subStep);\r\n            }\r\n            // SolveCollision, SolveRigid and SolveWall should be called after\r\n            // other force functions because they may require particles to have\r\n            // specific velocities.\r\n            this.SolveCollision(subStep);\r\n            if (this.m_allGroupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n                this.SolveRigid(subStep);\r\n            }\r\n            if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_wallParticle) {\r\n                this.SolveWall();\r\n            }\r\n            // The particle positions can be updated only at the end of substep.\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                ///m_positionBuffer.data[i] += subStep.dt * m_velocityBuffer.data[i];\r\n                this.m_positionBuffer.data[i].SelfMulAdd(subStep.dt, this.m_velocityBuffer.data[i]);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveCollision = function (step) {\r\n        var s_aabb = b2ParticleSystem.SolveCollision_s_aabb;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // This function detects particles which are crossing boundary of bodies\r\n        // and modifies velocities of them so that they will move just in front of\r\n        // boundary. This function function also applies the reaction force to\r\n        // bodies as precisely as the numerical stability is kept.\r\n        var aabb = s_aabb;\r\n        aabb.lowerBound.x = +b2Settings_1.b2_maxFloat;\r\n        aabb.lowerBound.y = +b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.x = -b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.y = -b2Settings_1.b2_maxFloat;\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            var v = vel_data[i];\r\n            var p1 = pos_data[i];\r\n            ///let p2 = p1 + step.dt * v;\r\n            var p2_x = p1.x + step.dt * v.x;\r\n            var p2_y = p1.y + step.dt * v.y;\r\n            ///aabb.lowerBound = b2Min(aabb.lowerBound, b2Min(p1, p2));\r\n            aabb.lowerBound.x = b2Math_1.b2Min(aabb.lowerBound.x, b2Math_1.b2Min(p1.x, p2_x));\r\n            aabb.lowerBound.y = b2Math_1.b2Min(aabb.lowerBound.y, b2Math_1.b2Min(p1.y, p2_y));\r\n            ///aabb.upperBound = b2Max(aabb.upperBound, b2Max(p1, p2));\r\n            aabb.upperBound.x = b2Math_1.b2Max(aabb.upperBound.x, b2Math_1.b2Max(p1.x, p2_x));\r\n            aabb.upperBound.y = b2Math_1.b2Max(aabb.upperBound.y, b2Math_1.b2Max(p1.y, p2_y));\r\n        }\r\n        if (this.SolveCollision_callback === null) {\r\n            this.SolveCollision_callback = new b2ParticleSystem_SolveCollisionCallback(this, step);\r\n        }\r\n        var callback = this.SolveCollision_callback;\r\n        callback.m_step = step;\r\n        this.m_world.QueryAABB(callback, aabb);\r\n    };\r\n    b2ParticleSystem.prototype.LimitVelocity = function (step) {\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var criticalVelocitySquared = this.GetCriticalVelocitySquared(step);\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            var v = vel_data[i];\r\n            var v2 = b2Math_1.b2Vec2.DotVV(v, v);\r\n            if (v2 > criticalVelocitySquared) {\r\n                ///v *= b2Sqrt(criticalVelocitySquared / v2);\r\n                v.SelfMul(b2Math_1.b2Sqrt(criticalVelocitySquared / v2));\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveGravity = function (step) {\r\n        var s_gravity = b2ParticleSystem.SolveGravity_s_gravity;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        ///b2Vec2 gravity = step.dt * m_def.gravityScale * m_world.GetGravity();\r\n        var gravity = b2Math_1.b2Vec2.MulSV(step.dt * this.m_def.gravityScale, this.m_world.GetGravity(), s_gravity);\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            vel_data[i].SelfAdd(gravity);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveBarrier = function (step) {\r\n        var s_aabb = b2ParticleSystem.SolveBarrier_s_aabb;\r\n        var s_va = b2ParticleSystem.SolveBarrier_s_va;\r\n        var s_vb = b2ParticleSystem.SolveBarrier_s_vb;\r\n        var s_pba = b2ParticleSystem.SolveBarrier_s_pba;\r\n        var s_vba = b2ParticleSystem.SolveBarrier_s_vba;\r\n        var s_vc = b2ParticleSystem.SolveBarrier_s_vc;\r\n        var s_pca = b2ParticleSystem.SolveBarrier_s_pca;\r\n        var s_vca = b2ParticleSystem.SolveBarrier_s_vca;\r\n        var s_qba = b2ParticleSystem.SolveBarrier_s_qba;\r\n        var s_qca = b2ParticleSystem.SolveBarrier_s_qca;\r\n        var s_dv = b2ParticleSystem.SolveBarrier_s_dv;\r\n        var s_f = b2ParticleSystem.SolveBarrier_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // If a particle is passing between paired barrier particles,\r\n        // its velocity will be decelerated to avoid passing.\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            var flags = this.m_flagsBuffer.data[i];\r\n            ///if ((flags & b2ParticleSystem.k_barrierWallFlags) === b2ParticleSystem.k_barrierWallFlags)\r\n            if ((flags & b2ParticleSystem.k_barrierWallFlags) !== 0) {\r\n                vel_data[i].SetZero();\r\n            }\r\n        }\r\n        var tmax = b2Settings_1.b2_barrierCollisionTime * step.dt;\r\n        var mass = this.GetParticleMass();\r\n        for (var k = 0; k < this.m_pairBuffer.count; k++) {\r\n            var pair = this.m_pairBuffer.data[k];\r\n            if (pair.flags & b2Particle_1.b2ParticleFlag.b2_barrierParticle) {\r\n                var a = pair.indexA;\r\n                var b = pair.indexB;\r\n                var pa = pos_data[a];\r\n                var pb = pos_data[b];\r\n                /// b2AABB aabb;\r\n                var aabb = s_aabb;\r\n                ///aabb.lowerBound = b2Min(pa, pb);\r\n                b2Math_1.b2Vec2.MinV(pa, pb, aabb.lowerBound);\r\n                ///aabb.upperBound = b2Max(pa, pb);\r\n                b2Math_1.b2Vec2.MaxV(pa, pb, aabb.upperBound);\r\n                var aGroup = this.m_groupBuffer[a];\r\n                var bGroup = this.m_groupBuffer[b];\r\n                ///b2Vec2 va = GetLinearVelocity(aGroup, a, pa);\r\n                var va = this.GetLinearVelocity(aGroup, a, pa, s_va);\r\n                ///b2Vec2 vb = GetLinearVelocity(bGroup, b, pb);\r\n                var vb = this.GetLinearVelocity(bGroup, b, pb, s_vb);\r\n                ///b2Vec2 pba = pb - pa;\r\n                var pba = b2Math_1.b2Vec2.SubVV(pb, pa, s_pba);\r\n                ///b2Vec2 vba = vb - va;\r\n                var vba = b2Math_1.b2Vec2.SubVV(vb, va, s_vba);\r\n                ///InsideBoundsEnumerator enumerator = GetInsideBoundsEnumerator(aabb);\r\n                var enumerator = this.GetInsideBoundsEnumerator(aabb);\r\n                var c = void 0;\r\n                while ((c = enumerator.GetNext()) >= 0) {\r\n                    var pc = pos_data[c];\r\n                    var cGroup = this.m_groupBuffer[c];\r\n                    if (aGroup !== cGroup && bGroup !== cGroup) {\r\n                        ///b2Vec2 vc = GetLinearVelocity(cGroup, c, pc);\r\n                        var vc = this.GetLinearVelocity(cGroup, c, pc, s_vc);\r\n                        // Solve the equation below:\r\n                        //   (1-s)*(pa+t*va)+s*(pb+t*vb) = pc+t*vc\r\n                        // which expresses that the particle c will pass a line\r\n                        // connecting the particles a and b at the time of t.\r\n                        // if s is between 0 and 1, c will pass between a and b.\r\n                        ///b2Vec2 pca = pc - pa;\r\n                        var pca = b2Math_1.b2Vec2.SubVV(pc, pa, s_pca);\r\n                        ///b2Vec2 vca = vc - va;\r\n                        var vca = b2Math_1.b2Vec2.SubVV(vc, va, s_vca);\r\n                        var e2 = b2Math_1.b2Vec2.CrossVV(vba, vca);\r\n                        var e1 = b2Math_1.b2Vec2.CrossVV(pba, vca) - b2Math_1.b2Vec2.CrossVV(pca, vba);\r\n                        var e0 = b2Math_1.b2Vec2.CrossVV(pba, pca);\r\n                        var s = void 0, t = void 0;\r\n                        ///b2Vec2 qba, qca;\r\n                        var qba = s_qba, qca = s_qca;\r\n                        if (e2 === 0) {\r\n                            if (e1 === 0) {\r\n                                continue;\r\n                            }\r\n                            t = -e0 / e1;\r\n                            if (!(t >= 0 && t < tmax)) {\r\n                                continue;\r\n                            }\r\n                            ///qba = pba + t * vba;\r\n                            b2Math_1.b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n                            ///qca = pca + t * vca;\r\n                            b2Math_1.b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n                            s = b2Math_1.b2Vec2.DotVV(qba, qca) / b2Math_1.b2Vec2.DotVV(qba, qba);\r\n                            if (!(s >= 0 && s <= 1)) {\r\n                                continue;\r\n                            }\r\n                        }\r\n                        else {\r\n                            var det = e1 * e1 - 4 * e0 * e2;\r\n                            if (det < 0) {\r\n                                continue;\r\n                            }\r\n                            var sqrtDet = b2Math_1.b2Sqrt(det);\r\n                            var t1 = (-e1 - sqrtDet) / (2 * e2);\r\n                            var t2 = (-e1 + sqrtDet) / (2 * e2);\r\n                            ///if (t1 > t2) b2Swap(t1, t2);\r\n                            if (t1 > t2) {\r\n                                var tmp = t1;\r\n                                t1 = t2;\r\n                                t2 = tmp;\r\n                            }\r\n                            t = t1;\r\n                            ///qba = pba + t * vba;\r\n                            b2Math_1.b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n                            ///qca = pca + t * vca;\r\n                            b2Math_1.b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n                            ///s = b2Dot(qba, qca) / b2Dot(qba, qba);\r\n                            s = b2Math_1.b2Vec2.DotVV(qba, qca) / b2Math_1.b2Vec2.DotVV(qba, qba);\r\n                            if (!(t >= 0 && t < tmax && s >= 0 && s <= 1)) {\r\n                                t = t2;\r\n                                if (!(t >= 0 && t < tmax)) {\r\n                                    continue;\r\n                                }\r\n                                ///qba = pba + t * vba;\r\n                                b2Math_1.b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n                                ///qca = pca + t * vca;\r\n                                b2Math_1.b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n                                ///s = b2Dot(qba, qca) / b2Dot(qba, qba);\r\n                                s = b2Math_1.b2Vec2.DotVV(qba, qca) / b2Math_1.b2Vec2.DotVV(qba, qba);\r\n                                if (!(s >= 0 && s <= 1)) {\r\n                                    continue;\r\n                                }\r\n                            }\r\n                        }\r\n                        // Apply a force to particle c so that it will have the\r\n                        // interpolated velocity at the collision point on line ab.\r\n                        ///b2Vec2 dv = va + s * vba - vc;\r\n                        var dv = s_dv;\r\n                        dv.x = va.x + s * vba.x - vc.x;\r\n                        dv.y = va.y + s * vba.y - vc.y;\r\n                        ///b2Vec2 f = GetParticleMass() * dv;\r\n                        var f = b2Math_1.b2Vec2.MulSV(mass, dv, s_f);\r\n                        if (cGroup && this.IsRigidGroup(cGroup)) {\r\n                            // If c belongs to a rigid group, the force will be\r\n                            // distributed in the group.\r\n                            var mass_1 = cGroup.GetMass();\r\n                            var inertia = cGroup.GetInertia();\r\n                            if (mass_1 > 0) {\r\n                                ///cGroup.m_linearVelocity += 1 / mass * f;\r\n                                cGroup.m_linearVelocity.SelfMulAdd(1 / mass_1, f);\r\n                            }\r\n                            if (inertia > 0) {\r\n                                ///cGroup.m_angularVelocity += b2Cross(pc - cGroup.GetCenter(), f) / inertia;\r\n                                cGroup.m_angularVelocity += b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.SubVV(pc, cGroup.GetCenter(), b2Math_1.b2Vec2.s_t0), f) / inertia;\r\n                            }\r\n                        }\r\n                        else {\r\n                            ///m_velocityBuffer.data[c] += dv;\r\n                            vel_data[c].SelfAdd(dv);\r\n                        }\r\n                        // Apply a reversed force to particle c after particle\r\n                        // movement so that momentum will be preserved.\r\n                        ///ParticleApplyForce(c, -step.inv_dt * f);\r\n                        this.ParticleApplyForce(c, f.SelfMul(-step.inv_dt));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveStaticPressure = function (step) {\r\n        this.m_staticPressureBuffer = this.RequestBuffer(this.m_staticPressureBuffer);\r\n        var criticalPressure = this.GetCriticalPressure(step);\r\n        var pressurePerWeight = this.m_def.staticPressureStrength * criticalPressure;\r\n        var maxPressure = b2Settings_2.b2_maxParticlePressure * criticalPressure;\r\n        var relaxation = this.m_def.staticPressureRelaxation;\r\n        /// Compute pressure satisfying the modified Poisson equation:\r\n        ///   Sum_for_j((p_i - p_j) * w_ij) + relaxation * p_i =\r\n        ///   pressurePerWeight * (w_i - b2_minParticleWeight)\r\n        /// by iterating the calculation:\r\n        ///   p_i = (Sum_for_j(p_j * w_ij) + pressurePerWeight *\r\n        ///         (w_i - b2_minParticleWeight)) / (w_i + relaxation)\r\n        /// where\r\n        ///   p_i and p_j are static pressure of particle i and j\r\n        ///   w_ij is contact weight between particle i and j\r\n        ///   w_i is sum of contact weight of particle i\r\n        for (var t = 0; t < this.m_def.staticPressureIterations; t++) {\r\n            ///memset(m_accumulationBuffer, 0, sizeof(*m_accumulationBuffer) * m_count);\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                this.m_accumulationBuffer[i] = 0;\r\n            }\r\n            for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n                var contact = this.m_contactBuffer.data[k];\r\n                if (contact.flags & b2Particle_1.b2ParticleFlag.b2_staticPressureParticle) {\r\n                    var a = contact.indexA;\r\n                    var b = contact.indexB;\r\n                    var w = contact.weight;\r\n                    this.m_accumulationBuffer[a] += w * this.m_staticPressureBuffer[b]; // a <- b\r\n                    this.m_accumulationBuffer[b] += w * this.m_staticPressureBuffer[a]; // b <- a\r\n                }\r\n            }\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                var w = this.m_weightBuffer[i];\r\n                if (this.m_flagsBuffer.data[i] & b2Particle_1.b2ParticleFlag.b2_staticPressureParticle) {\r\n                    var wh = this.m_accumulationBuffer[i];\r\n                    var h = (wh + pressurePerWeight * (w - b2Settings_2.b2_minParticleWeight)) /\r\n                        (w + relaxation);\r\n                    this.m_staticPressureBuffer[i] = b2Math_1.b2Clamp(h, 0.0, maxPressure);\r\n                }\r\n                else {\r\n                    this.m_staticPressureBuffer[i] = 0;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.ComputeWeight = function () {\r\n        // calculates the sum of contact-weights for each particle\r\n        // that means dimensionless density\r\n        ///memset(m_weightBuffer, 0, sizeof(*m_weightBuffer) * m_count);\r\n        for (var k = 0; k < this.m_count; k++) {\r\n            this.m_weightBuffer[k] = 0;\r\n        }\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            var w = contact.weight;\r\n            this.m_weightBuffer[a] += w;\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var w = contact.weight;\r\n            this.m_weightBuffer[a] += w;\r\n            this.m_weightBuffer[b] += w;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolvePressure = function (step) {\r\n        var s_f = b2ParticleSystem.SolvePressure_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // calculates pressure as a linear function of density\r\n        var criticalPressure = this.GetCriticalPressure(step);\r\n        var pressurePerWeight = this.m_def.pressureStrength * criticalPressure;\r\n        var maxPressure = b2Settings_2.b2_maxParticlePressure * criticalPressure;\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            var w = this.m_weightBuffer[i];\r\n            var h = pressurePerWeight * b2Math_1.b2Max(0.0, w - b2Settings_2.b2_minParticleWeight);\r\n            this.m_accumulationBuffer[i] = b2Math_1.b2Min(h, maxPressure);\r\n        }\r\n        // ignores particles which have their own repulsive force\r\n        if (this.m_allParticleFlags & b2ParticleSystem.k_noPressureFlags) {\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                if (this.m_flagsBuffer.data[i] & b2ParticleSystem.k_noPressureFlags) {\r\n                    this.m_accumulationBuffer[i] = 0;\r\n                }\r\n            }\r\n        }\r\n        // static pressure\r\n        if (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_staticPressureParticle) {\r\n            // DEBUG: b2Assert(this.m_staticPressureBuffer !== null);\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                if (this.m_flagsBuffer.data[i] & b2Particle_1.b2ParticleFlag.b2_staticPressureParticle) {\r\n                    this.m_accumulationBuffer[i] += this.m_staticPressureBuffer[i];\r\n                }\r\n            }\r\n        }\r\n        // applies pressure between each particles in contact\r\n        var velocityPerPressure = step.dt / (this.m_def.density * this.m_particleDiameter);\r\n        var inv_mass = this.GetParticleInvMass();\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            var b = contact.body;\r\n            var w = contact.weight;\r\n            var m = contact.mass;\r\n            var n = contact.normal;\r\n            var p = pos_data[a];\r\n            var h = this.m_accumulationBuffer[a] + pressurePerWeight * w;\r\n            ///b2Vec2 f = velocityPerPressure * w * m * h * n;\r\n            var f = b2Math_1.b2Vec2.MulSV(velocityPerPressure * w * m * h, n, s_f);\r\n            ///m_velocityBuffer.data[a] -= GetParticleInvMass() * f;\r\n            vel_data[a].SelfMulSub(inv_mass, f);\r\n            b.ApplyLinearImpulse(f, p, true);\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var w = contact.weight;\r\n            var n = contact.normal;\r\n            var h = this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b];\r\n            ///b2Vec2 f = velocityPerPressure * w * h * n;\r\n            var f = b2Math_1.b2Vec2.MulSV(velocityPerPressure * w * h, n, s_f);\r\n            ///m_velocityBuffer.data[a] -= f;\r\n            vel_data[a].SelfSub(f);\r\n            ///m_velocityBuffer.data[b] += f;\r\n            vel_data[b].SelfAdd(f);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveDamping = function (step) {\r\n        var s_v = b2ParticleSystem.SolveDamping_s_v;\r\n        var s_f = b2ParticleSystem.SolveDamping_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // reduces normal velocity of each contact\r\n        var linearDamping = this.m_def.dampingStrength;\r\n        var quadraticDamping = 1 / this.GetCriticalVelocity(step);\r\n        var inv_mass = this.GetParticleInvMass();\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            var b = contact.body;\r\n            var w = contact.weight;\r\n            var m = contact.mass;\r\n            var n = contact.normal;\r\n            var p = pos_data[a];\r\n            ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n            var v = b2Math_1.b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Math_1.b2Vec2.s_t0), vel_data[a], s_v);\r\n            var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n            if (vn < 0) {\r\n                var damping = b2Math_1.b2Max(linearDamping * w, b2Math_1.b2Min(-quadraticDamping * vn, 0.5));\r\n                ///b2Vec2 f = damping * m * vn * n;\r\n                var f = b2Math_1.b2Vec2.MulSV(damping * m * vn, n, s_f);\r\n                ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n                vel_data[a].SelfMulAdd(inv_mass, f);\r\n                ///b.ApplyLinearImpulse(-f, p, true);\r\n                b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n            }\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var w = contact.weight;\r\n            var n = contact.normal;\r\n            ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n            var v = b2Math_1.b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n            var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n            if (vn < 0) {\r\n                ///float32 damping = b2Max(linearDamping * w, b2Min(- quadraticDamping * vn, 0.5f));\r\n                var damping = b2Math_1.b2Max(linearDamping * w, b2Math_1.b2Min(-quadraticDamping * vn, 0.5));\r\n                ///b2Vec2 f = damping * vn * n;\r\n                var f = b2Math_1.b2Vec2.MulSV(damping * vn, n, s_f);\r\n                ///this.m_velocityBuffer.data[a] += f;\r\n                vel_data[a].SelfAdd(f);\r\n                ///this.m_velocityBuffer.data[b] -= f;\r\n                vel_data[b].SelfSub(f);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveRigidDamping = function () {\r\n        var s_t0 = b2ParticleSystem.SolveRigidDamping_s_t0;\r\n        var s_t1 = b2ParticleSystem.SolveRigidDamping_s_t1;\r\n        var s_p = b2ParticleSystem.SolveRigidDamping_s_p;\r\n        var s_v = b2ParticleSystem.SolveRigidDamping_s_v;\r\n        var invMassA = [0.0], invInertiaA = [0.0], tangentDistanceA = [0.0]; // TODO: static\r\n        var invMassB = [0.0], invInertiaB = [0.0], tangentDistanceB = [0.0]; // TODO: static\r\n        // Apply impulse to rigid particle groups colliding with other objects\r\n        // to reduce relative velocity at the colliding point.\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var damping = this.m_def.dampingStrength;\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            var aGroup = this.m_groupBuffer[a];\r\n            if (aGroup && this.IsRigidGroup(aGroup)) {\r\n                var b = contact.body;\r\n                var n = contact.normal;\r\n                var w = contact.weight;\r\n                var p = pos_data[a];\r\n                ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - aGroup.GetLinearVelocityFromWorldPoint(p);\r\n                var v = b2Math_1.b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, s_t0), aGroup.GetLinearVelocityFromWorldPoint(p, s_t1), s_v);\r\n                var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n                if (vn < 0) {\r\n                    // The group's average velocity at particle position 'p' is pushing\r\n                    // the particle into the body.\r\n                    ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, true, aGroup, a, p, n);\r\n                    this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, p, n);\r\n                    // Calculate b.m_I from public functions of b2Body.\r\n                    ///this.InitDampingParameter(&invMassB, &invInertiaB, &tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);\r\n                    this.InitDampingParameter(invMassB, invInertiaB, tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);\r\n                    ///float32 f = damping * b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);\r\n                    var f = damping * b2Math_1.b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);\r\n                    ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, f, n);\r\n                    this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], true, aGroup, a, f, n);\r\n                    ///b.ApplyLinearImpulse(-f * n, p, true);\r\n                    b.ApplyLinearImpulse(b2Math_1.b2Vec2.MulSV(-f, n, b2Math_1.b2Vec2.s_t0), p, true);\r\n                }\r\n            }\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            var n = contact.normal;\r\n            var w = contact.weight;\r\n            var aGroup = this.m_groupBuffer[a];\r\n            var bGroup = this.m_groupBuffer[b];\r\n            var aRigid = this.IsRigidGroup(aGroup);\r\n            var bRigid = this.IsRigidGroup(bGroup);\r\n            if (aGroup !== bGroup && (aRigid || bRigid)) {\r\n                ///b2Vec2 p = 0.5f * (this.m_positionBuffer.data[a] + this.m_positionBuffer.data[b]);\r\n                var p = b2Math_1.b2Vec2.MidVV(pos_data[a], pos_data[b], s_p);\r\n                ///b2Vec2 v = GetLinearVelocity(bGroup, b, p) - GetLinearVelocity(aGroup, a, p);\r\n                var v = b2Math_1.b2Vec2.SubVV(this.GetLinearVelocity(bGroup, b, p, s_t0), this.GetLinearVelocity(aGroup, a, p, s_t1), s_v);\r\n                var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n                if (vn < 0) {\r\n                    ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, aRigid, aGroup, a, p, n);\r\n                    this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, p, n);\r\n                    ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassB, &invInertiaB, &tangentDistanceB, bRigid, bGroup, b, p, n);\r\n                    this.InitDampingParameterWithRigidGroupOrParticle(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, p, n);\r\n                    ///float32 f = damping * w * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);\r\n                    var f = damping * w * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);\r\n                    ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, f, n);\r\n                    this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], aRigid, aGroup, a, f, n);\r\n                    ///this.ApplyDamping(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, -f, n);\r\n                    this.ApplyDamping(invMassB[0], invInertiaB[0], tangentDistanceB[0], bRigid, bGroup, b, -f, n);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveExtraDamping = function () {\r\n        var s_v = b2ParticleSystem.SolveExtraDamping_s_v;\r\n        var s_f = b2ParticleSystem.SolveExtraDamping_s_f;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // Applies additional damping force between bodies and particles which can\r\n        // produce strong repulsive force. Applying damping force multiple times\r\n        // is effective in suppressing vibration.\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var inv_mass = this.GetParticleInvMass();\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            if (this.m_flagsBuffer.data[a] & b2ParticleSystem.k_extraDampingFlags) {\r\n                var b = contact.body;\r\n                var m = contact.mass;\r\n                var n = contact.normal;\r\n                var p = pos_data[a];\r\n                ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n                var v = b2Math_1.b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Math_1.b2Vec2.s_t0), vel_data[a], s_v);\r\n                ///float32 vn = b2Dot(v, n);\r\n                var vn = b2Math_1.b2Vec2.DotVV(v, n);\r\n                if (vn < 0) {\r\n                    ///b2Vec2 f = 0.5f * m * vn * n;\r\n                    var f = b2Math_1.b2Vec2.MulSV(0.5 * m * vn, n, s_f);\r\n                    ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n                    vel_data[a].SelfMulAdd(inv_mass, f);\r\n                    ///b.ApplyLinearImpulse(-f, p, true);\r\n                    b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveWall = function () {\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            if (this.m_flagsBuffer.data[i] & b2Particle_1.b2ParticleFlag.b2_wallParticle) {\r\n                vel_data[i].SetZero();\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveRigid = function (step) {\r\n        var s_position = b2ParticleSystem.SolveRigid_s_position;\r\n        var s_rotation = b2ParticleSystem.SolveRigid_s_rotation;\r\n        var s_transform = b2ParticleSystem.SolveRigid_s_transform;\r\n        var s_velocityTransform = b2ParticleSystem.SolveRigid_s_velocityTransform;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        for (var group = this.m_groupList; group; group = group.GetNext()) {\r\n            if (group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n                group.UpdateStatistics();\r\n                ///b2Rot rotation(step.dt * group.m_angularVelocity);\r\n                var rotation = s_rotation;\r\n                rotation.SetAngle(step.dt * group.m_angularVelocity);\r\n                ///b2Transform transform(group.m_center + step.dt * group.m_linearVelocity - b2Mul(rotation, group.m_center), rotation);\r\n                var position = b2Math_1.b2Vec2.AddVV(group.m_center, b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.MulSV(step.dt, group.m_linearVelocity, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Rot.MulRV(rotation, group.m_center, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t0), s_position);\r\n                var transform = s_transform;\r\n                transform.SetPositionRotation(position, rotation);\r\n                ///group.m_transform = b2Mul(transform, group.m_transform);\r\n                b2Math_1.b2Transform.MulXX(transform, group.m_transform, group.m_transform);\r\n                var velocityTransform = s_velocityTransform;\r\n                velocityTransform.p.x = step.inv_dt * transform.p.x;\r\n                velocityTransform.p.y = step.inv_dt * transform.p.y;\r\n                velocityTransform.q.s = step.inv_dt * transform.q.s;\r\n                velocityTransform.q.c = step.inv_dt * (transform.q.c - 1);\r\n                for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n                    ///m_velocityBuffer.data[i] = b2Mul(velocityTransform, m_positionBuffer.data[i]);\r\n                    b2Math_1.b2Transform.MulXV(velocityTransform, pos_data[i], vel_data[i]);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveElastic = function (step) {\r\n        var s_pa = b2ParticleSystem.SolveElastic_s_pa;\r\n        var s_pb = b2ParticleSystem.SolveElastic_s_pb;\r\n        var s_pc = b2ParticleSystem.SolveElastic_s_pc;\r\n        var s_r = b2ParticleSystem.SolveElastic_s_r;\r\n        var s_t0 = b2ParticleSystem.SolveElastic_s_t0;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var elasticStrength = step.inv_dt * this.m_def.elasticStrength;\r\n        for (var k = 0; k < this.m_triadBuffer.count; k++) {\r\n            var triad = this.m_triadBuffer.data[k];\r\n            if (triad.flags & b2Particle_1.b2ParticleFlag.b2_elasticParticle) {\r\n                var a = triad.indexA;\r\n                var b = triad.indexB;\r\n                var c = triad.indexC;\r\n                var oa = triad.pa;\r\n                var ob = triad.pb;\r\n                var oc = triad.pc;\r\n                ///b2Vec2 pa = m_positionBuffer.data[a];\r\n                var pa = s_pa.Copy(pos_data[a]);\r\n                ///b2Vec2 pb = m_positionBuffer.data[b];\r\n                var pb = s_pb.Copy(pos_data[b]);\r\n                ///b2Vec2 pc = m_positionBuffer.data[c];\r\n                var pc = s_pc.Copy(pos_data[c]);\r\n                var va = vel_data[a];\r\n                var vb = vel_data[b];\r\n                var vc = vel_data[c];\r\n                ///pa += step.dt * va;\r\n                pa.SelfMulAdd(step.dt, va);\r\n                ///pb += step.dt * vb;\r\n                pb.SelfMulAdd(step.dt, vb);\r\n                ///pc += step.dt * vc;\r\n                pc.SelfMulAdd(step.dt, vc);\r\n                ///b2Vec2 midPoint = (float32) 1 / 3 * (pa + pb + pc);\r\n                var midPoint_x = (pa.x + pb.x + pc.x) / 3.0;\r\n                var midPoint_y = (pa.y + pb.y + pc.y) / 3.0;\r\n                ///pa -= midPoint;\r\n                pa.x -= midPoint_x;\r\n                pa.y -= midPoint_y;\r\n                ///pb -= midPoint;\r\n                pb.x -= midPoint_x;\r\n                pb.y -= midPoint_y;\r\n                ///pc -= midPoint;\r\n                pc.x -= midPoint_x;\r\n                pc.y -= midPoint_y;\r\n                ///b2Rot r;\r\n                var r = s_r;\r\n                r.s = b2Math_1.b2Vec2.CrossVV(oa, pa) + b2Math_1.b2Vec2.CrossVV(ob, pb) + b2Math_1.b2Vec2.CrossVV(oc, pc);\r\n                r.c = b2Math_1.b2Vec2.DotVV(oa, pa) + b2Math_1.b2Vec2.DotVV(ob, pb) + b2Math_1.b2Vec2.DotVV(oc, pc);\r\n                var r2 = r.s * r.s + r.c * r.c;\r\n                var invR = b2Math_1.b2InvSqrt(r2);\r\n                if (!isFinite(invR)) {\r\n                    invR = 1.98177537e+019;\r\n                }\r\n                r.s *= invR;\r\n                r.c *= invR;\r\n                ///r.angle = Math.atan2(r.s, r.c); // TODO: optimize\r\n                var strength = elasticStrength * triad.strength;\r\n                ///va += strength * (b2Mul(r, oa) - pa);\r\n                b2Math_1.b2Rot.MulRV(r, oa, s_t0);\r\n                b2Math_1.b2Vec2.SubVV(s_t0, pa, s_t0);\r\n                b2Math_1.b2Vec2.MulSV(strength, s_t0, s_t0);\r\n                va.SelfAdd(s_t0);\r\n                ///vb += strength * (b2Mul(r, ob) - pb);\r\n                b2Math_1.b2Rot.MulRV(r, ob, s_t0);\r\n                b2Math_1.b2Vec2.SubVV(s_t0, pb, s_t0);\r\n                b2Math_1.b2Vec2.MulSV(strength, s_t0, s_t0);\r\n                vb.SelfAdd(s_t0);\r\n                ///vc += strength * (b2Mul(r, oc) - pc);\r\n                b2Math_1.b2Rot.MulRV(r, oc, s_t0);\r\n                b2Math_1.b2Vec2.SubVV(s_t0, pc, s_t0);\r\n                b2Math_1.b2Vec2.MulSV(strength, s_t0, s_t0);\r\n                vc.SelfAdd(s_t0);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveSpring = function (step) {\r\n        var s_pa = b2ParticleSystem.SolveSpring_s_pa;\r\n        var s_pb = b2ParticleSystem.SolveSpring_s_pb;\r\n        var s_d = b2ParticleSystem.SolveSpring_s_d;\r\n        var s_f = b2ParticleSystem.SolveSpring_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var springStrength = step.inv_dt * this.m_def.springStrength;\r\n        for (var k = 0; k < this.m_pairBuffer.count; k++) {\r\n            var pair = this.m_pairBuffer.data[k];\r\n            if (pair.flags & b2Particle_1.b2ParticleFlag.b2_springParticle) {\r\n                ///int32 a = pair.indexA;\r\n                var a = pair.indexA;\r\n                ///int32 b = pair.indexB;\r\n                var b = pair.indexB;\r\n                ///b2Vec2 pa = m_positionBuffer.data[a];\r\n                var pa = s_pa.Copy(pos_data[a]);\r\n                ///b2Vec2 pb = m_positionBuffer.data[b];\r\n                var pb = s_pb.Copy(pos_data[b]);\r\n                ///b2Vec2& va = m_velocityBuffer.data[a];\r\n                var va = vel_data[a];\r\n                ///b2Vec2& vb = m_velocityBuffer.data[b];\r\n                var vb = vel_data[b];\r\n                ///pa += step.dt * va;\r\n                pa.SelfMulAdd(step.dt, va);\r\n                ///pb += step.dt * vb;\r\n                pb.SelfMulAdd(step.dt, vb);\r\n                ///b2Vec2 d = pb - pa;\r\n                var d = b2Math_1.b2Vec2.SubVV(pb, pa, s_d);\r\n                ///float32 r0 = pair.distance;\r\n                var r0 = pair.distance;\r\n                ///float32 r1 = d.Length();\r\n                var r1 = d.Length();\r\n                ///float32 strength = springStrength * pair.strength;\r\n                var strength = springStrength * pair.strength;\r\n                ///b2Vec2 f = strength * (r0 - r1) / r1 * d;\r\n                var f = b2Math_1.b2Vec2.MulSV(strength * (r0 - r1) / r1, d, s_f);\r\n                ///va -= f;\r\n                va.SelfSub(f);\r\n                ///vb += f;\r\n                vb.SelfAdd(f);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveTensile = function (step) {\r\n        var s_weightedNormal = b2ParticleSystem.SolveTensile_s_weightedNormal;\r\n        var s_s = b2ParticleSystem.SolveTensile_s_s;\r\n        var s_f = b2ParticleSystem.SolveTensile_s_f;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // DEBUG: b2Assert(this.m_accumulation2Buffer !== null);\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            this.m_accumulation2Buffer[i] = new b2Math_1.b2Vec2();\r\n            this.m_accumulation2Buffer[i].SetZero();\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            if (contact.flags & b2Particle_1.b2ParticleFlag.b2_tensileParticle) {\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                var w = contact.weight;\r\n                var n = contact.normal;\r\n                ///b2Vec2 weightedNormal = (1 - w) * w * n;\r\n                var weightedNormal = b2Math_1.b2Vec2.MulSV((1 - w) * w, n, s_weightedNormal);\r\n                ///m_accumulation2Buffer[a] -= weightedNormal;\r\n                this.m_accumulation2Buffer[a].SelfSub(weightedNormal);\r\n                ///m_accumulation2Buffer[b] += weightedNormal;\r\n                this.m_accumulation2Buffer[b].SelfAdd(weightedNormal);\r\n            }\r\n        }\r\n        var criticalVelocity = this.GetCriticalVelocity(step);\r\n        var pressureStrength = this.m_def.surfaceTensionPressureStrength * criticalVelocity;\r\n        var normalStrength = this.m_def.surfaceTensionNormalStrength * criticalVelocity;\r\n        var maxVelocityVariation = b2Settings_2.b2_maxParticleForce * criticalVelocity;\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            if (contact.flags & b2Particle_1.b2ParticleFlag.b2_tensileParticle) {\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                var w = contact.weight;\r\n                var n = contact.normal;\r\n                var h = this.m_weightBuffer[a] + this.m_weightBuffer[b];\r\n                ///b2Vec2 s = m_accumulation2Buffer[b] - m_accumulation2Buffer[a];\r\n                var s = b2Math_1.b2Vec2.SubVV(this.m_accumulation2Buffer[b], this.m_accumulation2Buffer[a], s_s);\r\n                var fn = b2Math_1.b2Min(pressureStrength * (h - 2) + normalStrength * b2Math_1.b2Vec2.DotVV(s, n), maxVelocityVariation) * w;\r\n                ///b2Vec2 f = fn * n;\r\n                var f = b2Math_1.b2Vec2.MulSV(fn, n, s_f);\r\n                ///m_velocityBuffer.data[a] -= f;\r\n                vel_data[a].SelfSub(f);\r\n                ///m_velocityBuffer.data[b] += f;\r\n                vel_data[b].SelfAdd(f);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveViscous = function () {\r\n        var s_v = b2ParticleSystem.SolveViscous_s_v;\r\n        var s_f = b2ParticleSystem.SolveViscous_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var viscousStrength = this.m_def.viscousStrength;\r\n        var inv_mass = this.GetParticleInvMass();\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            if (this.m_flagsBuffer.data[a] & b2Particle_1.b2ParticleFlag.b2_viscousParticle) {\r\n                var b = contact.body;\r\n                var w = contact.weight;\r\n                var m = contact.mass;\r\n                var p = pos_data[a];\r\n                ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n                var v = b2Math_1.b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Math_1.b2Vec2.s_t0), vel_data[a], s_v);\r\n                ///b2Vec2 f = viscousStrength * m * w * v;\r\n                var f = b2Math_1.b2Vec2.MulSV(viscousStrength * m * w, v, s_f);\r\n                ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n                vel_data[a].SelfMulAdd(inv_mass, f);\r\n                ///b.ApplyLinearImpulse(-f, p, true);\r\n                b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n            }\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            if (contact.flags & b2Particle_1.b2ParticleFlag.b2_viscousParticle) {\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                var w = contact.weight;\r\n                ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n                var v = b2Math_1.b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n                ///b2Vec2 f = viscousStrength * w * v;\r\n                var f = b2Math_1.b2Vec2.MulSV(viscousStrength * w, v, s_f);\r\n                ///m_velocityBuffer.data[a] += f;\r\n                vel_data[a].SelfAdd(f);\r\n                ///m_velocityBuffer.data[b] -= f;\r\n                vel_data[b].SelfSub(f);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveRepulsive = function (step) {\r\n        var s_f = b2ParticleSystem.SolveRepulsive_s_f;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var repulsiveStrength = this.m_def.repulsiveStrength * this.GetCriticalVelocity(step);\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            if (contact.flags & b2Particle_1.b2ParticleFlag.b2_repulsiveParticle) {\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {\r\n                    var w = contact.weight;\r\n                    var n = contact.normal;\r\n                    ///b2Vec2 f = repulsiveStrength * w * n;\r\n                    var f = b2Math_1.b2Vec2.MulSV(repulsiveStrength * w, n, s_f);\r\n                    ///m_velocityBuffer.data[a] -= f;\r\n                    vel_data[a].SelfSub(f);\r\n                    ///m_velocityBuffer.data[b] += f;\r\n                    vel_data[b].SelfAdd(f);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolvePowder = function (step) {\r\n        var s_f = b2ParticleSystem.SolvePowder_s_f;\r\n        var pos_data = this.m_positionBuffer.data;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var powderStrength = this.m_def.powderStrength * this.GetCriticalVelocity(step);\r\n        var minWeight = 1.0 - b2Settings_2.b2_particleStride;\r\n        var inv_mass = this.GetParticleInvMass();\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            var a = contact.index;\r\n            if (this.m_flagsBuffer.data[a] & b2Particle_1.b2ParticleFlag.b2_powderParticle) {\r\n                var w = contact.weight;\r\n                if (w > minWeight) {\r\n                    var b = contact.body;\r\n                    var m = contact.mass;\r\n                    var p = pos_data[a];\r\n                    var n = contact.normal;\r\n                    var f = b2Math_1.b2Vec2.MulSV(powderStrength * m * (w - minWeight), n, s_f);\r\n                    vel_data[a].SelfMulSub(inv_mass, f);\r\n                    b.ApplyLinearImpulse(f, p, true);\r\n                }\r\n            }\r\n        }\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            if (contact.flags & b2Particle_1.b2ParticleFlag.b2_powderParticle) {\r\n                var w = contact.weight;\r\n                if (w > minWeight) {\r\n                    var a = contact.indexA;\r\n                    var b = contact.indexB;\r\n                    var n = contact.normal;\r\n                    var f = b2Math_1.b2Vec2.MulSV(powderStrength * (w - minWeight), n, s_f);\r\n                    vel_data[a].SelfSub(f);\r\n                    vel_data[b].SelfAdd(f);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveSolid = function (step) {\r\n        var s_f = b2ParticleSystem.SolveSolid_s_f;\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        // applies extra repulsive force from solid particle groups\r\n        this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);\r\n        var ejectionStrength = step.inv_dt * this.m_def.ejectionStrength;\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            var a = contact.indexA;\r\n            var b = contact.indexB;\r\n            if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {\r\n                var w = contact.weight;\r\n                var n = contact.normal;\r\n                var h = this.m_depthBuffer[a] + this.m_depthBuffer[b];\r\n                var f = b2Math_1.b2Vec2.MulSV(ejectionStrength * h * w, n, s_f);\r\n                vel_data[a].SelfSub(f);\r\n                vel_data[b].SelfAdd(f);\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveForce = function (step) {\r\n        var vel_data = this.m_velocityBuffer.data;\r\n        var velocityPerForce = step.dt * this.GetParticleInvMass();\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            ///m_velocityBuffer.data[i] += velocityPerForce * m_forceBuffer[i];\r\n            vel_data[i].SelfMulAdd(velocityPerForce, this.m_forceBuffer[i]);\r\n        }\r\n        this.m_hasForce = false;\r\n    };\r\n    b2ParticleSystem.prototype.SolveColorMixing = function () {\r\n        // mixes color between contacting particles\r\n        var colorMixing = 0.5 * this.m_def.colorMixingStrength;\r\n        if (colorMixing) {\r\n            for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n                var contact = this.m_contactBuffer.data[k];\r\n                var a = contact.indexA;\r\n                var b = contact.indexB;\r\n                if (this.m_flagsBuffer.data[a] & this.m_flagsBuffer.data[b] &\r\n                    b2Particle_1.b2ParticleFlag.b2_colorMixingParticle) {\r\n                    var colorA = this.m_colorBuffer.data[a];\r\n                    var colorB = this.m_colorBuffer.data[b];\r\n                    // Use the static method to ensure certain compilers inline\r\n                    // this correctly.\r\n                    b2Draw_1.b2Color.MixColors(colorA, colorB, colorMixing);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.SolveZombie = function () {\r\n        // removes particles with zombie flag\r\n        var newCount = 0;\r\n        var newIndices = []; // TODO: static\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            newIndices[i] = b2Settings_1.b2_invalidParticleIndex;\r\n        }\r\n        // DEBUG: b2Assert(newIndices.length === this.m_count);\r\n        var allParticleFlags = 0;\r\n        for (var i = 0; i < this.m_count; i++) {\r\n            var flags = this.m_flagsBuffer.data[i];\r\n            if (flags & b2Particle_1.b2ParticleFlag.b2_zombieParticle) {\r\n                var destructionListener = this.m_world.m_destructionListener;\r\n                if ((flags & b2Particle_1.b2ParticleFlag.b2_destructionListenerParticle) && destructionListener) {\r\n                    destructionListener.SayGoodbyeParticle(this, i);\r\n                }\r\n                // Destroy particle handle.\r\n                if (this.m_handleIndexBuffer.data) {\r\n                    var handle = this.m_handleIndexBuffer.data[i];\r\n                    if (handle) {\r\n                        handle.SetIndex(b2Settings_1.b2_invalidParticleIndex);\r\n                        this.m_handleIndexBuffer.data[i] = null;\r\n                        ///m_handleAllocator.Free(handle);\r\n                    }\r\n                }\r\n                newIndices[i] = b2Settings_1.b2_invalidParticleIndex;\r\n            }\r\n            else {\r\n                newIndices[i] = newCount;\r\n                if (i !== newCount) {\r\n                    // Update handle to reference new particle index.\r\n                    if (this.m_handleIndexBuffer.data) {\r\n                        var handle = this.m_handleIndexBuffer.data[i];\r\n                        if (handle) {\r\n                            handle.SetIndex(newCount);\r\n                        }\r\n                        this.m_handleIndexBuffer.data[newCount] = handle;\r\n                    }\r\n                    this.m_flagsBuffer.data[newCount] = this.m_flagsBuffer.data[i];\r\n                    if (this.m_lastBodyContactStepBuffer.data) {\r\n                        this.m_lastBodyContactStepBuffer.data[newCount] = this.m_lastBodyContactStepBuffer.data[i];\r\n                    }\r\n                    if (this.m_bodyContactCountBuffer.data) {\r\n                        this.m_bodyContactCountBuffer.data[newCount] = this.m_bodyContactCountBuffer.data[i];\r\n                    }\r\n                    if (this.m_consecutiveContactStepsBuffer.data) {\r\n                        this.m_consecutiveContactStepsBuffer.data[newCount] = this.m_consecutiveContactStepsBuffer.data[i];\r\n                    }\r\n                    this.m_positionBuffer.data[newCount].Copy(this.m_positionBuffer.data[i]);\r\n                    this.m_velocityBuffer.data[newCount].Copy(this.m_velocityBuffer.data[i]);\r\n                    this.m_groupBuffer[newCount] = this.m_groupBuffer[i];\r\n                    if (this.m_hasForce) {\r\n                        this.m_forceBuffer[newCount].Copy(this.m_forceBuffer[i]);\r\n                    }\r\n                    if (this.m_staticPressureBuffer) {\r\n                        this.m_staticPressureBuffer[newCount] = this.m_staticPressureBuffer[i];\r\n                    }\r\n                    if (this.m_depthBuffer) {\r\n                        this.m_depthBuffer[newCount] = this.m_depthBuffer[i];\r\n                    }\r\n                    if (this.m_colorBuffer.data) {\r\n                        this.m_colorBuffer.data[newCount].Copy(this.m_colorBuffer.data[i]);\r\n                    }\r\n                    if (this.m_userDataBuffer.data) {\r\n                        this.m_userDataBuffer.data[newCount] = this.m_userDataBuffer.data[i];\r\n                    }\r\n                    if (this.m_expirationTimeBuffer.data) {\r\n                        this.m_expirationTimeBuffer.data[newCount] = this.m_expirationTimeBuffer.data[i];\r\n                    }\r\n                }\r\n                newCount++;\r\n                allParticleFlags |= flags;\r\n            }\r\n        }\r\n        // predicate functions\r\n        var Test = {\r\n            ///static bool IsProxyInvalid(const Proxy& proxy)\r\n            IsProxyInvalid: function (proxy) {\r\n                return proxy.index < 0;\r\n            },\r\n            ///static bool IsContactInvalid(const b2ParticleContact& contact)\r\n            IsContactInvalid: function (contact) {\r\n                return contact.indexA < 0 || contact.indexB < 0;\r\n            },\r\n            ///static bool IsBodyContactInvalid(const b2ParticleBodyContact& contact)\r\n            IsBodyContactInvalid: function (contact) {\r\n                return contact.index < 0;\r\n            },\r\n            ///static bool IsPairInvalid(const b2ParticlePair& pair)\r\n            IsPairInvalid: function (pair) {\r\n                return pair.indexA < 0 || pair.indexB < 0;\r\n            },\r\n            ///static bool IsTriadInvalid(const b2ParticleTriad& triad)\r\n            IsTriadInvalid: function (triad) {\r\n                return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;\r\n            }\r\n        };\r\n        // update proxies\r\n        for (var k = 0; k < this.m_proxyBuffer.count; k++) {\r\n            var proxy = this.m_proxyBuffer.data[k];\r\n            proxy.index = newIndices[proxy.index];\r\n        }\r\n        this.m_proxyBuffer.RemoveIf(Test.IsProxyInvalid);\r\n        // update contacts\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            contact.indexA = newIndices[contact.indexA];\r\n            contact.indexB = newIndices[contact.indexB];\r\n        }\r\n        this.m_contactBuffer.RemoveIf(Test.IsContactInvalid);\r\n        // update particle-body contacts\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            contact.index = newIndices[contact.index];\r\n        }\r\n        this.m_bodyContactBuffer.RemoveIf(Test.IsBodyContactInvalid);\r\n        // update pairs\r\n        for (var k = 0; k < this.m_pairBuffer.count; k++) {\r\n            var pair = this.m_pairBuffer.data[k];\r\n            pair.indexA = newIndices[pair.indexA];\r\n            pair.indexB = newIndices[pair.indexB];\r\n        }\r\n        this.m_pairBuffer.RemoveIf(Test.IsPairInvalid);\r\n        // update triads\r\n        for (var k = 0; k < this.m_triadBuffer.count; k++) {\r\n            var triad = this.m_triadBuffer.data[k];\r\n            triad.indexA = newIndices[triad.indexA];\r\n            triad.indexB = newIndices[triad.indexB];\r\n            triad.indexC = newIndices[triad.indexC];\r\n        }\r\n        this.m_triadBuffer.RemoveIf(Test.IsTriadInvalid);\r\n        // Update lifetime indices.\r\n        if (this.m_indexByExpirationTimeBuffer.data) {\r\n            var writeOffset = 0;\r\n            for (var readOffset = 0; readOffset < this.m_count; readOffset++) {\r\n                var newIndex = newIndices[this.m_indexByExpirationTimeBuffer.data[readOffset]];\r\n                if (newIndex !== b2Settings_1.b2_invalidParticleIndex) {\r\n                    this.m_indexByExpirationTimeBuffer.data[writeOffset++] = newIndex;\r\n                }\r\n            }\r\n        }\r\n        // update groups\r\n        for (var group = this.m_groupList; group; group = group.GetNext()) {\r\n            var firstIndex = newCount;\r\n            var lastIndex = 0;\r\n            var modified = false;\r\n            for (var i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n                var j = newIndices[i];\r\n                if (j >= 0) {\r\n                    firstIndex = b2Math_1.b2Min(firstIndex, j);\r\n                    lastIndex = b2Math_1.b2Max(lastIndex, j + 1);\r\n                }\r\n                else {\r\n                    modified = true;\r\n                }\r\n            }\r\n            if (firstIndex < lastIndex) {\r\n                group.m_firstIndex = firstIndex;\r\n                group.m_lastIndex = lastIndex;\r\n                if (modified) {\r\n                    if (group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n                        this.SetGroupFlags(group, group.m_groupFlags | b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                group.m_firstIndex = 0;\r\n                group.m_lastIndex = 0;\r\n                if (!(group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupCanBeEmpty)) {\r\n                    this.SetGroupFlags(group, group.m_groupFlags | b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed);\r\n                }\r\n            }\r\n        }\r\n        // update particle count\r\n        this.m_count = newCount;\r\n        this.m_allParticleFlags = allParticleFlags;\r\n        this.m_needsUpdateAllParticleFlags = false;\r\n        // destroy bodies with no particles\r\n        for (var group = this.m_groupList; group;) {\r\n            var next = group.GetNext();\r\n            if (group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed) {\r\n                this.DestroyParticleGroup(group);\r\n            }\r\n            group = next;\r\n        }\r\n    };\r\n    /**\r\n     * Destroy all particles which have outlived their lifetimes set\r\n     * by SetParticleLifetime().\r\n     */\r\n    b2ParticleSystem.prototype.SolveLifetimes = function (step) {\r\n        // Update the time elapsed.\r\n        this.m_timeElapsed = this.LifetimeToExpirationTime(step.dt);\r\n        // Get the floor (non-fractional component) of the elapsed time.\r\n        var quantizedTimeElapsed = this.GetQuantizedTimeElapsed();\r\n        var expirationTimes = this.m_expirationTimeBuffer.data;\r\n        var expirationTimeIndices = this.m_indexByExpirationTimeBuffer.data;\r\n        var particleCount = this.GetParticleCount();\r\n        // Sort the lifetime buffer if it's required.\r\n        if (this.m_expirationTimeBufferRequiresSorting) {\r\n            ///const ExpirationTimeComparator expirationTimeComparator(expirationTimes);\r\n            ///std::sort(expirationTimeIndices, expirationTimeIndices + particleCount, expirationTimeComparator);\r\n            /**\r\n             * Compare the lifetime of particleIndexA and particleIndexB\r\n             * returning true if the lifetime of A is greater than B for\r\n             * particles that will expire.  If either particle's lifetime is\r\n             * infinite (<= 0.0f) this function return true if the lifetime\r\n             * of A is lesser than B. When used with std::sort() this\r\n             * results in an array of particle indicies sorted in reverse\r\n             * order by particle lifetime.\r\n             *\r\n             * For example, the set of lifetimes\r\n             * (1.0, 0.7, 0.3, 0.0, -1.0, 2.0)\r\n             * would be sorted as\r\n             * (0.0, 1.0, -2.0, 1.0, 0.7, 0.3)\r\n             */\r\n            var ExpirationTimeComparator = function (particleIndexA, particleIndexB) {\r\n                var expirationTimeA = expirationTimes[particleIndexA];\r\n                var expirationTimeB = expirationTimes[particleIndexB];\r\n                var infiniteExpirationTimeA = expirationTimeA <= 0.0;\r\n                var infiniteExpirationTimeB = expirationTimeB <= 0.0;\r\n                return infiniteExpirationTimeA === infiniteExpirationTimeB ?\r\n                    expirationTimeA > expirationTimeB : infiniteExpirationTimeA;\r\n            };\r\n            std_sort(expirationTimeIndices, 0, particleCount, ExpirationTimeComparator);\r\n            this.m_expirationTimeBufferRequiresSorting = false;\r\n        }\r\n        // Destroy particles which have expired.\r\n        for (var i = particleCount - 1; i >= 0; --i) {\r\n            var particleIndex = expirationTimeIndices[i];\r\n            var expirationTime = expirationTimes[particleIndex];\r\n            // If no particles need to be destroyed, skip this.\r\n            if (quantizedTimeElapsed < expirationTime || expirationTime <= 0) {\r\n                break;\r\n            }\r\n            // Destroy this particle.\r\n            this.DestroyParticle(particleIndex);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.RotateBuffer = function (start, mid, end) {\r\n        // move the particles assigned to the given group toward the end of array\r\n        if (start === mid || mid === end) {\r\n            return;\r\n        }\r\n        // DEBUG: b2Assert(mid >= start && mid <= end);\r\n        function newIndices(i) {\r\n            if (i < start) {\r\n                return i;\r\n            }\r\n            else if (i < mid) {\r\n                return i + end - mid;\r\n            }\r\n            else if (i < end) {\r\n                return i + start - mid;\r\n            }\r\n            else {\r\n                return i;\r\n            }\r\n        }\r\n        ///std::rotate(m_flagsBuffer.data + start, m_flagsBuffer.data + mid, m_flagsBuffer.data + end);\r\n        std_rotate(this.m_flagsBuffer.data, start, mid, end);\r\n        if (this.m_lastBodyContactStepBuffer.data) {\r\n            ///std::rotate(m_lastBodyContactStepBuffer.data + start, m_lastBodyContactStepBuffer.data + mid, m_lastBodyContactStepBuffer.data + end);\r\n            std_rotate(this.m_lastBodyContactStepBuffer.data, start, mid, end);\r\n        }\r\n        if (this.m_bodyContactCountBuffer.data) {\r\n            ///std::rotate(m_bodyContactCountBuffer.data + start, m_bodyContactCountBuffer.data + mid, m_bodyContactCountBuffer.data + end);\r\n            std_rotate(this.m_bodyContactCountBuffer.data, start, mid, end);\r\n        }\r\n        if (this.m_consecutiveContactStepsBuffer.data) {\r\n            ///std::rotate(m_consecutiveContactStepsBuffer.data + start, m_consecutiveContactStepsBuffer.data + mid, m_consecutiveContactStepsBuffer.data + end);\r\n            std_rotate(this.m_consecutiveContactStepsBuffer.data, start, mid, end);\r\n        }\r\n        ///std::rotate(m_positionBuffer.data + start, m_positionBuffer.data + mid, m_positionBuffer.data + end);\r\n        std_rotate(this.m_positionBuffer.data, start, mid, end);\r\n        ///std::rotate(m_velocityBuffer.data + start, m_velocityBuffer.data + mid, m_velocityBuffer.data + end);\r\n        std_rotate(this.m_velocityBuffer.data, start, mid, end);\r\n        ///std::rotate(m_groupBuffer + start, m_groupBuffer + mid, m_groupBuffer + end);\r\n        std_rotate(this.m_groupBuffer, start, mid, end);\r\n        if (this.m_hasForce) {\r\n            ///std::rotate(m_forceBuffer + start, m_forceBuffer + mid, m_forceBuffer + end);\r\n            std_rotate(this.m_forceBuffer, start, mid, end);\r\n        }\r\n        if (this.m_staticPressureBuffer) {\r\n            ///std::rotate(m_staticPressureBuffer + start, m_staticPressureBuffer + mid, m_staticPressureBuffer + end);\r\n            std_rotate(this.m_staticPressureBuffer, start, mid, end);\r\n        }\r\n        if (this.m_depthBuffer) {\r\n            ///std::rotate(m_depthBuffer + start, m_depthBuffer + mid, m_depthBuffer + end);\r\n            std_rotate(this.m_depthBuffer, start, mid, end);\r\n        }\r\n        if (this.m_colorBuffer.data) {\r\n            ///std::rotate(m_colorBuffer.data + start, m_colorBuffer.data + mid, m_colorBuffer.data + end);\r\n            std_rotate(this.m_colorBuffer.data, start, mid, end);\r\n        }\r\n        if (this.m_userDataBuffer.data) {\r\n            ///std::rotate(m_userDataBuffer.data + start, m_userDataBuffer.data + mid, m_userDataBuffer.data + end);\r\n            std_rotate(this.m_userDataBuffer.data, start, mid, end);\r\n        }\r\n        // Update handle indices.\r\n        if (this.m_handleIndexBuffer.data) {\r\n            ///std::rotate(m_handleIndexBuffer.data + start, m_handleIndexBuffer.data + mid, m_handleIndexBuffer.data + end);\r\n            std_rotate(this.m_handleIndexBuffer.data, start, mid, end);\r\n            for (var i = start; i < end; ++i) {\r\n                var handle = this.m_handleIndexBuffer.data[i];\r\n                if (handle) {\r\n                    handle.SetIndex(newIndices(handle.GetIndex()));\r\n                }\r\n            }\r\n        }\r\n        if (this.m_expirationTimeBuffer.data) {\r\n            ///std::rotate(m_expirationTimeBuffer.data + start, m_expirationTimeBuffer.data + mid, m_expirationTimeBuffer.data + end);\r\n            std_rotate(this.m_expirationTimeBuffer.data, start, mid, end);\r\n            // Update expiration time buffer indices.\r\n            var particleCount = this.GetParticleCount();\r\n            var indexByExpirationTime = this.m_indexByExpirationTimeBuffer.data;\r\n            for (var i = 0; i < particleCount; ++i) {\r\n                indexByExpirationTime[i] = newIndices(indexByExpirationTime[i]);\r\n            }\r\n        }\r\n        // update proxies\r\n        for (var k = 0; k < this.m_proxyBuffer.count; k++) {\r\n            var proxy = this.m_proxyBuffer.data[k];\r\n            proxy.index = newIndices(proxy.index);\r\n        }\r\n        // update contacts\r\n        for (var k = 0; k < this.m_contactBuffer.count; k++) {\r\n            var contact = this.m_contactBuffer.data[k];\r\n            contact.indexA = newIndices(contact.indexA);\r\n            contact.indexB = newIndices(contact.indexB);\r\n        }\r\n        // update particle-body contacts\r\n        for (var k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n            var contact = this.m_bodyContactBuffer.data[k];\r\n            contact.index = newIndices(contact.index);\r\n        }\r\n        // update pairs\r\n        for (var k = 0; k < this.m_pairBuffer.count; k++) {\r\n            var pair = this.m_pairBuffer.data[k];\r\n            pair.indexA = newIndices(pair.indexA);\r\n            pair.indexB = newIndices(pair.indexB);\r\n        }\r\n        // update triads\r\n        for (var k = 0; k < this.m_triadBuffer.count; k++) {\r\n            var triad = this.m_triadBuffer.data[k];\r\n            triad.indexA = newIndices(triad.indexA);\r\n            triad.indexB = newIndices(triad.indexB);\r\n            triad.indexC = newIndices(triad.indexC);\r\n        }\r\n        // update groups\r\n        for (var group = this.m_groupList; group; group = group.GetNext()) {\r\n            group.m_firstIndex = newIndices(group.m_firstIndex);\r\n            group.m_lastIndex = newIndices(group.m_lastIndex - 1) + 1;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.GetCriticalVelocity = function (step) {\r\n        return this.m_particleDiameter * step.inv_dt;\r\n    };\r\n    b2ParticleSystem.prototype.GetCriticalVelocitySquared = function (step) {\r\n        var velocity = this.GetCriticalVelocity(step);\r\n        return velocity * velocity;\r\n    };\r\n    b2ParticleSystem.prototype.GetCriticalPressure = function (step) {\r\n        return this.m_def.density * this.GetCriticalVelocitySquared(step);\r\n    };\r\n    b2ParticleSystem.prototype.GetParticleStride = function () {\r\n        return b2Settings_2.b2_particleStride * this.m_particleDiameter;\r\n    };\r\n    b2ParticleSystem.prototype.GetParticleMass = function () {\r\n        var stride = this.GetParticleStride();\r\n        return this.m_def.density * stride * stride;\r\n    };\r\n    b2ParticleSystem.prototype.GetParticleInvMass = function () {\r\n        ///return 1.777777 * this.m_inverseDensity * this.m_inverseDiameter * this.m_inverseDiameter;\r\n        // mass = density * stride^2, so we take the inverse of this.\r\n        var inverseStride = this.m_inverseDiameter * (1.0 / b2Settings_2.b2_particleStride);\r\n        return this.m_inverseDensity * inverseStride * inverseStride;\r\n    };\r\n    /**\r\n     * Get the world's contact filter if any particles with the\r\n     * b2_contactFilterParticle flag are present in the system.\r\n     */\r\n    b2ParticleSystem.prototype.GetFixtureContactFilter = function () {\r\n        return (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_fixtureContactFilterParticle) ?\r\n            this.m_world.m_contactManager.m_contactFilter : null;\r\n    };\r\n    /**\r\n     * Get the world's contact filter if any particles with the\r\n     * b2_particleContactFilterParticle flag are present in the\r\n     * system.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleContactFilter = function () {\r\n        return (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_particleContactFilterParticle) ?\r\n            this.m_world.m_contactManager.m_contactFilter : null;\r\n    };\r\n    /**\r\n     * Get the world's contact listener if any particles with the\r\n     * b2_fixtureContactListenerParticle flag are present in the\r\n     * system.\r\n     */\r\n    b2ParticleSystem.prototype.GetFixtureContactListener = function () {\r\n        return (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_fixtureContactListenerParticle) ?\r\n            this.m_world.m_contactManager.m_contactListener : null;\r\n    };\r\n    /**\r\n     * Get the world's contact listener if any particles with the\r\n     * b2_particleContactListenerParticle flag are present in the\r\n     * system.\r\n     */\r\n    b2ParticleSystem.prototype.GetParticleContactListener = function () {\r\n        return (this.m_allParticleFlags & b2Particle_1.b2ParticleFlag.b2_particleContactListenerParticle) ?\r\n            this.m_world.m_contactManager.m_contactListener : null;\r\n    };\r\n    b2ParticleSystem.prototype.SetUserOverridableBuffer = function (buffer, data) {\r\n        buffer.data = data;\r\n        buffer.userSuppliedCapacity = data.length;\r\n    };\r\n    b2ParticleSystem.prototype.SetGroupFlags = function (group, newFlags) {\r\n        var oldFlags = group.m_groupFlags;\r\n        if ((oldFlags ^ newFlags) & b2ParticleGroup_1.b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n            // If the b2_solidParticleGroup flag changed schedule depth update.\r\n            newFlags |= b2ParticleGroup_1.b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth;\r\n        }\r\n        if (oldFlags & ~newFlags) {\r\n            // If any flags might be removed\r\n            this.m_needsUpdateAllGroupFlags = true;\r\n        }\r\n        if (~this.m_allGroupFlags & newFlags) {\r\n            // If any flags were added\r\n            if (newFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n                this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);\r\n            }\r\n            this.m_allGroupFlags |= newFlags;\r\n        }\r\n        group.m_groupFlags = newFlags;\r\n    };\r\n    b2ParticleSystem.BodyContactCompare = function (lhs, rhs) {\r\n        if (lhs.index === rhs.index) {\r\n            // Subsort by weight, decreasing.\r\n            return lhs.weight > rhs.weight;\r\n        }\r\n        return lhs.index < rhs.index;\r\n    };\r\n    b2ParticleSystem.prototype.RemoveSpuriousBodyContacts = function () {\r\n        // At this point we have a list of contact candidates based on AABB\r\n        // overlap.The AABB query that  generated this returns all collidable\r\n        // fixtures overlapping particle bounding boxes.  This breaks down around\r\n        // vertices where two shapes intersect, such as a \"ground\" surface made\r\n        // of multiple b2PolygonShapes; it potentially applies a lot of spurious\r\n        // impulses from normals that should not actually contribute.  See the\r\n        // Ramp example in Testbed.\r\n        //\r\n        // To correct for this, we apply this algorithm:\r\n        //   * sort contacts by particle and subsort by weight (nearest to farthest)\r\n        //   * for each contact per particle:\r\n        //      - project a point at the contact distance along the inverse of the\r\n        //        contact normal\r\n        //      - if this intersects the fixture that generated the contact, apply\r\n        //         it, otherwise discard as impossible\r\n        //      - repeat for up to n nearest contacts, currently we get good results\r\n        //        from n=3.\r\n        ///std::sort(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleSystem::BodyContactCompare);\r\n        std_sort(this.m_bodyContactBuffer.data, 0, this.m_bodyContactBuffer.count, b2ParticleSystem.BodyContactCompare);\r\n        ///int32 discarded = 0;\r\n        ///std::remove_if(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleBodyContactRemovePredicate(this, &discarded));\r\n        ///\r\n        ///m_bodyContactBuffer.SetCount(m_bodyContactBuffer.GetCount() - discarded);\r\n        var s_n = b2ParticleSystem.RemoveSpuriousBodyContacts_s_n;\r\n        var s_pos = b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos;\r\n        var s_normal = b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal;\r\n        // Max number of contacts processed per particle, from nearest to farthest.\r\n        // This must be at least 2 for correctness with concave shapes; 3 was\r\n        // experimentally arrived at as looking reasonable.\r\n        var k_maxContactsPerPoint = 3;\r\n        var system = this;\r\n        // Index of last particle processed.\r\n        var lastIndex = -1;\r\n        // Number of contacts processed for the current particle.\r\n        var currentContacts = 0;\r\n        // Output the number of discarded contacts.\r\n        // let discarded = 0;\r\n        var b2ParticleBodyContactRemovePredicate = function (contact) {\r\n            // This implements the selection criteria described in\r\n            // RemoveSpuriousBodyContacts().\r\n            // This functor is iterating through a list of Body contacts per\r\n            // Particle, ordered from near to far.  For up to the maximum number of\r\n            // contacts we allow per point per step, we verify that the contact\r\n            // normal of the Body that genenerated the contact makes physical sense\r\n            // by projecting a point back along that normal and seeing if it\r\n            // intersects the fixture generating the contact.\r\n            if (contact.index !== lastIndex) {\r\n                currentContacts = 0;\r\n                lastIndex = contact.index;\r\n            }\r\n            if (currentContacts++ > k_maxContactsPerPoint) {\r\n                // ++discarded;\r\n                return true;\r\n            }\r\n            // Project along inverse normal (as returned in the contact) to get the\r\n            // point to check.\r\n            ///b2Vec2 n = contact.normal;\r\n            var n = s_n.Copy(contact.normal);\r\n            // weight is 1-(inv(diameter) * distance)\r\n            ///n *= system.m_particleDiameter * (1 - contact.weight);\r\n            n.SelfMul(system.m_particleDiameter * (1 - contact.weight));\r\n            ///b2Vec2 pos = system.m_positionBuffer.data[contact.index] + n;\r\n            var pos = b2Math_1.b2Vec2.AddVV(system.m_positionBuffer.data[contact.index], n, s_pos);\r\n            // pos is now a point projected back along the contact normal to the\r\n            // contact distance. If the surface makes sense for a contact, pos will\r\n            // now lie on or in the fixture generating\r\n            if (!contact.fixture.TestPoint(pos)) {\r\n                var childCount = contact.fixture.GetShape().GetChildCount();\r\n                for (var childIndex = 0; childIndex < childCount; childIndex++) {\r\n                    var normal = s_normal;\r\n                    var distance = contact.fixture.ComputeDistance(pos, normal, childIndex);\r\n                    if (distance < b2Settings_1.b2_linearSlop) {\r\n                        return false;\r\n                    }\r\n                }\r\n                // ++discarded;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        this.m_bodyContactBuffer.count = std_remove_if(this.m_bodyContactBuffer.data, b2ParticleBodyContactRemovePredicate, this.m_bodyContactBuffer.count);\r\n    };\r\n    b2ParticleSystem.prototype.DetectStuckParticle = function (particle) {\r\n        // Detect stuck particles\r\n        //\r\n        // The basic algorithm is to allow the user to specify an optional\r\n        // threshold where we detect whenever a particle is contacting\r\n        // more than one fixture for more than threshold consecutive\r\n        // steps. This is considered to be \"stuck\", and these are put\r\n        // in a list the user can query per step, if enabled, to deal with\r\n        // such particles.\r\n        if (this.m_stuckThreshold <= 0) {\r\n            return;\r\n        }\r\n        // Get the state variables for this particle.\r\n        ///int32 * const consecutiveCount = &m_consecutiveContactStepsBuffer.data[particle];\r\n        ///int32 * const lastStep = &m_lastBodyContactStepBuffer.data[particle];\r\n        ///int32 * const bodyCount = &m_bodyContactCountBuffer.data[particle];\r\n        // This is only called when there is a body contact for this particle.\r\n        ///++(*bodyCount);\r\n        ++this.m_bodyContactCountBuffer.data[particle];\r\n        // We want to only trigger detection once per step, the first time we\r\n        // contact more than one fixture in a step for a given particle.\r\n        ///if (*bodyCount === 2)\r\n        if (this.m_bodyContactCountBuffer.data[particle] === 2) {\r\n            ///++(*consecutiveCount);\r\n            ++this.m_consecutiveContactStepsBuffer.data[particle];\r\n            ///if (*consecutiveCount > m_stuckThreshold)\r\n            if (this.m_consecutiveContactStepsBuffer.data[particle] > this.m_stuckThreshold) {\r\n                ///int32& newStuckParticle = m_stuckParticleBuffer.Append();\r\n                ///newStuckParticle = particle;\r\n                this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()] = particle;\r\n            }\r\n        }\r\n        ///*lastStep = m_timestamp;\r\n        this.m_lastBodyContactStepBuffer.data[particle] = this.m_timestamp;\r\n    };\r\n    /**\r\n     * Determine whether a particle index is valid.\r\n     */\r\n    b2ParticleSystem.prototype.ValidateParticleIndex = function (index) {\r\n        return index >= 0 && index < this.GetParticleCount() &&\r\n            index !== b2Settings_1.b2_invalidParticleIndex;\r\n    };\r\n    /**\r\n     * Get the time elapsed in\r\n     * b2ParticleSystemDef::lifetimeGranularity.\r\n     */\r\n    b2ParticleSystem.prototype.GetQuantizedTimeElapsed = function () {\r\n        ///return (int32)(m_timeElapsed >> 32);\r\n        return Math.floor(this.m_timeElapsed / 0x100000000);\r\n    };\r\n    /**\r\n     * Convert a lifetime in seconds to an expiration time.\r\n     */\r\n    b2ParticleSystem.prototype.LifetimeToExpirationTime = function (lifetime) {\r\n        ///return m_timeElapsed + (int64)((lifetime / m_def.lifetimeGranularity) * (float32)(1LL << 32));\r\n        return this.m_timeElapsed + Math.floor(((lifetime / this.m_def.lifetimeGranularity) * 0x100000000));\r\n    };\r\n    b2ParticleSystem.prototype.ForceCanBeApplied = function (flags) {\r\n        return !(flags & b2Particle_1.b2ParticleFlag.b2_wallParticle);\r\n    };\r\n    b2ParticleSystem.prototype.PrepareForceBuffer = function () {\r\n        if (!this.m_hasForce) {\r\n            ///memset(m_forceBuffer, 0, sizeof(*m_forceBuffer) * m_count);\r\n            for (var i = 0; i < this.m_count; i++) {\r\n                this.m_forceBuffer[i].SetZero();\r\n            }\r\n            this.m_hasForce = true;\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.IsRigidGroup = function (group) {\r\n        return (group !== null) && ((group.m_groupFlags & b2ParticleGroup_1.b2ParticleGroupFlag.b2_rigidParticleGroup) !== 0);\r\n    };\r\n    b2ParticleSystem.prototype.GetLinearVelocity = function (group, particleIndex, point, out) {\r\n        if (group && this.IsRigidGroup(group)) {\r\n            return group.GetLinearVelocityFromWorldPoint(point, out);\r\n        }\r\n        else {\r\n            ///return m_velocityBuffer.data[particleIndex];\r\n            return out.Copy(this.m_velocityBuffer.data[particleIndex]);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.InitDampingParameter = function (invMass, invInertia, tangentDistance, mass, inertia, center, point, normal) {\r\n        ///*invMass = mass > 0 ? 1 / mass : 0;\r\n        invMass[0] = mass > 0 ? 1 / mass : 0;\r\n        ///*invInertia = inertia > 0 ? 1 / inertia : 0;\r\n        invInertia[0] = inertia > 0 ? 1 / inertia : 0;\r\n        ///*tangentDistance = b2Cross(point - center, normal);\r\n        tangentDistance[0] = b2Math_1.b2Vec2.CrossVV(b2Math_1.b2Vec2.SubVV(point, center, b2Math_1.b2Vec2.s_t0), normal);\r\n    };\r\n    b2ParticleSystem.prototype.InitDampingParameterWithRigidGroupOrParticle = function (invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, point, normal) {\r\n        if (group && isRigidGroup) {\r\n            this.InitDampingParameter(invMass, invInertia, tangentDistance, group.GetMass(), group.GetInertia(), group.GetCenter(), point, normal);\r\n        }\r\n        else {\r\n            var flags = this.m_flagsBuffer.data[particleIndex];\r\n            this.InitDampingParameter(invMass, invInertia, tangentDistance, flags & b2Particle_1.b2ParticleFlag.b2_wallParticle ? 0 : this.GetParticleMass(), 0, point, point, normal);\r\n        }\r\n    };\r\n    b2ParticleSystem.prototype.ComputeDampingImpulse = function (invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, normalVelocity) {\r\n        var invMass = invMassA + invInertiaA * tangentDistanceA * tangentDistanceA +\r\n            invMassB + invInertiaB * tangentDistanceB * tangentDistanceB;\r\n        return invMass > 0 ? normalVelocity / invMass : 0;\r\n    };\r\n    b2ParticleSystem.prototype.ApplyDamping = function (invMass, invInertia, tangentDistance, isRigidGroup, group, particleIndex, impulse, normal) {\r\n        if (group && isRigidGroup) {\r\n            ///group.m_linearVelocity += impulse * invMass * normal;\r\n            group.m_linearVelocity.SelfMulAdd(impulse * invMass, normal);\r\n            ///group.m_angularVelocity += impulse * tangentDistance * invInertia;\r\n            group.m_angularVelocity += impulse * tangentDistance * invInertia;\r\n        }\r\n        else {\r\n            ///m_velocityBuffer.data[particleIndex] += impulse * invMass * normal;\r\n            this.m_velocityBuffer.data[particleIndex].SelfMulAdd(impulse * invMass, normal);\r\n        }\r\n    };\r\n    b2ParticleSystem.xTruncBits = 12;\r\n    b2ParticleSystem.yTruncBits = 12;\r\n    b2ParticleSystem.tagBits = 8 * 4; // 8u * sizeof(uint32);\r\n    b2ParticleSystem.yOffset = 1 << (b2ParticleSystem.yTruncBits - 1);\r\n    b2ParticleSystem.yShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits;\r\n    b2ParticleSystem.xShift = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits - b2ParticleSystem.xTruncBits;\r\n    b2ParticleSystem.xScale = 1 << b2ParticleSystem.xShift;\r\n    b2ParticleSystem.xOffset = b2ParticleSystem.xScale * (1 << (b2ParticleSystem.xTruncBits - 1));\r\n    b2ParticleSystem.yMask = ((1 << b2ParticleSystem.yTruncBits) - 1) << b2ParticleSystem.yShift;\r\n    b2ParticleSystem.xMask = ~b2ParticleSystem.yMask;\r\n    b2ParticleSystem.DestroyParticlesInShape_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.CreateParticleGroup_s_transform = new b2Math_1.b2Transform();\r\n    b2ParticleSystem.ComputeCollisionEnergy_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.QueryShapeAABB_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.QueryPointAABB_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.RayCast_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.RayCast_s_p = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RayCast_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RayCast_s_n = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RayCast_s_point = new b2Math_1.b2Vec2();\r\n    /**\r\n     * All particle types that require creating pairs\r\n     */\r\n    b2ParticleSystem.k_pairFlags = b2Particle_1.b2ParticleFlag.b2_springParticle;\r\n    /**\r\n     * All particle types that require creating triads\r\n     */\r\n    b2ParticleSystem.k_triadFlags = b2Particle_1.b2ParticleFlag.b2_elasticParticle;\r\n    /**\r\n     * All particle types that do not produce dynamic pressure\r\n     */\r\n    b2ParticleSystem.k_noPressureFlags = b2Particle_1.b2ParticleFlag.b2_powderParticle | b2Particle_1.b2ParticleFlag.b2_tensileParticle;\r\n    /**\r\n     * All particle types that apply extra damping force with bodies\r\n     */\r\n    b2ParticleSystem.k_extraDampingFlags = b2Particle_1.b2ParticleFlag.b2_staticPressureParticle;\r\n    b2ParticleSystem.k_barrierWallFlags = b2Particle_1.b2ParticleFlag.b2_barrierParticle | b2Particle_1.b2ParticleFlag.b2_wallParticle;\r\n    b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge = new b2EdgeShape_1.b2EdgeShape();\r\n    b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.UpdatePairsAndTriads_s_dab = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.UpdatePairsAndTriads_s_dbc = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.UpdatePairsAndTriads_s_dca = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.AddContact_s_d = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.UpdateBodyContacts_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.Solve_s_subStep = new b2TimeStep_1.b2TimeStep();\r\n    b2ParticleSystem.SolveCollision_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.SolveGravity_s_gravity = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_aabb = new b2Collision_1.b2AABB();\r\n    b2ParticleSystem.SolveBarrier_s_va = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_vb = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_pba = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_vba = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_vc = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_pca = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_vca = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_qba = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_qca = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_dv = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveBarrier_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolvePressure_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveDamping_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveDamping_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigidDamping_s_t0 = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigidDamping_s_t1 = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigidDamping_s_p = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigidDamping_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveExtraDamping_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveExtraDamping_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigid_s_position = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRigid_s_rotation = new b2Math_1.b2Rot();\r\n    b2ParticleSystem.SolveRigid_s_transform = new b2Math_1.b2Transform();\r\n    b2ParticleSystem.SolveRigid_s_velocityTransform = new b2Math_1.b2Transform();\r\n    b2ParticleSystem.SolveElastic_s_pa = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveElastic_s_pb = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveElastic_s_pc = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveElastic_s_r = new b2Math_1.b2Rot();\r\n    b2ParticleSystem.SolveElastic_s_t0 = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveSpring_s_pa = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveSpring_s_pb = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveSpring_s_d = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveSpring_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveTensile_s_weightedNormal = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveTensile_s_s = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveTensile_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveViscous_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveViscous_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveRepulsive_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolvePowder_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.SolveSolid_s_f = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RemoveSpuriousBodyContacts_s_n = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal = new b2Math_1.b2Vec2();\r\n    return b2ParticleSystem;\r\n}());\r\nexports.b2ParticleSystem = b2ParticleSystem;\r\nvar b2ParticleSystem_UserOverridableBuffer = /** @class */ (function () {\r\n    function b2ParticleSystem_UserOverridableBuffer() {\r\n        this._data = null;\r\n        this.userSuppliedCapacity = 0;\r\n    }\r\n    Object.defineProperty(b2ParticleSystem_UserOverridableBuffer.prototype, \"data\", {\r\n        get: function () { return this._data; } // HACK: may return null\r\n        ,\r\n        set: function (value) { this._data = value; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    return b2ParticleSystem_UserOverridableBuffer;\r\n}());\r\nexports.b2ParticleSystem_UserOverridableBuffer = b2ParticleSystem_UserOverridableBuffer;\r\nvar b2ParticleSystem_Proxy = /** @class */ (function () {\r\n    function b2ParticleSystem_Proxy() {\r\n        this.index = b2Settings_1.b2_invalidParticleIndex;\r\n        this.tag = 0;\r\n    }\r\n    b2ParticleSystem_Proxy.CompareProxyProxy = function (a, b) {\r\n        return a.tag < b.tag;\r\n    };\r\n    b2ParticleSystem_Proxy.CompareTagProxy = function (a, b) {\r\n        return a < b.tag;\r\n    };\r\n    b2ParticleSystem_Proxy.CompareProxyTag = function (a, b) {\r\n        return a.tag < b;\r\n    };\r\n    return b2ParticleSystem_Proxy;\r\n}());\r\nexports.b2ParticleSystem_Proxy = b2ParticleSystem_Proxy;\r\nvar b2ParticleSystem_InsideBoundsEnumerator = /** @class */ (function () {\r\n    /**\r\n     * InsideBoundsEnumerator enumerates all particles inside the\r\n     * given bounds.\r\n     *\r\n     * Construct an enumerator with bounds of tags and a range of\r\n     * proxies.\r\n     */\r\n    function b2ParticleSystem_InsideBoundsEnumerator(system, lower, upper, first, last) {\r\n        this.m_system = system;\r\n        this.m_xLower = (lower & b2ParticleSystem.xMask) >>> 0;\r\n        this.m_xUpper = (upper & b2ParticleSystem.xMask) >>> 0;\r\n        this.m_yLower = (lower & b2ParticleSystem.yMask) >>> 0;\r\n        this.m_yUpper = (upper & b2ParticleSystem.yMask) >>> 0;\r\n        this.m_first = first;\r\n        this.m_last = last;\r\n        // DEBUG: b2Assert(this.m_first <= this.m_last);\r\n    }\r\n    /**\r\n     * Get index of the next particle. Returns\r\n     * b2_invalidParticleIndex if there are no more particles.\r\n     */\r\n    b2ParticleSystem_InsideBoundsEnumerator.prototype.GetNext = function () {\r\n        while (this.m_first < this.m_last) {\r\n            var xTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem.xMask) >>> 0;\r\n            // #if B2_ASSERT_ENABLED\r\n            // DEBUG: const yTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem_yMask) >>> 0;\r\n            // DEBUG: b2Assert(yTag >= this.m_yLower);\r\n            // DEBUG: b2Assert(yTag <= this.m_yUpper);\r\n            // #endif\r\n            if (xTag >= this.m_xLower && xTag <= this.m_xUpper) {\r\n                return (this.m_system.m_proxyBuffer.data[this.m_first++]).index;\r\n            }\r\n            this.m_first++;\r\n        }\r\n        return b2Settings_1.b2_invalidParticleIndex;\r\n    };\r\n    return b2ParticleSystem_InsideBoundsEnumerator;\r\n}());\r\nexports.b2ParticleSystem_InsideBoundsEnumerator = b2ParticleSystem_InsideBoundsEnumerator;\r\nvar b2ParticleSystem_ParticleListNode = /** @class */ (function () {\r\n    function b2ParticleSystem_ParticleListNode() {\r\n        /**\r\n         * The next node in the list.\r\n         */\r\n        this.next = null;\r\n        /**\r\n         * Number of entries in the list. Valid only for the node at the\r\n         * head of the list.\r\n         */\r\n        this.count = 0;\r\n        /**\r\n         * Particle index.\r\n         */\r\n        this.index = 0;\r\n    }\r\n    return b2ParticleSystem_ParticleListNode;\r\n}());\r\nexports.b2ParticleSystem_ParticleListNode = b2ParticleSystem_ParticleListNode;\r\n/**\r\n * @constructor\r\n */\r\nvar b2ParticleSystem_FixedSetAllocator = /** @class */ (function () {\r\n    function b2ParticleSystem_FixedSetAllocator() {\r\n    }\r\n    b2ParticleSystem_FixedSetAllocator.prototype.Allocate = function (itemSize, count) {\r\n        // TODO\r\n        return count;\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.Clear = function () {\r\n        // TODO\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.GetCount = function () {\r\n        // TODO\r\n        return 0;\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.Invalidate = function (itemIndex) {\r\n        // TODO\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.GetValidBuffer = function () {\r\n        // TODO\r\n        return [];\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.GetBuffer = function () {\r\n        // TODO\r\n        return [];\r\n    };\r\n    b2ParticleSystem_FixedSetAllocator.prototype.SetCount = function (count) {\r\n        // TODO\r\n    };\r\n    return b2ParticleSystem_FixedSetAllocator;\r\n}());\r\nexports.b2ParticleSystem_FixedSetAllocator = b2ParticleSystem_FixedSetAllocator;\r\nvar b2ParticleSystem_FixtureParticle = /** @class */ (function () {\r\n    function b2ParticleSystem_FixtureParticle(fixture, particle) {\r\n        this.second = b2Settings_1.b2_invalidParticleIndex;\r\n        this.first = fixture;\r\n        this.second = particle;\r\n    }\r\n    return b2ParticleSystem_FixtureParticle;\r\n}());\r\nexports.b2ParticleSystem_FixtureParticle = b2ParticleSystem_FixtureParticle;\r\nvar b2ParticleSystem_FixtureParticleSet = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_FixtureParticleSet, _super);\r\n    function b2ParticleSystem_FixtureParticleSet() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    b2ParticleSystem_FixtureParticleSet.prototype.Initialize = function (bodyContactBuffer, flagsBuffer) {\r\n        // TODO\r\n    };\r\n    b2ParticleSystem_FixtureParticleSet.prototype.Find = function (pair) {\r\n        // TODO\r\n        return b2Settings_1.b2_invalidParticleIndex;\r\n    };\r\n    return b2ParticleSystem_FixtureParticleSet;\r\n}(b2ParticleSystem_FixedSetAllocator));\r\nexports.b2ParticleSystem_FixtureParticleSet = b2ParticleSystem_FixtureParticleSet;\r\nvar b2ParticleSystem_ParticlePair = /** @class */ (function () {\r\n    function b2ParticleSystem_ParticlePair(particleA, particleB) {\r\n        this.first = b2Settings_1.b2_invalidParticleIndex;\r\n        this.second = b2Settings_1.b2_invalidParticleIndex;\r\n        this.first = particleA;\r\n        this.second = particleB;\r\n    }\r\n    return b2ParticleSystem_ParticlePair;\r\n}());\r\nexports.b2ParticleSystem_ParticlePair = b2ParticleSystem_ParticlePair;\r\nvar b2ParticlePairSet = /** @class */ (function (_super) {\r\n    __extends(b2ParticlePairSet, _super);\r\n    function b2ParticlePairSet() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    b2ParticlePairSet.prototype.Initialize = function (contactBuffer, flagsBuffer) {\r\n        // TODO\r\n    };\r\n    b2ParticlePairSet.prototype.Find = function (pair) {\r\n        // TODO\r\n        return b2Settings_1.b2_invalidParticleIndex;\r\n    };\r\n    return b2ParticlePairSet;\r\n}(b2ParticleSystem_FixedSetAllocator));\r\nexports.b2ParticlePairSet = b2ParticlePairSet;\r\nvar b2ParticleSystem_ConnectionFilter = /** @class */ (function () {\r\n    function b2ParticleSystem_ConnectionFilter() {\r\n    }\r\n    /**\r\n     * Is the particle necessary for connection?\r\n     * A pair or a triad should contain at least one 'necessary'\r\n     * particle.\r\n     */\r\n    b2ParticleSystem_ConnectionFilter.prototype.IsNecessary = function (index) {\r\n        return true;\r\n    };\r\n    /**\r\n     * An additional condition for creating a pair.\r\n     */\r\n    b2ParticleSystem_ConnectionFilter.prototype.ShouldCreatePair = function (a, b) {\r\n        return true;\r\n    };\r\n    /**\r\n     * An additional condition for creating a triad.\r\n     */\r\n    b2ParticleSystem_ConnectionFilter.prototype.ShouldCreateTriad = function (a, b, c) {\r\n        return true;\r\n    };\r\n    return b2ParticleSystem_ConnectionFilter;\r\n}());\r\nexports.b2ParticleSystem_ConnectionFilter = b2ParticleSystem_ConnectionFilter;\r\nvar b2ParticleSystem_DestroyParticlesInShapeCallback = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_DestroyParticlesInShapeCallback, _super);\r\n    function b2ParticleSystem_DestroyParticlesInShapeCallback(system, shape, xf, callDestructionListener) {\r\n        var _this = _super.call(this) || this;\r\n        _this.m_callDestructionListener = false;\r\n        _this.m_destroyed = 0;\r\n        _this.m_system = system;\r\n        _this.m_shape = shape;\r\n        _this.m_xf = xf;\r\n        _this.m_callDestructionListener = callDestructionListener;\r\n        _this.m_destroyed = 0;\r\n        return _this;\r\n    }\r\n    b2ParticleSystem_DestroyParticlesInShapeCallback.prototype.ReportFixture = function (fixture) {\r\n        return false;\r\n    };\r\n    b2ParticleSystem_DestroyParticlesInShapeCallback.prototype.ReportParticle = function (particleSystem, index) {\r\n        if (particleSystem !== this.m_system) {\r\n            return false;\r\n        }\r\n        // DEBUG: b2Assert(index >= 0 && index < this.m_system.m_count);\r\n        if (this.m_shape.TestPoint(this.m_xf, this.m_system.m_positionBuffer.data[index])) {\r\n            this.m_system.DestroyParticle(index, this.m_callDestructionListener);\r\n            this.m_destroyed++;\r\n        }\r\n        return true;\r\n    };\r\n    b2ParticleSystem_DestroyParticlesInShapeCallback.prototype.Destroyed = function () {\r\n        return this.m_destroyed;\r\n    };\r\n    return b2ParticleSystem_DestroyParticlesInShapeCallback;\r\n}(b2WorldCallbacks_1.b2QueryCallback));\r\nexports.b2ParticleSystem_DestroyParticlesInShapeCallback = b2ParticleSystem_DestroyParticlesInShapeCallback;\r\nvar b2ParticleSystem_JoinParticleGroupsFilter = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_JoinParticleGroupsFilter, _super);\r\n    function b2ParticleSystem_JoinParticleGroupsFilter(threshold) {\r\n        var _this = _super.call(this) || this;\r\n        _this.m_threshold = 0;\r\n        _this.m_threshold = threshold;\r\n        return _this;\r\n    }\r\n    /**\r\n     * An additional condition for creating a pair.\r\n     */\r\n    b2ParticleSystem_JoinParticleGroupsFilter.prototype.ShouldCreatePair = function (a, b) {\r\n        return (a < this.m_threshold && this.m_threshold <= b) ||\r\n            (b < this.m_threshold && this.m_threshold <= a);\r\n    };\r\n    /**\r\n     * An additional condition for creating a triad.\r\n     */\r\n    b2ParticleSystem_JoinParticleGroupsFilter.prototype.ShouldCreateTriad = function (a, b, c) {\r\n        return (a < this.m_threshold || b < this.m_threshold || c < this.m_threshold) &&\r\n            (this.m_threshold <= a || this.m_threshold <= b || this.m_threshold <= c);\r\n    };\r\n    return b2ParticleSystem_JoinParticleGroupsFilter;\r\n}(b2ParticleSystem_ConnectionFilter));\r\nexports.b2ParticleSystem_JoinParticleGroupsFilter = b2ParticleSystem_JoinParticleGroupsFilter;\r\nvar b2ParticleSystem_CompositeShape = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_CompositeShape, _super);\r\n    function b2ParticleSystem_CompositeShape(shapes, shapeCount) {\r\n        if (shapeCount === void 0) { shapeCount = shapes.length; }\r\n        var _this = _super.call(this, b2Shape_1.b2ShapeType.e_unknown, 0) || this;\r\n        _this.m_shapeCount = 0;\r\n        _this.m_shapes = shapes;\r\n        _this.m_shapeCount = shapeCount;\r\n        return _this;\r\n    }\r\n    b2ParticleSystem_CompositeShape.prototype.Clone = function () {\r\n        // DEBUG: b2Assert(false);\r\n        throw new Error();\r\n    };\r\n    b2ParticleSystem_CompositeShape.prototype.GetChildCount = function () {\r\n        return 1;\r\n    };\r\n    /**\r\n     * @see b2Shape::TestPoint\r\n     */\r\n    b2ParticleSystem_CompositeShape.prototype.TestPoint = function (xf, p) {\r\n        for (var i = 0; i < this.m_shapeCount; i++) {\r\n            if (this.m_shapes[i].TestPoint(xf, p)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @see b2Shape::ComputeDistance\r\n     */\r\n    b2ParticleSystem_CompositeShape.prototype.ComputeDistance = function (xf, p, normal, childIndex) {\r\n        // DEBUG: b2Assert(false);\r\n        return 0;\r\n    };\r\n    /**\r\n     * Implement b2Shape.\r\n     */\r\n    b2ParticleSystem_CompositeShape.prototype.RayCast = function (output, input, xf, childIndex) {\r\n        // DEBUG: b2Assert(false);\r\n        return false;\r\n    };\r\n    /**\r\n     * @see b2Shape::ComputeAABB\r\n     */\r\n    b2ParticleSystem_CompositeShape.prototype.ComputeAABB = function (aabb, xf, childIndex) {\r\n        var s_subaabb = new b2Collision_1.b2AABB();\r\n        aabb.lowerBound.x = +b2Settings_1.b2_maxFloat;\r\n        aabb.lowerBound.y = +b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.x = -b2Settings_1.b2_maxFloat;\r\n        aabb.upperBound.y = -b2Settings_1.b2_maxFloat;\r\n        // DEBUG: b2Assert(childIndex === 0);\r\n        for (var i = 0; i < this.m_shapeCount; i++) {\r\n            var childCount = this.m_shapes[i].GetChildCount();\r\n            for (var j = 0; j < childCount; j++) {\r\n                var subaabb = s_subaabb;\r\n                this.m_shapes[i].ComputeAABB(subaabb, xf, j);\r\n                aabb.Combine1(subaabb);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * @see b2Shape::ComputeMass\r\n     */\r\n    b2ParticleSystem_CompositeShape.prototype.ComputeMass = function (massData, density) {\r\n        // DEBUG: b2Assert(false);\r\n    };\r\n    b2ParticleSystem_CompositeShape.prototype.SetupDistanceProxy = function (proxy, index) {\r\n        // DEBUG: b2Assert(false);\r\n    };\r\n    b2ParticleSystem_CompositeShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {\r\n        // DEBUG: b2Assert(false);\r\n        return 0;\r\n    };\r\n    b2ParticleSystem_CompositeShape.prototype.Dump = function (log) {\r\n        // DEBUG: b2Assert(false);\r\n    };\r\n    return b2ParticleSystem_CompositeShape;\r\n}(b2Shape_1.b2Shape));\r\nexports.b2ParticleSystem_CompositeShape = b2ParticleSystem_CompositeShape;\r\nvar b2ParticleSystem_ReactiveFilter = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_ReactiveFilter, _super);\r\n    function b2ParticleSystem_ReactiveFilter(flagsBuffer) {\r\n        var _this = _super.call(this) || this;\r\n        _this.m_flagsBuffer = flagsBuffer;\r\n        return _this;\r\n    }\r\n    b2ParticleSystem_ReactiveFilter.prototype.IsNecessary = function (index) {\r\n        return (this.m_flagsBuffer.data[index] & b2Particle_1.b2ParticleFlag.b2_reactiveParticle) !== 0;\r\n    };\r\n    return b2ParticleSystem_ReactiveFilter;\r\n}(b2ParticleSystem_ConnectionFilter));\r\nexports.b2ParticleSystem_ReactiveFilter = b2ParticleSystem_ReactiveFilter;\r\nvar b2ParticleSystem_UpdateBodyContactsCallback = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_UpdateBodyContactsCallback, _super);\r\n    function b2ParticleSystem_UpdateBodyContactsCallback(system, contactFilter) {\r\n        if (contactFilter === void 0) { contactFilter = null; }\r\n        var _this = _super.call(this, system) || this;\r\n        _this.m_contactFilter = null;\r\n        _this.m_contactFilter = contactFilter;\r\n        return _this;\r\n    }\r\n    b2ParticleSystem_UpdateBodyContactsCallback.prototype.ShouldCollideFixtureParticle = function (fixture, particleSystem, particleIndex) {\r\n        // Call the contact filter if it's set, to determine whether to\r\n        // filter this contact.  Returns true if contact calculations should\r\n        // be performed, false otherwise.\r\n        if (this.m_contactFilter) {\r\n            var flags = this.m_system.GetFlagsBuffer();\r\n            if (flags[particleIndex] & b2Particle_1.b2ParticleFlag.b2_fixtureContactFilterParticle) {\r\n                return this.m_contactFilter.ShouldCollideFixtureParticle(fixture, this.m_system, particleIndex);\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    b2ParticleSystem_UpdateBodyContactsCallback.prototype.ReportFixtureAndParticle = function (fixture, childIndex, a) {\r\n        var s_n = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n;\r\n        var s_rp = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp;\r\n        var ap = this.m_system.m_positionBuffer.data[a];\r\n        var n = s_n;\r\n        var d = fixture.ComputeDistance(ap, n, childIndex);\r\n        if (d < this.m_system.m_particleDiameter && this.ShouldCollideFixtureParticle(fixture, this.m_system, a)) {\r\n            var b = fixture.GetBody();\r\n            var bp = b.GetWorldCenter();\r\n            var bm = b.GetMass();\r\n            var bI = b.GetInertia() - bm * b.GetLocalCenter().LengthSquared();\r\n            var invBm = bm > 0 ? 1 / bm : 0;\r\n            var invBI = bI > 0 ? 1 / bI : 0;\r\n            var invAm = this.m_system.m_flagsBuffer.data[a] &\r\n                b2Particle_1.b2ParticleFlag.b2_wallParticle ? 0 : this.m_system.GetParticleInvMass();\r\n            ///b2Vec2 rp = ap - bp;\r\n            var rp = b2Math_1.b2Vec2.SubVV(ap, bp, s_rp);\r\n            var rpn = b2Math_1.b2Vec2.CrossVV(rp, n);\r\n            var invM = invAm + invBm + invBI * rpn * rpn;\r\n            ///b2ParticleBodyContact& contact = m_system.m_bodyContactBuffer.Append();\r\n            var contact = this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];\r\n            contact.index = a;\r\n            contact.body = b;\r\n            contact.fixture = fixture;\r\n            contact.weight = 1 - d * this.m_system.m_inverseDiameter;\r\n            ///contact.normal = -n;\r\n            contact.normal.Copy(n.SelfNeg());\r\n            contact.mass = invM > 0 ? 1 / invM : 0;\r\n            this.m_system.DetectStuckParticle(a);\r\n        }\r\n    };\r\n    b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp = new b2Math_1.b2Vec2();\r\n    return b2ParticleSystem_UpdateBodyContactsCallback;\r\n}(b2FixtureParticleQueryCallback));\r\nexports.b2ParticleSystem_UpdateBodyContactsCallback = b2ParticleSystem_UpdateBodyContactsCallback;\r\nvar b2ParticleSystem_SolveCollisionCallback = /** @class */ (function (_super) {\r\n    __extends(b2ParticleSystem_SolveCollisionCallback, _super);\r\n    function b2ParticleSystem_SolveCollisionCallback(system, step) {\r\n        var _this = _super.call(this, system) || this;\r\n        _this.m_step = step;\r\n        return _this;\r\n    }\r\n    b2ParticleSystem_SolveCollisionCallback.prototype.ReportFixtureAndParticle = function (fixture, childIndex, a) {\r\n        var s_p1 = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1;\r\n        var s_output = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output;\r\n        var s_input = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input;\r\n        var s_p = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p;\r\n        var s_v = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v;\r\n        var s_f = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f;\r\n        var body = fixture.GetBody();\r\n        var ap = this.m_system.m_positionBuffer.data[a];\r\n        var av = this.m_system.m_velocityBuffer.data[a];\r\n        var output = s_output;\r\n        var input = s_input;\r\n        if (this.m_system.m_iterationIndex === 0) {\r\n            // Put 'ap' in the local space of the previous frame\r\n            ///b2Vec2 p1 = b2MulT(body.m_xf0, ap);\r\n            var p1 = b2Math_1.b2Transform.MulTXV(body.m_xf0, ap, s_p1);\r\n            if (fixture.GetShape().GetType() === b2Shape_1.b2ShapeType.e_circleShape) {\r\n                // Make relative to the center of the circle\r\n                ///p1 -= body.GetLocalCenter();\r\n                p1.SelfSub(body.GetLocalCenter());\r\n                // Re-apply rotation about the center of the circle\r\n                ///p1 = b2Mul(body.m_xf0.q, p1);\r\n                b2Math_1.b2Rot.MulRV(body.m_xf0.q, p1, p1);\r\n                // Subtract rotation of the current frame\r\n                ///p1 = b2MulT(body.m_xf.q, p1);\r\n                b2Math_1.b2Rot.MulTRV(body.m_xf.q, p1, p1);\r\n                // Return to local space\r\n                ///p1 += body.GetLocalCenter();\r\n                p1.SelfAdd(body.GetLocalCenter());\r\n            }\r\n            // Return to global space and apply rotation of current frame\r\n            ///input.p1 = b2Mul(body.m_xf, p1);\r\n            b2Math_1.b2Transform.MulXV(body.m_xf, p1, input.p1);\r\n        }\r\n        else {\r\n            ///input.p1 = ap;\r\n            input.p1.Copy(ap);\r\n        }\r\n        ///input.p2 = ap + m_step.dt * av;\r\n        b2Math_1.b2Vec2.AddVMulSV(ap, this.m_step.dt, av, input.p2);\r\n        input.maxFraction = 1;\r\n        if (fixture.RayCast(output, input, childIndex)) {\r\n            var n = output.normal;\r\n            ///b2Vec2 p = (1 - output.fraction) * input.p1 + output.fraction * input.p2 + b2_linearSlop * n;\r\n            var p = s_p;\r\n            p.x = (1 - output.fraction) * input.p1.x + output.fraction * input.p2.x + b2Settings_1.b2_linearSlop * n.x;\r\n            p.y = (1 - output.fraction) * input.p1.y + output.fraction * input.p2.y + b2Settings_1.b2_linearSlop * n.y;\r\n            ///b2Vec2 v = m_step.inv_dt * (p - ap);\r\n            var v = s_v;\r\n            v.x = this.m_step.inv_dt * (p.x - ap.x);\r\n            v.y = this.m_step.inv_dt * (p.y - ap.y);\r\n            ///m_system.m_velocityBuffer.data[a] = v;\r\n            this.m_system.m_velocityBuffer.data[a].Copy(v);\r\n            ///b2Vec2 f = m_step.inv_dt * m_system.GetParticleMass() * (av - v);\r\n            var f = s_f;\r\n            f.x = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.x - v.x);\r\n            f.y = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.y - v.y);\r\n            this.m_system.ParticleApplyForce(a, f);\r\n        }\r\n    };\r\n    b2ParticleSystem_SolveCollisionCallback.prototype.ReportParticle = function (system, index) {\r\n        return false;\r\n    };\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1 = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output = new b2Collision_1.b2RayCastOutput();\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input = new b2Collision_1.b2RayCastInput();\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v = new b2Math_1.b2Vec2();\r\n    b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f = new b2Math_1.b2Vec2();\r\n    return b2ParticleSystem_SolveCollisionCallback;\r\n}(b2FixtureParticleQueryCallback));\r\nexports.b2ParticleSystem_SolveCollisionCallback = b2ParticleSystem_SolveCollisionCallback;\r\n// #endif\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2ParticleSystem.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Particle/b2ParticleSystem.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2013 Google, Inc.\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\n// #if B2_ENABLE_PARTICLE\r\n\r\n// DEBUG: import { b2Assert, b2_maxParticleIndex } from \"../Common/b2Settings\";\r\nimport { b2_linearSlop, b2_maxFloat, b2_invalidParticleIndex, b2_minParticleSystemBufferCapacity, b2_maxTriadDistanceSquared, b2_barrierCollisionTime, b2MakeArray, b2Maybe } from \"../Common/b2Settings\";\r\nimport { b2_maxParticlePressure, b2_minParticleWeight, b2_maxParticleForce, b2_particleStride } from \"../Common/b2Settings\";\r\nimport { b2Min, b2Max, b2Abs, b2Clamp, b2Sqrt, b2InvSqrt, b2Vec2, b2Rot, b2Transform, XY } from \"../Common/b2Math\";\r\nimport { b2Color } from \"../Common/b2Draw\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../Collision/b2Collision\";\r\nimport { b2ShapeType, b2Shape, b2MassData } from \"../Collision/Shapes/b2Shape\";\r\nimport { b2EdgeShape } from \"../Collision/Shapes/b2EdgeShape\";\r\nimport { b2ChainShape } from \"../Collision/Shapes/b2ChainShape\";\r\nimport { b2TimeStep } from \"../Dynamics/b2TimeStep\";\r\nimport { b2Fixture } from \"../Dynamics/b2Fixture\";\r\nimport { b2Body } from \"../Dynamics/b2Body\";\r\nimport { b2World } from \"../Dynamics/b2World\";\r\nimport { b2ContactFilter, b2ContactListener, b2QueryCallback, b2RayCastCallback } from \"../Dynamics/b2WorldCallbacks\";\r\nimport { b2ParticleFlag, b2ParticleDef, b2ParticleHandle, b2IParticleDef } from \"./b2Particle\";\r\nimport { b2ParticleGroupFlag, b2ParticleGroupDef, b2ParticleGroup, b2IParticleGroupDef } from \"./b2ParticleGroup\";\r\nimport { b2VoronoiDiagram } from \"./b2VoronoiDiagram\";\r\nimport { b2DistanceProxy } from \"../Collision/b2Distance\";\r\n\r\nfunction std_iter_swap<T>(array: T[], a: number, b: number): void {\r\n  const tmp: T = array[a];\r\n  array[a] = array[b];\r\n  array[b] = tmp;\r\n}\r\n\r\nfunction default_compare<T>(a: T, b: T): boolean { return a < b; }\r\n\r\nfunction std_sort<T>(array: T[], first: number = 0, len: number = array.length - first, cmp: (a: T, b: T) => boolean = default_compare): T[] {\r\n  let left = first;\r\n  const stack: number[] = [];\r\n  let pos = 0;\r\n\r\n  for (; ; ) { /* outer loop */\r\n    for (; left + 1 < len; len++) { /* sort left to len-1 */\r\n      const pivot = array[left + Math.floor(Math.random() * (len - left))]; /* pick random pivot */\r\n      stack[pos++] = len; /* sort right part later */\r\n      for (let right = left - 1; ; ) { /* inner loop: partitioning */\r\n        while (cmp(array[++right], pivot)) {} /* look for greater element */\r\n        while (cmp(pivot, array[--len])) {} /* look for smaller element */\r\n        if (right >= len) {\r\n          break;\r\n        } /* partition point found? */\r\n        std_iter_swap(array, right, len); /* the only swap */\r\n      } /* partitioned, continue left part */\r\n    }\r\n    if (pos === 0) {\r\n      break;\r\n    } /* stack empty? */\r\n    left = len; /* left to right is sorted */\r\n    len = stack[--pos]; /* get next range to sort */\r\n  }\r\n\r\n  return array;\r\n}\r\n\r\nfunction std_stable_sort<T>(array: T[], first: number = 0, len: number = array.length - first, cmp: (a: T, b: T) => boolean = default_compare): T[] {\r\n  return std_sort(array, first, len, cmp);\r\n}\r\n\r\nfunction std_remove_if<T>(array: T[], predicate: (value: T) => boolean, length: number = array.length) {\r\n  let l = 0;\r\n\r\n  for (let c = 0; c < length; ++c) {\r\n    // if we can be collapsed, keep l where it is.\r\n    if (predicate(array[c])) {\r\n      continue;\r\n    }\r\n\r\n    // this node can't be collapsed; push it back as far as we can.\r\n    if (c === l) {\r\n      ++l;\r\n      continue; // quick exit if we're already in the right spot\r\n    }\r\n\r\n    // array[l++] = array[c];\r\n    std_iter_swap(array, l++, c);\r\n  }\r\n\r\n  return l;\r\n}\r\n\r\nfunction std_lower_bound<A, B>(array: A[], first: number, last: number, val: B, cmp: (a: A, b: B) => boolean): number {\r\n  let count = last - first;\r\n  while (count > 0) {\r\n    const step = Math.floor(count / 2);\r\n    let it = first + step;\r\n\r\n    if (cmp(array[it], val)) {\r\n      first = ++it;\r\n      count -= step + 1;\r\n    } else {\r\n      count = step;\r\n    }\r\n  }\r\n  return first;\r\n}\r\n\r\nfunction std_upper_bound<A, B>(array: B[], first: number, last: number, val: A, cmp: (a: A, b: B) => boolean): number {\r\n  let count = last - first;\r\n  while (count > 0) {\r\n    const step = Math.floor(count / 2);\r\n    let it = first + step;\r\n\r\n    if (!cmp(val, array[it])) {\r\n      first = ++it;\r\n      count -= step + 1;\r\n    } else {\r\n      count = step;\r\n    }\r\n  }\r\n  return first;\r\n}\r\n\r\nfunction std_rotate<T>(array: T[], first: number, n_first: number, last: number): void {\r\n  let next = n_first;\r\n  while (first !== next) {\r\n    std_iter_swap(array, first++, next++);\r\n    if (next === last) {\r\n      next = n_first;\r\n    } else if (first === n_first) {\r\n      n_first = next;\r\n         }\r\n  }\r\n}\r\n\r\nfunction std_unique<T>(array: T[], first: number, last: number, cmp: (a: T, b: T) => boolean): number {\r\n  if (first === last) {\r\n    return last;\r\n  }\r\n  let result = first;\r\n  while (++first !== last) {\r\n    if (!cmp(array[result], array[first])) {\r\n      ///array[++result] = array[first];\r\n      std_iter_swap(array, ++result, first);\r\n    }\r\n  }\r\n  return ++result;\r\n}\r\n\r\nexport class b2GrowableBuffer<T> {\r\n  public data: T[] = [];\r\n  public count: number = 0;\r\n  public capacity: number = 0;\r\n  public allocator: () => T;\r\n\r\n  constructor(allocator: () => T) {\r\n    this.allocator = allocator;\r\n  }\r\n\r\n  public Append(): number {\r\n    if (this.count >= this.capacity) {\r\n      this.Grow();\r\n    }\r\n    return this.count++;\r\n  }\r\n\r\n  public Reserve(newCapacity: number): void {\r\n    if (this.capacity >= newCapacity) {\r\n      return;\r\n    }\r\n\r\n    // DEBUG: b2Assert(this.capacity === this.data.length);\r\n    for (let i = this.capacity; i < newCapacity; ++i) {\r\n      this.data[i] = this.allocator();\r\n    }\r\n    this.capacity = newCapacity;\r\n  }\r\n\r\n  public Grow(): void {\r\n    // Double the capacity.\r\n    const newCapacity = this.capacity ? 2 * this.capacity : b2_minParticleSystemBufferCapacity;\r\n    // DEBUG: b2Assert(newCapacity > this.capacity);\r\n    this.Reserve(newCapacity);\r\n  }\r\n\r\n  public Free(): void {\r\n    if (this.data.length === 0) {\r\n      return;\r\n    }\r\n\r\n    this.data = [];\r\n    this.capacity = 0;\r\n    this.count = 0;\r\n  }\r\n\r\n  public Shorten(newEnd: number): void {\r\n    // DEBUG: b2Assert(false);\r\n  }\r\n\r\n  public Data(): T[] {\r\n    return this.data;\r\n  }\r\n\r\n  public GetCount(): number {\r\n    return this.count;\r\n  }\r\n\r\n  public SetCount(newCount: number): void {\r\n    // DEBUG: b2Assert(0 <= newCount && newCount <= this.capacity);\r\n    this.count = newCount;\r\n  }\r\n\r\n  public GetCapacity(): number {\r\n    return this.capacity;\r\n  }\r\n\r\n  public RemoveIf(pred: (t: T) => boolean): void {\r\n    // DEBUG: let count = 0;\r\n    // DEBUG: for (let i = 0; i < this.count; ++i) {\r\n    // DEBUG:   if (!pred(this.data[i])) {\r\n    // DEBUG:     count++;\r\n    // DEBUG:   }\r\n    // DEBUG: }\r\n\r\n    this.count = std_remove_if(this.data, pred, this.count);\r\n\r\n    // DEBUG: b2Assert(count === this.count);\r\n  }\r\n\r\n  public Unique(pred: (a: T, b: T) => boolean): void {\r\n    this.count = std_unique(this.data, 0, this.count, pred);\r\n  }\r\n}\r\n\r\nexport type b2ParticleIndex = number;\r\n\r\nexport class b2FixtureParticleQueryCallback extends b2QueryCallback {\r\n  public m_system: b2ParticleSystem;\r\n  constructor(system: b2ParticleSystem) {\r\n    super();\r\n    this.m_system = system;\r\n  }\r\n  public ShouldQueryParticleSystem(system: b2ParticleSystem): boolean {\r\n    // Skip reporting particles.\r\n    return false;\r\n  }\r\n  public ReportFixture(fixture: b2Fixture): boolean {\r\n    if (fixture.IsSensor()) {\r\n      return true;\r\n    }\r\n    const shape = fixture.GetShape();\r\n    const childCount = shape.GetChildCount();\r\n    for (let childIndex = 0; childIndex < childCount; childIndex++) {\r\n      const aabb = fixture.GetAABB(childIndex);\r\n      const enumerator = this.m_system.GetInsideBoundsEnumerator(aabb);\r\n      let index: number;\r\n      while ((index = enumerator.GetNext()) >= 0) {\r\n        this.ReportFixtureAndParticle(fixture, childIndex, index);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  public ReportParticle(system: b2ParticleSystem, index: number): boolean {\r\n    return false;\r\n  }\r\n  public ReportFixtureAndParticle(fixture: b2Fixture, childIndex: number, index: number): void {\r\n    // DEBUG: b2Assert(false); // pure virtual\r\n  }\r\n}\r\n\r\nexport class b2ParticleContact {\r\n  public indexA: number = 0;\r\n  public indexB: number = 0;\r\n  public weight: number = 0;\r\n  public normal: b2Vec2 = new b2Vec2();\r\n  public flags: b2ParticleFlag = 0;\r\n\r\n  public SetIndices(a: number, b: number): void {\r\n    // DEBUG: b2Assert(a <= b2_maxParticleIndex && b <= b2_maxParticleIndex);\r\n    this.indexA = a;\r\n    this.indexB = b;\r\n  }\r\n\r\n  public SetWeight(w: number): void {\r\n    this.weight = w;\r\n  }\r\n\r\n  public SetNormal(n: b2Vec2): void {\r\n    this.normal.Copy(n);\r\n  }\r\n\r\n  public SetFlags(f: b2ParticleFlag): void {\r\n    this.flags = f;\r\n  }\r\n\r\n  public GetIndexA(): number {\r\n    return this.indexA;\r\n  }\r\n\r\n  public GetIndexB(): number {\r\n    return this.indexB;\r\n  }\r\n\r\n  public GetWeight(): number {\r\n    return this.weight;\r\n  }\r\n\r\n  public GetNormal(): b2Vec2 {\r\n    return this.normal;\r\n  }\r\n\r\n  public GetFlags(): b2ParticleFlag {\r\n    return this.flags;\r\n  }\r\n\r\n  public IsEqual(rhs: b2ParticleContact): boolean {\r\n    return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && this.weight === rhs.weight && this.normal.x === rhs.normal.x && this.normal.y === rhs.normal.y;\r\n  }\r\n\r\n  public IsNotEqual(rhs: b2ParticleContact): boolean {\r\n    return !this.IsEqual(rhs);\r\n  }\r\n\r\n  public ApproximatelyEqual(rhs: b2ParticleContact): boolean {\r\n    const MAX_WEIGHT_DIFF = 0.01; // Weight 0 ~ 1, so about 1%\r\n    const MAX_NORMAL_DIFF_SQ = 0.01 * 0.01; // Normal length = 1, so 1%\r\n    return this.indexA === rhs.indexA && this.indexB === rhs.indexB && this.flags === rhs.flags && b2Abs(this.weight - rhs.weight) < MAX_WEIGHT_DIFF && b2Vec2.DistanceSquaredVV(this.normal, rhs.normal) < MAX_NORMAL_DIFF_SQ;\r\n  }\r\n}\r\n\r\nexport class b2ParticleBodyContact {\r\n  public index: number = 0; // Index of the particle making contact.\r\n  public body!: b2Body; // The body making contact.\r\n  public fixture!: b2Fixture; // The specific fixture making contact\r\n  public weight: number = 0.0; // Weight of the contact. A value between 0.0f and 1.0f.\r\n  public normal: b2Vec2 = new b2Vec2(); // The normalized direction from the particle to the body.\r\n  public mass: number = 0.0; // The effective mass used in calculating force.\r\n}\r\n\r\nexport class b2ParticlePair {\r\n  public indexA: number = 0; // Indices of the respective particles making pair.\r\n  public indexB: number = 0;\r\n  public flags: b2ParticleFlag = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.\r\n  public strength: number = 0.0; // The strength of cohesion among the particles.\r\n  public distance: number = 0.0; // The initial distance of the particles.\r\n}\r\n\r\nexport class b2ParticleTriad {\r\n  public indexA: number = 0; // Indices of the respective particles making triad.\r\n  public indexB: number = 0;\r\n  public indexC: number = 0;\r\n  public flags: b2ParticleFlag = 0; // The logical sum of the particle flags. See the b2ParticleFlag enum.\r\n  public strength: number = 0.0; // The strength of cohesion among the particles.\r\n  public pa: b2Vec2 = new b2Vec2(0.0, 0.0); // Values used for calculation.\r\n  public pb: b2Vec2 = new b2Vec2(0.0, 0.0);\r\n  public pc: b2Vec2 = new b2Vec2(0.0, 0.0);\r\n  public ka: number = 0.0;\r\n  public kb: number = 0.0;\r\n  public kc: number = 0.0;\r\n  public s: number = 0.0;\r\n}\r\n\r\nexport class b2ParticleSystemDef {\r\n  // Initialize physical coefficients to the maximum values that\r\n  // maintain numerical stability.\r\n\r\n  /**\r\n   * Enable strict Particle/Body contact check.\r\n   * See SetStrictContactCheck for details.\r\n   */\r\n  public strictContactCheck: boolean = false;\r\n\r\n  /**\r\n   * Set the particle density.\r\n   * See SetDensity for details.\r\n   */\r\n  public density: number = 1.0;\r\n\r\n  /**\r\n   * Change the particle gravity scale. Adjusts the effect of the\r\n   * global gravity vector on particles. Default value is 1.0f.\r\n   */\r\n  public gravityScale: number = 1.0;\r\n\r\n  /**\r\n   * Particles behave as circles with this radius. In Box2D units.\r\n   */\r\n  public radius: number = 1.0;\r\n\r\n  /**\r\n   * Set the maximum number of particles.\r\n   * By default, there is no maximum. The particle buffers can\r\n   * continue to grow while b2World's block allocator still has\r\n   * memory.\r\n   * See SetMaxParticleCount for details.\r\n   */\r\n  public maxCount: number = 0;\r\n\r\n  /**\r\n   * Increases pressure in response to compression\r\n   * Smaller values allow more compression\r\n   */\r\n  public pressureStrength: number = 0.005;\r\n\r\n  /**\r\n   * Reduces velocity along the collision normal\r\n   * Smaller value reduces less\r\n   */\r\n  public dampingStrength: number = 1.0;\r\n\r\n  /**\r\n   * Restores shape of elastic particle groups\r\n   * Larger values increase elastic particle velocity\r\n   */\r\n  public elasticStrength: number = 0.25;\r\n\r\n  /**\r\n   * Restores length of spring particle groups\r\n   * Larger values increase spring particle velocity\r\n   */\r\n  public springStrength: number = 0.25;\r\n\r\n  /**\r\n   * Reduces relative velocity of viscous particles\r\n   * Larger values slow down viscous particles more\r\n   */\r\n  public viscousStrength: number = 0.25;\r\n\r\n  /**\r\n   * Produces pressure on tensile particles\r\n   * 0~0.2. Larger values increase the amount of surface tension.\r\n   */\r\n  public surfaceTensionPressureStrength: number = 0.2;\r\n\r\n  /**\r\n   * Smoothes outline of tensile particles\r\n   * 0~0.2. Larger values result in rounder, smoother,\r\n   * water-drop-like clusters of particles.\r\n   */\r\n  public surfaceTensionNormalStrength: number = 0.2;\r\n\r\n  /**\r\n   * Produces additional pressure on repulsive particles\r\n   * Larger values repulse more\r\n   * Negative values mean attraction. The range where particles\r\n   * behave stably is about -0.2 to 2.0.\r\n   */\r\n  public repulsiveStrength: number = 1.0;\r\n\r\n  /**\r\n   * Produces repulsion between powder particles\r\n   * Larger values repulse more\r\n   */\r\n  public powderStrength: number = 0.5;\r\n\r\n  /**\r\n   * Pushes particles out of solid particle group\r\n   * Larger values repulse more\r\n   */\r\n  public ejectionStrength: number = 0.5;\r\n\r\n  /**\r\n   * Produces static pressure\r\n   * Larger values increase the pressure on neighboring partilces\r\n   * For a description of static pressure, see\r\n   * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics\r\n   */\r\n  public staticPressureStrength: number = 0.2;\r\n\r\n  /**\r\n   * Reduces instability in static pressure calculation\r\n   * Larger values make stabilize static pressure with fewer\r\n   * iterations\r\n   */\r\n  public staticPressureRelaxation: number = 0.2;\r\n\r\n  /**\r\n   * Computes static pressure more precisely\r\n   * See SetStaticPressureIterations for details\r\n   */\r\n  public staticPressureIterations: number = 8;\r\n\r\n  /**\r\n   * Determines how fast colors are mixed\r\n   * 1.0f ==> mixed immediately\r\n   * 0.5f ==> mixed half way each simulation step (see\r\n   * b2World::Step())\r\n   */\r\n  public colorMixingStrength: number = 0.5;\r\n\r\n  /**\r\n   * Whether to destroy particles by age when no more particles\r\n   * can be created.  See #b2ParticleSystem::SetDestructionByAge()\r\n   * for more information.\r\n   */\r\n  public destroyByAge: boolean = true;\r\n\r\n  /**\r\n   * Granularity of particle lifetimes in seconds.  By default\r\n   * this is set to (1.0f / 60.0f) seconds.  b2ParticleSystem uses\r\n   * a 32-bit signed value to track particle lifetimes so the\r\n   * maximum lifetime of a particle is (2^32 - 1) / (1.0f /\r\n   * lifetimeGranularity) seconds. With the value set to 1/60 the\r\n   * maximum lifetime or age of a particle is 2.27 years.\r\n   */\r\n  public lifetimeGranularity: number = 1.0 / 60.0;\r\n\r\n  public Copy(def: b2ParticleSystemDef): b2ParticleSystemDef {\r\n    this.strictContactCheck = def.strictContactCheck;\r\n    this.density = def.density;\r\n    this.gravityScale = def.gravityScale;\r\n    this.radius = def.radius;\r\n    this.maxCount = def.maxCount;\r\n    this.pressureStrength = def.pressureStrength;\r\n    this.dampingStrength = def.dampingStrength;\r\n    this.elasticStrength = def.elasticStrength;\r\n    this.springStrength = def.springStrength;\r\n    this.viscousStrength = def.viscousStrength;\r\n    this.surfaceTensionPressureStrength = def.surfaceTensionPressureStrength;\r\n    this.surfaceTensionNormalStrength = def.surfaceTensionNormalStrength;\r\n    this.repulsiveStrength = def.repulsiveStrength;\r\n    this.powderStrength = def.powderStrength;\r\n    this.ejectionStrength = def.ejectionStrength;\r\n    this.staticPressureStrength = def.staticPressureStrength;\r\n    this.staticPressureRelaxation = def.staticPressureRelaxation;\r\n    this.staticPressureIterations = def.staticPressureIterations;\r\n    this.colorMixingStrength = def.colorMixingStrength;\r\n    this.destroyByAge = def.destroyByAge;\r\n    this.lifetimeGranularity = def.lifetimeGranularity;\r\n    return this;\r\n  }\r\n\r\n  public Clone(): b2ParticleSystemDef {\r\n    return new b2ParticleSystemDef().Copy(this);\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem {\r\n  public m_paused: boolean = false;\r\n  public m_timestamp: number = 0;\r\n  public m_allParticleFlags: b2ParticleFlag = 0;\r\n  public m_needsUpdateAllParticleFlags: boolean = false;\r\n  public m_allGroupFlags: b2ParticleGroupFlag = 0;\r\n  public m_needsUpdateAllGroupFlags: boolean = false;\r\n  public m_hasForce: boolean = false;\r\n  public m_iterationIndex: number = 0;\r\n  public m_inverseDensity: number = 0.0;\r\n  public m_particleDiameter: number = 0.0;\r\n  public m_inverseDiameter: number = 0.0;\r\n  public m_squaredDiameter: number = 0.0;\r\n  public m_count: number = 0;\r\n  public m_internalAllocatedCapacity: number = 0;\r\n  /**\r\n   * Allocator for b2ParticleHandle instances.\r\n   */\r\n  ///m_handleAllocator: any = null;\r\n  /**\r\n   * Maps particle indicies to handles.\r\n   */\r\n  public m_handleIndexBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleHandle | null> = new b2ParticleSystem_UserOverridableBuffer<b2ParticleHandle | null>();\r\n  public m_flagsBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag> = new b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag>();\r\n  public m_positionBuffer: b2ParticleSystem_UserOverridableBuffer<b2Vec2> = new b2ParticleSystem_UserOverridableBuffer<b2Vec2>();\r\n  public m_velocityBuffer: b2ParticleSystem_UserOverridableBuffer<b2Vec2> = new b2ParticleSystem_UserOverridableBuffer<b2Vec2>();\r\n  public m_forceBuffer: b2Vec2[] = [];\r\n  /**\r\n   * this.m_weightBuffer is populated in ComputeWeight and used in\r\n   * ComputeDepth(), SolveStaticPressure() and SolvePressure().\r\n   */\r\n  public m_weightBuffer: number[] = [];\r\n  /**\r\n   * When any particles have the flag b2_staticPressureParticle,\r\n   * this.m_staticPressureBuffer is first allocated and used in\r\n   * SolveStaticPressure() and SolvePressure().  It will be\r\n   * reallocated on subsequent CreateParticle() calls.\r\n   */\r\n  public m_staticPressureBuffer: number[] = [];\r\n  /**\r\n   * this.m_accumulationBuffer is used in many functions as a temporary\r\n   * buffer for scalar values.\r\n   */\r\n  public m_accumulationBuffer: number[] = [];\r\n  /**\r\n   * When any particles have the flag b2_tensileParticle,\r\n   * this.m_accumulation2Buffer is first allocated and used in\r\n   * SolveTensile() as a temporary buffer for vector values.  It\r\n   * will be reallocated on subsequent CreateParticle() calls.\r\n   */\r\n  public m_accumulation2Buffer: b2Vec2[] = [];\r\n  /**\r\n   * When any particle groups have the flag b2_solidParticleGroup,\r\n   * this.m_depthBuffer is first allocated and populated in\r\n   * ComputeDepth() and used in SolveSolid(). It will be\r\n   * reallocated on subsequent CreateParticle() calls.\r\n   */\r\n  public m_depthBuffer: number[] = [];\r\n  public m_colorBuffer: b2ParticleSystem_UserOverridableBuffer<b2Color> = new b2ParticleSystem_UserOverridableBuffer<b2Color>();\r\n  public m_groupBuffer: Array<b2ParticleGroup | null> = [];\r\n  public m_userDataBuffer: b2ParticleSystem_UserOverridableBuffer<any> = new b2ParticleSystem_UserOverridableBuffer();\r\n  /**\r\n   * Stuck particle detection parameters and record keeping\r\n   */\r\n  public m_stuckThreshold: number = 0;\r\n  public m_lastBodyContactStepBuffer: b2ParticleSystem_UserOverridableBuffer<number> = new b2ParticleSystem_UserOverridableBuffer<number>();\r\n  public m_bodyContactCountBuffer: b2ParticleSystem_UserOverridableBuffer<number> = new b2ParticleSystem_UserOverridableBuffer<number>();\r\n  public m_consecutiveContactStepsBuffer: b2ParticleSystem_UserOverridableBuffer<number> = new b2ParticleSystem_UserOverridableBuffer<number>();\r\n  public m_stuckParticleBuffer: b2GrowableBuffer<number> = new b2GrowableBuffer<number>(() => 0);\r\n  public m_proxyBuffer: b2GrowableBuffer<b2ParticleSystem_Proxy> = new b2GrowableBuffer<b2ParticleSystem_Proxy>(() => new b2ParticleSystem_Proxy());\r\n  public m_contactBuffer: b2GrowableBuffer<b2ParticleContact> = new b2GrowableBuffer<b2ParticleContact>(() => new b2ParticleContact());\r\n  public m_bodyContactBuffer: b2GrowableBuffer<b2ParticleBodyContact> = new b2GrowableBuffer<b2ParticleBodyContact>(() => new b2ParticleBodyContact());\r\n  public m_pairBuffer: b2GrowableBuffer<b2ParticlePair> = new b2GrowableBuffer<b2ParticlePair>(() => new b2ParticlePair());\r\n  public m_triadBuffer: b2GrowableBuffer<b2ParticleTriad> = new b2GrowableBuffer<b2ParticleTriad>(() => new b2ParticleTriad());\r\n  /**\r\n   * Time each particle should be destroyed relative to the last\r\n   * time this.m_timeElapsed was initialized.  Each unit of time\r\n   * corresponds to b2ParticleSystemDef::lifetimeGranularity\r\n   * seconds.\r\n   */\r\n  public m_expirationTimeBuffer: b2ParticleSystem_UserOverridableBuffer<number> = new b2ParticleSystem_UserOverridableBuffer<number>();\r\n  /**\r\n   * List of particle indices sorted by expiration time.\r\n   */\r\n  public m_indexByExpirationTimeBuffer: b2ParticleSystem_UserOverridableBuffer<number> = new b2ParticleSystem_UserOverridableBuffer<number>();\r\n  /**\r\n   * Time elapsed in 32:32 fixed point.  Each non-fractional unit\r\n   * of time corresponds to\r\n   * b2ParticleSystemDef::lifetimeGranularity seconds.\r\n   */\r\n  public m_timeElapsed: number = 0;\r\n  /**\r\n   * Whether the expiration time buffer has been modified and\r\n   * needs to be resorted.\r\n   */\r\n  public m_expirationTimeBufferRequiresSorting: boolean = false;\r\n  public m_groupCount: number = 0;\r\n  public m_groupList: b2ParticleGroup | null = null;\r\n  public m_def: b2ParticleSystemDef = new b2ParticleSystemDef();\r\n  public m_world: b2World;\r\n  public m_prev: b2ParticleSystem | null = null;\r\n  public m_next: b2ParticleSystem | null = null;\r\n\r\n  public static readonly xTruncBits: number = 12;\r\n  public static readonly yTruncBits: number = 12;\r\n  public static readonly tagBits: number = 8 * 4; // 8u * sizeof(uint32);\r\n  public static readonly yOffset: number = 1 << (b2ParticleSystem.yTruncBits - 1);\r\n  public static readonly yShift: number = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits;\r\n  public static readonly xShift: number = b2ParticleSystem.tagBits - b2ParticleSystem.yTruncBits - b2ParticleSystem.xTruncBits;\r\n  public static readonly xScale: number = 1 << b2ParticleSystem.xShift;\r\n  public static readonly xOffset: number = b2ParticleSystem.xScale * (1 << (b2ParticleSystem.xTruncBits - 1));\r\n  public static readonly yMask: number = ((1 << b2ParticleSystem.yTruncBits) - 1) << b2ParticleSystem.yShift;\r\n  public static readonly xMask: number = ~b2ParticleSystem.yMask;\r\n\r\n  public static computeTag(x: number, y: number): number {\r\n    ///return ((uint32)(y + yOffset) << yShift) + (uint32)(xScale * x + xOffset);\r\n    return ((((y + b2ParticleSystem.yOffset) >>> 0) << b2ParticleSystem.yShift) + ((b2ParticleSystem.xScale * x + b2ParticleSystem.xOffset) >>> 0)) >>> 0;\r\n  }\r\n\r\n  public static computeRelativeTag(tag: number, x: number, y: number): number {\r\n    ///return tag + (y << yShift) + (x << xShift);\r\n    return (tag + (y << b2ParticleSystem.yShift) + (x << b2ParticleSystem.xShift)) >>> 0;\r\n  }\r\n\r\n  constructor(def: b2ParticleSystemDef, world: b2World) {\r\n    this.SetStrictContactCheck(def.strictContactCheck);\r\n    this.SetDensity(def.density);\r\n    this.SetGravityScale(def.gravityScale);\r\n    this.SetRadius(def.radius);\r\n    this.SetMaxParticleCount(def.maxCount);\r\n    // DEBUG: b2Assert(def.lifetimeGranularity > 0.0);\r\n    this.m_def = def.Clone();\r\n    this.m_world = world;\r\n    this.SetDestructionByAge(this.m_def.destroyByAge);\r\n  }\r\n\r\n  public Drop(): void {\r\n    while (this.m_groupList) {\r\n      this.DestroyParticleGroup(this.m_groupList);\r\n    }\r\n\r\n    this.FreeUserOverridableBuffer(this.m_handleIndexBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_flagsBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_lastBodyContactStepBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_bodyContactCountBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_consecutiveContactStepsBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_positionBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_velocityBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_colorBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_userDataBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_expirationTimeBuffer);\r\n    this.FreeUserOverridableBuffer(this.m_indexByExpirationTimeBuffer);\r\n    this.FreeBuffer(this.m_forceBuffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_weightBuffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_staticPressureBuffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_accumulationBuffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_accumulation2Buffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_depthBuffer, this.m_internalAllocatedCapacity);\r\n    this.FreeBuffer(this.m_groupBuffer, this.m_internalAllocatedCapacity);\r\n  }\r\n\r\n  /**\r\n   * Create a particle whose properties have been defined.\r\n   *\r\n   * No reference to the definition is retained.\r\n   *\r\n   * A simulation step must occur before it's possible to interact\r\n   * with a newly created particle.  For example,\r\n   * DestroyParticleInShape() will not destroy a particle until\r\n   * b2World::Step() has been called.\r\n   *\r\n   * warning: This function is locked during callbacks.\r\n   */\r\n  public CreateParticle(def: b2IParticleDef): number {\r\n    if (this.m_world.IsLocked()) { throw new Error(); }\r\n\r\n    if (this.m_count >= this.m_internalAllocatedCapacity) {\r\n      // Double the particle capacity.\r\n      const capacity = this.m_count ? 2 * this.m_count : b2_minParticleSystemBufferCapacity;\r\n      this.ReallocateInternalAllocatedBuffers(capacity);\r\n    }\r\n    if (this.m_count >= this.m_internalAllocatedCapacity) {\r\n      // If the oldest particle should be destroyed...\r\n      if (this.m_def.destroyByAge) {\r\n        this.DestroyOldestParticle(0, false);\r\n        // Need to destroy this particle *now* so that it's possible to\r\n        // create a new particle.\r\n        this.SolveZombie();\r\n      } else {\r\n        return b2_invalidParticleIndex;\r\n      }\r\n    }\r\n    const index = this.m_count++;\r\n    this.m_flagsBuffer.data[index] = 0;\r\n    if (this.m_lastBodyContactStepBuffer.data) {\r\n      this.m_lastBodyContactStepBuffer.data[index] = 0;\r\n    }\r\n    if (this.m_bodyContactCountBuffer.data) {\r\n      this.m_bodyContactCountBuffer.data[index] = 0;\r\n    }\r\n    if (this.m_consecutiveContactStepsBuffer.data) {\r\n      this.m_consecutiveContactStepsBuffer.data[index] = 0;\r\n    }\r\n    this.m_positionBuffer.data[index] = (this.m_positionBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.position, b2Vec2.ZERO));\r\n    this.m_velocityBuffer.data[index] = (this.m_velocityBuffer.data[index] || new b2Vec2()).Copy(b2Maybe(def.velocity, b2Vec2.ZERO));\r\n    this.m_weightBuffer[index] = 0;\r\n    this.m_forceBuffer[index] = (this.m_forceBuffer[index] || new b2Vec2()).SetZero();\r\n    if (this.m_staticPressureBuffer) {\r\n      this.m_staticPressureBuffer[index] = 0;\r\n    }\r\n    if (this.m_depthBuffer) {\r\n      this.m_depthBuffer[index] = 0;\r\n    }\r\n    const color: b2Color = new b2Color().Copy(b2Maybe(def.color, b2Color.ZERO));\r\n    if (this.m_colorBuffer.data || !color.IsZero()) {\r\n      this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n      this.m_colorBuffer.data[index] = (this.m_colorBuffer.data[index] || new b2Color()).Copy(color);\r\n    }\r\n    if (this.m_userDataBuffer.data || def.userData) {\r\n      this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);\r\n      this.m_userDataBuffer.data[index] = def.userData;\r\n    }\r\n    if (this.m_handleIndexBuffer.data) {\r\n      this.m_handleIndexBuffer.data[index] = null;\r\n    }\r\n    ///Proxy& proxy = m_proxyBuffer.Append();\r\n    const proxy = this.m_proxyBuffer.data[this.m_proxyBuffer.Append()];\r\n\r\n    // If particle lifetimes are enabled or the lifetime is set in the particle\r\n    // definition, initialize the lifetime.\r\n    const lifetime = b2Maybe(def.lifetime, 0.0);\r\n    const finiteLifetime = lifetime > 0.0;\r\n    if (this.m_expirationTimeBuffer.data || finiteLifetime) {\r\n      this.SetParticleLifetime(index, finiteLifetime ? lifetime :\r\n        this.ExpirationTimeToLifetime(-this.GetQuantizedTimeElapsed()));\r\n      // Add a reference to the newly added particle to the end of the\r\n      // queue.\r\n      this.m_indexByExpirationTimeBuffer.data[index] = index;\r\n    }\r\n\r\n    proxy.index = index;\r\n    const group = b2Maybe(def.group, null);\r\n    this.m_groupBuffer[index] = group;\r\n    if (group) {\r\n      if (group.m_firstIndex < group.m_lastIndex) {\r\n        // Move particles in the group just before the new particle.\r\n        this.RotateBuffer(group.m_firstIndex, group.m_lastIndex, index);\r\n        // DEBUG: b2Assert(group.m_lastIndex === index);\r\n        // Update the index range of the group to contain the new particle.\r\n        group.m_lastIndex = index + 1;\r\n      } else {\r\n        // If the group is empty, reset the index range to contain only the\r\n        // new particle.\r\n        group.m_firstIndex = index;\r\n        group.m_lastIndex = index + 1;\r\n      }\r\n    }\r\n    this.SetParticleFlags(index, b2Maybe(def.flags, 0));\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Retrieve a handle to the particle at the specified index.\r\n   *\r\n   * Please see #b2ParticleHandle for why you might want a handle.\r\n   */\r\n  public GetParticleHandleFromIndex(index: number): b2ParticleHandle {\r\n    // DEBUG: b2Assert(index >= 0 && index < this.GetParticleCount() && index !== b2_invalidParticleIndex);\r\n    this.m_handleIndexBuffer.data = this.RequestBuffer(this.m_handleIndexBuffer.data);\r\n    let handle = this.m_handleIndexBuffer.data[index];\r\n    if (handle) {\r\n      return handle;\r\n    }\r\n    // Create a handle.\r\n    ///handle = m_handleAllocator.Allocate();\r\n    handle = new b2ParticleHandle();\r\n    // DEBUG: b2Assert(handle !== null);\r\n    handle.SetIndex(index);\r\n    this.m_handleIndexBuffer.data[index] = handle;\r\n    return handle;\r\n  }\r\n\r\n  /**\r\n   * Destroy a particle.\r\n   *\r\n   * The particle is removed after the next simulation step (see\r\n   * b2World::Step()).\r\n   *\r\n   * @param index Index of the particle to destroy.\r\n   * @param callDestructionListener Whether to call the\r\n   *      destruction listener just before the particle is\r\n   *      destroyed.\r\n   */\r\n  public DestroyParticle(index: number, callDestructionListener: boolean = false): void {\r\n    let flags = b2ParticleFlag.b2_zombieParticle;\r\n    if (callDestructionListener) {\r\n      flags |= b2ParticleFlag.b2_destructionListenerParticle;\r\n    }\r\n    this.SetParticleFlags(index, this.m_flagsBuffer.data[index] | flags);\r\n  }\r\n\r\n  /**\r\n   * Destroy the Nth oldest particle in the system.\r\n   *\r\n   * The particle is removed after the next b2World::Step().\r\n   *\r\n   * @param index Index of the Nth oldest particle to\r\n   *      destroy, 0 will destroy the oldest particle in the\r\n   *      system, 1 will destroy the next oldest particle etc.\r\n   * @param callDestructionListener Whether to call the\r\n   *      destruction listener just before the particle is\r\n   *      destroyed.\r\n   */\r\n  public DestroyOldestParticle(index: number, callDestructionListener: boolean = false): void {\r\n    const particleCount = this.GetParticleCount();\r\n    // DEBUG: b2Assert(index >= 0 && index < particleCount);\r\n    // Make sure particle lifetime tracking is enabled.\r\n    // DEBUG: b2Assert(this.m_indexByExpirationTimeBuffer.data !== null);\r\n    // Destroy the oldest particle (preferring to destroy finite\r\n    // lifetime particles first) to free a slot in the buffer.\r\n    const oldestFiniteLifetimeParticle =\r\n      this.m_indexByExpirationTimeBuffer.data[particleCount - (index + 1)];\r\n    const oldestInfiniteLifetimeParticle =\r\n      this.m_indexByExpirationTimeBuffer.data[index];\r\n    this.DestroyParticle(\r\n      this.m_expirationTimeBuffer.data[oldestFiniteLifetimeParticle] > 0.0 ?\r\n      oldestFiniteLifetimeParticle : oldestInfiniteLifetimeParticle,\r\n      callDestructionListener);\r\n  }\r\n\r\n  /**\r\n   * Destroy particles inside a shape.\r\n   *\r\n   * warning: This function is locked during callbacks.\r\n   *\r\n   * In addition, this function immediately destroys particles in\r\n   * the shape in constrast to DestroyParticle() which defers the\r\n   * destruction until the next simulation step.\r\n   *\r\n   * @return Number of particles destroyed.\r\n   * @param shape Shape which encloses particles\r\n   *      that should be destroyed.\r\n   * @param xf Transform applied to the shape.\r\n   * @param callDestructionListener Whether to call the\r\n   *      world b2DestructionListener for each particle\r\n   *      destroyed.\r\n   */\r\n  public DestroyParticlesInShape(shape: b2Shape, xf: b2Transform, callDestructionListener: boolean = false): number {\r\n    const s_aabb = b2ParticleSystem.DestroyParticlesInShape_s_aabb;\r\n    if (this.m_world.IsLocked()) { throw new Error(); }\r\n\r\n    const callback = new b2ParticleSystem_DestroyParticlesInShapeCallback(this, shape, xf, callDestructionListener);\r\n\r\n    const aabb = s_aabb;\r\n    shape.ComputeAABB(aabb, xf, 0);\r\n    this.m_world.QueryAABB(callback, aabb);\r\n    return callback.Destroyed();\r\n  }\r\n  public static readonly DestroyParticlesInShape_s_aabb = new b2AABB();\r\n\r\n  /**\r\n   * Create a particle group whose properties have been defined.\r\n   *\r\n   * No reference to the definition is retained.\r\n   *\r\n   * warning: This function is locked during callbacks.\r\n   */\r\n  public CreateParticleGroup(groupDef: b2IParticleGroupDef): b2ParticleGroup {\r\n    const s_transform = b2ParticleSystem.CreateParticleGroup_s_transform;\r\n\r\n    if (this.m_world.IsLocked()) { throw new Error(); }\r\n\r\n    const transform = s_transform;\r\n    transform.SetPositionAngle(b2Maybe(groupDef.position, b2Vec2.ZERO), b2Maybe(groupDef.angle, 0));\r\n    const firstIndex = this.m_count;\r\n    if (groupDef.shape) {\r\n      this.CreateParticlesWithShapeForGroup(groupDef.shape, groupDef, transform);\r\n    }\r\n    if (groupDef.shapes) {\r\n      this.CreateParticlesWithShapesForGroup(groupDef.shapes, b2Maybe(groupDef.shapeCount, groupDef.shapes.length), groupDef, transform);\r\n    }\r\n    if (groupDef.positionData) {\r\n      const count = b2Maybe(groupDef.particleCount, groupDef.positionData.length);\r\n      for (let i = 0; i < count; i++) {\r\n        const p = groupDef.positionData[i];\r\n        this.CreateParticleForGroup(groupDef, transform, p);\r\n      }\r\n    }\r\n    const lastIndex = this.m_count;\r\n\r\n    let group = new b2ParticleGroup(this);\r\n    group.m_firstIndex = firstIndex;\r\n    group.m_lastIndex = lastIndex;\r\n    group.m_strength = b2Maybe(groupDef.strength, 1);\r\n    group.m_userData = groupDef.userData;\r\n    group.m_transform.Copy(transform);\r\n    group.m_prev = null;\r\n    group.m_next = this.m_groupList;\r\n    if (this.m_groupList) {\r\n      this.m_groupList.m_prev = group;\r\n    }\r\n    this.m_groupList = group;\r\n    ++this.m_groupCount;\r\n    for (let i = firstIndex; i < lastIndex; i++) {\r\n      this.m_groupBuffer[i] = group;\r\n    }\r\n    this.SetGroupFlags(group, b2Maybe(groupDef.groupFlags, 0));\r\n\r\n    // Create pairs and triads between particles in the group.\r\n    const filter = new b2ParticleSystem_ConnectionFilter();\r\n    this.UpdateContacts(true);\r\n    this.UpdatePairsAndTriads(firstIndex, lastIndex, filter);\r\n\r\n    if (groupDef.group) {\r\n      this.JoinParticleGroups(groupDef.group, group);\r\n      group = groupDef.group;\r\n    }\r\n\r\n    return group;\r\n  }\r\n  public static readonly CreateParticleGroup_s_transform = new b2Transform();\r\n\r\n  /**\r\n   * Join two particle groups.\r\n   *\r\n   * warning: This function is locked during callbacks.\r\n   *\r\n   * @param groupA the first group. Expands to encompass the second group.\r\n   * @param groupB the second group. It is destroyed.\r\n   */\r\n  public JoinParticleGroups(groupA: b2ParticleGroup, groupB: b2ParticleGroup): void {\r\n    if (this.m_world.IsLocked()) { throw new Error(); }\r\n\r\n    // DEBUG: b2Assert(groupA !== groupB);\r\n    this.RotateBuffer(groupB.m_firstIndex, groupB.m_lastIndex, this.m_count);\r\n    // DEBUG: b2Assert(groupB.m_lastIndex === this.m_count);\r\n    this.RotateBuffer(groupA.m_firstIndex, groupA.m_lastIndex, groupB.m_firstIndex);\r\n    // DEBUG: b2Assert(groupA.m_lastIndex === groupB.m_firstIndex);\r\n\r\n    // Create pairs and triads connecting groupA and groupB.\r\n    const filter = new b2ParticleSystem_JoinParticleGroupsFilter(groupB.m_firstIndex);\r\n    this.UpdateContacts(true);\r\n    this.UpdatePairsAndTriads(groupA.m_firstIndex, groupB.m_lastIndex, filter);\r\n\r\n    for (let i = groupB.m_firstIndex; i < groupB.m_lastIndex; i++) {\r\n      this.m_groupBuffer[i] = groupA;\r\n    }\r\n    const groupFlags = groupA.m_groupFlags | groupB.m_groupFlags;\r\n    this.SetGroupFlags(groupA, groupFlags);\r\n    groupA.m_lastIndex = groupB.m_lastIndex;\r\n    groupB.m_firstIndex = groupB.m_lastIndex;\r\n    this.DestroyParticleGroup(groupB);\r\n  }\r\n\r\n  /**\r\n   * Split particle group into multiple disconnected groups.\r\n   *\r\n   * warning: This function is locked during callbacks.\r\n   *\r\n   * @param group the group to be split.\r\n   */\r\n  public SplitParticleGroup(group: b2ParticleGroup): void {\r\n    this.UpdateContacts(true);\r\n    const particleCount = group.GetParticleCount();\r\n    // We create several linked lists. Each list represents a set of connected particles.\r\n    const nodeBuffer: b2ParticleSystem_ParticleListNode[] = b2MakeArray(particleCount, (index: number) => new b2ParticleSystem_ParticleListNode());\r\n    b2ParticleSystem.InitializeParticleLists(group, nodeBuffer);\r\n    this.MergeParticleListsInContact(group, nodeBuffer);\r\n    const survivingList = b2ParticleSystem.FindLongestParticleList(group, nodeBuffer);\r\n    this.MergeZombieParticleListNodes(group, nodeBuffer, survivingList);\r\n    this.CreateParticleGroupsFromParticleList(group, nodeBuffer, survivingList);\r\n    this.UpdatePairsAndTriadsWithParticleList(group, nodeBuffer);\r\n  }\r\n\r\n  /**\r\n   * Get the world particle group list. With the returned group,\r\n   * use b2ParticleGroup::GetNext to get the next group in the\r\n   * world list.\r\n   *\r\n   * A null group indicates the end of the list.\r\n   *\r\n   * @return the head of the world particle group list.\r\n   */\r\n  public GetParticleGroupList(): b2ParticleGroup | null {\r\n    return this.m_groupList;\r\n  }\r\n\r\n  /**\r\n   * Get the number of particle groups.\r\n   */\r\n  public GetParticleGroupCount(): number {\r\n    return this.m_groupCount;\r\n  }\r\n\r\n  /**\r\n   * Get the number of particles.\r\n   */\r\n  public GetParticleCount(): number {\r\n    return this.m_count;\r\n  }\r\n\r\n  /**\r\n   * Get the maximum number of particles.\r\n   */\r\n  public GetMaxParticleCount(): number {\r\n    return this.m_def.maxCount;\r\n  }\r\n\r\n  /**\r\n   * Set the maximum number of particles.\r\n   *\r\n   * A value of 0 means there is no maximum. The particle buffers\r\n   * can continue to grow while b2World's block allocator still\r\n   * has memory.\r\n   *\r\n   * Note: If you try to CreateParticle() with more than this\r\n   * count, b2_invalidParticleIndex is returned unless\r\n   * SetDestructionByAge() is used to enable the destruction of\r\n   * the oldest particles in the system.\r\n   */\r\n  public SetMaxParticleCount(count: number): void {\r\n    // DEBUG: b2Assert(this.m_count <= count);\r\n    this.m_def.maxCount = count;\r\n  }\r\n\r\n  /**\r\n   * Get all existing particle flags.\r\n   */\r\n  public GetAllParticleFlags(): b2ParticleFlag {\r\n    return this.m_allParticleFlags;\r\n  }\r\n\r\n  /**\r\n   * Get all existing particle group flags.\r\n   */\r\n  public GetAllGroupFlags(): b2ParticleGroupFlag {\r\n    return this.m_allGroupFlags;\r\n  }\r\n\r\n  /**\r\n   * Pause or unpause the particle system. When paused,\r\n   * b2World::Step() skips over this particle system. All\r\n   * b2ParticleSystem function calls still work.\r\n   *\r\n   * @param paused paused is true to pause, false to un-pause.\r\n   */\r\n  public SetPaused(paused: boolean): void {\r\n    this.m_paused = paused;\r\n  }\r\n\r\n  /**\r\n   * Initially, true, then, the last value passed into\r\n   * SetPaused().\r\n   *\r\n   * @return true if the particle system is being updated in b2World::Step().\r\n   */\r\n  public GetPaused(): boolean {\r\n    return this.m_paused;\r\n  }\r\n\r\n  /**\r\n   * Change the particle density.\r\n   *\r\n   * Particle density affects the mass of the particles, which in\r\n   * turn affects how the particles interact with b2Bodies. Note\r\n   * that the density does not affect how the particles interact\r\n   * with each other.\r\n   */\r\n  public SetDensity(density: number): void {\r\n    this.m_def.density = density;\r\n    this.m_inverseDensity = 1 / this.m_def.density;\r\n  }\r\n\r\n  /**\r\n   * Get the particle density.\r\n   */\r\n  public GetDensity(): number {\r\n    return this.m_def.density;\r\n  }\r\n\r\n  /**\r\n   * Change the particle gravity scale. Adjusts the effect of the\r\n   * global gravity vector on particles.\r\n   */\r\n  public SetGravityScale(gravityScale: number): void {\r\n    this.m_def.gravityScale = gravityScale;\r\n  }\r\n\r\n  /**\r\n   * Get the particle gravity scale.\r\n   */\r\n  public GetGravityScale(): number {\r\n    return this.m_def.gravityScale;\r\n  }\r\n\r\n  /**\r\n   * Damping is used to reduce the velocity of particles. The\r\n   * damping parameter can be larger than 1.0f but the damping\r\n   * effect becomes sensitive to the time step when the damping\r\n   * parameter is large.\r\n   */\r\n  public SetDamping(damping: number): void {\r\n    this.m_def.dampingStrength = damping;\r\n  }\r\n\r\n  /**\r\n   * Get damping for particles\r\n   */\r\n  public GetDamping(): number {\r\n    return this.m_def.dampingStrength;\r\n  }\r\n\r\n  /**\r\n   * Change the number of iterations when calculating the static\r\n   * pressure of particles. By default, 8 iterations. You can\r\n   * reduce the number of iterations down to 1 in some situations,\r\n   * but this may cause instabilities when many particles come\r\n   * together. If you see particles popping away from each other\r\n   * like popcorn, you may have to increase the number of\r\n   * iterations.\r\n   *\r\n   * For a description of static pressure, see\r\n   * http://en.wikipedia.org/wiki/Static_pressure#Static_pressure_in_fluid_dynamics\r\n   */\r\n  public SetStaticPressureIterations(iterations: number): void {\r\n    this.m_def.staticPressureIterations = iterations;\r\n  }\r\n\r\n  /**\r\n   * Get the number of iterations for static pressure of\r\n   * particles.\r\n   */\r\n  public GetStaticPressureIterations(): number {\r\n    return this.m_def.staticPressureIterations;\r\n  }\r\n\r\n  /**\r\n   * Change the particle radius.\r\n   *\r\n   * You should set this only once, on world start.\r\n   * If you change the radius during execution, existing particles\r\n   * may explode, shrink, or behave unexpectedly.\r\n   */\r\n  public SetRadius(radius: number): void {\r\n    this.m_particleDiameter = 2 * radius;\r\n    this.m_squaredDiameter = this.m_particleDiameter * this.m_particleDiameter;\r\n    this.m_inverseDiameter = 1 / this.m_particleDiameter;\r\n  }\r\n\r\n  /**\r\n   * Get the particle radius.\r\n   */\r\n  public GetRadius(): number {\r\n    return this.m_particleDiameter / 2;\r\n  }\r\n\r\n  /**\r\n   * Get the position of each particle\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle positions array.\r\n   */\r\n  public GetPositionBuffer(): b2Vec2[] {\r\n    return this.m_positionBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Get the velocity of each particle\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle velocities array.\r\n   */\r\n  public GetVelocityBuffer(): b2Vec2[] {\r\n    return this.m_velocityBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Get the color of each particle\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle colors array.\r\n   */\r\n  public GetColorBuffer(): b2Color[] {\r\n    this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n    return this.m_colorBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Get the particle-group of each particle.\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle group array.\r\n   */\r\n  public GetGroupBuffer(): Array<b2ParticleGroup | null> {\r\n    return this.m_groupBuffer;\r\n  }\r\n\r\n  /**\r\n   * Get the weight of each particle\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle positions array.\r\n   */\r\n  public GetWeightBuffer(): number[] {\r\n    return this.m_weightBuffer;\r\n  }\r\n\r\n  /**\r\n   * Get the user-specified data of each particle.\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle user-data array.\r\n   */\r\n  public GetUserDataBuffer<T>(): T[] {\r\n    this.m_userDataBuffer.data = this.RequestBuffer(this.m_userDataBuffer.data);\r\n    return this.m_userDataBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Get the flags for each particle. See the b2ParticleFlag enum.\r\n   *\r\n   * Array is length GetParticleCount()\r\n   *\r\n   * @return the pointer to the head of the particle-flags array.\r\n   */\r\n  public GetFlagsBuffer(): b2ParticleFlag[] {\r\n    return this.m_flagsBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Set flags for a particle. See the b2ParticleFlag enum.\r\n   */\r\n  public SetParticleFlags(index: number, newFlags: b2ParticleFlag): void {\r\n    const oldFlags = this.m_flagsBuffer.data[index];\r\n    if (oldFlags & ~newFlags) {\r\n      // If any flags might be removed\r\n      this.m_needsUpdateAllParticleFlags = true;\r\n    }\r\n    if (~this.m_allParticleFlags & newFlags) {\r\n      // If any flags were added\r\n      if (newFlags & b2ParticleFlag.b2_tensileParticle) {\r\n        this.m_accumulation2Buffer = this.RequestBuffer(this.m_accumulation2Buffer);\r\n      }\r\n      if (newFlags & b2ParticleFlag.b2_colorMixingParticle) {\r\n        this.m_colorBuffer.data = this.RequestBuffer(this.m_colorBuffer.data);\r\n      }\r\n      this.m_allParticleFlags |= newFlags;\r\n    }\r\n    this.m_flagsBuffer.data[index] = newFlags;\r\n  }\r\n\r\n  /**\r\n   * Get flags for a particle. See the b2ParticleFlag enum.\r\n   */\r\n  public GetParticleFlags(index: number): b2ParticleFlag {\r\n    return this.m_flagsBuffer.data[index];\r\n  }\r\n\r\n  /**\r\n   * Set an external buffer for particle data.\r\n   *\r\n   * Normally, the b2World's block allocator is used for particle\r\n   * data. However, sometimes you may have an OpenGL or Java\r\n   * buffer for particle data. To avoid data duplication, you may\r\n   * supply this external buffer.\r\n   *\r\n   * Note that, when b2World's block allocator is used, the\r\n   * particle data buffers can grow as required. However, when\r\n   * external buffers are used, the maximum number of particles is\r\n   * clamped to the size of the smallest external buffer.\r\n   *\r\n   * @param buffer a pointer to a block of memory.\r\n   * @param capacity the number of values in the block.\r\n   */\r\n  public SetFlagsBuffer(buffer: b2ParticleFlag[]): void {\r\n    this.SetUserOverridableBuffer(this.m_flagsBuffer, buffer);\r\n  }\r\n\r\n  public SetPositionBuffer(buffer: b2Vec2[] | Float32Array): void {\r\n    if (buffer instanceof Float32Array) {\r\n      if (buffer.length % 2 !== 0) { throw new Error(); }\r\n      const count: number = buffer.length / 2;\r\n      const array: b2Vec2[] = new Array(count);\r\n      for (let i = 0; i < count; ++i) {\r\n        array[i] = new b2Vec2(buffer.subarray(i * 2, i * 2 + 2));\r\n      }\r\n      buffer = array;\r\n    }\r\n    this.SetUserOverridableBuffer(this.m_positionBuffer, buffer);\r\n  }\r\n\r\n  public SetVelocityBuffer(buffer: b2Vec2[] | Float32Array): void {\r\n    if (buffer instanceof Float32Array) {\r\n      if (buffer.length % 2 !== 0) { throw new Error(); }\r\n      const count: number = buffer.length / 2;\r\n      const array: b2Vec2[] = new Array(count);\r\n      for (let i = 0; i < count; ++i) {\r\n        array[i] = new b2Vec2(buffer.subarray(i * 2, i * 2 + 2));\r\n      }\r\n      buffer = array;\r\n    }\r\n    this.SetUserOverridableBuffer(this.m_velocityBuffer, buffer);\r\n  }\r\n\r\n  public SetColorBuffer(buffer: b2Color[] | Float32Array): void {\r\n    if (buffer instanceof Float32Array) {\r\n      if (buffer.length % 4 !== 0) { throw new Error(); }\r\n      const count: number = buffer.length / 4;\r\n      const array: b2Color[] = new Array(count);\r\n      for (let i = 0; i < count; ++i) {\r\n        array[i] = new b2Color(buffer.subarray(i * 4, i * 4 + 4));\r\n      }\r\n      buffer = array;\r\n    }\r\n    this.SetUserOverridableBuffer(this.m_colorBuffer, buffer);\r\n  }\r\n\r\n  public SetUserDataBuffer<T>(buffer: T[]): void {\r\n    this.SetUserOverridableBuffer(this.m_userDataBuffer, buffer);\r\n  }\r\n\r\n  /**\r\n   * Get contacts between particles\r\n   * Contact data can be used for many reasons, for example to\r\n   * trigger rendering or audio effects.\r\n   */\r\n  public GetContacts(): b2ParticleContact[] {\r\n    return this.m_contactBuffer.data;\r\n  }\r\n\r\n  public GetContactCount(): number {\r\n    return this.m_contactBuffer.count;\r\n  }\r\n\r\n  /**\r\n   * Get contacts between particles and bodies\r\n   *\r\n   * Contact data can be used for many reasons, for example to\r\n   * trigger rendering or audio effects.\r\n   */\r\n  public GetBodyContacts(): b2ParticleBodyContact[] {\r\n    return this.m_bodyContactBuffer.data;\r\n  }\r\n\r\n  public GetBodyContactCount(): number {\r\n    return this.m_bodyContactBuffer.count;\r\n  }\r\n\r\n  /**\r\n   * Get array of particle pairs. The particles in a pair:\r\n   *   (1) are contacting,\r\n   *   (2) are in the same particle group,\r\n   *   (3) are part of a rigid particle group, or are spring, elastic,\r\n   *       or wall particles.\r\n   *   (4) have at least one particle that is a spring or barrier\r\n   *       particle (i.e. one of the types in k_pairFlags),\r\n   *   (5) have at least one particle that returns true for\r\n   *       ConnectionFilter::IsNecessary,\r\n   *   (6) are not zombie particles.\r\n   *\r\n   * Essentially, this is an array of spring or barrier particles\r\n   * that are interacting. The array is sorted by b2ParticlePair's\r\n   * indexA, and then indexB. There are no duplicate entries.\r\n   */\r\n  public GetPairs(): b2ParticlePair[] {\r\n    return this.m_pairBuffer.data;\r\n  }\r\n\r\n  public GetPairCount(): number {\r\n    return this.m_pairBuffer.count;\r\n  }\r\n\r\n  /**\r\n   * Get array of particle triads. The particles in a triad:\r\n   *   (1) are in the same particle group,\r\n   *   (2) are in a Voronoi triangle together,\r\n   *   (3) are within b2_maxTriadDistance particle diameters of each\r\n   *       other,\r\n   *   (4) return true for ConnectionFilter::ShouldCreateTriad\r\n   *   (5) have at least one particle of type elastic (i.e. one of the\r\n   *       types in k_triadFlags),\r\n   *   (6) are part of a rigid particle group, or are spring, elastic,\r\n   *       or wall particles.\r\n   *   (7) are not zombie particles.\r\n   *\r\n   * Essentially, this is an array of elastic particles that are\r\n   * interacting. The array is sorted by b2ParticleTriad's indexA,\r\n   * then indexB, then indexC. There are no duplicate entries.\r\n   */\r\n  public GetTriads(): b2ParticleTriad[] {\r\n    return this.m_triadBuffer.data;\r\n  }\r\n\r\n  public GetTriadCount(): number {\r\n    return this.m_triadBuffer.count;\r\n  }\r\n\r\n  /**\r\n   * Set an optional threshold for the maximum number of\r\n   * consecutive particle iterations that a particle may contact\r\n   * multiple bodies before it is considered a candidate for being\r\n   * \"stuck\". Setting to zero or less disables.\r\n   */\r\n  public SetStuckThreshold(steps: number): void {\r\n    this.m_stuckThreshold = steps;\r\n\r\n    if (steps > 0) {\r\n      this.m_lastBodyContactStepBuffer.data = this.RequestBuffer(this.m_lastBodyContactStepBuffer.data);\r\n      this.m_bodyContactCountBuffer.data = this.RequestBuffer(this.m_bodyContactCountBuffer.data);\r\n      this.m_consecutiveContactStepsBuffer.data = this.RequestBuffer(this.m_consecutiveContactStepsBuffer.data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get potentially stuck particles from the last step; the user\r\n   * must decide if they are stuck or not, and if so, delete or\r\n   * move them\r\n   */\r\n  public GetStuckCandidates(): number[] {\r\n    ///return m_stuckParticleBuffer.Data();\r\n    return this.m_stuckParticleBuffer.Data();\r\n  }\r\n\r\n  /**\r\n   * Get the number of stuck particle candidates from the last\r\n   * step.\r\n   */\r\n  public GetStuckCandidateCount(): number {\r\n    ///return m_stuckParticleBuffer.GetCount();\r\n    return this.m_stuckParticleBuffer.GetCount();\r\n  }\r\n\r\n  /**\r\n   * Compute the kinetic energy that can be lost by damping force\r\n   */\r\n  public ComputeCollisionEnergy(): number {\r\n    const s_v = b2ParticleSystem.ComputeCollisionEnergy_s_v;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    let sum_v2 = 0;\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const n = contact.normal;\r\n      ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n      const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n      const vn = b2Vec2.DotVV(v, n);\r\n      if (vn < 0) {\r\n        sum_v2 += vn * vn;\r\n      }\r\n    }\r\n    return 0.5 * this.GetParticleMass() * sum_v2;\r\n  }\r\n  public static readonly ComputeCollisionEnergy_s_v = new b2Vec2();\r\n\r\n  /**\r\n   * Set strict Particle/Body contact check.\r\n   *\r\n   * This is an option that will help ensure correct behavior if\r\n   * there are corners in the world model where Particle/Body\r\n   * contact is ambiguous. This option scales at n*log(n) of the\r\n   * number of Particle/Body contacts, so it is best to only\r\n   * enable if it is necessary for your geometry. Enable if you\r\n   * see strange particle behavior around b2Body intersections.\r\n   */\r\n  public SetStrictContactCheck(enabled: boolean): void {\r\n    this.m_def.strictContactCheck = enabled;\r\n  }\r\n\r\n  /**\r\n   * Get the status of the strict contact check.\r\n   */\r\n  public GetStrictContactCheck(): boolean {\r\n    return this.m_def.strictContactCheck;\r\n  }\r\n\r\n  /**\r\n   * Set the lifetime (in seconds) of a particle relative to the\r\n   * current time.  A lifetime of less than or equal to 0.0f\r\n   * results in the particle living forever until it's manually\r\n   * destroyed by the application.\r\n   */\r\n  public SetParticleLifetime(index: number, lifetime: number): void {\r\n    // DEBUG: b2Assert(this.ValidateParticleIndex(index));\r\n    const initializeExpirationTimes = this.m_indexByExpirationTimeBuffer.data === null;\r\n    this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);\r\n    this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);\r\n\r\n    // Initialize the inverse mapping buffer.\r\n    if (initializeExpirationTimes) {\r\n      const particleCount = this.GetParticleCount();\r\n      for (let i = 0; i < particleCount; ++i) {\r\n        this.m_indexByExpirationTimeBuffer.data[i] = i;\r\n      }\r\n    }\r\n    ///const int32 quantizedLifetime = (int32)(lifetime / m_def.lifetimeGranularity);\r\n    const quantizedLifetime = lifetime / this.m_def.lifetimeGranularity;\r\n    // Use a negative lifetime so that it's possible to track which\r\n    // of the infinite lifetime particles are older.\r\n    const newExpirationTime = quantizedLifetime > 0.0 ? this.GetQuantizedTimeElapsed() + quantizedLifetime : quantizedLifetime;\r\n    if (newExpirationTime !== this.m_expirationTimeBuffer.data[index]) {\r\n      this.m_expirationTimeBuffer.data[index] = newExpirationTime;\r\n      this.m_expirationTimeBufferRequiresSorting = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the lifetime (in seconds) of a particle relative to the\r\n   * current time.  A value > 0.0f is returned if the particle is\r\n   * scheduled to be destroyed in the future, values <= 0.0f\r\n   * indicate the particle has an infinite lifetime.\r\n   */\r\n  public GetParticleLifetime(index: number): number {\r\n    // DEBUG: b2Assert(this.ValidateParticleIndex(index));\r\n    return this.ExpirationTimeToLifetime(this.GetExpirationTimeBuffer()[index]);\r\n  }\r\n\r\n  /**\r\n   * Enable / disable destruction of particles in CreateParticle()\r\n   * when no more particles can be created due to a prior call to\r\n   * SetMaxParticleCount().  When this is enabled, the oldest\r\n   * particle is destroyed in CreateParticle() favoring the\r\n   * destruction of particles with a finite lifetime over\r\n   * particles with infinite lifetimes. This feature is enabled by\r\n   * default when particle lifetimes are tracked.  Explicitly\r\n   * enabling this feature using this function enables particle\r\n   * lifetime tracking.\r\n   */\r\n  public SetDestructionByAge(enable: boolean): void {\r\n    if (enable) {\r\n      this.GetExpirationTimeBuffer();\r\n    }\r\n    this.m_def.destroyByAge = enable;\r\n  }\r\n\r\n  /**\r\n   * Get whether the oldest particle will be destroyed in\r\n   * CreateParticle() when the maximum number of particles are\r\n   * present in the system.\r\n   */\r\n  public GetDestructionByAge(): boolean {\r\n    return this.m_def.destroyByAge;\r\n  }\r\n\r\n  /**\r\n   * Get the array of particle expiration times indexed by\r\n   * particle index.\r\n   *\r\n   * GetParticleCount() items are in the returned array.\r\n   */\r\n  public GetExpirationTimeBuffer(): number[] {\r\n    this.m_expirationTimeBuffer.data = this.RequestBuffer(this.m_expirationTimeBuffer.data);\r\n    return this.m_expirationTimeBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Convert a expiration time value in returned by\r\n   * GetExpirationTimeBuffer() to a time in seconds relative to\r\n   * the current simulation time.\r\n   */\r\n  public ExpirationTimeToLifetime(expirationTime: number): number {\r\n    return (expirationTime > 0 ?\r\n      expirationTime - this.GetQuantizedTimeElapsed() :\r\n      expirationTime) * this.m_def.lifetimeGranularity;\r\n  }\r\n\r\n  /**\r\n   * Get the array of particle indices ordered by reverse\r\n   * lifetime. The oldest particle indexes are at the end of the\r\n   * array with the newest at the start.  Particles with infinite\r\n   * lifetimes (i.e expiration times less than or equal to 0) are\r\n   * placed at the start of the array.\r\n   * ExpirationTimeToLifetime(GetExpirationTimeBuffer()[index]) is\r\n   * equivalent to GetParticleLifetime(index).\r\n   *\r\n   * GetParticleCount() items are in the returned array.\r\n   */\r\n  public GetIndexByExpirationTimeBuffer(): number[] {\r\n    // If particles are present, initialize / reinitialize the lifetime buffer.\r\n    if (this.GetParticleCount()) {\r\n      this.SetParticleLifetime(0, this.GetParticleLifetime(0));\r\n    } else {\r\n      this.m_indexByExpirationTimeBuffer.data = this.RequestBuffer(this.m_indexByExpirationTimeBuffer.data);\r\n    }\r\n    return this.m_indexByExpirationTimeBuffer.data;\r\n  }\r\n\r\n  /**\r\n   * Apply an impulse to one particle. This immediately modifies\r\n   * the velocity. Similar to b2Body::ApplyLinearImpulse.\r\n   *\r\n   * @param index the particle that will be modified.\r\n   * @param impulse impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n   */\r\n  public ParticleApplyLinearImpulse(index: number, impulse: XY): void {\r\n    this.ApplyLinearImpulse(index, index + 1, impulse);\r\n  }\r\n\r\n  /**\r\n   * Apply an impulse to all particles between 'firstIndex' and\r\n   * 'lastIndex'. This immediately modifies the velocity. Note\r\n   * that the impulse is applied to the total mass of all\r\n   * particles. So, calling ParticleApplyLinearImpulse(0, impulse)\r\n   * and ParticleApplyLinearImpulse(1, impulse) will impart twice\r\n   * as much velocity as calling just ApplyLinearImpulse(0, 1,\r\n   * impulse).\r\n   *\r\n   * @param firstIndex the first particle to be modified.\r\n   * @param lastIndex the last particle to be modified.\r\n   * @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n   */\r\n  public ApplyLinearImpulse(firstIndex: number, lastIndex: number, impulse: XY): void {\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const numParticles = (lastIndex - firstIndex);\r\n    const totalMass = numParticles * this.GetParticleMass();\r\n    ///const b2Vec2 velocityDelta = impulse / totalMass;\r\n    const velocityDelta = new b2Vec2().Copy(impulse).SelfMul(1 / totalMass);\r\n    for (let i = firstIndex; i < lastIndex; i++) {\r\n      ///m_velocityBuffer.data[i] += velocityDelta;\r\n      vel_data[i].SelfAdd(velocityDelta);\r\n    }\r\n  }\r\n\r\n  public static IsSignificantForce(force: XY): boolean {\r\n    return force.x !== 0 || force.y !== 0;\r\n  }\r\n\r\n  /**\r\n   * Apply a force to the center of a particle.\r\n   *\r\n   * @param index the particle that will be modified.\r\n   * @param force the world force vector, usually in Newtons (N).\r\n   */\r\n  public ParticleApplyForce(index: number, force: XY): void {\r\n    if (b2ParticleSystem.IsSignificantForce(force) &&\r\n      this.ForceCanBeApplied(this.m_flagsBuffer.data[index])) {\r\n      this.PrepareForceBuffer();\r\n      ///m_forceBuffer[index] += force;\r\n      this.m_forceBuffer[index].SelfAdd(force);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Distribute a force across several particles. The particles\r\n   * must not be wall particles. Note that the force is\r\n   * distributed across all the particles, so calling this\r\n   * function for indices 0..N is not the same as calling\r\n   * ParticleApplyForce(i, force) for i in 0..N.\r\n   *\r\n   * @param firstIndex the first particle to be modified.\r\n   * @param lastIndex the last particle to be modified.\r\n   * @param force the world force vector, usually in Newtons (N).\r\n   */\r\n  public ApplyForce(firstIndex: number, lastIndex: number, force: XY): void {\r\n    // Ensure we're not trying to apply force to particles that can't move,\r\n    // such as wall particles.\r\n    // DEBUG: let flags = 0;\r\n    // DEBUG: for (let i = firstIndex; i < lastIndex; i++) {\r\n    // DEBUG:   flags |= this.m_flagsBuffer.data[i];\r\n    // DEBUG: }\r\n    // DEBUG: b2Assert(this.ForceCanBeApplied(flags));\r\n\r\n    // Early out if force does nothing (optimization).\r\n    ///const b2Vec2 distributedForce = force / (float32)(lastIndex - firstIndex);\r\n    const distributedForce =  new b2Vec2().Copy(force).SelfMul(1 / (lastIndex - firstIndex));\r\n    if (b2ParticleSystem.IsSignificantForce(distributedForce)) {\r\n      this.PrepareForceBuffer();\r\n\r\n      // Distribute the force over all the particles.\r\n      for (let i = firstIndex; i < lastIndex; i++) {\r\n        ///m_forceBuffer[i] += distributedForce;\r\n        this.m_forceBuffer[i].SelfAdd(distributedForce);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the next particle-system in the world's particle-system\r\n   * list.\r\n   */\r\n  public GetNext(): b2ParticleSystem | null {\r\n    return this.m_next;\r\n  }\r\n\r\n  /**\r\n   * Query the particle system for all particles that potentially\r\n   * overlap the provided AABB.\r\n   * b2QueryCallback::ShouldQueryParticleSystem is ignored.\r\n   *\r\n   * @param callback a user implemented callback class.\r\n   * @param aabb the query box.\r\n   */\r\n  public QueryAABB(callback: b2QueryCallback, aabb: b2AABB): void {\r\n    if (this.m_proxyBuffer.count === 0) {\r\n      return;\r\n    }\r\n    const beginProxy = 0;\r\n    const endProxy = this.m_proxyBuffer.count;\r\n    const firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy,\r\n      b2ParticleSystem.computeTag(\r\n        this.m_inverseDiameter * aabb.lowerBound.x,\r\n        this.m_inverseDiameter * aabb.lowerBound.y),\r\n      b2ParticleSystem_Proxy.CompareProxyTag);\r\n    const lastProxy = std_upper_bound(this.m_proxyBuffer.data, firstProxy, endProxy,\r\n      b2ParticleSystem.computeTag(\r\n        this.m_inverseDiameter * aabb.upperBound.x,\r\n        this.m_inverseDiameter * aabb.upperBound.y),\r\n      b2ParticleSystem_Proxy.CompareTagProxy);\r\n    const pos_data = this.m_positionBuffer.data;\r\n    for (let k = firstProxy; k < lastProxy; ++k) {\r\n      const proxy = this.m_proxyBuffer.data[k];\r\n      const i = proxy.index;\r\n      const p = pos_data[i];\r\n      if (aabb.lowerBound.x < p.x && p.x < aabb.upperBound.x &&\r\n        aabb.lowerBound.y < p.y && p.y < aabb.upperBound.y) {\r\n        if (!callback.ReportParticle(this, i)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Query the particle system for all particles that potentially\r\n   * overlap the provided shape's AABB. Calls QueryAABB\r\n   * internally. b2QueryCallback::ShouldQueryParticleSystem is\r\n   * ignored.\r\n   *\r\n   * @param callback a user implemented callback class.\r\n   * @param shape the query shape\r\n   * @param xf the transform of the AABB\r\n   * @param childIndex\r\n   */\r\n  public QueryShapeAABB(callback: b2QueryCallback, shape: b2Shape, xf: b2Transform, childIndex: number = 0): void {\r\n    const s_aabb = b2ParticleSystem.QueryShapeAABB_s_aabb;\r\n    const aabb = s_aabb;\r\n    shape.ComputeAABB(aabb, xf, childIndex);\r\n    this.QueryAABB(callback, aabb);\r\n  }\r\n  public static readonly QueryShapeAABB_s_aabb = new b2AABB();\r\n\r\n  public QueryPointAABB(callback: b2QueryCallback, point: XY, slop: number = b2_linearSlop): void {\r\n    const s_aabb = b2ParticleSystem.QueryPointAABB_s_aabb;\r\n    const aabb = s_aabb;\r\n    aabb.lowerBound.Set(point.x - slop, point.y - slop);\r\n    aabb.upperBound.Set(point.x + slop, point.y + slop);\r\n    this.QueryAABB(callback, aabb);\r\n  }\r\n  public static readonly QueryPointAABB_s_aabb = new b2AABB();\r\n\r\n  /**\r\n   * Ray-cast the particle system for all particles in the path of\r\n   * the ray. Your callback controls whether you get the closest\r\n   * point, any point, or n-points. The ray-cast ignores particles\r\n   * that contain the starting point.\r\n   * b2RayCastCallback::ShouldQueryParticleSystem is ignored.\r\n   *\r\n   * @param callback a user implemented callback class.\r\n   * @param point1 the ray starting point\r\n   * @param point2 the ray ending point\r\n   */\r\n  public RayCast(callback: b2RayCastCallback, point1: XY, point2: XY): void {\r\n    const s_aabb = b2ParticleSystem.RayCast_s_aabb;\r\n    const s_p = b2ParticleSystem.RayCast_s_p;\r\n    const s_v = b2ParticleSystem.RayCast_s_v;\r\n    const s_n = b2ParticleSystem.RayCast_s_n;\r\n    const s_point = b2ParticleSystem.RayCast_s_point;\r\n    if (this.m_proxyBuffer.count === 0) {\r\n      return;\r\n    }\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const aabb = s_aabb;\r\n    b2Vec2.MinV(point1, point2, aabb.lowerBound);\r\n    b2Vec2.MaxV(point1, point2, aabb.upperBound);\r\n    let fraction = 1;\r\n    // solving the following equation:\r\n    // ((1-t)*point1+t*point2-position)^2=diameter^2\r\n    // where t is a potential fraction\r\n    ///b2Vec2 v = point2 - point1;\r\n    const v = b2Vec2.SubVV(point2, point1, s_v);\r\n    const v2 = b2Vec2.DotVV(v, v);\r\n    const enumerator = this.GetInsideBoundsEnumerator(aabb);\r\n\r\n    let i: number;\r\n    while ((i = enumerator.GetNext()) >= 0) {\r\n      ///b2Vec2 p = point1 - m_positionBuffer.data[i];\r\n      const p = b2Vec2.SubVV(point1, pos_data[i], s_p);\r\n      const pv = b2Vec2.DotVV(p, v);\r\n      const p2 = b2Vec2.DotVV(p, p);\r\n      const determinant = pv * pv - v2 * (p2 - this.m_squaredDiameter);\r\n      if (determinant >= 0) {\r\n        const sqrtDeterminant = b2Sqrt(determinant);\r\n        // find a solution between 0 and fraction\r\n        let t = (-pv - sqrtDeterminant) / v2;\r\n        if (t > fraction) {\r\n          continue;\r\n        }\r\n        if (t < 0) {\r\n          t = (-pv + sqrtDeterminant) / v2;\r\n          if (t < 0 || t > fraction) {\r\n            continue;\r\n          }\r\n        }\r\n        ///b2Vec2 n = p + t * v;\r\n        const n = b2Vec2.AddVMulSV(p, t, v, s_n);\r\n        n.Normalize();\r\n        ///float32 f = callback.ReportParticle(this, i, point1 + t * v, n, t);\r\n        const f = callback.ReportParticle(this, i, b2Vec2.AddVMulSV(point1, t, v, s_point), n, t);\r\n        fraction = b2Min(fraction, f);\r\n        if (fraction <= 0) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly RayCast_s_aabb = new b2AABB();\r\n  public static readonly RayCast_s_p = new b2Vec2();\r\n  public static readonly RayCast_s_v = new b2Vec2();\r\n  public static readonly RayCast_s_n = new b2Vec2();\r\n  public static readonly RayCast_s_point = new b2Vec2();\r\n\r\n  /**\r\n   * Compute the axis-aligned bounding box for all particles\r\n   * contained within this particle system.\r\n   * @param aabb Returns the axis-aligned bounding box of the system.\r\n   */\r\n  public ComputeAABB(aabb: b2AABB): void {\r\n    const particleCount = this.GetParticleCount();\r\n    // DEBUG: b2Assert(aabb !== null);\r\n    aabb.lowerBound.x = +b2_maxFloat;\r\n    aabb.lowerBound.y = +b2_maxFloat;\r\n    aabb.upperBound.x = -b2_maxFloat;\r\n    aabb.upperBound.y = -b2_maxFloat;\r\n\r\n    const pos_data = this.m_positionBuffer.data;\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const p = pos_data[i];\r\n      b2Vec2.MinV(aabb.lowerBound, p, aabb.lowerBound);\r\n      b2Vec2.MaxV(aabb.upperBound, p, aabb.upperBound);\r\n    }\r\n    aabb.lowerBound.x -= this.m_particleDiameter;\r\n    aabb.lowerBound.y -= this.m_particleDiameter;\r\n    aabb.upperBound.x += this.m_particleDiameter;\r\n    aabb.upperBound.y += this.m_particleDiameter;\r\n  }\r\n\r\n  /**\r\n   * All particle types that require creating pairs\r\n   */\r\n  public static readonly k_pairFlags: number = b2ParticleFlag.b2_springParticle;\r\n\r\n  /**\r\n   * All particle types that require creating triads\r\n   */\r\n  public static readonly k_triadFlags = b2ParticleFlag.b2_elasticParticle;\r\n\r\n  /**\r\n   * All particle types that do not produce dynamic pressure\r\n   */\r\n  public static readonly k_noPressureFlags = b2ParticleFlag.b2_powderParticle | b2ParticleFlag.b2_tensileParticle;\r\n\r\n  /**\r\n   * All particle types that apply extra damping force with bodies\r\n   */\r\n  public static readonly k_extraDampingFlags = b2ParticleFlag.b2_staticPressureParticle;\r\n\r\n  public static readonly k_barrierWallFlags = b2ParticleFlag.b2_barrierParticle | b2ParticleFlag.b2_wallParticle;\r\n\r\n  public FreeBuffer<T>(b: T[] | null, capacity: number): void {\r\n    if (b === null) {\r\n      return;\r\n    }\r\n    b.length = 0;\r\n  }\r\n\r\n  public FreeUserOverridableBuffer<T>(b: b2ParticleSystem_UserOverridableBuffer<T>): void {\r\n    if (b.userSuppliedCapacity === 0) {\r\n      this.FreeBuffer(b.data, this.m_internalAllocatedCapacity);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reallocate a buffer\r\n   */\r\n  public ReallocateBuffer3<T>(oldBuffer: T[] | null, oldCapacity: number, newCapacity: number): T[] {\r\n    // b2Assert(newCapacity > oldCapacity);\r\n    if (newCapacity <= oldCapacity) { throw new Error(); }\r\n    const newBuffer = (oldBuffer) ? oldBuffer.slice() : [];\r\n    newBuffer.length = newCapacity;\r\n    return newBuffer;\r\n  }\r\n\r\n  /**\r\n   * Reallocate a buffer\r\n   */\r\n  public ReallocateBuffer5<T>(buffer: T[] | null, userSuppliedCapacity: number, oldCapacity: number, newCapacity: number, deferred: boolean): T[] {\r\n    // b2Assert(newCapacity > oldCapacity);\r\n    if (newCapacity <= oldCapacity) { throw new Error(); }\r\n    // A 'deferred' buffer is reallocated only if it is not NULL.\r\n    // If 'userSuppliedCapacity' is not zero, buffer is user supplied and must\r\n    // be kept.\r\n    // b2Assert(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity);\r\n    if (!(!userSuppliedCapacity || newCapacity <= userSuppliedCapacity)) { throw new Error(); }\r\n    if ((!deferred || buffer) && !userSuppliedCapacity) {\r\n      buffer = this.ReallocateBuffer3(buffer, oldCapacity, newCapacity);\r\n    }\r\n    return buffer as any; // TODO: fix this\r\n  }\r\n\r\n  /**\r\n   * Reallocate a buffer\r\n   */\r\n  public ReallocateBuffer4<T>(buffer: b2ParticleSystem_UserOverridableBuffer<any>, oldCapacity: number, newCapacity: number, deferred: boolean): T[] {\r\n    // DEBUG: b2Assert(newCapacity > oldCapacity);\r\n    return this.ReallocateBuffer5(buffer.data, buffer.userSuppliedCapacity, oldCapacity, newCapacity, deferred);\r\n  }\r\n\r\n  public RequestBuffer<T>(buffer: T[] | null): T[] {\r\n    if (!buffer) {\r\n      if (this.m_internalAllocatedCapacity === 0) {\r\n        this.ReallocateInternalAllocatedBuffers(b2_minParticleSystemBufferCapacity);\r\n      }\r\n\r\n      buffer = [];\r\n      buffer.length = this.m_internalAllocatedCapacity;\r\n    }\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Reallocate the handle / index map and schedule the allocation\r\n   * of a new pool for handle allocation.\r\n   */\r\n  public ReallocateHandleBuffers(newCapacity: number): void {\r\n    // DEBUG: b2Assert(newCapacity > this.m_internalAllocatedCapacity);\r\n    // Reallocate a new handle / index map buffer, copying old handle pointers\r\n    // is fine since they're kept around.\r\n    this.m_handleIndexBuffer.data = this.ReallocateBuffer4(this.m_handleIndexBuffer, this.m_internalAllocatedCapacity, newCapacity, true);\r\n    // Set the size of the next handle allocation.\r\n    ///this.m_handleAllocator.SetItemsPerSlab(newCapacity - this.m_internalAllocatedCapacity);\r\n  }\r\n\r\n  public ReallocateInternalAllocatedBuffers(capacity: number): void {\r\n    function LimitCapacity(capacity: number, maxCount: number): number {\r\n      return maxCount && capacity > maxCount ? maxCount : capacity;\r\n    }\r\n\r\n    // Don't increase capacity beyond the smallest user-supplied buffer size.\r\n    capacity = LimitCapacity(capacity, this.m_def.maxCount);\r\n    capacity = LimitCapacity(capacity, this.m_flagsBuffer.userSuppliedCapacity);\r\n    capacity = LimitCapacity(capacity, this.m_positionBuffer.userSuppliedCapacity);\r\n    capacity = LimitCapacity(capacity, this.m_velocityBuffer.userSuppliedCapacity);\r\n    capacity = LimitCapacity(capacity, this.m_colorBuffer.userSuppliedCapacity);\r\n    capacity = LimitCapacity(capacity, this.m_userDataBuffer.userSuppliedCapacity);\r\n    if (this.m_internalAllocatedCapacity < capacity) {\r\n      this.ReallocateHandleBuffers(capacity);\r\n      this.m_flagsBuffer.data = this.ReallocateBuffer4(this.m_flagsBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n\r\n      // Conditionally defer these as they are optional if the feature is\r\n      // not enabled.\r\n      const stuck = this.m_stuckThreshold > 0;\r\n      this.m_lastBodyContactStepBuffer.data = this.ReallocateBuffer4(this.m_lastBodyContactStepBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n      this.m_bodyContactCountBuffer.data = this.ReallocateBuffer4(this.m_bodyContactCountBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n      this.m_consecutiveContactStepsBuffer.data = this.ReallocateBuffer4(this.m_consecutiveContactStepsBuffer, this.m_internalAllocatedCapacity, capacity, stuck);\r\n      this.m_positionBuffer.data = this.ReallocateBuffer4(this.m_positionBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_velocityBuffer.data = this.ReallocateBuffer4(this.m_velocityBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_forceBuffer = this.ReallocateBuffer5(this.m_forceBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_weightBuffer = this.ReallocateBuffer5(this.m_weightBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_staticPressureBuffer = this.ReallocateBuffer5(this.m_staticPressureBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_accumulationBuffer = this.ReallocateBuffer5(this.m_accumulationBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_accumulation2Buffer = this.ReallocateBuffer5(this.m_accumulation2Buffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_depthBuffer = this.ReallocateBuffer5(this.m_depthBuffer, 0, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_colorBuffer.data = this.ReallocateBuffer4(this.m_colorBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_groupBuffer = this.ReallocateBuffer5(this.m_groupBuffer, 0, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_userDataBuffer.data = this.ReallocateBuffer4(this.m_userDataBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_expirationTimeBuffer.data = this.ReallocateBuffer4(this.m_expirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, true);\r\n      this.m_indexByExpirationTimeBuffer.data = this.ReallocateBuffer4(this.m_indexByExpirationTimeBuffer, this.m_internalAllocatedCapacity, capacity, false);\r\n      this.m_internalAllocatedCapacity = capacity;\r\n    }\r\n  }\r\n\r\n  public CreateParticleForGroup(groupDef: b2IParticleGroupDef, xf: b2Transform, p: XY): void {\r\n    const particleDef = new b2ParticleDef();\r\n    particleDef.flags = b2Maybe(groupDef.flags, 0);\r\n    ///particleDef.position = b2Mul(xf, p);\r\n    b2Transform.MulXV(xf, p, particleDef.position);\r\n    ///particleDef.velocity =\r\n    ///  groupDef.linearVelocity +\r\n    ///  b2Cross(groupDef.angularVelocity,\r\n    ///      particleDef.position - groupDef.position);\r\n    b2Vec2.AddVV(\r\n      b2Maybe(groupDef.linearVelocity, b2Vec2.ZERO),\r\n      b2Vec2.CrossSV(\r\n        b2Maybe(groupDef.angularVelocity, 0),\r\n        b2Vec2.SubVV(\r\n          particleDef.position,\r\n          b2Maybe(groupDef.position, b2Vec2.ZERO),\r\n          b2Vec2.s_t0,\r\n        ),\r\n        b2Vec2.s_t0,\r\n      ),\r\n      particleDef.velocity,\r\n    );\r\n    particleDef.color.Copy(b2Maybe(groupDef.color, b2Color.ZERO));\r\n    particleDef.lifetime = b2Maybe(groupDef.lifetime, 0);\r\n    particleDef.userData = groupDef.userData;\r\n    this.CreateParticle(particleDef);\r\n  }\r\n\r\n  public CreateParticlesStrokeShapeForGroup(shape: b2Shape, groupDef: b2IParticleGroupDef, xf: b2Transform): void {\r\n    const s_edge = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_edge;\r\n    const s_d = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_d;\r\n    const s_p = b2ParticleSystem.CreateParticlesStrokeShapeForGroup_s_p;\r\n    let stride = b2Maybe(groupDef.stride, 0);\r\n    if (stride === 0) {\r\n      stride = this.GetParticleStride();\r\n    }\r\n    let positionOnEdge = 0;\r\n    const childCount = shape.GetChildCount();\r\n    for (let childIndex = 0; childIndex < childCount; childIndex++) {\r\n      let edge: b2EdgeShape | null = null;\r\n      if (shape.GetType() === b2ShapeType.e_edgeShape) {\r\n        edge = shape as b2EdgeShape;\r\n      } else {\r\n        // DEBUG: b2Assert(shape.GetType() === b2ShapeType.e_chainShape);\r\n        edge = s_edge;\r\n        (shape as b2ChainShape).GetChildEdge(edge, childIndex);\r\n      }\r\n      const d = b2Vec2.SubVV(edge.m_vertex2, edge.m_vertex1, s_d);\r\n      const edgeLength = d.Length();\r\n\r\n      while (positionOnEdge < edgeLength) {\r\n        ///b2Vec2 p = edge.m_vertex1 + positionOnEdge / edgeLength * d;\r\n        const p = b2Vec2.AddVMulSV(edge.m_vertex1, positionOnEdge / edgeLength, d, s_p);\r\n        this.CreateParticleForGroup(groupDef, xf, p);\r\n        positionOnEdge += stride;\r\n      }\r\n      positionOnEdge -= edgeLength;\r\n    }\r\n  }\r\n  public static readonly CreateParticlesStrokeShapeForGroup_s_edge = new b2EdgeShape();\r\n  public static readonly CreateParticlesStrokeShapeForGroup_s_d = new b2Vec2();\r\n  public static readonly CreateParticlesStrokeShapeForGroup_s_p = new b2Vec2();\r\n\r\n  public CreateParticlesFillShapeForGroup(shape: b2Shape, groupDef: b2IParticleGroupDef, xf: b2Transform): void {\r\n    const s_aabb = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_aabb;\r\n    const s_p = b2ParticleSystem.CreateParticlesFillShapeForGroup_s_p;\r\n    let stride = b2Maybe(groupDef.stride, 0);\r\n    if (stride === 0) {\r\n      stride = this.GetParticleStride();\r\n    }\r\n    ///b2Transform identity;\r\n    /// identity.SetIdentity();\r\n    const identity = b2Transform.IDENTITY;\r\n    const aabb = s_aabb;\r\n    // DEBUG: b2Assert(shape.GetChildCount() === 1);\r\n    shape.ComputeAABB(aabb, identity, 0);\r\n    for (let y = Math.floor(aabb.lowerBound.y / stride) * stride; y < aabb.upperBound.y; y += stride) {\r\n      for (let x = Math.floor(aabb.lowerBound.x / stride) * stride; x < aabb.upperBound.x; x += stride) {\r\n        const p = s_p.Set(x, y);\r\n        if (shape.TestPoint(identity, p)) {\r\n          this.CreateParticleForGroup(groupDef, xf, p);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly CreateParticlesFillShapeForGroup_s_aabb = new b2AABB();\r\n  public static readonly CreateParticlesFillShapeForGroup_s_p = new b2Vec2();\r\n\r\n  public CreateParticlesWithShapeForGroup(shape: b2Shape, groupDef: b2IParticleGroupDef, xf: b2Transform): void {\r\n    switch (shape.GetType()) {\r\n      case b2ShapeType.e_edgeShape:\r\n      case b2ShapeType.e_chainShape:\r\n        this.CreateParticlesStrokeShapeForGroup(shape, groupDef, xf);\r\n        break;\r\n      case b2ShapeType.e_polygonShape:\r\n      case b2ShapeType.e_circleShape:\r\n        this.CreateParticlesFillShapeForGroup(shape, groupDef, xf);\r\n        break;\r\n      default:\r\n        // DEBUG: b2Assert(false);\r\n        break;\r\n    }\r\n  }\r\n\r\n  public CreateParticlesWithShapesForGroup(shapes: b2Shape[], shapeCount: number, groupDef: b2IParticleGroupDef, xf: b2Transform): void {\r\n    const compositeShape = new b2ParticleSystem_CompositeShape(shapes, shapeCount);\r\n    this.CreateParticlesFillShapeForGroup(compositeShape, groupDef, xf);\r\n  }\r\n\r\n  public CloneParticle(oldIndex: number, group: b2ParticleGroup): number {\r\n    const def = new b2ParticleDef();\r\n    def.flags = this.m_flagsBuffer.data[oldIndex];\r\n    def.position.Copy(this.m_positionBuffer.data[oldIndex]);\r\n    def.velocity.Copy(this.m_velocityBuffer.data[oldIndex]);\r\n    if (this.m_colorBuffer.data) {\r\n      def.color.Copy(this.m_colorBuffer.data[oldIndex]);\r\n    }\r\n    if (this.m_userDataBuffer.data) {\r\n      def.userData = this.m_userDataBuffer.data[oldIndex];\r\n    }\r\n    def.group = group;\r\n    const newIndex = this.CreateParticle(def);\r\n    if (this.m_handleIndexBuffer.data) {\r\n      const handle = this.m_handleIndexBuffer.data[oldIndex];\r\n      if (handle) { handle.SetIndex(newIndex); }\r\n      this.m_handleIndexBuffer.data[newIndex] = handle;\r\n      this.m_handleIndexBuffer.data[oldIndex] = null;\r\n    }\r\n    if (this.m_lastBodyContactStepBuffer.data) {\r\n      this.m_lastBodyContactStepBuffer.data[newIndex] =\r\n        this.m_lastBodyContactStepBuffer.data[oldIndex];\r\n    }\r\n    if (this.m_bodyContactCountBuffer.data) {\r\n      this.m_bodyContactCountBuffer.data[newIndex] =\r\n        this.m_bodyContactCountBuffer.data[oldIndex];\r\n    }\r\n    if (this.m_consecutiveContactStepsBuffer.data) {\r\n      this.m_consecutiveContactStepsBuffer.data[newIndex] =\r\n        this.m_consecutiveContactStepsBuffer.data[oldIndex];\r\n    }\r\n    if (this.m_hasForce) {\r\n      this.m_forceBuffer[newIndex].Copy(this.m_forceBuffer[oldIndex]);\r\n    }\r\n    if (this.m_staticPressureBuffer) {\r\n      this.m_staticPressureBuffer[newIndex] = this.m_staticPressureBuffer[oldIndex];\r\n    }\r\n    if (this.m_depthBuffer) {\r\n      this.m_depthBuffer[newIndex] = this.m_depthBuffer[oldIndex];\r\n    }\r\n    if (this.m_expirationTimeBuffer.data) {\r\n      this.m_expirationTimeBuffer.data[newIndex] =\r\n        this.m_expirationTimeBuffer.data[oldIndex];\r\n    }\r\n    return newIndex;\r\n  }\r\n\r\n  public DestroyParticlesInGroup(group: b2ParticleGroup, callDestructionListener: boolean = false): void {\r\n    for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n      this.DestroyParticle(i, callDestructionListener);\r\n    }\r\n  }\r\n\r\n  public DestroyParticleGroup(group: b2ParticleGroup): void {\r\n    // DEBUG: b2Assert(this.m_groupCount > 0);\r\n    // DEBUG: b2Assert(group !== null);\r\n\r\n    if (this.m_world.m_destructionListener) {\r\n      this.m_world.m_destructionListener.SayGoodbyeParticleGroup(group);\r\n    }\r\n\r\n    this.SetGroupFlags(group, 0);\r\n    for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n      this.m_groupBuffer[i] = null;\r\n    }\r\n\r\n    if (group.m_prev) {\r\n      group.m_prev.m_next = group.m_next;\r\n    }\r\n    if (group.m_next) {\r\n      group.m_next.m_prev = group.m_prev;\r\n    }\r\n    if (group === this.m_groupList) {\r\n      this.m_groupList = group.m_next;\r\n    }\r\n\r\n    --this.m_groupCount;\r\n  }\r\n\r\n  public static ParticleCanBeConnected(flags: b2ParticleFlag, group: b2ParticleGroup | null): boolean {\r\n    return ((flags & (b2ParticleFlag.b2_wallParticle | b2ParticleFlag.b2_springParticle | b2ParticleFlag.b2_elasticParticle)) !== 0) ||\r\n      ((group !== null) && ((group.GetGroupFlags() & b2ParticleGroupFlag.b2_rigidParticleGroup) !== 0));\r\n  }\r\n\r\n  public UpdatePairsAndTriads(firstIndex: number, lastIndex: number, filter: b2ParticleSystem_ConnectionFilter): void {\r\n    const s_dab = b2ParticleSystem.UpdatePairsAndTriads_s_dab;\r\n    const s_dbc = b2ParticleSystem.UpdatePairsAndTriads_s_dbc;\r\n    const s_dca = b2ParticleSystem.UpdatePairsAndTriads_s_dca;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    // Create pairs or triads.\r\n    // All particles in each pair/triad should satisfy the following:\r\n    // * firstIndex <= index < lastIndex\r\n    // * don't have b2_zombieParticle\r\n    // * ParticleCanBeConnected returns true\r\n    // * ShouldCreatePair/ShouldCreateTriad returns true\r\n    // Any particles in each pair/triad should satisfy the following:\r\n    // * filter.IsNeeded returns true\r\n    // * have one of k_pairFlags/k_triadsFlags\r\n    // DEBUG: b2Assert(firstIndex <= lastIndex);\r\n    let particleFlags = 0;\r\n    for (let i = firstIndex; i < lastIndex; i++) {\r\n      particleFlags |= this.m_flagsBuffer.data[i];\r\n    }\r\n    if (particleFlags & b2ParticleSystem.k_pairFlags) {\r\n      for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n        const contact = this.m_contactBuffer.data[k];\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        const af = this.m_flagsBuffer.data[a];\r\n        const bf = this.m_flagsBuffer.data[b];\r\n        const groupA = this.m_groupBuffer[a];\r\n        const groupB = this.m_groupBuffer[b];\r\n        if (a >= firstIndex && a < lastIndex &&\r\n          b >= firstIndex && b < lastIndex &&\r\n          !((af | bf) & b2ParticleFlag.b2_zombieParticle) &&\r\n          ((af | bf) & b2ParticleSystem.k_pairFlags) &&\r\n          (filter.IsNecessary(a) || filter.IsNecessary(b)) &&\r\n          b2ParticleSystem.ParticleCanBeConnected(af, groupA) &&\r\n          b2ParticleSystem.ParticleCanBeConnected(bf, groupB) &&\r\n          filter.ShouldCreatePair(a, b)) {\r\n          ///b2ParticlePair& pair = m_pairBuffer.Append();\r\n          const pair = this.m_pairBuffer.data[this.m_pairBuffer.Append()];\r\n          pair.indexA = a;\r\n          pair.indexB = b;\r\n          pair.flags = contact.flags;\r\n          pair.strength = b2Min(\r\n            groupA ? groupA.m_strength : 1,\r\n            groupB ? groupB.m_strength : 1);\r\n          ///pair.distance = b2Distance(pos_data[a], pos_data[b]); // TODO: this was wrong!\r\n          pair.distance = b2Vec2.DistanceVV(pos_data[a], pos_data[b]);\r\n        }\r\n        ///std::stable_sort(m_pairBuffer.Begin(), m_pairBuffer.End(), ComparePairIndices);\r\n        std_stable_sort(this.m_pairBuffer.data, 0, this.m_pairBuffer.count, b2ParticleSystem.ComparePairIndices);\r\n        ///m_pairBuffer.Unique(MatchPairIndices);\r\n        this.m_pairBuffer.Unique(b2ParticleSystem.MatchPairIndices);\r\n      }\r\n    }\r\n    if (particleFlags & b2ParticleSystem.k_triadFlags) {\r\n      const diagram = new b2VoronoiDiagram(lastIndex - firstIndex);\r\n      ///let necessary_count = 0;\r\n      for (let i = firstIndex; i < lastIndex; i++) {\r\n        const flags = this.m_flagsBuffer.data[i];\r\n        const group = this.m_groupBuffer[i];\r\n        if (!(flags & b2ParticleFlag.b2_zombieParticle) &&\r\n          b2ParticleSystem.ParticleCanBeConnected(flags, group)) {\r\n          ///if (filter.IsNecessary(i)) {\r\n          ///++necessary_count;\r\n          ///}\r\n          diagram.AddGenerator(pos_data[i], i, filter.IsNecessary(i));\r\n        }\r\n      }\r\n      ///if (necessary_count === 0) {\r\n      /////debugger;\r\n      ///for (let i = firstIndex; i < lastIndex; i++) {\r\n      ///  filter.IsNecessary(i);\r\n      ///}\r\n      ///}\r\n      const stride = this.GetParticleStride();\r\n      diagram.Generate(stride / 2, stride * 2);\r\n      const system = this;\r\n      const callback = /*UpdateTriadsCallback*/(a: number, b: number, c: number): void => {\r\n        const af = system.m_flagsBuffer.data[a];\r\n        const bf = system.m_flagsBuffer.data[b];\r\n        const cf = system.m_flagsBuffer.data[c];\r\n        if (((af | bf | cf) & b2ParticleSystem.k_triadFlags) &&\r\n          filter.ShouldCreateTriad(a, b, c)) {\r\n          const pa = pos_data[a];\r\n          const pb = pos_data[b];\r\n          const pc = pos_data[c];\r\n          const dab = b2Vec2.SubVV(pa, pb, s_dab);\r\n          const dbc = b2Vec2.SubVV(pb, pc, s_dbc);\r\n          const dca = b2Vec2.SubVV(pc, pa, s_dca);\r\n          const maxDistanceSquared = b2_maxTriadDistanceSquared * system.m_squaredDiameter;\r\n          if (b2Vec2.DotVV(dab, dab) > maxDistanceSquared ||\r\n            b2Vec2.DotVV(dbc, dbc) > maxDistanceSquared ||\r\n            b2Vec2.DotVV(dca, dca) > maxDistanceSquared) {\r\n            return;\r\n          }\r\n          const groupA = system.m_groupBuffer[a];\r\n          const groupB = system.m_groupBuffer[b];\r\n          const groupC = system.m_groupBuffer[c];\r\n          ///b2ParticleTriad& triad = m_system.m_triadBuffer.Append();\r\n          const triad = system.m_triadBuffer.data[system.m_triadBuffer.Append()];\r\n          triad.indexA = a;\r\n          triad.indexB = b;\r\n          triad.indexC = c;\r\n          triad.flags = af | bf | cf;\r\n          triad.strength = b2Min(b2Min(\r\n              groupA ? groupA.m_strength : 1,\r\n              groupB ? groupB.m_strength : 1),\r\n            groupC ? groupC.m_strength : 1);\r\n          ///let midPoint = b2Vec2.MulSV(1.0 / 3.0, b2Vec2.AddVV(pa, b2Vec2.AddVV(pb, pc, new b2Vec2()), new b2Vec2()), new b2Vec2());\r\n          const midPoint_x = (pa.x + pb.x + pc.x) / 3.0;\r\n          const midPoint_y = (pa.y + pb.y + pc.y) / 3.0;\r\n          ///triad.pa = b2Vec2.SubVV(pa, midPoint, new b2Vec2());\r\n          triad.pa.x = pa.x - midPoint_x;\r\n          triad.pa.y = pa.y - midPoint_y;\r\n          ///triad.pb = b2Vec2.SubVV(pb, midPoint, new b2Vec2());\r\n          triad.pb.x = pb.x - midPoint_x;\r\n          triad.pb.y = pb.y - midPoint_y;\r\n          ///triad.pc = b2Vec2.SubVV(pc, midPoint, new b2Vec2());\r\n          triad.pc.x = pc.x - midPoint_x;\r\n          triad.pc.y = pc.y - midPoint_y;\r\n          triad.ka = -b2Vec2.DotVV(dca, dab);\r\n          triad.kb = -b2Vec2.DotVV(dab, dbc);\r\n          triad.kc = -b2Vec2.DotVV(dbc, dca);\r\n          triad.s = b2Vec2.CrossVV(pa, pb) + b2Vec2.CrossVV(pb, pc) + b2Vec2.CrossVV(pc, pa);\r\n        }\r\n      };\r\n      diagram.GetNodes(callback);\r\n      ///std::stable_sort(m_triadBuffer.Begin(), m_triadBuffer.End(), CompareTriadIndices);\r\n      std_stable_sort(this.m_triadBuffer.data, 0, this.m_triadBuffer.count, b2ParticleSystem.CompareTriadIndices);\r\n      ///m_triadBuffer.Unique(MatchTriadIndices);\r\n      this.m_triadBuffer.Unique(b2ParticleSystem.MatchTriadIndices);\r\n    }\r\n  }\r\n  private static UpdatePairsAndTriads_s_dab = new b2Vec2();\r\n  private static UpdatePairsAndTriads_s_dbc = new b2Vec2();\r\n  private static UpdatePairsAndTriads_s_dca = new b2Vec2();\r\n\r\n  public UpdatePairsAndTriadsWithReactiveParticles(): void {\r\n    const filter = new b2ParticleSystem_ReactiveFilter(this.m_flagsBuffer);\r\n    this.UpdatePairsAndTriads(0, this.m_count, filter);\r\n\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      this.m_flagsBuffer.data[i] &= ~b2ParticleFlag.b2_reactiveParticle;\r\n    }\r\n    this.m_allParticleFlags &= ~b2ParticleFlag.b2_reactiveParticle;\r\n  }\r\n\r\n  public static ComparePairIndices(a: b2ParticlePair, b: b2ParticlePair): boolean {\r\n    const diffA = a.indexA - b.indexA;\r\n    if (diffA !== 0) { return diffA < 0; }\r\n    return a.indexB < b.indexB;\r\n  }\r\n\r\n  public static MatchPairIndices(a: b2ParticlePair, b: b2ParticlePair): boolean {\r\n    return a.indexA === b.indexA && a.indexB === b.indexB;\r\n  }\r\n\r\n  public static CompareTriadIndices(a: b2ParticleTriad, b: b2ParticleTriad): boolean {\r\n    const diffA = a.indexA - b.indexA;\r\n    if (diffA !== 0) { return diffA < 0; }\r\n    const diffB = a.indexB - b.indexB;\r\n    if (diffB !== 0) { return diffB < 0; }\r\n    return a.indexC < b.indexC;\r\n  }\r\n\r\n  public static MatchTriadIndices(a: b2ParticleTriad, b: b2ParticleTriad): boolean {\r\n    return a.indexA === b.indexA && a.indexB === b.indexB && a.indexC === b.indexC;\r\n  }\r\n\r\n  public static InitializeParticleLists(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[]): void {\r\n    const bufferIndex = group.GetBufferIndex();\r\n    const particleCount = group.GetParticleCount();\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const node: b2ParticleSystem_ParticleListNode = nodeBuffer[i];\r\n      node.list = node;\r\n      node.next = null;\r\n      node.count = 1;\r\n      node.index = i + bufferIndex;\r\n    }\r\n  }\r\n\r\n  public MergeParticleListsInContact(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[]): void {\r\n    const bufferIndex = group.GetBufferIndex();\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      /*const b2ParticleContact&*/\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      if (!group.ContainsParticle(a) || !group.ContainsParticle(b)) {\r\n        continue;\r\n      }\r\n      let listA: b2ParticleSystem_ParticleListNode = nodeBuffer[a - bufferIndex].list;\r\n      let listB: b2ParticleSystem_ParticleListNode = nodeBuffer[b - bufferIndex].list;\r\n      if (listA === listB) {\r\n        continue;\r\n      }\r\n      // To minimize the cost of insertion, make sure listA is longer than\r\n      // listB.\r\n      if (listA.count < listB.count) {\r\n        const _tmp = listA;\r\n        listA = listB;\r\n        listB = _tmp; ///b2Swap(listA, listB);\r\n      }\r\n      // DEBUG: b2Assert(listA.count >= listB.count);\r\n      b2ParticleSystem.MergeParticleLists(listA, listB);\r\n    }\r\n  }\r\n\r\n  public static MergeParticleLists(listA: b2ParticleSystem_ParticleListNode, listB: b2ParticleSystem_ParticleListNode): void {\r\n    // Insert listB between index 0 and 1 of listA\r\n    // Example:\r\n    //     listA => a1 => a2 => a3 => null\r\n    //     listB => b1 => b2 => null\r\n    // to\r\n    //     listA => listB => b1 => b2 => a1 => a2 => a3 => null\r\n    // DEBUG: b2Assert(listA !== listB);\r\n    for (let b: b2ParticleSystem_ParticleListNode = listB; ; ) {\r\n      b.list = listA;\r\n      const nextB: b2ParticleSystem_ParticleListNode | null = b.next;\r\n      if (nextB) {\r\n        b = nextB;\r\n      } else {\r\n        b.next = listA.next;\r\n        break;\r\n      }\r\n    }\r\n    listA.next = listB;\r\n    listA.count += listB.count;\r\n    listB.count = 0;\r\n  }\r\n\r\n  public static FindLongestParticleList(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[]): b2ParticleSystem_ParticleListNode {\r\n    const particleCount = group.GetParticleCount();\r\n    let result: b2ParticleSystem_ParticleListNode = nodeBuffer[0];\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const node: b2ParticleSystem_ParticleListNode = nodeBuffer[i];\r\n      if (result.count < node.count) {\r\n        result = node;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  public MergeZombieParticleListNodes(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[], survivingList: b2ParticleSystem_ParticleListNode): void {\r\n    const particleCount = group.GetParticleCount();\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const node: b2ParticleSystem_ParticleListNode = nodeBuffer[i];\r\n      if (node !== survivingList &&\r\n        (this.m_flagsBuffer.data[node.index] & b2ParticleFlag.b2_zombieParticle)) {\r\n        b2ParticleSystem.MergeParticleListAndNode(survivingList, node);\r\n      }\r\n    }\r\n  }\r\n\r\n  public static MergeParticleListAndNode(list: b2ParticleSystem_ParticleListNode, node: b2ParticleSystem_ParticleListNode): void {\r\n    // Insert node between index 0 and 1 of list\r\n    // Example:\r\n    //     list => a1 => a2 => a3 => null\r\n    //     node => null\r\n    // to\r\n    //     list => node => a1 => a2 => a3 => null\r\n    // DEBUG: b2Assert(node !== list);\r\n    // DEBUG: b2Assert(node.list === node);\r\n    // DEBUG: b2Assert(node.count === 1);\r\n    node.list = list;\r\n    node.next = list.next;\r\n    list.next = node;\r\n    list.count++;\r\n    node.count = 0;\r\n  }\r\n\r\n  public CreateParticleGroupsFromParticleList(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[], survivingList: b2ParticleSystem_ParticleListNode): void {\r\n    const particleCount = group.GetParticleCount();\r\n    const def = new b2ParticleGroupDef();\r\n    def.groupFlags = group.GetGroupFlags();\r\n    def.userData = group.GetUserData();\r\n    for (let i = 0; i < particleCount; i++) {\r\n      const list: b2ParticleSystem_ParticleListNode = nodeBuffer[i];\r\n      if (!list.count || list === survivingList) {\r\n        continue;\r\n      }\r\n      // DEBUG: b2Assert(list.list === list);\r\n      const newGroup: b2ParticleGroup = this.CreateParticleGroup(def);\r\n      for (let node: b2ParticleSystem_ParticleListNode | null = list; node; node = node.next) {\r\n        const oldIndex = node.index;\r\n        // DEBUG: const flags = this.m_flagsBuffer.data[oldIndex];\r\n        // DEBUG: b2Assert(!(flags & b2ParticleFlag.b2_zombieParticle));\r\n        const newIndex = this.CloneParticle(oldIndex, newGroup);\r\n        this.m_flagsBuffer.data[oldIndex] |= b2ParticleFlag.b2_zombieParticle;\r\n        node.index = newIndex;\r\n      }\r\n    }\r\n  }\r\n\r\n  public UpdatePairsAndTriadsWithParticleList(group: b2ParticleGroup, nodeBuffer: b2ParticleSystem_ParticleListNode[]): void {\r\n    const bufferIndex = group.GetBufferIndex();\r\n    // Update indices in pairs and triads. If an index belongs to the group,\r\n    // replace it with the corresponding value in nodeBuffer.\r\n    // Note that nodeBuffer is allocated only for the group and the index should\r\n    // be shifted by bufferIndex.\r\n    for (let k = 0; k < this.m_pairBuffer.count; k++) {\r\n      const pair = this.m_pairBuffer.data[k];\r\n      const a = pair.indexA;\r\n      const b = pair.indexB;\r\n      if (group.ContainsParticle(a)) {\r\n        pair.indexA = nodeBuffer[a - bufferIndex].index;\r\n      }\r\n      if (group.ContainsParticle(b)) {\r\n        pair.indexB = nodeBuffer[b - bufferIndex].index;\r\n      }\r\n    }\r\n    for (let k = 0; k < this.m_triadBuffer.count; k++) {\r\n      const triad = this.m_triadBuffer.data[k];\r\n      const a = triad.indexA;\r\n      const b = triad.indexB;\r\n      const c = triad.indexC;\r\n      if (group.ContainsParticle(a)) {\r\n        triad.indexA = nodeBuffer[a - bufferIndex].index;\r\n      }\r\n      if (group.ContainsParticle(b)) {\r\n        triad.indexB = nodeBuffer[b - bufferIndex].index;\r\n      }\r\n      if (group.ContainsParticle(c)) {\r\n        triad.indexC = nodeBuffer[c - bufferIndex].index;\r\n      }\r\n    }\r\n  }\r\n\r\n  public ComputeDepth(): void {\r\n    const contactGroups: b2ParticleContact[] = []; // TODO: static\r\n    let contactGroupsCount = 0;\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const groupA = this.m_groupBuffer[a];\r\n      const groupB = this.m_groupBuffer[b];\r\n      if (groupA && groupA === groupB &&\r\n        (groupA.m_groupFlags & b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth)) {\r\n        contactGroups[contactGroupsCount++] = contact;\r\n      }\r\n    }\r\n    const groupsToUpdate: b2ParticleGroup[] = []; // TODO: static\r\n    let groupsToUpdateCount = 0;\r\n    for (let group = this.m_groupList; group; group = group.GetNext()) {\r\n      if (group.m_groupFlags & b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {\r\n        groupsToUpdate[groupsToUpdateCount++] = group;\r\n        this.SetGroupFlags(group,\r\n          group.m_groupFlags &\r\n          ~b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);\r\n        for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n          this.m_accumulationBuffer[i] = 0;\r\n        }\r\n      }\r\n    }\r\n    // Compute sum of weight of contacts except between different groups.\r\n    for (let k = 0; k < contactGroupsCount; k++) {\r\n      const contact = contactGroups[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const w = contact.weight;\r\n      this.m_accumulationBuffer[a] += w;\r\n      this.m_accumulationBuffer[b] += w;\r\n    }\r\n\r\n    // DEBUG: b2Assert(this.m_depthBuffer !== null);\r\n    for (let i = 0; i < groupsToUpdateCount; i++) {\r\n      const group = groupsToUpdate[i];\r\n      for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n        const w = this.m_accumulationBuffer[i];\r\n        this.m_depthBuffer[i] = w < 0.8 ? 0 : b2_maxFloat;\r\n      }\r\n    }\r\n    // The number of iterations is equal to particle number from the deepest\r\n    // particle to the nearest surface particle, and in general it is smaller\r\n    // than sqrt of total particle number.\r\n    ///int32 iterationCount = (int32)b2Sqrt((float)m_count);\r\n    const iterationCount = b2Sqrt(this.m_count) >> 0;\r\n    for (let t = 0; t < iterationCount; t++) {\r\n      let updated = false;\r\n      for (let k = 0; k < contactGroupsCount; k++) {\r\n        const contact = contactGroups[k];\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        const r = 1 - contact.weight;\r\n        ///float32& ap0 = m_depthBuffer[a];\r\n        const ap0 = this.m_depthBuffer[a];\r\n        ///float32& bp0 = m_depthBuffer[b];\r\n        const bp0 = this.m_depthBuffer[b];\r\n        const ap1 = bp0 + r;\r\n        const bp1 = ap0 + r;\r\n        if (ap0 > ap1) {\r\n          ///ap0 = ap1;\r\n          this.m_depthBuffer[a] = ap1;\r\n          updated = true;\r\n        }\r\n        if (bp0 > bp1) {\r\n          ///bp0 = bp1;\r\n          this.m_depthBuffer[b] = bp1;\r\n          updated = true;\r\n        }\r\n      }\r\n      if (!updated) {\r\n        break;\r\n      }\r\n    }\r\n    for (let i = 0; i < groupsToUpdateCount; i++) {\r\n      const group = groupsToUpdate[i];\r\n      for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n        if (this.m_depthBuffer[i] < b2_maxFloat) {\r\n          this.m_depthBuffer[i] *= this.m_particleDiameter;\r\n        } else {\r\n          this.m_depthBuffer[i] = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public GetInsideBoundsEnumerator(aabb: Readonly<b2AABB>): b2ParticleSystem_InsideBoundsEnumerator {\r\n    const lowerTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.lowerBound.x - 1,\r\n      this.m_inverseDiameter * aabb.lowerBound.y - 1);\r\n    const upperTag = b2ParticleSystem.computeTag(this.m_inverseDiameter * aabb.upperBound.x + 1,\r\n      this.m_inverseDiameter * aabb.upperBound.y + 1);\r\n    ///const Proxy* beginProxy = m_proxyBuffer.Begin();\r\n    const beginProxy = 0;\r\n    ///const Proxy* endProxy = m_proxyBuffer.End();\r\n    const endProxy = this.m_proxyBuffer.count;\r\n    ///const Proxy* firstProxy = std::lower_bound(beginProxy, endProxy, lowerTag);\r\n    const firstProxy = std_lower_bound(this.m_proxyBuffer.data, beginProxy, endProxy, lowerTag, b2ParticleSystem_Proxy.CompareProxyTag);\r\n    ///const Proxy* lastProxy = std::upper_bound(firstProxy, endProxy, upperTag);\r\n    const lastProxy = std_upper_bound(this.m_proxyBuffer.data, beginProxy, endProxy, upperTag, b2ParticleSystem_Proxy.CompareTagProxy);\r\n\r\n    // DEBUG: b2Assert(beginProxy <= firstProxy);\r\n    // DEBUG: b2Assert(firstProxy <= lastProxy);\r\n    // DEBUG: b2Assert(lastProxy <= endProxy);\r\n\r\n    return new b2ParticleSystem_InsideBoundsEnumerator(this, lowerTag, upperTag, firstProxy, lastProxy);\r\n  }\r\n\r\n  public UpdateAllParticleFlags(): void {\r\n    this.m_allParticleFlags = 0;\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      this.m_allParticleFlags |= this.m_flagsBuffer.data[i];\r\n    }\r\n    this.m_needsUpdateAllParticleFlags = false;\r\n  }\r\n\r\n  public UpdateAllGroupFlags(): void {\r\n    this.m_allGroupFlags = 0;\r\n    for (let group = this.m_groupList; group; group = group.GetNext()) {\r\n      this.m_allGroupFlags |= group.m_groupFlags;\r\n    }\r\n    this.m_needsUpdateAllGroupFlags = false;\r\n  }\r\n\r\n  public AddContact(a: number, b: number, contacts: b2GrowableBuffer<b2ParticleContact>): void {\r\n    // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n    const flags_data = this.m_flagsBuffer.data;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    ///b2Vec2 d = m_positionBuffer.data[b] - m_positionBuffer.data[a];\r\n    const d = b2Vec2.SubVV(pos_data[b], pos_data[a], b2ParticleSystem.AddContact_s_d);\r\n    const distBtParticlesSq = b2Vec2.DotVV(d, d);\r\n    if (0 < distBtParticlesSq && distBtParticlesSq < this.m_squaredDiameter) {\r\n      let invD = b2InvSqrt(distBtParticlesSq);\r\n      ///b2ParticleContact& contact = contacts.Append();\r\n      const contact = this.m_contactBuffer.data[this.m_contactBuffer.Append()];\r\n      contact.indexA = a;\r\n      contact.indexB = b;\r\n      contact.flags = flags_data[a] | flags_data[b];\r\n      contact.weight = 1 - distBtParticlesSq * invD * this.m_inverseDiameter;\r\n      contact.normal.x = invD * d.x;\r\n      contact.normal.y = invD * d.y;\r\n    }\r\n  }\r\n  public static readonly AddContact_s_d = new b2Vec2();\r\n\r\n  public FindContacts_Reference(contacts: b2GrowableBuffer<b2ParticleContact>): void {\r\n    // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n    const beginProxy = 0;\r\n    const endProxy = this.m_proxyBuffer.count;\r\n\r\n    this.m_contactBuffer.count = 0;\r\n    for (let a = beginProxy, c = beginProxy; a < endProxy; a++) {\r\n      const rightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 0);\r\n      for (let b = a + 1; b < endProxy; b++) {\r\n        if (rightTag < this.m_proxyBuffer.data[b].tag) { break; }\r\n        this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);\r\n      }\r\n      const bottomLeftTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, -1, 1);\r\n      for (; c < endProxy; c++) {\r\n        if (bottomLeftTag <= this.m_proxyBuffer.data[c].tag) { break; }\r\n      }\r\n      const bottomRightTag = b2ParticleSystem.computeRelativeTag(this.m_proxyBuffer.data[a].tag, 1, 1);\r\n      for (let b = c; b < endProxy; b++) {\r\n        if (bottomRightTag < this.m_proxyBuffer.data[b].tag) { break; }\r\n        this.AddContact(this.m_proxyBuffer.data[a].index, this.m_proxyBuffer.data[b].index, this.m_contactBuffer);\r\n      }\r\n    }\r\n  }\r\n\r\n  ///void ReorderForFindContact(FindContactInput* reordered, int alignedCount) const;\r\n  ///void GatherChecksOneParticle(const uint32 bound, const int startIndex, const int particleIndex, int* nextUncheckedIndex, b2GrowableBuffer<FindContactCheck>& checks) const;\r\n  ///void GatherChecks(b2GrowableBuffer<FindContactCheck>& checks) const;\r\n  ///void FindContacts_Simd(b2GrowableBuffer<b2ParticleContact>& contacts) const;\r\n\r\n  public FindContacts(contacts: b2GrowableBuffer<b2ParticleContact>): void {\r\n    this.FindContacts_Reference(contacts);\r\n  }\r\n\r\n  ///static void UpdateProxyTags(const uint32* const tags, b2GrowableBuffer<Proxy>& proxies);\r\n  ///static bool ProxyBufferHasIndex(int32 index, const Proxy* const a, int count);\r\n  ///static int NumProxiesWithSameTag(const Proxy* const a, const Proxy* const b, int count);\r\n  ///static bool AreProxyBuffersTheSame(const b2GrowableBuffer<Proxy>& a, const b2GrowableBuffer<Proxy>& b);\r\n\r\n  public UpdateProxies_Reference(proxies: b2GrowableBuffer<b2ParticleSystem_Proxy>): void {\r\n    // DEBUG: b2Assert(proxies === this.m_proxyBuffer);\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const inv_diam = this.m_inverseDiameter;\r\n    for (let k = 0; k < this.m_proxyBuffer.count; ++k) {\r\n      const proxy = this.m_proxyBuffer.data[k];\r\n      const i = proxy.index;\r\n      const p = pos_data[i];\r\n      proxy.tag = b2ParticleSystem.computeTag(inv_diam * p.x, inv_diam * p.y);\r\n    }\r\n  }\r\n\r\n  ///void UpdateProxies_Simd(b2GrowableBuffer<Proxy>& proxies) const;\r\n\r\n  public UpdateProxies(proxies: b2GrowableBuffer<b2ParticleSystem_Proxy>): void {\r\n    this.UpdateProxies_Reference(proxies);\r\n  }\r\n\r\n  public SortProxies(proxies: b2GrowableBuffer<b2ParticleSystem_Proxy>): void {\r\n    // DEBUG: b2Assert(proxies === this.m_proxyBuffer);\r\n\r\n    ///std::sort(proxies.Begin(), proxies.End());\r\n    std_sort(this.m_proxyBuffer.data, 0, this.m_proxyBuffer.count, b2ParticleSystem_Proxy.CompareProxyProxy);\r\n  }\r\n\r\n  public FilterContacts(contacts: b2GrowableBuffer<b2ParticleContact>): void {\r\n    // Optionally filter the contact.\r\n    const contactFilter = this.GetParticleContactFilter();\r\n    if (contactFilter === null) {\r\n      return;\r\n    }\r\n\r\n    /// contacts.RemoveIf(b2ParticleContactRemovePredicate(this, contactFilter));\r\n    // DEBUG: b2Assert(contacts === this.m_contactBuffer);\r\n    const system = this;\r\n    const predicate = (contact: b2ParticleContact): boolean => {\r\n      return ((contact.flags & b2ParticleFlag.b2_particleContactFilterParticle) !== 0) && !contactFilter.ShouldCollideParticleParticle(system, contact.indexA, contact.indexB);\r\n    };\r\n    this.m_contactBuffer.RemoveIf(predicate);\r\n  }\r\n\r\n  public NotifyContactListenerPreContact(particlePairs: b2ParticlePairSet): void {\r\n    const contactListener = this.GetParticleContactListener();\r\n    if (contactListener === null) {\r\n      return;\r\n    }\r\n\r\n    ///particlePairs.Initialize(m_contactBuffer.Begin(), m_contactBuffer.GetCount(), GetFlagsBuffer());\r\n    particlePairs.Initialize(this.m_contactBuffer, this.m_flagsBuffer);\r\n\r\n    throw new Error(); // TODO: notify\r\n  }\r\n\r\n  public NotifyContactListenerPostContact(particlePairs: b2ParticlePairSet): void {\r\n    const contactListener = this.GetParticleContactListener();\r\n    if (contactListener === null) {\r\n      return;\r\n    }\r\n\r\n    // Loop through all new contacts, reporting any new ones, and\r\n    // \"invalidating\" the ones that still exist.\r\n    ///const b2ParticleContact* const endContact = m_contactBuffer.End();\r\n    ///for (b2ParticleContact* contact = m_contactBuffer.Begin(); contact < endContact; ++contact)\r\n    for (let k = 0; k < this.m_contactBuffer.count; ++k) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      ///ParticlePair pair;\r\n      ///pair.first = contact.GetIndexA();\r\n      ///pair.second = contact.GetIndexB();\r\n      ///const int32 itemIndex = particlePairs.Find(pair);\r\n      const itemIndex = -1; // TODO\r\n      if (itemIndex >= 0) {\r\n        // Already touching, ignore this contact.\r\n        particlePairs.Invalidate(itemIndex);\r\n      } else {\r\n        // Just started touching, inform the listener.\r\n        contactListener.BeginContactParticleParticle(this, contact);\r\n      }\r\n    }\r\n\r\n    // Report particles that are no longer touching.\r\n    // That is, any pairs that were not invalidated above.\r\n    ///const int32 pairCount = particlePairs.GetCount();\r\n    ///const ParticlePair* const pairs = particlePairs.GetBuffer();\r\n    ///const int8* const valid = particlePairs.GetValidBuffer();\r\n    ///for (int32 i = 0; i < pairCount; ++i)\r\n    ///{\r\n    ///  if (valid[i])\r\n    ///  {\r\n    ///    contactListener.EndContactParticleParticle(this, pairs[i].first, pairs[i].second);\r\n    ///  }\r\n    ///}\r\n\r\n    throw new Error(); // TODO: notify\r\n  }\r\n\r\n  public static b2ParticleContactIsZombie(contact: b2ParticleContact): boolean {\r\n    return (contact.flags & b2ParticleFlag.b2_zombieParticle) === b2ParticleFlag.b2_zombieParticle;\r\n  }\r\n\r\n  public UpdateContacts(exceptZombie: boolean): void {\r\n    this.UpdateProxies(this.m_proxyBuffer);\r\n    this.SortProxies(this.m_proxyBuffer);\r\n\r\n    const particlePairs = new b2ParticlePairSet(); // TODO: static\r\n    this.NotifyContactListenerPreContact(particlePairs);\r\n\r\n    this.FindContacts(this.m_contactBuffer);\r\n    this.FilterContacts(this.m_contactBuffer);\r\n\r\n    this.NotifyContactListenerPostContact(particlePairs);\r\n\r\n    if (exceptZombie) {\r\n      this.m_contactBuffer.RemoveIf(b2ParticleSystem.b2ParticleContactIsZombie);\r\n    }\r\n  }\r\n\r\n  public NotifyBodyContactListenerPreContact(fixtureSet: b2ParticleSystem_FixtureParticleSet): void {\r\n    const contactListener = this.GetFixtureContactListener();\r\n    if (contactListener === null) {\r\n      return;\r\n    }\r\n\r\n    ///fixtureSet.Initialize(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.GetCount(), GetFlagsBuffer());\r\n    fixtureSet.Initialize(this.m_bodyContactBuffer, this.m_flagsBuffer);\r\n\r\n    throw new Error(); // TODO: notify\r\n  }\r\n\r\n  public NotifyBodyContactListenerPostContact(fixtureSet: b2ParticleSystem_FixtureParticleSet): void {\r\n    const contactListener = this.GetFixtureContactListener();\r\n    if (contactListener === null) {\r\n      return;\r\n    }\r\n\r\n    // Loop through all new contacts, reporting any new ones, and\r\n    // \"invalidating\" the ones that still exist.\r\n    ///for (b2ParticleBodyContact* contact = m_bodyContactBuffer.Begin(); contact !== m_bodyContactBuffer.End(); ++contact)\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      // DEBUG: b2Assert(contact !== null);\r\n      ///FixtureParticle fixtureParticleToFind;\r\n      ///fixtureParticleToFind.first = contact.fixture;\r\n      ///fixtureParticleToFind.second = contact.index;\r\n      ///const int32 index = fixtureSet.Find(fixtureParticleToFind);\r\n      const index = -1; // TODO\r\n      if (index >= 0) {\r\n        // Already touching remove this from the set.\r\n        fixtureSet.Invalidate(index);\r\n      } else {\r\n        // Just started touching, report it!\r\n        contactListener.BeginContactFixtureParticle(this, contact);\r\n      }\r\n    }\r\n\r\n    // If the contact listener is enabled, report all fixtures that are no\r\n    // longer in contact with particles.\r\n    ///const FixtureParticle* const fixtureParticles = fixtureSet.GetBuffer();\r\n    ///const int8* const fixtureParticlesValid = fixtureSet.GetValidBuffer();\r\n    ///const int32 fixtureParticleCount = fixtureSet.GetCount();\r\n    ///for (int32 i = 0; i < fixtureParticleCount; ++i)\r\n    ///{\r\n    ///  if (fixtureParticlesValid[i])\r\n    ///  {\r\n    ///    const FixtureParticle* const fixtureParticle = &fixtureParticles[i];\r\n    ///    contactListener.EndContactFixtureParticle(fixtureParticle.first, this, fixtureParticle.second);\r\n    ///  }\r\n    ///}\r\n\r\n    throw new Error(); // TODO: notify\r\n  }\r\n\r\n  public UpdateBodyContacts(): void {\r\n    const s_aabb = b2ParticleSystem.UpdateBodyContacts_s_aabb;\r\n\r\n    // If the particle contact listener is enabled, generate a set of\r\n    // fixture / particle contacts.\r\n    const fixtureSet = new b2ParticleSystem_FixtureParticleSet(); // TODO: static\r\n    this.NotifyBodyContactListenerPreContact(fixtureSet);\r\n\r\n    if (this.m_stuckThreshold > 0) {\r\n      const particleCount = this.GetParticleCount();\r\n      for (let i = 0; i < particleCount; i++) {\r\n        // Detect stuck particles, see comment in\r\n        // b2ParticleSystem::DetectStuckParticle()\r\n        this.m_bodyContactCountBuffer.data[i] = 0;\r\n        if (this.m_timestamp > (this.m_lastBodyContactStepBuffer.data[i] + 1)) {\r\n          this.m_consecutiveContactStepsBuffer.data[i] = 0;\r\n        }\r\n      }\r\n    }\r\n    this.m_bodyContactBuffer.SetCount(0);\r\n    this.m_stuckParticleBuffer.SetCount(0);\r\n\r\n    const aabb = s_aabb;\r\n    this.ComputeAABB(aabb);\r\n\r\n    if (this.UpdateBodyContacts_callback === null) {\r\n      this.UpdateBodyContacts_callback = new b2ParticleSystem_UpdateBodyContactsCallback(this);\r\n    }\r\n    const callback = this.UpdateBodyContacts_callback;\r\n    callback.m_contactFilter = this.GetFixtureContactFilter();\r\n    this.m_world.QueryAABB(callback, aabb);\r\n\r\n    if (this.m_def.strictContactCheck) {\r\n      this.RemoveSpuriousBodyContacts();\r\n    }\r\n\r\n    this.NotifyBodyContactListenerPostContact(fixtureSet);\r\n  }\r\n  public static readonly UpdateBodyContacts_s_aabb = new b2AABB();\r\n  public UpdateBodyContacts_callback: b2ParticleSystem_UpdateBodyContactsCallback | null = null;\r\n\r\n  public Solve(step: b2TimeStep): void {\r\n    const s_subStep = b2ParticleSystem.Solve_s_subStep;\r\n    if (this.m_count === 0) {\r\n      return;\r\n    }\r\n    // If particle lifetimes are enabled, destroy particles that are too old.\r\n    if (this.m_expirationTimeBuffer.data) {\r\n      this.SolveLifetimes(step);\r\n    }\r\n    if (this.m_allParticleFlags & b2ParticleFlag.b2_zombieParticle) {\r\n      this.SolveZombie();\r\n    }\r\n    if (this.m_needsUpdateAllParticleFlags) {\r\n      this.UpdateAllParticleFlags();\r\n    }\r\n    if (this.m_needsUpdateAllGroupFlags) {\r\n      this.UpdateAllGroupFlags();\r\n    }\r\n    if (this.m_paused) {\r\n      return;\r\n    }\r\n    for (this.m_iterationIndex = 0; this.m_iterationIndex < step.particleIterations; this.m_iterationIndex++) {\r\n      ++this.m_timestamp;\r\n      const subStep = s_subStep.Copy(step);\r\n      subStep.dt /= step.particleIterations;\r\n      subStep.inv_dt *= step.particleIterations;\r\n      this.UpdateContacts(false);\r\n      this.UpdateBodyContacts();\r\n      this.ComputeWeight();\r\n      if (this.m_allGroupFlags & b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth) {\r\n        this.ComputeDepth();\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_reactiveParticle) {\r\n        this.UpdatePairsAndTriadsWithReactiveParticles();\r\n      }\r\n      if (this.m_hasForce) {\r\n        this.SolveForce(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_viscousParticle) {\r\n        this.SolveViscous();\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_repulsiveParticle) {\r\n        this.SolveRepulsive(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_powderParticle) {\r\n        this.SolvePowder(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_tensileParticle) {\r\n        this.SolveTensile(subStep);\r\n      }\r\n      if (this.m_allGroupFlags & b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n        this.SolveSolid(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_colorMixingParticle) {\r\n        this.SolveColorMixing();\r\n      }\r\n      this.SolveGravity(subStep);\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_staticPressureParticle) {\r\n        this.SolveStaticPressure(subStep);\r\n      }\r\n      this.SolvePressure(subStep);\r\n      this.SolveDamping(subStep);\r\n      if (this.m_allParticleFlags & b2ParticleSystem.k_extraDampingFlags) {\r\n        this.SolveExtraDamping();\r\n      }\r\n      // SolveElastic and SolveSpring refer the current velocities for\r\n      // numerical stability, they should be called as late as possible.\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_elasticParticle) {\r\n        this.SolveElastic(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_springParticle) {\r\n        this.SolveSpring(subStep);\r\n      }\r\n      this.LimitVelocity(subStep);\r\n      if (this.m_allGroupFlags & b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n        this.SolveRigidDamping();\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_barrierParticle) {\r\n        this.SolveBarrier(subStep);\r\n      }\r\n      // SolveCollision, SolveRigid and SolveWall should be called after\r\n      // other force functions because they may require particles to have\r\n      // specific velocities.\r\n      this.SolveCollision(subStep);\r\n      if (this.m_allGroupFlags & b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n        this.SolveRigid(subStep);\r\n      }\r\n      if (this.m_allParticleFlags & b2ParticleFlag.b2_wallParticle) {\r\n        this.SolveWall();\r\n      }\r\n      // The particle positions can be updated only at the end of substep.\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        ///m_positionBuffer.data[i] += subStep.dt * m_velocityBuffer.data[i];\r\n        this.m_positionBuffer.data[i].SelfMulAdd(subStep.dt, this.m_velocityBuffer.data[i]);\r\n      }\r\n    }\r\n  }\r\n  public static readonly Solve_s_subStep = new b2TimeStep();\r\n\r\n  public SolveCollision(step: b2TimeStep): void {\r\n    const s_aabb = b2ParticleSystem.SolveCollision_s_aabb;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n\r\n    // This function detects particles which are crossing boundary of bodies\r\n    // and modifies velocities of them so that they will move just in front of\r\n    // boundary. This function function also applies the reaction force to\r\n    // bodies as precisely as the numerical stability is kept.\r\n    const aabb = s_aabb;\r\n    aabb.lowerBound.x = +b2_maxFloat;\r\n    aabb.lowerBound.y = +b2_maxFloat;\r\n    aabb.upperBound.x = -b2_maxFloat;\r\n    aabb.upperBound.y = -b2_maxFloat;\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      const v = vel_data[i];\r\n      const p1 = pos_data[i];\r\n      ///let p2 = p1 + step.dt * v;\r\n      const p2_x = p1.x + step.dt * v.x;\r\n      const p2_y = p1.y + step.dt * v.y;\r\n      ///aabb.lowerBound = b2Min(aabb.lowerBound, b2Min(p1, p2));\r\n      aabb.lowerBound.x = b2Min(aabb.lowerBound.x, b2Min(p1.x, p2_x));\r\n      aabb.lowerBound.y = b2Min(aabb.lowerBound.y, b2Min(p1.y, p2_y));\r\n      ///aabb.upperBound = b2Max(aabb.upperBound, b2Max(p1, p2));\r\n      aabb.upperBound.x = b2Max(aabb.upperBound.x, b2Max(p1.x, p2_x));\r\n      aabb.upperBound.y = b2Max(aabb.upperBound.y, b2Max(p1.y, p2_y));\r\n    }\r\n    if (this.SolveCollision_callback === null) {\r\n      this.SolveCollision_callback = new b2ParticleSystem_SolveCollisionCallback(this, step);\r\n    }\r\n    const callback = this.SolveCollision_callback;\r\n    callback.m_step = step;\r\n    this.m_world.QueryAABB(callback, aabb);\r\n  }\r\n  public static readonly SolveCollision_s_aabb = new b2AABB();\r\n  public SolveCollision_callback: b2ParticleSystem_SolveCollisionCallback | null = null;\r\n\r\n  public LimitVelocity(step: b2TimeStep): void {\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const criticalVelocitySquared = this.GetCriticalVelocitySquared(step);\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      const v = vel_data[i];\r\n      const v2 = b2Vec2.DotVV(v, v);\r\n      if (v2 > criticalVelocitySquared) {\r\n        ///v *= b2Sqrt(criticalVelocitySquared / v2);\r\n        v.SelfMul(b2Sqrt(criticalVelocitySquared / v2));\r\n      }\r\n    }\r\n  }\r\n\r\n  public SolveGravity(step: b2TimeStep): void {\r\n    const s_gravity = b2ParticleSystem.SolveGravity_s_gravity;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    ///b2Vec2 gravity = step.dt * m_def.gravityScale * m_world.GetGravity();\r\n    const gravity = b2Vec2.MulSV(step.dt * this.m_def.gravityScale, this.m_world.GetGravity(), s_gravity);\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      vel_data[i].SelfAdd(gravity);\r\n    }\r\n  }\r\n  public static readonly SolveGravity_s_gravity = new b2Vec2();\r\n\r\n  public SolveBarrier(step: b2TimeStep): void {\r\n    const s_aabb = b2ParticleSystem.SolveBarrier_s_aabb;\r\n    const s_va = b2ParticleSystem.SolveBarrier_s_va;\r\n    const s_vb = b2ParticleSystem.SolveBarrier_s_vb;\r\n    const s_pba = b2ParticleSystem.SolveBarrier_s_pba;\r\n    const s_vba = b2ParticleSystem.SolveBarrier_s_vba;\r\n    const s_vc = b2ParticleSystem.SolveBarrier_s_vc;\r\n    const s_pca = b2ParticleSystem.SolveBarrier_s_pca;\r\n    const s_vca = b2ParticleSystem.SolveBarrier_s_vca;\r\n    const s_qba = b2ParticleSystem.SolveBarrier_s_qba;\r\n    const s_qca = b2ParticleSystem.SolveBarrier_s_qca;\r\n    const s_dv = b2ParticleSystem.SolveBarrier_s_dv;\r\n    const s_f = b2ParticleSystem.SolveBarrier_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // If a particle is passing between paired barrier particles,\r\n    // its velocity will be decelerated to avoid passing.\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      const flags = this.m_flagsBuffer.data[i];\r\n      ///if ((flags & b2ParticleSystem.k_barrierWallFlags) === b2ParticleSystem.k_barrierWallFlags)\r\n      if ((flags & b2ParticleSystem.k_barrierWallFlags) !== 0) {\r\n        vel_data[i].SetZero();\r\n      }\r\n    }\r\n    const tmax = b2_barrierCollisionTime * step.dt;\r\n    const mass = this.GetParticleMass();\r\n    for (let k = 0; k < this.m_pairBuffer.count; k++) {\r\n      const pair = this.m_pairBuffer.data[k];\r\n      if (pair.flags & b2ParticleFlag.b2_barrierParticle) {\r\n        const a = pair.indexA;\r\n        const b = pair.indexB;\r\n        const pa = pos_data[a];\r\n        const pb = pos_data[b];\r\n        /// b2AABB aabb;\r\n        const aabb = s_aabb;\r\n        ///aabb.lowerBound = b2Min(pa, pb);\r\n        b2Vec2.MinV(pa, pb, aabb.lowerBound);\r\n        ///aabb.upperBound = b2Max(pa, pb);\r\n        b2Vec2.MaxV(pa, pb, aabb.upperBound);\r\n        const aGroup = this.m_groupBuffer[a];\r\n        const bGroup = this.m_groupBuffer[b];\r\n        ///b2Vec2 va = GetLinearVelocity(aGroup, a, pa);\r\n        const va = this.GetLinearVelocity(aGroup, a, pa, s_va);\r\n        ///b2Vec2 vb = GetLinearVelocity(bGroup, b, pb);\r\n        const vb = this.GetLinearVelocity(bGroup, b, pb, s_vb);\r\n        ///b2Vec2 pba = pb - pa;\r\n        const pba = b2Vec2.SubVV(pb, pa, s_pba);\r\n        ///b2Vec2 vba = vb - va;\r\n        const vba = b2Vec2.SubVV(vb, va, s_vba);\r\n        ///InsideBoundsEnumerator enumerator = GetInsideBoundsEnumerator(aabb);\r\n        const enumerator = this.GetInsideBoundsEnumerator(aabb);\r\n        let c: number;\r\n        while ((c = enumerator.GetNext()) >= 0) {\r\n          const pc = pos_data[c];\r\n          const cGroup = this.m_groupBuffer[c];\r\n          if (aGroup !== cGroup && bGroup !== cGroup) {\r\n            ///b2Vec2 vc = GetLinearVelocity(cGroup, c, pc);\r\n            const vc = this.GetLinearVelocity(cGroup, c, pc, s_vc);\r\n            // Solve the equation below:\r\n            //   (1-s)*(pa+t*va)+s*(pb+t*vb) = pc+t*vc\r\n            // which expresses that the particle c will pass a line\r\n            // connecting the particles a and b at the time of t.\r\n            // if s is between 0 and 1, c will pass between a and b.\r\n            ///b2Vec2 pca = pc - pa;\r\n            const pca = b2Vec2.SubVV(pc, pa, s_pca);\r\n            ///b2Vec2 vca = vc - va;\r\n            const vca = b2Vec2.SubVV(vc, va, s_vca);\r\n            const e2 = b2Vec2.CrossVV(vba, vca);\r\n            const e1 = b2Vec2.CrossVV(pba, vca) - b2Vec2.CrossVV(pca, vba);\r\n            const e0 = b2Vec2.CrossVV(pba, pca);\r\n            let s: number, t: number;\r\n            ///b2Vec2 qba, qca;\r\n            const qba = s_qba,\r\n              qca = s_qca;\r\n            if (e2 === 0) {\r\n              if (e1 === 0) { continue; }\r\n              t = -e0 / e1;\r\n              if (!(t >= 0 && t < tmax)) { continue; }\r\n              ///qba = pba + t * vba;\r\n              b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n              ///qca = pca + t * vca;\r\n              b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n              s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);\r\n              if (!(s >= 0 && s <= 1)) { continue; }\r\n            } else {\r\n              const det = e1 * e1 - 4 * e0 * e2;\r\n              if (det < 0) { continue; }\r\n              const sqrtDet = b2Sqrt(det);\r\n              let t1 = (-e1 - sqrtDet) / (2 * e2);\r\n              let t2 = (-e1 + sqrtDet) / (2 * e2);\r\n              ///if (t1 > t2) b2Swap(t1, t2);\r\n              if (t1 > t2) {\r\n                const tmp = t1;\r\n                t1 = t2;\r\n                t2 = tmp;\r\n              }\r\n              t = t1;\r\n              ///qba = pba + t * vba;\r\n              b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n              ///qca = pca + t * vca;\r\n              b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n              ///s = b2Dot(qba, qca) / b2Dot(qba, qba);\r\n              s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);\r\n              if (!(t >= 0 && t < tmax && s >= 0 && s <= 1)) {\r\n                t = t2;\r\n                if (!(t >= 0 && t < tmax)) { continue; }\r\n                ///qba = pba + t * vba;\r\n                b2Vec2.AddVMulSV(pba, t, vba, qba);\r\n                ///qca = pca + t * vca;\r\n                b2Vec2.AddVMulSV(pca, t, vca, qca);\r\n                ///s = b2Dot(qba, qca) / b2Dot(qba, qba);\r\n                s = b2Vec2.DotVV(qba, qca) / b2Vec2.DotVV(qba, qba);\r\n                if (!(s >= 0 && s <= 1)) { continue; }\r\n              }\r\n            }\r\n            // Apply a force to particle c so that it will have the\r\n            // interpolated velocity at the collision point on line ab.\r\n            ///b2Vec2 dv = va + s * vba - vc;\r\n            const dv = s_dv;\r\n            dv.x = va.x + s * vba.x - vc.x;\r\n            dv.y = va.y + s * vba.y - vc.y;\r\n            ///b2Vec2 f = GetParticleMass() * dv;\r\n            const f = b2Vec2.MulSV(mass, dv, s_f);\r\n            if (cGroup && this.IsRigidGroup(cGroup)) {\r\n              // If c belongs to a rigid group, the force will be\r\n              // distributed in the group.\r\n              const mass = cGroup.GetMass();\r\n              const inertia = cGroup.GetInertia();\r\n              if (mass > 0) {\r\n                ///cGroup.m_linearVelocity += 1 / mass * f;\r\n                cGroup.m_linearVelocity.SelfMulAdd(1 / mass, f);\r\n              }\r\n              if (inertia > 0) {\r\n                ///cGroup.m_angularVelocity += b2Cross(pc - cGroup.GetCenter(), f) / inertia;\r\n                cGroup.m_angularVelocity += b2Vec2.CrossVV(\r\n                  b2Vec2.SubVV(pc, cGroup.GetCenter(), b2Vec2.s_t0),\r\n                  f) / inertia;\r\n              }\r\n            } else {\r\n              ///m_velocityBuffer.data[c] += dv;\r\n              vel_data[c].SelfAdd(dv);\r\n            }\r\n            // Apply a reversed force to particle c after particle\r\n            // movement so that momentum will be preserved.\r\n            ///ParticleApplyForce(c, -step.inv_dt * f);\r\n            this.ParticleApplyForce(c, f.SelfMul(-step.inv_dt));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveBarrier_s_aabb = new b2AABB();\r\n  public static readonly SolveBarrier_s_va = new b2Vec2();\r\n  public static readonly SolveBarrier_s_vb = new b2Vec2();\r\n  public static readonly SolveBarrier_s_pba = new b2Vec2();\r\n  public static readonly SolveBarrier_s_vba = new b2Vec2();\r\n  public static readonly SolveBarrier_s_vc = new b2Vec2();\r\n  public static readonly SolveBarrier_s_pca = new b2Vec2();\r\n  public static readonly SolveBarrier_s_vca = new b2Vec2();\r\n  public static readonly SolveBarrier_s_qba = new b2Vec2();\r\n  public static readonly SolveBarrier_s_qca = new b2Vec2();\r\n  public static readonly SolveBarrier_s_dv = new b2Vec2();\r\n  public static readonly SolveBarrier_s_f = new b2Vec2();\r\n\r\n  public SolveStaticPressure(step: b2TimeStep): void {\r\n    this.m_staticPressureBuffer = this.RequestBuffer(this.m_staticPressureBuffer);\r\n    const criticalPressure = this.GetCriticalPressure(step);\r\n    const pressurePerWeight = this.m_def.staticPressureStrength * criticalPressure;\r\n    const maxPressure = b2_maxParticlePressure * criticalPressure;\r\n    const relaxation = this.m_def.staticPressureRelaxation;\r\n    /// Compute pressure satisfying the modified Poisson equation:\r\n    ///   Sum_for_j((p_i - p_j) * w_ij) + relaxation * p_i =\r\n    ///   pressurePerWeight * (w_i - b2_minParticleWeight)\r\n    /// by iterating the calculation:\r\n    ///   p_i = (Sum_for_j(p_j * w_ij) + pressurePerWeight *\r\n    ///         (w_i - b2_minParticleWeight)) / (w_i + relaxation)\r\n    /// where\r\n    ///   p_i and p_j are static pressure of particle i and j\r\n    ///   w_ij is contact weight between particle i and j\r\n    ///   w_i is sum of contact weight of particle i\r\n    for (let t = 0; t < this.m_def.staticPressureIterations; t++) {\r\n      ///memset(m_accumulationBuffer, 0, sizeof(*m_accumulationBuffer) * m_count);\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        this.m_accumulationBuffer[i] = 0;\r\n      }\r\n      for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n        const contact = this.m_contactBuffer.data[k];\r\n        if (contact.flags & b2ParticleFlag.b2_staticPressureParticle) {\r\n          const a = contact.indexA;\r\n          const b = contact.indexB;\r\n          const w = contact.weight;\r\n          this.m_accumulationBuffer[a] += w * this.m_staticPressureBuffer[b]; // a <- b\r\n          this.m_accumulationBuffer[b] += w * this.m_staticPressureBuffer[a]; // b <- a\r\n        }\r\n      }\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        const w = this.m_weightBuffer[i];\r\n        if (this.m_flagsBuffer.data[i] & b2ParticleFlag.b2_staticPressureParticle) {\r\n          const wh = this.m_accumulationBuffer[i];\r\n          const h =\r\n            (wh + pressurePerWeight * (w - b2_minParticleWeight)) /\r\n            (w + relaxation);\r\n          this.m_staticPressureBuffer[i] = b2Clamp(h, 0.0, maxPressure);\r\n        } else {\r\n          this.m_staticPressureBuffer[i] = 0;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public ComputeWeight(): void {\r\n    // calculates the sum of contact-weights for each particle\r\n    // that means dimensionless density\r\n    ///memset(m_weightBuffer, 0, sizeof(*m_weightBuffer) * m_count);\r\n    for (let k = 0; k < this.m_count; k++) {\r\n      this.m_weightBuffer[k] = 0;\r\n    }\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      const w = contact.weight;\r\n      this.m_weightBuffer[a] += w;\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const w = contact.weight;\r\n      this.m_weightBuffer[a] += w;\r\n      this.m_weightBuffer[b] += w;\r\n    }\r\n  }\r\n\r\n  public SolvePressure(step: b2TimeStep): void {\r\n    const s_f = b2ParticleSystem.SolvePressure_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // calculates pressure as a linear function of density\r\n    const criticalPressure = this.GetCriticalPressure(step);\r\n    const pressurePerWeight = this.m_def.pressureStrength * criticalPressure;\r\n    const maxPressure = b2_maxParticlePressure * criticalPressure;\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      const w = this.m_weightBuffer[i];\r\n      const h = pressurePerWeight * b2Max(0.0, w - b2_minParticleWeight);\r\n      this.m_accumulationBuffer[i] = b2Min(h, maxPressure);\r\n    }\r\n    // ignores particles which have their own repulsive force\r\n    if (this.m_allParticleFlags & b2ParticleSystem.k_noPressureFlags) {\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        if (this.m_flagsBuffer.data[i] & b2ParticleSystem.k_noPressureFlags) {\r\n          this.m_accumulationBuffer[i] = 0;\r\n        }\r\n      }\r\n    }\r\n    // static pressure\r\n    if (this.m_allParticleFlags & b2ParticleFlag.b2_staticPressureParticle) {\r\n      // DEBUG: b2Assert(this.m_staticPressureBuffer !== null);\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        if (this.m_flagsBuffer.data[i] & b2ParticleFlag.b2_staticPressureParticle) {\r\n          this.m_accumulationBuffer[i] += this.m_staticPressureBuffer[i];\r\n        }\r\n      }\r\n    }\r\n    // applies pressure between each particles in contact\r\n    const velocityPerPressure = step.dt / (this.m_def.density * this.m_particleDiameter);\r\n    const inv_mass = this.GetParticleInvMass();\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      const b = contact.body;\r\n      const w = contact.weight;\r\n      const m = contact.mass;\r\n      const n = contact.normal;\r\n      const p = pos_data[a];\r\n      const h = this.m_accumulationBuffer[a] + pressurePerWeight * w;\r\n      ///b2Vec2 f = velocityPerPressure * w * m * h * n;\r\n      const f = b2Vec2.MulSV(velocityPerPressure * w * m * h, n, s_f);\r\n      ///m_velocityBuffer.data[a] -= GetParticleInvMass() * f;\r\n      vel_data[a].SelfMulSub(inv_mass, f);\r\n      b.ApplyLinearImpulse(f, p, true);\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const w = contact.weight;\r\n      const n = contact.normal;\r\n      const h = this.m_accumulationBuffer[a] + this.m_accumulationBuffer[b];\r\n      ///b2Vec2 f = velocityPerPressure * w * h * n;\r\n      const f = b2Vec2.MulSV(velocityPerPressure * w * h, n, s_f);\r\n      ///m_velocityBuffer.data[a] -= f;\r\n      vel_data[a].SelfSub(f);\r\n      ///m_velocityBuffer.data[b] += f;\r\n      vel_data[b].SelfAdd(f);\r\n    }\r\n  }\r\n  public static readonly SolvePressure_s_f = new b2Vec2();\r\n\r\n  public SolveDamping(step: b2TimeStep): void {\r\n    const s_v = b2ParticleSystem.SolveDamping_s_v;\r\n    const s_f = b2ParticleSystem.SolveDamping_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // reduces normal velocity of each contact\r\n    const linearDamping = this.m_def.dampingStrength;\r\n    const quadraticDamping = 1 / this.GetCriticalVelocity(step);\r\n    const inv_mass = this.GetParticleInvMass();\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      const b = contact.body;\r\n      const w = contact.weight;\r\n      const m = contact.mass;\r\n      const n = contact.normal;\r\n      const p = pos_data[a];\r\n      ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n      const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);\r\n      const vn = b2Vec2.DotVV(v, n);\r\n      if (vn < 0) {\r\n        const damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, 0.5));\r\n        ///b2Vec2 f = damping * m * vn * n;\r\n        const f = b2Vec2.MulSV(damping * m * vn, n, s_f);\r\n        ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n        vel_data[a].SelfMulAdd(inv_mass, f);\r\n        ///b.ApplyLinearImpulse(-f, p, true);\r\n        b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n      }\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const w = contact.weight;\r\n      const n = contact.normal;\r\n      ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n      const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n      const vn = b2Vec2.DotVV(v, n);\r\n      if (vn < 0) {\r\n        ///float32 damping = b2Max(linearDamping * w, b2Min(- quadraticDamping * vn, 0.5f));\r\n        const damping = b2Max(linearDamping * w, b2Min(-quadraticDamping * vn, 0.5));\r\n        ///b2Vec2 f = damping * vn * n;\r\n        const f = b2Vec2.MulSV(damping * vn, n, s_f);\r\n        ///this.m_velocityBuffer.data[a] += f;\r\n        vel_data[a].SelfAdd(f);\r\n        ///this.m_velocityBuffer.data[b] -= f;\r\n        vel_data[b].SelfSub(f);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveDamping_s_v = new b2Vec2();\r\n  public static readonly SolveDamping_s_f = new b2Vec2();\r\n\r\n  public SolveRigidDamping(): void {\r\n    const s_t0 = b2ParticleSystem.SolveRigidDamping_s_t0;\r\n    const s_t1 = b2ParticleSystem.SolveRigidDamping_s_t1;\r\n    const s_p = b2ParticleSystem.SolveRigidDamping_s_p;\r\n    const s_v = b2ParticleSystem.SolveRigidDamping_s_v;\r\n    const invMassA = [0.0],\r\n      invInertiaA = [0.0],\r\n      tangentDistanceA = [0.0]; // TODO: static\r\n    const invMassB = [0.0],\r\n      invInertiaB = [0.0],\r\n      tangentDistanceB = [0.0]; // TODO: static\r\n    // Apply impulse to rigid particle groups colliding with other objects\r\n    // to reduce relative velocity at the colliding point.\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const damping = this.m_def.dampingStrength;\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      const aGroup = this.m_groupBuffer[a];\r\n      if (aGroup && this.IsRigidGroup(aGroup)) {\r\n        const b = contact.body;\r\n        const n = contact.normal;\r\n        const w = contact.weight;\r\n        const p = pos_data[a];\r\n        ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - aGroup.GetLinearVelocityFromWorldPoint(p);\r\n        const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, s_t0), aGroup.GetLinearVelocityFromWorldPoint(p, s_t1), s_v);\r\n        const vn = b2Vec2.DotVV(v, n);\r\n        if (vn < 0) {\r\n          // The group's average velocity at particle position 'p' is pushing\r\n          // the particle into the body.\r\n          ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, true, aGroup, a, p, n);\r\n          this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, p, n);\r\n          // Calculate b.m_I from public functions of b2Body.\r\n          ///this.InitDampingParameter(&invMassB, &invInertiaB, &tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);\r\n          this.InitDampingParameter(invMassB, invInertiaB, tangentDistanceB, b.GetMass(), b.GetInertia() - b.GetMass() * b.GetLocalCenter().LengthSquared(), b.GetWorldCenter(), p, n);\r\n          ///float32 f = damping * b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);\r\n          const f = damping * b2Min(w, 1.0) * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);\r\n          ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, true, aGroup, a, f, n);\r\n          this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], true, aGroup, a, f, n);\r\n          ///b.ApplyLinearImpulse(-f * n, p, true);\r\n          b.ApplyLinearImpulse(b2Vec2.MulSV(-f, n, b2Vec2.s_t0), p, true);\r\n        }\r\n      }\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      const n = contact.normal;\r\n      const w = contact.weight;\r\n      const aGroup = this.m_groupBuffer[a];\r\n      const bGroup = this.m_groupBuffer[b];\r\n      const aRigid = this.IsRigidGroup(aGroup);\r\n      const bRigid = this.IsRigidGroup(bGroup);\r\n      if (aGroup !== bGroup && (aRigid || bRigid)) {\r\n        ///b2Vec2 p = 0.5f * (this.m_positionBuffer.data[a] + this.m_positionBuffer.data[b]);\r\n        const p = b2Vec2.MidVV(pos_data[a], pos_data[b], s_p);\r\n        ///b2Vec2 v = GetLinearVelocity(bGroup, b, p) - GetLinearVelocity(aGroup, a, p);\r\n        const v = b2Vec2.SubVV(this.GetLinearVelocity(bGroup, b, p, s_t0), this.GetLinearVelocity(aGroup, a, p, s_t1), s_v);\r\n        const vn = b2Vec2.DotVV(v, n);\r\n        if (vn < 0) {\r\n          ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassA, &invInertiaA, &tangentDistanceA, aRigid, aGroup, a, p, n);\r\n          this.InitDampingParameterWithRigidGroupOrParticle(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, p, n);\r\n          ///this.InitDampingParameterWithRigidGroupOrParticle(&invMassB, &invInertiaB, &tangentDistanceB, bRigid, bGroup, b, p, n);\r\n          this.InitDampingParameterWithRigidGroupOrParticle(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, p, n);\r\n          ///float32 f = damping * w * this.ComputeDampingImpulse(invMassA, invInertiaA, tangentDistanceA, invMassB, invInertiaB, tangentDistanceB, vn);\r\n          const f = damping * w * this.ComputeDampingImpulse(invMassA[0], invInertiaA[0], tangentDistanceA[0], invMassB[0], invInertiaB[0], tangentDistanceB[0], vn);\r\n          ///this.ApplyDamping(invMassA, invInertiaA, tangentDistanceA, aRigid, aGroup, a, f, n);\r\n          this.ApplyDamping(invMassA[0], invInertiaA[0], tangentDistanceA[0], aRigid, aGroup, a, f, n);\r\n          ///this.ApplyDamping(invMassB, invInertiaB, tangentDistanceB, bRigid, bGroup, b, -f, n);\r\n          this.ApplyDamping(invMassB[0], invInertiaB[0], tangentDistanceB[0], bRigid, bGroup, b, -f, n);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveRigidDamping_s_t0 = new b2Vec2();\r\n  public static readonly SolveRigidDamping_s_t1 = new b2Vec2();\r\n  public static readonly SolveRigidDamping_s_p = new b2Vec2();\r\n  public static readonly SolveRigidDamping_s_v = new b2Vec2();\r\n\r\n  public SolveExtraDamping(): void {\r\n    const s_v = b2ParticleSystem.SolveExtraDamping_s_v;\r\n    const s_f = b2ParticleSystem.SolveExtraDamping_s_f;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // Applies additional damping force between bodies and particles which can\r\n    // produce strong repulsive force. Applying damping force multiple times\r\n    // is effective in suppressing vibration.\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const inv_mass = this.GetParticleInvMass();\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      if (this.m_flagsBuffer.data[a] & b2ParticleSystem.k_extraDampingFlags) {\r\n        const b = contact.body;\r\n        const m = contact.mass;\r\n        const n = contact.normal;\r\n        const p = pos_data[a];\r\n        ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n        const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);\r\n        ///float32 vn = b2Dot(v, n);\r\n        const vn = b2Vec2.DotVV(v, n);\r\n        if (vn < 0) {\r\n          ///b2Vec2 f = 0.5f * m * vn * n;\r\n          const f = b2Vec2.MulSV(0.5 * m * vn, n, s_f);\r\n          ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n          vel_data[a].SelfMulAdd(inv_mass, f);\r\n          ///b.ApplyLinearImpulse(-f, p, true);\r\n          b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveExtraDamping_s_v = new b2Vec2();\r\n  public static readonly SolveExtraDamping_s_f = new b2Vec2();\r\n\r\n  public SolveWall(): void {\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      if (this.m_flagsBuffer.data[i] & b2ParticleFlag.b2_wallParticle) {\r\n        vel_data[i].SetZero();\r\n      }\r\n    }\r\n  }\r\n\r\n  public SolveRigid(step: b2TimeStep): void {\r\n    const s_position = b2ParticleSystem.SolveRigid_s_position;\r\n    const s_rotation = b2ParticleSystem.SolveRigid_s_rotation;\r\n    const s_transform = b2ParticleSystem.SolveRigid_s_transform;\r\n    const s_velocityTransform = b2ParticleSystem.SolveRigid_s_velocityTransform;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    for (let group = this.m_groupList; group; group = group.GetNext()) {\r\n      if (group.m_groupFlags & b2ParticleGroupFlag.b2_rigidParticleGroup) {\r\n        group.UpdateStatistics();\r\n        ///b2Rot rotation(step.dt * group.m_angularVelocity);\r\n        const rotation = s_rotation;\r\n        rotation.SetAngle(step.dt * group.m_angularVelocity);\r\n        ///b2Transform transform(group.m_center + step.dt * group.m_linearVelocity - b2Mul(rotation, group.m_center), rotation);\r\n        const position = b2Vec2.AddVV(\r\n          group.m_center,\r\n          b2Vec2.SubVV(\r\n            b2Vec2.MulSV(step.dt, group.m_linearVelocity, b2Vec2.s_t0),\r\n            b2Rot.MulRV(rotation, group.m_center, b2Vec2.s_t1),\r\n            b2Vec2.s_t0),\r\n          s_position);\r\n        const transform = s_transform;\r\n        transform.SetPositionRotation(position, rotation);\r\n        ///group.m_transform = b2Mul(transform, group.m_transform);\r\n        b2Transform.MulXX(transform, group.m_transform, group.m_transform);\r\n        const velocityTransform = s_velocityTransform;\r\n        velocityTransform.p.x = step.inv_dt * transform.p.x;\r\n        velocityTransform.p.y = step.inv_dt * transform.p.y;\r\n        velocityTransform.q.s = step.inv_dt * transform.q.s;\r\n        velocityTransform.q.c = step.inv_dt * (transform.q.c - 1);\r\n        for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n          ///m_velocityBuffer.data[i] = b2Mul(velocityTransform, m_positionBuffer.data[i]);\r\n          b2Transform.MulXV(velocityTransform, pos_data[i], vel_data[i]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveRigid_s_position = new b2Vec2();\r\n  public static readonly SolveRigid_s_rotation = new b2Rot();\r\n  public static readonly SolveRigid_s_transform = new b2Transform();\r\n  public static readonly SolveRigid_s_velocityTransform = new b2Transform();\r\n\r\n  public SolveElastic(step: b2TimeStep): void {\r\n    const s_pa = b2ParticleSystem.SolveElastic_s_pa;\r\n    const s_pb = b2ParticleSystem.SolveElastic_s_pb;\r\n    const s_pc = b2ParticleSystem.SolveElastic_s_pc;\r\n    const s_r = b2ParticleSystem.SolveElastic_s_r;\r\n    const s_t0 = b2ParticleSystem.SolveElastic_s_t0;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const elasticStrength = step.inv_dt * this.m_def.elasticStrength;\r\n    for (let k = 0; k < this.m_triadBuffer.count; k++) {\r\n      const triad = this.m_triadBuffer.data[k];\r\n      if (triad.flags & b2ParticleFlag.b2_elasticParticle) {\r\n        const a = triad.indexA;\r\n        const b = triad.indexB;\r\n        const c = triad.indexC;\r\n        const oa = triad.pa;\r\n        const ob = triad.pb;\r\n        const oc = triad.pc;\r\n        ///b2Vec2 pa = m_positionBuffer.data[a];\r\n        const pa = s_pa.Copy(pos_data[a]);\r\n        ///b2Vec2 pb = m_positionBuffer.data[b];\r\n        const pb = s_pb.Copy(pos_data[b]);\r\n        ///b2Vec2 pc = m_positionBuffer.data[c];\r\n        const pc = s_pc.Copy(pos_data[c]);\r\n        const va = vel_data[a];\r\n        const vb = vel_data[b];\r\n        const vc = vel_data[c];\r\n        ///pa += step.dt * va;\r\n        pa.SelfMulAdd(step.dt, va);\r\n        ///pb += step.dt * vb;\r\n        pb.SelfMulAdd(step.dt, vb);\r\n        ///pc += step.dt * vc;\r\n        pc.SelfMulAdd(step.dt, vc);\r\n        ///b2Vec2 midPoint = (float32) 1 / 3 * (pa + pb + pc);\r\n        const midPoint_x = (pa.x + pb.x + pc.x) / 3.0;\r\n        const midPoint_y = (pa.y + pb.y + pc.y) / 3.0;\r\n        ///pa -= midPoint;\r\n        pa.x -= midPoint_x;\r\n        pa.y -= midPoint_y;\r\n        ///pb -= midPoint;\r\n        pb.x -= midPoint_x;\r\n        pb.y -= midPoint_y;\r\n        ///pc -= midPoint;\r\n        pc.x -= midPoint_x;\r\n        pc.y -= midPoint_y;\r\n        ///b2Rot r;\r\n        const r = s_r;\r\n        r.s = b2Vec2.CrossVV(oa, pa) + b2Vec2.CrossVV(ob, pb) + b2Vec2.CrossVV(oc, pc);\r\n        r.c = b2Vec2.DotVV(oa, pa) + b2Vec2.DotVV(ob, pb) + b2Vec2.DotVV(oc, pc);\r\n        const r2 = r.s * r.s + r.c * r.c;\r\n        let invR = b2InvSqrt(r2);\r\n        if (!isFinite(invR)) {\r\n          invR = 1.98177537e+019;\r\n        }\r\n        r.s *= invR;\r\n        r.c *= invR;\r\n        ///r.angle = Math.atan2(r.s, r.c); // TODO: optimize\r\n        const strength = elasticStrength * triad.strength;\r\n        ///va += strength * (b2Mul(r, oa) - pa);\r\n        b2Rot.MulRV(r, oa, s_t0);\r\n        b2Vec2.SubVV(s_t0, pa, s_t0);\r\n        b2Vec2.MulSV(strength, s_t0, s_t0);\r\n        va.SelfAdd(s_t0);\r\n        ///vb += strength * (b2Mul(r, ob) - pb);\r\n        b2Rot.MulRV(r, ob, s_t0);\r\n        b2Vec2.SubVV(s_t0, pb, s_t0);\r\n        b2Vec2.MulSV(strength, s_t0, s_t0);\r\n        vb.SelfAdd(s_t0);\r\n        ///vc += strength * (b2Mul(r, oc) - pc);\r\n        b2Rot.MulRV(r, oc, s_t0);\r\n        b2Vec2.SubVV(s_t0, pc, s_t0);\r\n        b2Vec2.MulSV(strength, s_t0, s_t0);\r\n        vc.SelfAdd(s_t0);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveElastic_s_pa = new b2Vec2();\r\n  public static readonly SolveElastic_s_pb = new b2Vec2();\r\n  public static readonly SolveElastic_s_pc = new b2Vec2();\r\n  public static readonly SolveElastic_s_r = new b2Rot();\r\n  public static readonly SolveElastic_s_t0 = new b2Vec2();\r\n\r\n  public SolveSpring(step: b2TimeStep): void {\r\n    const s_pa = b2ParticleSystem.SolveSpring_s_pa;\r\n    const s_pb = b2ParticleSystem.SolveSpring_s_pb;\r\n    const s_d = b2ParticleSystem.SolveSpring_s_d;\r\n    const s_f = b2ParticleSystem.SolveSpring_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const springStrength = step.inv_dt * this.m_def.springStrength;\r\n    for (let k = 0; k < this.m_pairBuffer.count; k++) {\r\n      const pair = this.m_pairBuffer.data[k];\r\n      if (pair.flags & b2ParticleFlag.b2_springParticle) {\r\n        ///int32 a = pair.indexA;\r\n        const a = pair.indexA;\r\n        ///int32 b = pair.indexB;\r\n        const b = pair.indexB;\r\n        ///b2Vec2 pa = m_positionBuffer.data[a];\r\n        const pa = s_pa.Copy(pos_data[a]);\r\n        ///b2Vec2 pb = m_positionBuffer.data[b];\r\n        const pb = s_pb.Copy(pos_data[b]);\r\n        ///b2Vec2& va = m_velocityBuffer.data[a];\r\n        const va = vel_data[a];\r\n        ///b2Vec2& vb = m_velocityBuffer.data[b];\r\n        const vb = vel_data[b];\r\n        ///pa += step.dt * va;\r\n        pa.SelfMulAdd(step.dt, va);\r\n        ///pb += step.dt * vb;\r\n        pb.SelfMulAdd(step.dt, vb);\r\n        ///b2Vec2 d = pb - pa;\r\n        const d = b2Vec2.SubVV(pb, pa, s_d);\r\n        ///float32 r0 = pair.distance;\r\n        const r0 = pair.distance;\r\n        ///float32 r1 = d.Length();\r\n        const r1 = d.Length();\r\n        ///float32 strength = springStrength * pair.strength;\r\n        const strength = springStrength * pair.strength;\r\n        ///b2Vec2 f = strength * (r0 - r1) / r1 * d;\r\n        const f = b2Vec2.MulSV(strength * (r0 - r1) / r1, d, s_f);\r\n        ///va -= f;\r\n        va.SelfSub(f);\r\n        ///vb += f;\r\n        vb.SelfAdd(f);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveSpring_s_pa = new b2Vec2();\r\n  public static readonly SolveSpring_s_pb = new b2Vec2();\r\n  public static readonly SolveSpring_s_d = new b2Vec2();\r\n  public static readonly SolveSpring_s_f = new b2Vec2();\r\n\r\n  public SolveTensile(step: b2TimeStep): void {\r\n    const s_weightedNormal = b2ParticleSystem.SolveTensile_s_weightedNormal;\r\n    const s_s = b2ParticleSystem.SolveTensile_s_s;\r\n    const s_f = b2ParticleSystem.SolveTensile_s_f;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // DEBUG: b2Assert(this.m_accumulation2Buffer !== null);\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      this.m_accumulation2Buffer[i] = new b2Vec2();\r\n      this.m_accumulation2Buffer[i].SetZero();\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      if (contact.flags & b2ParticleFlag.b2_tensileParticle) {\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        const w = contact.weight;\r\n        const n = contact.normal;\r\n        ///b2Vec2 weightedNormal = (1 - w) * w * n;\r\n        const weightedNormal = b2Vec2.MulSV((1 - w) * w, n, s_weightedNormal);\r\n        ///m_accumulation2Buffer[a] -= weightedNormal;\r\n        this.m_accumulation2Buffer[a].SelfSub(weightedNormal);\r\n        ///m_accumulation2Buffer[b] += weightedNormal;\r\n        this.m_accumulation2Buffer[b].SelfAdd(weightedNormal);\r\n      }\r\n    }\r\n    const criticalVelocity = this.GetCriticalVelocity(step);\r\n    const pressureStrength = this.m_def.surfaceTensionPressureStrength * criticalVelocity;\r\n    const normalStrength = this.m_def.surfaceTensionNormalStrength * criticalVelocity;\r\n    const maxVelocityVariation = b2_maxParticleForce * criticalVelocity;\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      if (contact.flags & b2ParticleFlag.b2_tensileParticle) {\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        const w = contact.weight;\r\n        const n = contact.normal;\r\n        const h = this.m_weightBuffer[a] + this.m_weightBuffer[b];\r\n        ///b2Vec2 s = m_accumulation2Buffer[b] - m_accumulation2Buffer[a];\r\n        const s = b2Vec2.SubVV(this.m_accumulation2Buffer[b], this.m_accumulation2Buffer[a], s_s);\r\n        const fn = b2Min(\r\n          pressureStrength * (h - 2) + normalStrength * b2Vec2.DotVV(s, n),\r\n          maxVelocityVariation) * w;\r\n        ///b2Vec2 f = fn * n;\r\n        const f = b2Vec2.MulSV(fn, n, s_f);\r\n        ///m_velocityBuffer.data[a] -= f;\r\n        vel_data[a].SelfSub(f);\r\n        ///m_velocityBuffer.data[b] += f;\r\n        vel_data[b].SelfAdd(f);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveTensile_s_weightedNormal = new b2Vec2();\r\n  public static readonly SolveTensile_s_s = new b2Vec2();\r\n  public static readonly SolveTensile_s_f = new b2Vec2();\r\n\r\n  public SolveViscous(): void {\r\n    const s_v = b2ParticleSystem.SolveViscous_s_v;\r\n    const s_f = b2ParticleSystem.SolveViscous_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const viscousStrength = this.m_def.viscousStrength;\r\n    const inv_mass = this.GetParticleInvMass();\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      if (this.m_flagsBuffer.data[a] & b2ParticleFlag.b2_viscousParticle) {\r\n        const b = contact.body;\r\n        const w = contact.weight;\r\n        const m = contact.mass;\r\n        const p = pos_data[a];\r\n        ///b2Vec2 v = b.GetLinearVelocityFromWorldPoint(p) - m_velocityBuffer.data[a];\r\n        const v = b2Vec2.SubVV(b.GetLinearVelocityFromWorldPoint(p, b2Vec2.s_t0), vel_data[a], s_v);\r\n        ///b2Vec2 f = viscousStrength * m * w * v;\r\n        const f = b2Vec2.MulSV(viscousStrength * m * w, v, s_f);\r\n        ///m_velocityBuffer.data[a] += GetParticleInvMass() * f;\r\n        vel_data[a].SelfMulAdd(inv_mass, f);\r\n        ///b.ApplyLinearImpulse(-f, p, true);\r\n        b.ApplyLinearImpulse(f.SelfNeg(), p, true);\r\n      }\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      if (contact.flags & b2ParticleFlag.b2_viscousParticle) {\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        const w = contact.weight;\r\n        ///b2Vec2 v = m_velocityBuffer.data[b] - m_velocityBuffer.data[a];\r\n        const v = b2Vec2.SubVV(vel_data[b], vel_data[a], s_v);\r\n        ///b2Vec2 f = viscousStrength * w * v;\r\n        const f = b2Vec2.MulSV(viscousStrength * w, v, s_f);\r\n        ///m_velocityBuffer.data[a] += f;\r\n        vel_data[a].SelfAdd(f);\r\n        ///m_velocityBuffer.data[b] -= f;\r\n        vel_data[b].SelfSub(f);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveViscous_s_v = new b2Vec2();\r\n  public static readonly SolveViscous_s_f = new b2Vec2();\r\n\r\n  public SolveRepulsive(step: b2TimeStep): void {\r\n    const s_f = b2ParticleSystem.SolveRepulsive_s_f;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const repulsiveStrength = this.m_def.repulsiveStrength * this.GetCriticalVelocity(step);\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      if (contact.flags & b2ParticleFlag.b2_repulsiveParticle) {\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {\r\n          const w = contact.weight;\r\n          const n = contact.normal;\r\n          ///b2Vec2 f = repulsiveStrength * w * n;\r\n          const f = b2Vec2.MulSV(repulsiveStrength * w, n, s_f);\r\n          ///m_velocityBuffer.data[a] -= f;\r\n          vel_data[a].SelfSub(f);\r\n          ///m_velocityBuffer.data[b] += f;\r\n          vel_data[b].SelfAdd(f);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveRepulsive_s_f = new b2Vec2();\r\n\r\n  public SolvePowder(step: b2TimeStep): void {\r\n    const s_f = b2ParticleSystem.SolvePowder_s_f;\r\n    const pos_data = this.m_positionBuffer.data;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const powderStrength = this.m_def.powderStrength * this.GetCriticalVelocity(step);\r\n    const minWeight = 1.0 - b2_particleStride;\r\n    const inv_mass = this.GetParticleInvMass();\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      const a = contact.index;\r\n      if (this.m_flagsBuffer.data[a] & b2ParticleFlag.b2_powderParticle) {\r\n        const w = contact.weight;\r\n        if (w > minWeight) {\r\n          const b = contact.body;\r\n          const m = contact.mass;\r\n          const p = pos_data[a];\r\n          const n = contact.normal;\r\n          const f = b2Vec2.MulSV(powderStrength * m * (w - minWeight), n, s_f);\r\n          vel_data[a].SelfMulSub(inv_mass, f);\r\n          b.ApplyLinearImpulse(f, p, true);\r\n        }\r\n      }\r\n    }\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      if (contact.flags & b2ParticleFlag.b2_powderParticle) {\r\n        const w = contact.weight;\r\n        if (w > minWeight) {\r\n          const a = contact.indexA;\r\n          const b = contact.indexB;\r\n          const n = contact.normal;\r\n          const f = b2Vec2.MulSV(powderStrength * (w - minWeight), n, s_f);\r\n          vel_data[a].SelfSub(f);\r\n          vel_data[b].SelfAdd(f);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolvePowder_s_f = new b2Vec2();\r\n\r\n  public SolveSolid(step: b2TimeStep): void {\r\n    const s_f = b2ParticleSystem.SolveSolid_s_f;\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    // applies extra repulsive force from solid particle groups\r\n    this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);\r\n    const ejectionStrength = step.inv_dt * this.m_def.ejectionStrength;\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      const a = contact.indexA;\r\n      const b = contact.indexB;\r\n      if (this.m_groupBuffer[a] !== this.m_groupBuffer[b]) {\r\n        const w = contact.weight;\r\n        const n = contact.normal;\r\n        const h = this.m_depthBuffer[a] + this.m_depthBuffer[b];\r\n        const f = b2Vec2.MulSV(ejectionStrength * h * w, n, s_f);\r\n        vel_data[a].SelfSub(f);\r\n        vel_data[b].SelfAdd(f);\r\n      }\r\n    }\r\n  }\r\n  public static readonly SolveSolid_s_f = new b2Vec2();\r\n\r\n  public SolveForce(step: b2TimeStep): void {\r\n    const vel_data = this.m_velocityBuffer.data;\r\n    const velocityPerForce = step.dt * this.GetParticleInvMass();\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      ///m_velocityBuffer.data[i] += velocityPerForce * m_forceBuffer[i];\r\n      vel_data[i].SelfMulAdd(velocityPerForce, this.m_forceBuffer[i]);\r\n    }\r\n    this.m_hasForce = false;\r\n  }\r\n\r\n  public SolveColorMixing(): void {\r\n    // mixes color between contacting particles\r\n    const colorMixing = 0.5 * this.m_def.colorMixingStrength;\r\n    if (colorMixing) {\r\n      for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n        const contact = this.m_contactBuffer.data[k];\r\n        const a = contact.indexA;\r\n        const b = contact.indexB;\r\n        if (this.m_flagsBuffer.data[a] & this.m_flagsBuffer.data[b] &\r\n          b2ParticleFlag.b2_colorMixingParticle) {\r\n          const colorA = this.m_colorBuffer.data[a];\r\n          const colorB = this.m_colorBuffer.data[b];\r\n          // Use the static method to ensure certain compilers inline\r\n          // this correctly.\r\n          b2Color.MixColors(colorA, colorB, colorMixing);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public SolveZombie(): void {\r\n    // removes particles with zombie flag\r\n    let newCount = 0;\r\n    const newIndices: number[] = []; // TODO: static\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      newIndices[i] = b2_invalidParticleIndex;\r\n    }\r\n    // DEBUG: b2Assert(newIndices.length === this.m_count);\r\n    let allParticleFlags = 0;\r\n    for (let i = 0; i < this.m_count; i++) {\r\n      const flags = this.m_flagsBuffer.data[i];\r\n      if (flags & b2ParticleFlag.b2_zombieParticle) {\r\n        const destructionListener = this.m_world.m_destructionListener;\r\n        if ((flags & b2ParticleFlag.b2_destructionListenerParticle) && destructionListener) {\r\n          destructionListener.SayGoodbyeParticle(this, i);\r\n        }\r\n        // Destroy particle handle.\r\n        if (this.m_handleIndexBuffer.data) {\r\n          const handle = this.m_handleIndexBuffer.data[i];\r\n          if (handle) {\r\n            handle.SetIndex(b2_invalidParticleIndex);\r\n            this.m_handleIndexBuffer.data[i] = null;\r\n            ///m_handleAllocator.Free(handle);\r\n          }\r\n        }\r\n        newIndices[i] = b2_invalidParticleIndex;\r\n      } else {\r\n        newIndices[i] = newCount;\r\n        if (i !== newCount) {\r\n          // Update handle to reference new particle index.\r\n          if (this.m_handleIndexBuffer.data) {\r\n            const handle = this.m_handleIndexBuffer.data[i];\r\n            if (handle) { handle.SetIndex(newCount); }\r\n            this.m_handleIndexBuffer.data[newCount] = handle;\r\n          }\r\n          this.m_flagsBuffer.data[newCount] = this.m_flagsBuffer.data[i];\r\n          if (this.m_lastBodyContactStepBuffer.data) {\r\n            this.m_lastBodyContactStepBuffer.data[newCount] = this.m_lastBodyContactStepBuffer.data[i];\r\n          }\r\n          if (this.m_bodyContactCountBuffer.data) {\r\n            this.m_bodyContactCountBuffer.data[newCount] = this.m_bodyContactCountBuffer.data[i];\r\n          }\r\n          if (this.m_consecutiveContactStepsBuffer.data) {\r\n            this.m_consecutiveContactStepsBuffer.data[newCount] = this.m_consecutiveContactStepsBuffer.data[i];\r\n          }\r\n          this.m_positionBuffer.data[newCount].Copy(this.m_positionBuffer.data[i]);\r\n          this.m_velocityBuffer.data[newCount].Copy(this.m_velocityBuffer.data[i]);\r\n          this.m_groupBuffer[newCount] = this.m_groupBuffer[i];\r\n          if (this.m_hasForce) {\r\n            this.m_forceBuffer[newCount].Copy(this.m_forceBuffer[i]);\r\n          }\r\n          if (this.m_staticPressureBuffer) {\r\n            this.m_staticPressureBuffer[newCount] = this.m_staticPressureBuffer[i];\r\n          }\r\n          if (this.m_depthBuffer) {\r\n            this.m_depthBuffer[newCount] = this.m_depthBuffer[i];\r\n          }\r\n          if (this.m_colorBuffer.data) {\r\n            this.m_colorBuffer.data[newCount].Copy(this.m_colorBuffer.data[i]);\r\n          }\r\n          if (this.m_userDataBuffer.data) {\r\n            this.m_userDataBuffer.data[newCount] = this.m_userDataBuffer.data[i];\r\n          }\r\n          if (this.m_expirationTimeBuffer.data) {\r\n            this.m_expirationTimeBuffer.data[newCount] = this.m_expirationTimeBuffer.data[i];\r\n          }\r\n        }\r\n        newCount++;\r\n        allParticleFlags |= flags;\r\n      }\r\n    }\r\n\r\n    // predicate functions\r\n    const Test = {\r\n      ///static bool IsProxyInvalid(const Proxy& proxy)\r\n      IsProxyInvalid: (proxy: b2ParticleSystem_Proxy) => {\r\n        return proxy.index < 0;\r\n      },\r\n      ///static bool IsContactInvalid(const b2ParticleContact& contact)\r\n      IsContactInvalid: (contact: b2ParticleContact) => {\r\n        return contact.indexA < 0 || contact.indexB < 0;\r\n      },\r\n      ///static bool IsBodyContactInvalid(const b2ParticleBodyContact& contact)\r\n      IsBodyContactInvalid: (contact: b2ParticleBodyContact) => {\r\n        return contact.index < 0;\r\n      },\r\n      ///static bool IsPairInvalid(const b2ParticlePair& pair)\r\n      IsPairInvalid: (pair: b2ParticlePair) => {\r\n        return pair.indexA < 0 || pair.indexB < 0;\r\n      },\r\n      ///static bool IsTriadInvalid(const b2ParticleTriad& triad)\r\n      IsTriadInvalid: (triad: b2ParticleTriad) => {\r\n        return triad.indexA < 0 || triad.indexB < 0 || triad.indexC < 0;\r\n      },\r\n    };\r\n\r\n    // update proxies\r\n    for (let k = 0; k < this.m_proxyBuffer.count; k++) {\r\n      const proxy = this.m_proxyBuffer.data[k];\r\n      proxy.index = newIndices[proxy.index];\r\n    }\r\n    this.m_proxyBuffer.RemoveIf(Test.IsProxyInvalid);\r\n\r\n    // update contacts\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      contact.indexA = newIndices[contact.indexA];\r\n      contact.indexB = newIndices[contact.indexB];\r\n    }\r\n    this.m_contactBuffer.RemoveIf(Test.IsContactInvalid);\r\n\r\n    // update particle-body contacts\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      contact.index = newIndices[contact.index];\r\n    }\r\n    this.m_bodyContactBuffer.RemoveIf(Test.IsBodyContactInvalid);\r\n\r\n    // update pairs\r\n    for (let k = 0; k < this.m_pairBuffer.count; k++) {\r\n      const pair = this.m_pairBuffer.data[k];\r\n      pair.indexA = newIndices[pair.indexA];\r\n      pair.indexB = newIndices[pair.indexB];\r\n    }\r\n    this.m_pairBuffer.RemoveIf(Test.IsPairInvalid);\r\n\r\n    // update triads\r\n    for (let k = 0; k < this.m_triadBuffer.count; k++) {\r\n      const triad = this.m_triadBuffer.data[k];\r\n      triad.indexA = newIndices[triad.indexA];\r\n      triad.indexB = newIndices[triad.indexB];\r\n      triad.indexC = newIndices[triad.indexC];\r\n    }\r\n    this.m_triadBuffer.RemoveIf(Test.IsTriadInvalid);\r\n\r\n    // Update lifetime indices.\r\n    if (this.m_indexByExpirationTimeBuffer.data) {\r\n      let writeOffset = 0;\r\n      for (let readOffset = 0; readOffset < this.m_count; readOffset++) {\r\n        const newIndex = newIndices[this.m_indexByExpirationTimeBuffer.data[readOffset]];\r\n        if (newIndex !== b2_invalidParticleIndex) {\r\n          this.m_indexByExpirationTimeBuffer.data[writeOffset++] = newIndex;\r\n        }\r\n      }\r\n    }\r\n\r\n    // update groups\r\n    for (let group = this.m_groupList; group; group = group.GetNext()) {\r\n      let firstIndex = newCount;\r\n      let lastIndex = 0;\r\n      let modified = false;\r\n      for (let i = group.m_firstIndex; i < group.m_lastIndex; i++) {\r\n        const j = newIndices[i];\r\n        if (j >= 0) {\r\n          firstIndex = b2Min(firstIndex, j);\r\n          lastIndex = b2Max(lastIndex, j + 1);\r\n        } else {\r\n          modified = true;\r\n        }\r\n      }\r\n      if (firstIndex < lastIndex) {\r\n        group.m_firstIndex = firstIndex;\r\n        group.m_lastIndex = lastIndex;\r\n        if (modified) {\r\n          if (group.m_groupFlags & b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n            this.SetGroupFlags(group, group.m_groupFlags | b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth);\r\n          }\r\n        }\r\n      } else {\r\n        group.m_firstIndex = 0;\r\n        group.m_lastIndex = 0;\r\n        if (!(group.m_groupFlags & b2ParticleGroupFlag.b2_particleGroupCanBeEmpty)) {\r\n          this.SetGroupFlags(group, group.m_groupFlags | b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed);\r\n        }\r\n      }\r\n    }\r\n\r\n    // update particle count\r\n    this.m_count = newCount;\r\n    this.m_allParticleFlags = allParticleFlags;\r\n    this.m_needsUpdateAllParticleFlags = false;\r\n\r\n    // destroy bodies with no particles\r\n    for (let group = this.m_groupList; group; ) {\r\n      const next = group.GetNext();\r\n      if (group.m_groupFlags & b2ParticleGroupFlag.b2_particleGroupWillBeDestroyed) {\r\n        this.DestroyParticleGroup(group);\r\n      }\r\n      group = next;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Destroy all particles which have outlived their lifetimes set\r\n   * by SetParticleLifetime().\r\n   */\r\n  public SolveLifetimes(step: b2TimeStep): void {\r\n    // Update the time elapsed.\r\n    this.m_timeElapsed = this.LifetimeToExpirationTime(step.dt);\r\n    // Get the floor (non-fractional component) of the elapsed time.\r\n    const quantizedTimeElapsed = this.GetQuantizedTimeElapsed();\r\n\r\n    const expirationTimes = this.m_expirationTimeBuffer.data;\r\n    const expirationTimeIndices = this.m_indexByExpirationTimeBuffer.data;\r\n    const particleCount = this.GetParticleCount();\r\n    // Sort the lifetime buffer if it's required.\r\n    if (this.m_expirationTimeBufferRequiresSorting) {\r\n      ///const ExpirationTimeComparator expirationTimeComparator(expirationTimes);\r\n      ///std::sort(expirationTimeIndices, expirationTimeIndices + particleCount, expirationTimeComparator);\r\n\r\n      /**\r\n       * Compare the lifetime of particleIndexA and particleIndexB\r\n       * returning true if the lifetime of A is greater than B for\r\n       * particles that will expire.  If either particle's lifetime is\r\n       * infinite (<= 0.0f) this function return true if the lifetime\r\n       * of A is lesser than B. When used with std::sort() this\r\n       * results in an array of particle indicies sorted in reverse\r\n       * order by particle lifetime.\r\n       *\r\n       * For example, the set of lifetimes\r\n       * (1.0, 0.7, 0.3, 0.0, -1.0, 2.0)\r\n       * would be sorted as\r\n       * (0.0, 1.0, -2.0, 1.0, 0.7, 0.3)\r\n       */\r\n      const ExpirationTimeComparator = (particleIndexA: number, particleIndexB: number): boolean => {\r\n        const expirationTimeA = expirationTimes[particleIndexA];\r\n        const expirationTimeB = expirationTimes[particleIndexB];\r\n        const infiniteExpirationTimeA = expirationTimeA <= 0.0;\r\n        const infiniteExpirationTimeB = expirationTimeB <= 0.0;\r\n        return infiniteExpirationTimeA === infiniteExpirationTimeB ?\r\n          expirationTimeA > expirationTimeB : infiniteExpirationTimeA;\r\n      };\r\n\r\n      std_sort(expirationTimeIndices, 0, particleCount, ExpirationTimeComparator);\r\n\r\n      this.m_expirationTimeBufferRequiresSorting = false;\r\n    }\r\n\r\n    // Destroy particles which have expired.\r\n    for (let i = particleCount - 1; i >= 0; --i) {\r\n      const particleIndex = expirationTimeIndices[i];\r\n      const expirationTime = expirationTimes[particleIndex];\r\n      // If no particles need to be destroyed, skip this.\r\n      if (quantizedTimeElapsed < expirationTime || expirationTime <= 0) {\r\n        break;\r\n      }\r\n      // Destroy this particle.\r\n      this.DestroyParticle(particleIndex);\r\n    }\r\n  }\r\n\r\n  public RotateBuffer(start: number, mid: number, end: number): void {\r\n    // move the particles assigned to the given group toward the end of array\r\n    if (start === mid || mid === end) {\r\n      return;\r\n    }\r\n    // DEBUG: b2Assert(mid >= start && mid <= end);\r\n\r\n    function newIndices(i: number): number {\r\n      if (i < start) {\r\n        return i;\r\n      } else if (i < mid) {\r\n        return i + end - mid;\r\n      } else if (i < end) {\r\n        return i + start - mid;\r\n      } else {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    ///std::rotate(m_flagsBuffer.data + start, m_flagsBuffer.data + mid, m_flagsBuffer.data + end);\r\n    std_rotate(this.m_flagsBuffer.data, start, mid, end);\r\n    if (this.m_lastBodyContactStepBuffer.data) {\r\n      ///std::rotate(m_lastBodyContactStepBuffer.data + start, m_lastBodyContactStepBuffer.data + mid, m_lastBodyContactStepBuffer.data + end);\r\n      std_rotate(this.m_lastBodyContactStepBuffer.data, start, mid, end);\r\n    }\r\n    if (this.m_bodyContactCountBuffer.data) {\r\n      ///std::rotate(m_bodyContactCountBuffer.data + start, m_bodyContactCountBuffer.data + mid, m_bodyContactCountBuffer.data + end);\r\n      std_rotate(this.m_bodyContactCountBuffer.data, start, mid, end);\r\n    }\r\n    if (this.m_consecutiveContactStepsBuffer.data) {\r\n      ///std::rotate(m_consecutiveContactStepsBuffer.data + start, m_consecutiveContactStepsBuffer.data + mid, m_consecutiveContactStepsBuffer.data + end);\r\n      std_rotate(this.m_consecutiveContactStepsBuffer.data, start, mid, end);\r\n    }\r\n    ///std::rotate(m_positionBuffer.data + start, m_positionBuffer.data + mid, m_positionBuffer.data + end);\r\n    std_rotate(this.m_positionBuffer.data, start, mid, end);\r\n    ///std::rotate(m_velocityBuffer.data + start, m_velocityBuffer.data + mid, m_velocityBuffer.data + end);\r\n    std_rotate(this.m_velocityBuffer.data, start, mid, end);\r\n    ///std::rotate(m_groupBuffer + start, m_groupBuffer + mid, m_groupBuffer + end);\r\n    std_rotate(this.m_groupBuffer, start, mid, end);\r\n    if (this.m_hasForce) {\r\n      ///std::rotate(m_forceBuffer + start, m_forceBuffer + mid, m_forceBuffer + end);\r\n      std_rotate(this.m_forceBuffer, start, mid, end);\r\n    }\r\n    if (this.m_staticPressureBuffer) {\r\n      ///std::rotate(m_staticPressureBuffer + start, m_staticPressureBuffer + mid, m_staticPressureBuffer + end);\r\n      std_rotate(this.m_staticPressureBuffer, start, mid, end);\r\n    }\r\n    if (this.m_depthBuffer) {\r\n      ///std::rotate(m_depthBuffer + start, m_depthBuffer + mid, m_depthBuffer + end);\r\n      std_rotate(this.m_depthBuffer, start, mid, end);\r\n    }\r\n    if (this.m_colorBuffer.data) {\r\n      ///std::rotate(m_colorBuffer.data + start, m_colorBuffer.data + mid, m_colorBuffer.data + end);\r\n      std_rotate(this.m_colorBuffer.data, start, mid, end);\r\n    }\r\n    if (this.m_userDataBuffer.data) {\r\n      ///std::rotate(m_userDataBuffer.data + start, m_userDataBuffer.data + mid, m_userDataBuffer.data + end);\r\n      std_rotate(this.m_userDataBuffer.data, start, mid, end);\r\n    }\r\n\r\n    // Update handle indices.\r\n    if (this.m_handleIndexBuffer.data) {\r\n      ///std::rotate(m_handleIndexBuffer.data + start, m_handleIndexBuffer.data + mid, m_handleIndexBuffer.data + end);\r\n      std_rotate(this.m_handleIndexBuffer.data, start, mid, end);\r\n      for (let i = start; i < end; ++i) {\r\n        const handle = this.m_handleIndexBuffer.data[i];\r\n        if (handle) { handle.SetIndex(newIndices(handle.GetIndex())); }\r\n      }\r\n    }\r\n\r\n    if (this.m_expirationTimeBuffer.data) {\r\n      ///std::rotate(m_expirationTimeBuffer.data + start, m_expirationTimeBuffer.data + mid, m_expirationTimeBuffer.data + end);\r\n      std_rotate(this.m_expirationTimeBuffer.data, start, mid, end);\r\n      // Update expiration time buffer indices.\r\n      const particleCount = this.GetParticleCount();\r\n      const indexByExpirationTime = this.m_indexByExpirationTimeBuffer.data;\r\n      for (let i = 0; i < particleCount; ++i) {\r\n        indexByExpirationTime[i] = newIndices(indexByExpirationTime[i]);\r\n      }\r\n    }\r\n\r\n    // update proxies\r\n    for (let k = 0; k < this.m_proxyBuffer.count; k++) {\r\n      const proxy = this.m_proxyBuffer.data[k];\r\n      proxy.index = newIndices(proxy.index);\r\n    }\r\n\r\n    // update contacts\r\n    for (let k = 0; k < this.m_contactBuffer.count; k++) {\r\n      const contact = this.m_contactBuffer.data[k];\r\n      contact.indexA = newIndices(contact.indexA);\r\n      contact.indexB = newIndices(contact.indexB);\r\n    }\r\n\r\n    // update particle-body contacts\r\n    for (let k = 0; k < this.m_bodyContactBuffer.count; k++) {\r\n      const contact = this.m_bodyContactBuffer.data[k];\r\n      contact.index = newIndices(contact.index);\r\n    }\r\n\r\n    // update pairs\r\n    for (let k = 0; k < this.m_pairBuffer.count; k++) {\r\n      const pair = this.m_pairBuffer.data[k];\r\n      pair.indexA = newIndices(pair.indexA);\r\n      pair.indexB = newIndices(pair.indexB);\r\n    }\r\n\r\n    // update triads\r\n    for (let k = 0; k < this.m_triadBuffer.count; k++) {\r\n      const triad = this.m_triadBuffer.data[k];\r\n      triad.indexA = newIndices(triad.indexA);\r\n      triad.indexB = newIndices(triad.indexB);\r\n      triad.indexC = newIndices(triad.indexC);\r\n    }\r\n\r\n    // update groups\r\n    for (let group = this.m_groupList; group; group = group.GetNext()) {\r\n      group.m_firstIndex = newIndices(group.m_firstIndex);\r\n      group.m_lastIndex = newIndices(group.m_lastIndex - 1) + 1;\r\n    }\r\n  }\r\n\r\n  public GetCriticalVelocity(step: b2TimeStep): number {\r\n    return this.m_particleDiameter * step.inv_dt;\r\n  }\r\n\r\n  public GetCriticalVelocitySquared(step: b2TimeStep): number {\r\n    const velocity = this.GetCriticalVelocity(step);\r\n    return velocity * velocity;\r\n  }\r\n\r\n  public GetCriticalPressure(step: b2TimeStep): number {\r\n    return this.m_def.density * this.GetCriticalVelocitySquared(step);\r\n  }\r\n\r\n  public GetParticleStride(): number {\r\n    return b2_particleStride * this.m_particleDiameter;\r\n  }\r\n\r\n  public GetParticleMass(): number {\r\n    const stride = this.GetParticleStride();\r\n    return this.m_def.density * stride * stride;\r\n  }\r\n\r\n  public GetParticleInvMass(): number {\r\n    ///return 1.777777 * this.m_inverseDensity * this.m_inverseDiameter * this.m_inverseDiameter;\r\n    // mass = density * stride^2, so we take the inverse of this.\r\n    const inverseStride = this.m_inverseDiameter * (1.0 / b2_particleStride);\r\n    return this.m_inverseDensity * inverseStride * inverseStride;\r\n  }\r\n\r\n  /**\r\n   * Get the world's contact filter if any particles with the\r\n   * b2_contactFilterParticle flag are present in the system.\r\n   */\r\n  public GetFixtureContactFilter(): b2ContactFilter | null {\r\n    return (this.m_allParticleFlags & b2ParticleFlag.b2_fixtureContactFilterParticle) ?\r\n      this.m_world.m_contactManager.m_contactFilter : null;\r\n  }\r\n\r\n  /**\r\n   * Get the world's contact filter if any particles with the\r\n   * b2_particleContactFilterParticle flag are present in the\r\n   * system.\r\n   */\r\n  public GetParticleContactFilter(): b2ContactFilter | null {\r\n    return (this.m_allParticleFlags & b2ParticleFlag.b2_particleContactFilterParticle) ?\r\n      this.m_world.m_contactManager.m_contactFilter : null;\r\n  }\r\n\r\n  /**\r\n   * Get the world's contact listener if any particles with the\r\n   * b2_fixtureContactListenerParticle flag are present in the\r\n   * system.\r\n   */\r\n  public GetFixtureContactListener(): b2ContactListener | null {\r\n    return (this.m_allParticleFlags & b2ParticleFlag.b2_fixtureContactListenerParticle) ?\r\n      this.m_world.m_contactManager.m_contactListener : null;\r\n  }\r\n\r\n  /**\r\n   * Get the world's contact listener if any particles with the\r\n   * b2_particleContactListenerParticle flag are present in the\r\n   * system.\r\n   */\r\n  public GetParticleContactListener(): b2ContactListener | null {\r\n    return (this.m_allParticleFlags & b2ParticleFlag.b2_particleContactListenerParticle) ?\r\n      this.m_world.m_contactManager.m_contactListener : null;\r\n  }\r\n\r\n  public SetUserOverridableBuffer<T>(buffer: b2ParticleSystem_UserOverridableBuffer<T>, data: T[]): void {\r\n    buffer.data = data;\r\n    buffer.userSuppliedCapacity = data.length;\r\n  }\r\n\r\n  public SetGroupFlags(group: b2ParticleGroup, newFlags: b2ParticleGroupFlag): void {\r\n    const oldFlags = group.m_groupFlags;\r\n    if ((oldFlags ^ newFlags) & b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n      // If the b2_solidParticleGroup flag changed schedule depth update.\r\n      newFlags |= b2ParticleGroupFlag.b2_particleGroupNeedsUpdateDepth;\r\n    }\r\n    if (oldFlags & ~newFlags) {\r\n      // If any flags might be removed\r\n      this.m_needsUpdateAllGroupFlags = true;\r\n    }\r\n    if (~this.m_allGroupFlags & newFlags) {\r\n      // If any flags were added\r\n      if (newFlags & b2ParticleGroupFlag.b2_solidParticleGroup) {\r\n        this.m_depthBuffer = this.RequestBuffer(this.m_depthBuffer);\r\n      }\r\n      this.m_allGroupFlags |= newFlags;\r\n    }\r\n    group.m_groupFlags = newFlags;\r\n  }\r\n\r\n  public static BodyContactCompare(lhs: b2ParticleBodyContact, rhs: b2ParticleBodyContact): boolean {\r\n    if (lhs.index === rhs.index) {\r\n      // Subsort by weight, decreasing.\r\n      return lhs.weight > rhs.weight;\r\n    }\r\n    return lhs.index < rhs.index;\r\n  }\r\n\r\n  public RemoveSpuriousBodyContacts(): void {\r\n    // At this point we have a list of contact candidates based on AABB\r\n    // overlap.The AABB query that  generated this returns all collidable\r\n    // fixtures overlapping particle bounding boxes.  This breaks down around\r\n    // vertices where two shapes intersect, such as a \"ground\" surface made\r\n    // of multiple b2PolygonShapes; it potentially applies a lot of spurious\r\n    // impulses from normals that should not actually contribute.  See the\r\n    // Ramp example in Testbed.\r\n    //\r\n    // To correct for this, we apply this algorithm:\r\n    //   * sort contacts by particle and subsort by weight (nearest to farthest)\r\n    //   * for each contact per particle:\r\n    //      - project a point at the contact distance along the inverse of the\r\n    //        contact normal\r\n    //      - if this intersects the fixture that generated the contact, apply\r\n    //         it, otherwise discard as impossible\r\n    //      - repeat for up to n nearest contacts, currently we get good results\r\n    //        from n=3.\r\n    ///std::sort(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleSystem::BodyContactCompare);\r\n    std_sort(this.m_bodyContactBuffer.data, 0, this.m_bodyContactBuffer.count, b2ParticleSystem.BodyContactCompare);\r\n\r\n    ///int32 discarded = 0;\r\n    ///std::remove_if(m_bodyContactBuffer.Begin(), m_bodyContactBuffer.End(), b2ParticleBodyContactRemovePredicate(this, &discarded));\r\n    ///\r\n    ///m_bodyContactBuffer.SetCount(m_bodyContactBuffer.GetCount() - discarded);\r\n\r\n    const s_n = b2ParticleSystem.RemoveSpuriousBodyContacts_s_n;\r\n    const s_pos = b2ParticleSystem.RemoveSpuriousBodyContacts_s_pos;\r\n    const s_normal = b2ParticleSystem.RemoveSpuriousBodyContacts_s_normal;\r\n\r\n    // Max number of contacts processed per particle, from nearest to farthest.\r\n    // This must be at least 2 for correctness with concave shapes; 3 was\r\n    // experimentally arrived at as looking reasonable.\r\n    const k_maxContactsPerPoint = 3;\r\n    const system = this;\r\n    // Index of last particle processed.\r\n    let lastIndex = -1;\r\n    // Number of contacts processed for the current particle.\r\n    let currentContacts = 0;\r\n    // Output the number of discarded contacts.\r\n    // let discarded = 0;\r\n    const b2ParticleBodyContactRemovePredicate = (contact: b2ParticleBodyContact): boolean => {\r\n      // This implements the selection criteria described in\r\n      // RemoveSpuriousBodyContacts().\r\n      // This functor is iterating through a list of Body contacts per\r\n      // Particle, ordered from near to far.  For up to the maximum number of\r\n      // contacts we allow per point per step, we verify that the contact\r\n      // normal of the Body that genenerated the contact makes physical sense\r\n      // by projecting a point back along that normal and seeing if it\r\n      // intersects the fixture generating the contact.\r\n\r\n      if (contact.index !== lastIndex) {\r\n        currentContacts = 0;\r\n        lastIndex = contact.index;\r\n      }\r\n\r\n      if (currentContacts++ > k_maxContactsPerPoint) {\r\n        // ++discarded;\r\n        return true;\r\n      }\r\n\r\n      // Project along inverse normal (as returned in the contact) to get the\r\n      // point to check.\r\n      ///b2Vec2 n = contact.normal;\r\n      const n = s_n.Copy(contact.normal);\r\n      // weight is 1-(inv(diameter) * distance)\r\n      ///n *= system.m_particleDiameter * (1 - contact.weight);\r\n      n.SelfMul(system.m_particleDiameter * (1 - contact.weight));\r\n      ///b2Vec2 pos = system.m_positionBuffer.data[contact.index] + n;\r\n      const pos = b2Vec2.AddVV(system.m_positionBuffer.data[contact.index], n, s_pos);\r\n\r\n      // pos is now a point projected back along the contact normal to the\r\n      // contact distance. If the surface makes sense for a contact, pos will\r\n      // now lie on or in the fixture generating\r\n      if (!contact.fixture.TestPoint(pos)) {\r\n        const childCount = contact.fixture.GetShape().GetChildCount();\r\n        for (let childIndex = 0; childIndex < childCount; childIndex++) {\r\n          const normal = s_normal;\r\n          const distance = contact.fixture.ComputeDistance(pos, normal, childIndex);\r\n          if (distance < b2_linearSlop) {\r\n            return false;\r\n          }\r\n        }\r\n        // ++discarded;\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n    this.m_bodyContactBuffer.count = std_remove_if(this.m_bodyContactBuffer.data, b2ParticleBodyContactRemovePredicate, this.m_bodyContactBuffer.count);\r\n  }\r\n  private static RemoveSpuriousBodyContacts_s_n = new b2Vec2();\r\n  private static RemoveSpuriousBodyContacts_s_pos = new b2Vec2();\r\n  private static RemoveSpuriousBodyContacts_s_normal = new b2Vec2();\r\n\r\n  public DetectStuckParticle(particle: number): void {\r\n    // Detect stuck particles\r\n    //\r\n    // The basic algorithm is to allow the user to specify an optional\r\n    // threshold where we detect whenever a particle is contacting\r\n    // more than one fixture for more than threshold consecutive\r\n    // steps. This is considered to be \"stuck\", and these are put\r\n    // in a list the user can query per step, if enabled, to deal with\r\n    // such particles.\r\n\r\n    if (this.m_stuckThreshold <= 0) {\r\n      return;\r\n    }\r\n\r\n    // Get the state variables for this particle.\r\n    ///int32 * const consecutiveCount = &m_consecutiveContactStepsBuffer.data[particle];\r\n    ///int32 * const lastStep = &m_lastBodyContactStepBuffer.data[particle];\r\n    ///int32 * const bodyCount = &m_bodyContactCountBuffer.data[particle];\r\n\r\n    // This is only called when there is a body contact for this particle.\r\n    ///++(*bodyCount);\r\n    ++this.m_bodyContactCountBuffer.data[particle];\r\n\r\n    // We want to only trigger detection once per step, the first time we\r\n    // contact more than one fixture in a step for a given particle.\r\n    ///if (*bodyCount === 2)\r\n    if (this.m_bodyContactCountBuffer.data[particle] === 2) {\r\n      ///++(*consecutiveCount);\r\n      ++this.m_consecutiveContactStepsBuffer.data[particle];\r\n      ///if (*consecutiveCount > m_stuckThreshold)\r\n      if (this.m_consecutiveContactStepsBuffer.data[particle] > this.m_stuckThreshold) {\r\n        ///int32& newStuckParticle = m_stuckParticleBuffer.Append();\r\n        ///newStuckParticle = particle;\r\n        this.m_stuckParticleBuffer.data[this.m_stuckParticleBuffer.Append()] = particle;\r\n      }\r\n    }\r\n    ///*lastStep = m_timestamp;\r\n    this.m_lastBodyContactStepBuffer.data[particle] = this.m_timestamp;\r\n  }\r\n\r\n  /**\r\n   * Determine whether a particle index is valid.\r\n   */\r\n  public ValidateParticleIndex(index: number): boolean {\r\n    return index >= 0 && index < this.GetParticleCount() &&\r\n      index !== b2_invalidParticleIndex;\r\n  }\r\n\r\n  /**\r\n   * Get the time elapsed in\r\n   * b2ParticleSystemDef::lifetimeGranularity.\r\n   */\r\n  public GetQuantizedTimeElapsed(): number {\r\n    ///return (int32)(m_timeElapsed >> 32);\r\n    return Math.floor(this.m_timeElapsed / 0x100000000);\r\n  }\r\n\r\n  /**\r\n   * Convert a lifetime in seconds to an expiration time.\r\n   */\r\n  public LifetimeToExpirationTime(lifetime: number): number {\r\n    ///return m_timeElapsed + (int64)((lifetime / m_def.lifetimeGranularity) * (float32)(1LL << 32));\r\n    return this.m_timeElapsed + Math.floor(((lifetime / this.m_def.lifetimeGranularity) * 0x100000000));\r\n  }\r\n\r\n  public ForceCanBeApplied(flags: b2ParticleFlag): boolean {\r\n    return !(flags & b2ParticleFlag.b2_wallParticle);\r\n  }\r\n\r\n  public PrepareForceBuffer(): void {\r\n    if (!this.m_hasForce) {\r\n      ///memset(m_forceBuffer, 0, sizeof(*m_forceBuffer) * m_count);\r\n      for (let i = 0; i < this.m_count; i++) {\r\n        this.m_forceBuffer[i].SetZero();\r\n      }\r\n      this.m_hasForce = true;\r\n    }\r\n  }\r\n\r\n  public IsRigidGroup(group: b2ParticleGroup | null): boolean {\r\n    return (group !== null) && ((group.m_groupFlags & b2ParticleGroupFlag.b2_rigidParticleGroup) !== 0);\r\n  }\r\n\r\n  public GetLinearVelocity(group: b2ParticleGroup | null, particleIndex: number, point: b2Vec2, out: b2Vec2): b2Vec2 {\r\n    if (group && this.IsRigidGroup(group)) {\r\n      return group.GetLinearVelocityFromWorldPoint(point, out);\r\n    } else {\r\n      ///return m_velocityBuffer.data[particleIndex];\r\n      return out.Copy(this.m_velocityBuffer.data[particleIndex]);\r\n    }\r\n  }\r\n\r\n  public InitDampingParameter(invMass: number[], invInertia: number[], tangentDistance: number[], mass: number, inertia: number, center: b2Vec2, point: b2Vec2, normal: b2Vec2): void {\r\n    ///*invMass = mass > 0 ? 1 / mass : 0;\r\n    invMass[0] = mass > 0 ? 1 / mass : 0;\r\n    ///*invInertia = inertia > 0 ? 1 / inertia : 0;\r\n    invInertia[0] = inertia > 0 ? 1 / inertia : 0;\r\n    ///*tangentDistance = b2Cross(point - center, normal);\r\n    tangentDistance[0] = b2Vec2.CrossVV(b2Vec2.SubVV(point, center, b2Vec2.s_t0), normal);\r\n  }\r\n\r\n  public InitDampingParameterWithRigidGroupOrParticle(invMass: number[], invInertia: number[], tangentDistance: number[], isRigidGroup: boolean, group: b2ParticleGroup | null, particleIndex: number, point: b2Vec2, normal: b2Vec2): void {\r\n    if (group && isRigidGroup) {\r\n      this.InitDampingParameter(invMass, invInertia, tangentDistance, group.GetMass(), group.GetInertia(), group.GetCenter(), point, normal);\r\n    } else {\r\n      const flags = this.m_flagsBuffer.data[particleIndex];\r\n      this.InitDampingParameter(invMass, invInertia, tangentDistance, flags & b2ParticleFlag.b2_wallParticle ? 0 : this.GetParticleMass(), 0, point, point, normal);\r\n    }\r\n  }\r\n\r\n  public ComputeDampingImpulse(invMassA: number, invInertiaA: number, tangentDistanceA: number, invMassB: number, invInertiaB: number, tangentDistanceB: number, normalVelocity: number): number {\r\n    const invMass =\r\n      invMassA + invInertiaA * tangentDistanceA * tangentDistanceA +\r\n      invMassB + invInertiaB * tangentDistanceB * tangentDistanceB;\r\n    return invMass > 0 ? normalVelocity / invMass : 0;\r\n  }\r\n\r\n  public ApplyDamping(invMass: number, invInertia: number, tangentDistance: number, isRigidGroup: boolean, group: b2ParticleGroup | null, particleIndex: number, impulse: number, normal: b2Vec2): void {\r\n    if (group && isRigidGroup) {\r\n      ///group.m_linearVelocity += impulse * invMass * normal;\r\n      group.m_linearVelocity.SelfMulAdd(impulse * invMass, normal);\r\n      ///group.m_angularVelocity += impulse * tangentDistance * invInertia;\r\n      group.m_angularVelocity += impulse * tangentDistance * invInertia;\r\n    } else {\r\n      ///m_velocityBuffer.data[particleIndex] += impulse * invMass * normal;\r\n      this.m_velocityBuffer.data[particleIndex].SelfMulAdd(impulse * invMass, normal);\r\n    }\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_UserOverridableBuffer<T> {\r\n  public _data: T[] | null = null;\r\n  public get data(): T[] { return this._data as T[]; } // HACK: may return null\r\n  public set data(value: T[]) { this._data = value; }\r\n  public userSuppliedCapacity: number = 0;\r\n}\r\n\r\nexport class b2ParticleSystem_Proxy {\r\n  public index: number = b2_invalidParticleIndex;\r\n  public tag: number = 0;\r\n  public static CompareProxyProxy(a: b2ParticleSystem_Proxy, b: b2ParticleSystem_Proxy): boolean {\r\n    return a.tag < b.tag;\r\n  }\r\n  public static CompareTagProxy(a: number, b: b2ParticleSystem_Proxy): boolean {\r\n    return a < b.tag;\r\n  }\r\n  public static CompareProxyTag(a: b2ParticleSystem_Proxy, b: number): boolean {\r\n    return a.tag < b;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_InsideBoundsEnumerator {\r\n  public m_system: b2ParticleSystem;\r\n  public m_xLower: number;\r\n  public m_xUpper: number;\r\n  public m_yLower: number;\r\n  public m_yUpper: number;\r\n  public m_first: number;\r\n  public m_last: number;\r\n  /**\r\n   * InsideBoundsEnumerator enumerates all particles inside the\r\n   * given bounds.\r\n   *\r\n   * Construct an enumerator with bounds of tags and a range of\r\n   * proxies.\r\n   */\r\n  constructor(system: b2ParticleSystem, lower: number, upper: number, first: number, last: number) {\r\n    this.m_system = system;\r\n    this.m_xLower = (lower & b2ParticleSystem.xMask) >>> 0;\r\n    this.m_xUpper = (upper & b2ParticleSystem.xMask) >>> 0;\r\n    this.m_yLower = (lower & b2ParticleSystem.yMask) >>> 0;\r\n    this.m_yUpper = (upper & b2ParticleSystem.yMask) >>> 0;\r\n    this.m_first = first;\r\n    this.m_last = last;\r\n    // DEBUG: b2Assert(this.m_first <= this.m_last);\r\n  }\r\n\r\n  /**\r\n   * Get index of the next particle. Returns\r\n   * b2_invalidParticleIndex if there are no more particles.\r\n   */\r\n  public GetNext(): number {\r\n    while (this.m_first < this.m_last) {\r\n      const xTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem.xMask) >>> 0;\r\n      // #if B2_ASSERT_ENABLED\r\n      // DEBUG: const yTag = (this.m_system.m_proxyBuffer.data[this.m_first].tag & b2ParticleSystem_yMask) >>> 0;\r\n      // DEBUG: b2Assert(yTag >= this.m_yLower);\r\n      // DEBUG: b2Assert(yTag <= this.m_yUpper);\r\n      // #endif\r\n      if (xTag >= this.m_xLower && xTag <= this.m_xUpper) {\r\n        return (this.m_system.m_proxyBuffer.data[this.m_first++]).index;\r\n      }\r\n      this.m_first++;\r\n    }\r\n    return b2_invalidParticleIndex;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_ParticleListNode {\r\n  /**\r\n   * The head of the list.\r\n   */\r\n  public list!: b2ParticleSystem_ParticleListNode;\r\n  /**\r\n   * The next node in the list.\r\n   */\r\n  public next: b2ParticleSystem_ParticleListNode | null = null;\r\n  /**\r\n   * Number of entries in the list. Valid only for the node at the\r\n   * head of the list.\r\n   */\r\n  public count: number = 0;\r\n  /**\r\n   * Particle index.\r\n   */\r\n  public index: number = 0;\r\n}\r\n\r\n/**\r\n * @constructor\r\n */\r\nexport class b2ParticleSystem_FixedSetAllocator<T> {\r\n  public Allocate(itemSize: number, count: number): number {\r\n    // TODO\r\n    return count;\r\n  }\r\n\r\n  public Clear(): void {\r\n    // TODO\r\n  }\r\n\r\n  public GetCount(): number {\r\n    // TODO\r\n    return 0;\r\n  }\r\n\r\n  public Invalidate(itemIndex: number): void {\r\n    // TODO\r\n  }\r\n\r\n  public GetValidBuffer(): boolean[] {\r\n    // TODO\r\n    return [];\r\n  }\r\n\r\n  public GetBuffer(): T[] {\r\n    // TODO\r\n    return [];\r\n  }\r\n\r\n  public SetCount(count: number): void {\r\n    // TODO\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_FixtureParticle {\r\n  public first: b2Fixture;\r\n  public second: number = b2_invalidParticleIndex;\r\n  constructor(fixture: b2Fixture, particle: number) {\r\n    this.first = fixture;\r\n    this.second = particle;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_FixtureParticleSet extends b2ParticleSystem_FixedSetAllocator<b2ParticleSystem_FixtureParticle> {\r\n  public Initialize(bodyContactBuffer: b2GrowableBuffer<b2ParticleBodyContact>, flagsBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag>): void {\r\n    // TODO\r\n  }\r\n  public Find(pair: b2ParticleSystem_FixtureParticle): number {\r\n    // TODO\r\n    return b2_invalidParticleIndex;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_ParticlePair {\r\n  public first: number = b2_invalidParticleIndex;\r\n  public second: number = b2_invalidParticleIndex;\r\n  constructor(particleA: number, particleB: number) {\r\n    this.first = particleA;\r\n    this.second = particleB;\r\n  }\r\n}\r\n\r\nexport class b2ParticlePairSet extends b2ParticleSystem_FixedSetAllocator<b2ParticleSystem_ParticlePair> {\r\n  public Initialize(contactBuffer: b2GrowableBuffer<b2ParticleContact>, flagsBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag>): void {\r\n    // TODO\r\n  }\r\n\r\n  public Find(pair: b2ParticleSystem_ParticlePair): number {\r\n    // TODO\r\n    return b2_invalidParticleIndex;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_ConnectionFilter {\r\n  /**\r\n   * Is the particle necessary for connection?\r\n   * A pair or a triad should contain at least one 'necessary'\r\n   * particle.\r\n   */\r\n  public IsNecessary(index: number): boolean {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * An additional condition for creating a pair.\r\n   */\r\n  public ShouldCreatePair(a: number, b: number): boolean {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * An additional condition for creating a triad.\r\n   */\r\n  public ShouldCreateTriad(a: number, b: number, c: number): boolean {\r\n    return true;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_DestroyParticlesInShapeCallback extends b2QueryCallback {\r\n  public m_system: b2ParticleSystem;\r\n  public m_shape: b2Shape;\r\n  public m_xf: b2Transform;\r\n  public m_callDestructionListener: boolean = false;\r\n  public m_destroyed: number = 0;\r\n\r\n  constructor(system: b2ParticleSystem, shape: b2Shape, xf: b2Transform, callDestructionListener: boolean) {\r\n    super();\r\n    this.m_system = system;\r\n    this.m_shape = shape;\r\n    this.m_xf = xf;\r\n    this.m_callDestructionListener = callDestructionListener;\r\n    this.m_destroyed = 0;\r\n  }\r\n\r\n  public ReportFixture(fixture: b2Fixture): boolean {\r\n    return false;\r\n  }\r\n\r\n  public ReportParticle(particleSystem: b2ParticleSystem, index: number): boolean {\r\n    if (particleSystem !== this.m_system) {\r\n      return false;\r\n    }\r\n    // DEBUG: b2Assert(index >= 0 && index < this.m_system.m_count);\r\n    if (this.m_shape.TestPoint(this.m_xf, this.m_system.m_positionBuffer.data[index])) {\r\n      this.m_system.DestroyParticle(index, this.m_callDestructionListener);\r\n      this.m_destroyed++;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public Destroyed(): number {\r\n    return this.m_destroyed;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_JoinParticleGroupsFilter extends b2ParticleSystem_ConnectionFilter {\r\n  public m_threshold: number = 0;\r\n\r\n  constructor(threshold: number) {\r\n    super();\r\n    this.m_threshold = threshold;\r\n  }\r\n\r\n  /**\r\n   * An additional condition for creating a pair.\r\n   */\r\n  public ShouldCreatePair(a: number, b: number): boolean {\r\n    return (a < this.m_threshold && this.m_threshold <= b) ||\r\n      (b < this.m_threshold && this.m_threshold <= a);\r\n  }\r\n\r\n  /**\r\n   * An additional condition for creating a triad.\r\n   */\r\n  public ShouldCreateTriad(a: number, b: number, c: number): boolean {\r\n    return (a < this.m_threshold || b < this.m_threshold || c < this.m_threshold) &&\r\n      (this.m_threshold <= a || this.m_threshold <= b || this.m_threshold <= c);\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_CompositeShape extends b2Shape {\r\n  constructor(shapes: b2Shape[], shapeCount: number = shapes.length) {\r\n    super(b2ShapeType.e_unknown, 0);\r\n    this.m_shapes = shapes;\r\n    this.m_shapeCount = shapeCount;\r\n  }\r\n\r\n  public m_shapes: b2Shape[];\r\n  public m_shapeCount: number = 0;\r\n\r\n  public Clone(): b2Shape {\r\n    // DEBUG: b2Assert(false);\r\n    throw new Error();\r\n  }\r\n\r\n  public GetChildCount(): number {\r\n    return 1;\r\n  }\r\n\r\n  /**\r\n   * @see b2Shape::TestPoint\r\n   */\r\n  public TestPoint(xf: b2Transform, p: XY): boolean {\r\n    for (let i = 0; i < this.m_shapeCount; i++) {\r\n      if (this.m_shapes[i].TestPoint(xf, p)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @see b2Shape::ComputeDistance\r\n   */\r\n  public ComputeDistance(xf: b2Transform, p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    // DEBUG: b2Assert(false);\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Implement b2Shape.\r\n   */\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, xf: b2Transform, childIndex: number): boolean {\r\n    // DEBUG: b2Assert(false);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @see b2Shape::ComputeAABB\r\n   */\r\n  public ComputeAABB(aabb: b2AABB, xf: b2Transform, childIndex: number): void {\r\n    const s_subaabb = new b2AABB();\r\n    aabb.lowerBound.x = +b2_maxFloat;\r\n    aabb.lowerBound.y = +b2_maxFloat;\r\n    aabb.upperBound.x = -b2_maxFloat;\r\n    aabb.upperBound.y = -b2_maxFloat;\r\n    // DEBUG: b2Assert(childIndex === 0);\r\n    for (let i = 0; i < this.m_shapeCount; i++) {\r\n      const childCount = this.m_shapes[i].GetChildCount();\r\n      for (let j = 0; j < childCount; j++) {\r\n        const subaabb = s_subaabb;\r\n        this.m_shapes[i].ComputeAABB(subaabb, xf, j);\r\n        aabb.Combine1(subaabb);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @see b2Shape::ComputeMass\r\n   */\r\n  public ComputeMass(massData: b2MassData, density: number): void {\r\n    // DEBUG: b2Assert(false);\r\n  }\r\n\r\n  public SetupDistanceProxy(proxy: b2DistanceProxy, index: number): void {\r\n    // DEBUG: b2Assert(false);\r\n  }\r\n\r\n  public ComputeSubmergedArea(normal: b2Vec2, offset: number, xf: b2Transform, c: b2Vec2): number {\r\n    // DEBUG: b2Assert(false);\r\n    return 0;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    // DEBUG: b2Assert(false);\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_ReactiveFilter extends b2ParticleSystem_ConnectionFilter {\r\n  public m_flagsBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag>;\r\n  constructor(flagsBuffer: b2ParticleSystem_UserOverridableBuffer<b2ParticleFlag>) {\r\n    super();\r\n    this.m_flagsBuffer = flagsBuffer;\r\n  }\r\n  public IsNecessary(index: number): boolean {\r\n    return (this.m_flagsBuffer.data[index] & b2ParticleFlag.b2_reactiveParticle) !== 0;\r\n  }\r\n}\r\n\r\nexport class b2ParticleSystem_UpdateBodyContactsCallback extends b2FixtureParticleQueryCallback {\r\n  public m_contactFilter: b2ContactFilter | null = null;\r\n  constructor(system: b2ParticleSystem, contactFilter: b2ContactFilter | null = null) {\r\n    super(system); // base class constructor\r\n    this.m_contactFilter = contactFilter;\r\n  }\r\n\r\n  public ShouldCollideFixtureParticle(fixture: b2Fixture, particleSystem: b2ParticleSystem, particleIndex: number): boolean {\r\n    // Call the contact filter if it's set, to determine whether to\r\n    // filter this contact.  Returns true if contact calculations should\r\n    // be performed, false otherwise.\r\n    if (this.m_contactFilter) {\r\n      const flags = this.m_system.GetFlagsBuffer();\r\n      if (flags[particleIndex] & b2ParticleFlag.b2_fixtureContactFilterParticle) {\r\n        return this.m_contactFilter.ShouldCollideFixtureParticle(fixture, this.m_system, particleIndex);\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  public ReportFixtureAndParticle(fixture: b2Fixture, childIndex: number, a: number): void {\r\n    const s_n = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_n;\r\n    const s_rp = b2ParticleSystem_UpdateBodyContactsCallback.ReportFixtureAndParticle_s_rp;\r\n    const ap = this.m_system.m_positionBuffer.data[a];\r\n    const n = s_n;\r\n    const d = fixture.ComputeDistance(ap, n, childIndex);\r\n    if (d < this.m_system.m_particleDiameter && this.ShouldCollideFixtureParticle(fixture, this.m_system, a)) {\r\n      const b = fixture.GetBody();\r\n      const bp = b.GetWorldCenter();\r\n      const bm = b.GetMass();\r\n      const bI = b.GetInertia() - bm * b.GetLocalCenter().LengthSquared();\r\n      const invBm = bm > 0 ? 1 / bm : 0;\r\n      const invBI = bI > 0 ? 1 / bI : 0;\r\n      const invAm =\r\n        this.m_system.m_flagsBuffer.data[a] &\r\n        b2ParticleFlag.b2_wallParticle ? 0 : this.m_system.GetParticleInvMass();\r\n      ///b2Vec2 rp = ap - bp;\r\n      const rp = b2Vec2.SubVV(ap, bp, s_rp);\r\n      const rpn = b2Vec2.CrossVV(rp, n);\r\n      const invM = invAm + invBm + invBI * rpn * rpn;\r\n\r\n      ///b2ParticleBodyContact& contact = m_system.m_bodyContactBuffer.Append();\r\n      const contact = this.m_system.m_bodyContactBuffer.data[this.m_system.m_bodyContactBuffer.Append()];\r\n      contact.index = a;\r\n      contact.body = b;\r\n      contact.fixture = fixture;\r\n      contact.weight = 1 - d * this.m_system.m_inverseDiameter;\r\n      ///contact.normal = -n;\r\n      contact.normal.Copy(n.SelfNeg());\r\n      contact.mass = invM > 0 ? 1 / invM : 0;\r\n      this.m_system.DetectStuckParticle(a);\r\n    }\r\n  }\r\n  public static readonly ReportFixtureAndParticle_s_n = new b2Vec2();\r\n  public static readonly ReportFixtureAndParticle_s_rp = new b2Vec2();\r\n}\r\n\r\nexport class b2ParticleSystem_SolveCollisionCallback extends b2FixtureParticleQueryCallback {\r\n  public m_step: b2TimeStep;\r\n  constructor(system: b2ParticleSystem, step: b2TimeStep) {\r\n    super(system); // base class constructor\r\n    this.m_step = step;\r\n  }\r\n\r\n  public ReportFixtureAndParticle(fixture: b2Fixture, childIndex: number, a: number): void {\r\n    const s_p1 = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p1;\r\n    const s_output = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_output;\r\n    const s_input = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_input;\r\n    const s_p = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_p;\r\n    const s_v = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_v;\r\n    const s_f = b2ParticleSystem_SolveCollisionCallback.ReportFixtureAndParticle_s_f;\r\n\r\n    const body = fixture.GetBody();\r\n    const ap = this.m_system.m_positionBuffer.data[a];\r\n    const av = this.m_system.m_velocityBuffer.data[a];\r\n    const output = s_output;\r\n    const input = s_input;\r\n    if (this.m_system.m_iterationIndex === 0) {\r\n      // Put 'ap' in the local space of the previous frame\r\n      ///b2Vec2 p1 = b2MulT(body.m_xf0, ap);\r\n      const p1 = b2Transform.MulTXV(body.m_xf0, ap, s_p1);\r\n      if (fixture.GetShape().GetType() === b2ShapeType.e_circleShape) {\r\n        // Make relative to the center of the circle\r\n        ///p1 -= body.GetLocalCenter();\r\n        p1.SelfSub(body.GetLocalCenter());\r\n        // Re-apply rotation about the center of the circle\r\n        ///p1 = b2Mul(body.m_xf0.q, p1);\r\n        b2Rot.MulRV(body.m_xf0.q, p1, p1);\r\n        // Subtract rotation of the current frame\r\n        ///p1 = b2MulT(body.m_xf.q, p1);\r\n        b2Rot.MulTRV(body.m_xf.q, p1, p1);\r\n        // Return to local space\r\n        ///p1 += body.GetLocalCenter();\r\n        p1.SelfAdd(body.GetLocalCenter());\r\n      }\r\n      // Return to global space and apply rotation of current frame\r\n      ///input.p1 = b2Mul(body.m_xf, p1);\r\n      b2Transform.MulXV(body.m_xf, p1, input.p1);\r\n    } else {\r\n      ///input.p1 = ap;\r\n      input.p1.Copy(ap);\r\n    }\r\n    ///input.p2 = ap + m_step.dt * av;\r\n    b2Vec2.AddVMulSV(ap, this.m_step.dt, av, input.p2);\r\n    input.maxFraction = 1;\r\n    if (fixture.RayCast(output, input, childIndex)) {\r\n      const n = output.normal;\r\n      ///b2Vec2 p = (1 - output.fraction) * input.p1 + output.fraction * input.p2 + b2_linearSlop * n;\r\n      const p = s_p;\r\n      p.x = (1 - output.fraction) * input.p1.x + output.fraction * input.p2.x + b2_linearSlop * n.x;\r\n      p.y = (1 - output.fraction) * input.p1.y + output.fraction * input.p2.y + b2_linearSlop * n.y;\r\n      ///b2Vec2 v = m_step.inv_dt * (p - ap);\r\n      const v = s_v;\r\n      v.x = this.m_step.inv_dt * (p.x - ap.x);\r\n      v.y = this.m_step.inv_dt * (p.y - ap.y);\r\n      ///m_system.m_velocityBuffer.data[a] = v;\r\n      this.m_system.m_velocityBuffer.data[a].Copy(v);\r\n      ///b2Vec2 f = m_step.inv_dt * m_system.GetParticleMass() * (av - v);\r\n      const f = s_f;\r\n      f.x = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.x - v.x);\r\n      f.y = this.m_step.inv_dt * this.m_system.GetParticleMass() * (av.y - v.y);\r\n      this.m_system.ParticleApplyForce(a, f);\r\n    }\r\n  }\r\n  public static readonly ReportFixtureAndParticle_s_p1 = new b2Vec2();\r\n  public static readonly ReportFixtureAndParticle_s_output = new b2RayCastOutput();\r\n  public static readonly ReportFixtureAndParticle_s_input = new b2RayCastInput();\r\n  public static readonly ReportFixtureAndParticle_s_p = new b2Vec2();\r\n  public static readonly ReportFixtureAndParticle_s_v = new b2Vec2();\r\n  public static readonly ReportFixtureAndParticle_s_f = new b2Vec2();\r\n\r\n  public ReportParticle(system: b2ParticleSystem, index: number): boolean {\r\n    return false;\r\n  }\r\n}\r\n\r\n// #endif\r\n"]}},"error":null,"hash":"b818c49642f9439e0a141ea48b857e3f","cacheData":{"env":{}}}