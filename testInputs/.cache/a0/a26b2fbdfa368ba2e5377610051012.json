{"id":"../node_modules/box2d.package.ts/Collision/Shapes/b2ChainShape.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":31,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2ChainShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":32,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2ChainShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Shape","loc":{"line":33,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2ChainShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"},{"name":"./b2EdgeShape","loc":{"line":34,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2ChainShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2EdgeShape.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert, b2_linearSlop } from \"../../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Shape_1 = require(\"./b2Shape\");\r\nvar b2EdgeShape_1 = require(\"./b2EdgeShape\");\r\n/// A chain shape is a free form sequence of line segments.\r\n/// The chain has two-sided collision, so you can use inside and outside collision.\r\n/// Therefore, you may use any winding order.\r\n/// Since there may be many vertices, they are allocated using b2Alloc.\r\n/// Connectivity information is used to create smooth collisions.\r\n/// WARNING: The chain will not collide properly if there are self-intersections.\r\nvar b2ChainShape = /** @class */ (function (_super) {\r\n    __extends(b2ChainShape, _super);\r\n    function b2ChainShape() {\r\n        var _this = _super.call(this, b2Shape_1.b2ShapeType.e_chainShape, b2Settings_1.b2_polygonRadius) || this;\r\n        _this.m_vertices = [];\r\n        _this.m_count = 0;\r\n        _this.m_prevVertex = new b2Math_1.b2Vec2();\r\n        _this.m_nextVertex = new b2Math_1.b2Vec2();\r\n        _this.m_hasPrevVertex = false;\r\n        _this.m_hasNextVertex = false;\r\n        return _this;\r\n    }\r\n    b2ChainShape.prototype.CreateLoop = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (typeof args[0][0] === \"number\") {\r\n            var vertices_1 = args[0];\r\n            if (vertices_1.length % 2 !== 0) {\r\n                throw new Error();\r\n            }\r\n            return this._CreateLoop(function (index) { return ({ x: vertices_1[index * 2], y: vertices_1[index * 2 + 1] }); }, vertices_1.length / 2);\r\n        }\r\n        else {\r\n            var vertices_2 = args[0];\r\n            var count = args[1] || vertices_2.length;\r\n            return this._CreateLoop(function (index) { return vertices_2[index]; }, count);\r\n        }\r\n    };\r\n    b2ChainShape.prototype._CreateLoop = function (vertices, count) {\r\n        // DEBUG: b2Assert(count >= 3);\r\n        if (count < 3) {\r\n            return this;\r\n        }\r\n        // DEBUG: for (let i: number = 1; i < count; ++i) {\r\n        // DEBUG:   const v1 = vertices[start + i - 1];\r\n        // DEBUG:   const v2 = vertices[start + i];\r\n        // DEBUG:   // If the code crashes here, it means your vertices are too close together.\r\n        // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);\r\n        // DEBUG: }\r\n        this.m_count = count + 1;\r\n        this.m_vertices = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        for (var i = 0; i < count; ++i) {\r\n            this.m_vertices[i].Copy(vertices(i));\r\n        }\r\n        this.m_vertices[count].Copy(this.m_vertices[0]);\r\n        this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);\r\n        this.m_nextVertex.Copy(this.m_vertices[1]);\r\n        this.m_hasPrevVertex = true;\r\n        this.m_hasNextVertex = true;\r\n        return this;\r\n    };\r\n    b2ChainShape.prototype.CreateChain = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (typeof args[0][0] === \"number\") {\r\n            var vertices_3 = args[0];\r\n            if (vertices_3.length % 2 !== 0) {\r\n                throw new Error();\r\n            }\r\n            return this._CreateChain(function (index) { return ({ x: vertices_3[index * 2], y: vertices_3[index * 2 + 1] }); }, vertices_3.length / 2);\r\n        }\r\n        else {\r\n            var vertices_4 = args[0];\r\n            var count = args[1] || vertices_4.length;\r\n            return this._CreateChain(function (index) { return vertices_4[index]; }, count);\r\n        }\r\n    };\r\n    b2ChainShape.prototype._CreateChain = function (vertices, count) {\r\n        // DEBUG: b2Assert(count >= 2);\r\n        // DEBUG: for (let i: number = 1; i < count; ++i) {\r\n        // DEBUG:   const v1 = vertices[start + i - 1];\r\n        // DEBUG:   const v2 = vertices[start + i];\r\n        // DEBUG:   // If the code crashes here, it means your vertices are too close together.\r\n        // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);\r\n        // DEBUG: }\r\n        this.m_count = count;\r\n        this.m_vertices = b2Math_1.b2Vec2.MakeArray(count);\r\n        for (var i = 0; i < count; ++i) {\r\n            this.m_vertices[i].Copy(vertices(i));\r\n        }\r\n        this.m_hasPrevVertex = false;\r\n        this.m_hasNextVertex = false;\r\n        this.m_prevVertex.SetZero();\r\n        this.m_nextVertex.SetZero();\r\n        return this;\r\n    };\r\n    /// Establish connectivity to a vertex that precedes the first vertex.\r\n    /// Don't call this for loops.\r\n    b2ChainShape.prototype.SetPrevVertex = function (prevVertex) {\r\n        this.m_prevVertex.Copy(prevVertex);\r\n        this.m_hasPrevVertex = true;\r\n        return this;\r\n    };\r\n    /// Establish connectivity to a vertex that follows the last vertex.\r\n    /// Don't call this for loops.\r\n    b2ChainShape.prototype.SetNextVertex = function (nextVertex) {\r\n        this.m_nextVertex.Copy(nextVertex);\r\n        this.m_hasNextVertex = true;\r\n        return this;\r\n    };\r\n    /// Implement b2Shape. Vertices are cloned using b2Alloc.\r\n    b2ChainShape.prototype.Clone = function () {\r\n        return new b2ChainShape().Copy(this);\r\n    };\r\n    b2ChainShape.prototype.Copy = function (other) {\r\n        _super.prototype.Copy.call(this, other);\r\n        // DEBUG: b2Assert(other instanceof b2ChainShape);\r\n        this._CreateChain(function (index) { return other.m_vertices[index]; }, other.m_count);\r\n        this.m_prevVertex.Copy(other.m_prevVertex);\r\n        this.m_nextVertex.Copy(other.m_nextVertex);\r\n        this.m_hasPrevVertex = other.m_hasPrevVertex;\r\n        this.m_hasNextVertex = other.m_hasNextVertex;\r\n        return this;\r\n    };\r\n    /// @see b2Shape::GetChildCount\r\n    b2ChainShape.prototype.GetChildCount = function () {\r\n        // edge count = vertex count - 1\r\n        return this.m_count - 1;\r\n    };\r\n    /// Get a child edge.\r\n    b2ChainShape.prototype.GetChildEdge = function (edge, index) {\r\n        // DEBUG: b2Assert(0 <= index && index < this.m_count - 1);\r\n        edge.m_radius = this.m_radius;\r\n        edge.m_vertex1.Copy(this.m_vertices[index]);\r\n        edge.m_vertex2.Copy(this.m_vertices[index + 1]);\r\n        if (index > 0) {\r\n            edge.m_vertex0.Copy(this.m_vertices[index - 1]);\r\n            edge.m_hasVertex0 = true;\r\n        }\r\n        else {\r\n            edge.m_vertex0.Copy(this.m_prevVertex);\r\n            edge.m_hasVertex0 = this.m_hasPrevVertex;\r\n        }\r\n        if (index < this.m_count - 2) {\r\n            edge.m_vertex3.Copy(this.m_vertices[index + 2]);\r\n            edge.m_hasVertex3 = true;\r\n        }\r\n        else {\r\n            edge.m_vertex3.Copy(this.m_nextVertex);\r\n            edge.m_hasVertex3 = this.m_hasNextVertex;\r\n        }\r\n    };\r\n    /// This always return false.\r\n    /// @see b2Shape::TestPoint\r\n    b2ChainShape.prototype.TestPoint = function (xf, p) {\r\n        return false;\r\n    };\r\n    b2ChainShape.prototype.ComputeDistance = function (xf, p, normal, childIndex) {\r\n        var edge = b2ChainShape.ComputeDistance_s_edgeShape;\r\n        this.GetChildEdge(edge, childIndex);\r\n        return edge.ComputeDistance(xf, p, normal, 0);\r\n    };\r\n    b2ChainShape.prototype.RayCast = function (output, input, xf, childIndex) {\r\n        // DEBUG: b2Assert(childIndex < this.m_count);\r\n        var edgeShape = b2ChainShape.RayCast_s_edgeShape;\r\n        edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);\r\n        edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);\r\n        return edgeShape.RayCast(output, input, xf, 0);\r\n    };\r\n    b2ChainShape.prototype.ComputeAABB = function (aabb, xf, childIndex) {\r\n        // DEBUG: b2Assert(childIndex < this.m_count);\r\n        var vertexi1 = this.m_vertices[childIndex];\r\n        var vertexi2 = this.m_vertices[(childIndex + 1) % this.m_count];\r\n        var v1 = b2Math_1.b2Transform.MulXV(xf, vertexi1, b2ChainShape.ComputeAABB_s_v1);\r\n        var v2 = b2Math_1.b2Transform.MulXV(xf, vertexi2, b2ChainShape.ComputeAABB_s_v2);\r\n        b2Math_1.b2Vec2.MinV(v1, v2, aabb.lowerBound);\r\n        b2Math_1.b2Vec2.MaxV(v1, v2, aabb.upperBound);\r\n    };\r\n    /// Chains have zero mass.\r\n    /// @see b2Shape::ComputeMass\r\n    b2ChainShape.prototype.ComputeMass = function (massData, density) {\r\n        massData.mass = 0;\r\n        massData.center.SetZero();\r\n        massData.I = 0;\r\n    };\r\n    b2ChainShape.prototype.SetupDistanceProxy = function (proxy, index) {\r\n        // DEBUG: b2Assert(0 <= index && index < this.m_count);\r\n        proxy.m_vertices = proxy.m_buffer;\r\n        proxy.m_vertices[0].Copy(this.m_vertices[index]);\r\n        if (index + 1 < this.m_count) {\r\n            proxy.m_vertices[1].Copy(this.m_vertices[index + 1]);\r\n        }\r\n        else {\r\n            proxy.m_vertices[1].Copy(this.m_vertices[0]);\r\n        }\r\n        proxy.m_count = 2;\r\n        proxy.m_radius = this.m_radius;\r\n    };\r\n    b2ChainShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {\r\n        c.SetZero();\r\n        return 0;\r\n    };\r\n    b2ChainShape.prototype.Dump = function (log) {\r\n        log(\"    const shape: b2ChainShape = new b2ChainShape();\\n\");\r\n        log(\"    const vs: b2Vec2[] = [];\\n\");\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            log(\"    vs[%d] = new bVec2(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n        }\r\n        log(\"    shape.CreateChain(vs, %d);\\n\", this.m_count);\r\n        log(\"    shape.m_prevVertex.Set(%.15f, %.15f);\\n\", this.m_prevVertex.x, this.m_prevVertex.y);\r\n        log(\"    shape.m_nextVertex.Set(%.15f, %.15f);\\n\", this.m_nextVertex.x, this.m_nextVertex.y);\r\n        log(\"    shape.m_hasPrevVertex = %s;\\n\", (this.m_hasPrevVertex) ? (\"true\") : (\"false\"));\r\n        log(\"    shape.m_hasNextVertex = %s;\\n\", (this.m_hasNextVertex) ? (\"true\") : (\"false\"));\r\n    };\r\n    // #if B2_ENABLE_PARTICLE\r\n    /// @see b2Shape::ComputeDistance\r\n    b2ChainShape.ComputeDistance_s_edgeShape = new b2EdgeShape_1.b2EdgeShape();\r\n    // #endif\r\n    /// Implement b2Shape.\r\n    b2ChainShape.RayCast_s_edgeShape = new b2EdgeShape_1.b2EdgeShape();\r\n    /// @see b2Shape::ComputeAABB\r\n    b2ChainShape.ComputeAABB_s_v1 = new b2Math_1.b2Vec2();\r\n    b2ChainShape.ComputeAABB_s_v2 = new b2Math_1.b2Vec2();\r\n    return b2ChainShape;\r\n}(b2Shape_1.b2Shape));\r\nexports.b2ChainShape = b2ChainShape;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2ChainShape.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/Shapes/b2ChainShape.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2010 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert, b2_linearSlop } from \"../../Common/b2Settings\";\r\nimport { b2_polygonRadius } from \"../../Common/b2Settings\";\r\nimport { b2Vec2, b2Transform, XY } from \"../../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../b2Collision\";\r\nimport { b2DistanceProxy } from \"../b2Distance\";\r\nimport { b2MassData } from \"./b2Shape\";\r\nimport { b2Shape, b2ShapeType } from \"./b2Shape\";\r\nimport { b2EdgeShape } from \"./b2EdgeShape\";\r\n\r\n/// A chain shape is a free form sequence of line segments.\r\n/// The chain has two-sided collision, so you can use inside and outside collision.\r\n/// Therefore, you may use any winding order.\r\n/// Since there may be many vertices, they are allocated using b2Alloc.\r\n/// Connectivity information is used to create smooth collisions.\r\n/// WARNING: The chain will not collide properly if there are self-intersections.\r\nexport class b2ChainShape extends b2Shape {\r\n  public m_vertices: b2Vec2[] = [];\r\n  public m_count: number = 0;\r\n  public readonly m_prevVertex: b2Vec2 = new b2Vec2();\r\n  public readonly m_nextVertex: b2Vec2 = new b2Vec2();\r\n  public m_hasPrevVertex: boolean = false;\r\n  public m_hasNextVertex: boolean = false;\r\n\r\n  constructor() {\r\n    super(b2ShapeType.e_chainShape, b2_polygonRadius);\r\n  }\r\n\r\n  /// Create a loop. This automatically adjusts connectivity.\r\n  /// @param vertices an array of vertices, these are copied\r\n  /// @param count the vertex count\r\n  public CreateLoop(vertices: XY[]): b2ChainShape;\r\n  public CreateLoop(vertices: XY[], count: number): b2ChainShape;\r\n  public CreateLoop(vertices: number[]): b2ChainShape;\r\n  public CreateLoop(...args: any[]): b2ChainShape {\r\n    if (typeof args[0][0] === \"number\") {\r\n      const vertices: number[] = args[0];\r\n      if (vertices.length % 2 !== 0) { throw new Error(); }\r\n      return this._CreateLoop((index: number): XY => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2);\r\n    } else {\r\n      const vertices: XY[] = args[0];\r\n      const count: number = args[1] || vertices.length;\r\n      return this._CreateLoop((index: number): XY => vertices[index], count);\r\n    }\r\n  }\r\n  private _CreateLoop(vertices: (index: number) => XY, count: number): b2ChainShape {\r\n    // DEBUG: b2Assert(count >= 3);\r\n    if (count < 3) {\r\n      return this;\r\n    }\r\n    // DEBUG: for (let i: number = 1; i < count; ++i) {\r\n    // DEBUG:   const v1 = vertices[start + i - 1];\r\n    // DEBUG:   const v2 = vertices[start + i];\r\n    // DEBUG:   // If the code crashes here, it means your vertices are too close together.\r\n    // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);\r\n    // DEBUG: }\r\n\r\n    this.m_count = count + 1;\r\n    this.m_vertices = b2Vec2.MakeArray(this.m_count);\r\n    for (let i: number = 0; i < count; ++i) {\r\n      this.m_vertices[i].Copy(vertices(i));\r\n    }\r\n    this.m_vertices[count].Copy(this.m_vertices[0]);\r\n    this.m_prevVertex.Copy(this.m_vertices[this.m_count - 2]);\r\n    this.m_nextVertex.Copy(this.m_vertices[1]);\r\n    this.m_hasPrevVertex = true;\r\n    this.m_hasNextVertex = true;\r\n    return this;\r\n  }\r\n\r\n  /// Create a chain with isolated end vertices.\r\n  /// @param vertices an array of vertices, these are copied\r\n  /// @param count the vertex count\r\n  public CreateChain(vertices: XY[]): b2ChainShape;\r\n  public CreateChain(vertices: XY[], count: number): b2ChainShape;\r\n  public CreateChain(vertices: number[]): b2ChainShape;\r\n  public CreateChain(...args: any[]): b2ChainShape {\r\n    if (typeof args[0][0] === \"number\") {\r\n      const vertices: number[] = args[0];\r\n      if (vertices.length % 2 !== 0) { throw new Error(); }\r\n      return this._CreateChain((index: number): XY => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2);\r\n    } else {\r\n      const vertices: XY[] = args[0];\r\n      const count: number = args[1] || vertices.length;\r\n      return this._CreateChain((index: number): XY => vertices[index], count);\r\n    }\r\n  }\r\n  private _CreateChain(vertices: (index: number) => XY, count: number): b2ChainShape {\r\n    // DEBUG: b2Assert(count >= 2);\r\n    // DEBUG: for (let i: number = 1; i < count; ++i) {\r\n    // DEBUG:   const v1 = vertices[start + i - 1];\r\n    // DEBUG:   const v2 = vertices[start + i];\r\n    // DEBUG:   // If the code crashes here, it means your vertices are too close together.\r\n    // DEBUG:   b2Assert(b2Vec2.DistanceSquaredVV(v1, v2) > b2_linearSlop * b2_linearSlop);\r\n    // DEBUG: }\r\n\r\n    this.m_count = count;\r\n    this.m_vertices = b2Vec2.MakeArray(count);\r\n    for (let i: number = 0; i < count; ++i) {\r\n      this.m_vertices[i].Copy(vertices(i));\r\n    }\r\n    this.m_hasPrevVertex = false;\r\n    this.m_hasNextVertex = false;\r\n\r\n    this.m_prevVertex.SetZero();\r\n    this.m_nextVertex.SetZero();\r\n\r\n    return this;\r\n  }\r\n\r\n  /// Establish connectivity to a vertex that precedes the first vertex.\r\n  /// Don't call this for loops.\r\n  public SetPrevVertex(prevVertex: XY): b2ChainShape {\r\n    this.m_prevVertex.Copy(prevVertex);\r\n    this.m_hasPrevVertex = true;\r\n    return this;\r\n  }\r\n\r\n  /// Establish connectivity to a vertex that follows the last vertex.\r\n  /// Don't call this for loops.\r\n  public SetNextVertex(nextVertex: XY): b2ChainShape {\r\n    this.m_nextVertex.Copy(nextVertex);\r\n    this.m_hasNextVertex = true;\r\n    return this;\r\n  }\r\n\r\n  /// Implement b2Shape. Vertices are cloned using b2Alloc.\r\n  public Clone(): b2ChainShape {\r\n    return new b2ChainShape().Copy(this);\r\n  }\r\n\r\n  public Copy(other: b2ChainShape): b2ChainShape {\r\n    super.Copy(other);\r\n\r\n    // DEBUG: b2Assert(other instanceof b2ChainShape);\r\n\r\n    this._CreateChain((index: number): XY => other.m_vertices[index], other.m_count);\r\n    this.m_prevVertex.Copy(other.m_prevVertex);\r\n    this.m_nextVertex.Copy(other.m_nextVertex);\r\n    this.m_hasPrevVertex = other.m_hasPrevVertex;\r\n    this.m_hasNextVertex = other.m_hasNextVertex;\r\n\r\n    return this;\r\n  }\r\n\r\n  /// @see b2Shape::GetChildCount\r\n  public GetChildCount(): number {\r\n    // edge count = vertex count - 1\r\n    return this.m_count - 1;\r\n  }\r\n\r\n  /// Get a child edge.\r\n  public GetChildEdge(edge: b2EdgeShape, index: number): void {\r\n    // DEBUG: b2Assert(0 <= index && index < this.m_count - 1);\r\n    edge.m_radius = this.m_radius;\r\n\r\n    edge.m_vertex1.Copy(this.m_vertices[index]);\r\n    edge.m_vertex2.Copy(this.m_vertices[index + 1]);\r\n\r\n    if (index > 0) {\r\n      edge.m_vertex0.Copy(this.m_vertices[index - 1]);\r\n      edge.m_hasVertex0 = true;\r\n    } else {\r\n      edge.m_vertex0.Copy(this.m_prevVertex);\r\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\r\n    }\r\n\r\n    if (index < this.m_count - 2) {\r\n      edge.m_vertex3.Copy(this.m_vertices[index + 2]);\r\n      edge.m_hasVertex3 = true;\r\n    } else {\r\n      edge.m_vertex3.Copy(this.m_nextVertex);\r\n      edge.m_hasVertex3 = this.m_hasNextVertex;\r\n    }\r\n  }\r\n\r\n  /// This always return false.\r\n  /// @see b2Shape::TestPoint\r\n  public TestPoint(xf: b2Transform, p: XY): boolean {\r\n    return false;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  /// @see b2Shape::ComputeDistance\r\n  private static ComputeDistance_s_edgeShape = new b2EdgeShape();\r\n  public ComputeDistance(xf: b2Transform, p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    const edge = b2ChainShape.ComputeDistance_s_edgeShape;\r\n    this.GetChildEdge(edge, childIndex);\r\n    return edge.ComputeDistance(xf, p, normal, 0);\r\n  }\r\n  // #endif\r\n\r\n  /// Implement b2Shape.\r\n  private static RayCast_s_edgeShape = new b2EdgeShape();\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, xf: b2Transform, childIndex: number): boolean {\r\n    // DEBUG: b2Assert(childIndex < this.m_count);\r\n\r\n    const edgeShape: b2EdgeShape = b2ChainShape.RayCast_s_edgeShape;\r\n\r\n    edgeShape.m_vertex1.Copy(this.m_vertices[childIndex]);\r\n    edgeShape.m_vertex2.Copy(this.m_vertices[(childIndex + 1) % this.m_count]);\r\n\r\n    return edgeShape.RayCast(output, input, xf, 0);\r\n  }\r\n\r\n  /// @see b2Shape::ComputeAABB\r\n  private static ComputeAABB_s_v1 = new b2Vec2();\r\n  private static ComputeAABB_s_v2 = new b2Vec2();\r\n  public ComputeAABB(aabb: b2AABB, xf: b2Transform, childIndex: number): void {\r\n    // DEBUG: b2Assert(childIndex < this.m_count);\r\n\r\n    const vertexi1: b2Vec2 = this.m_vertices[childIndex];\r\n    const vertexi2: b2Vec2 = this.m_vertices[(childIndex + 1) % this.m_count];\r\n\r\n    const v1: b2Vec2 = b2Transform.MulXV(xf, vertexi1, b2ChainShape.ComputeAABB_s_v1);\r\n    const v2: b2Vec2 = b2Transform.MulXV(xf, vertexi2, b2ChainShape.ComputeAABB_s_v2);\r\n\r\n    b2Vec2.MinV(v1, v2, aabb.lowerBound);\r\n    b2Vec2.MaxV(v1, v2, aabb.upperBound);\r\n  }\r\n\r\n  /// Chains have zero mass.\r\n  /// @see b2Shape::ComputeMass\r\n  public ComputeMass(massData: b2MassData, density: number): void {\r\n    massData.mass = 0;\r\n    massData.center.SetZero();\r\n    massData.I = 0;\r\n  }\r\n\r\n  public SetupDistanceProxy(proxy: b2DistanceProxy, index: number): void {\r\n    // DEBUG: b2Assert(0 <= index && index < this.m_count);\r\n\r\n    proxy.m_vertices = proxy.m_buffer;\r\n    proxy.m_vertices[0].Copy(this.m_vertices[index]);\r\n    if (index + 1 < this.m_count) {\r\n      proxy.m_vertices[1].Copy(this.m_vertices[index + 1]);\r\n    } else {\r\n      proxy.m_vertices[1].Copy(this.m_vertices[0]);\r\n    }\r\n    proxy.m_count = 2;\r\n    proxy.m_radius = this.m_radius;\r\n  }\r\n\r\n  public ComputeSubmergedArea(normal: b2Vec2, offset: number, xf: b2Transform, c: b2Vec2): number {\r\n    c.SetZero();\r\n    return 0;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    log(\"    const shape: b2ChainShape = new b2ChainShape();\\n\");\r\n    log(\"    const vs: b2Vec2[] = [];\\n\");\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      log(\"    vs[%d] = new bVec2(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n    }\r\n    log(\"    shape.CreateChain(vs, %d);\\n\", this.m_count);\r\n    log(\"    shape.m_prevVertex.Set(%.15f, %.15f);\\n\", this.m_prevVertex.x, this.m_prevVertex.y);\r\n    log(\"    shape.m_nextVertex.Set(%.15f, %.15f);\\n\", this.m_nextVertex.x, this.m_nextVertex.y);\r\n    log(\"    shape.m_hasPrevVertex = %s;\\n\", (this.m_hasPrevVertex) ? (\"true\") : (\"false\"));\r\n    log(\"    shape.m_hasNextVertex = %s;\\n\", (this.m_hasNextVertex) ? (\"true\") : (\"false\"));\r\n  }\r\n}\r\n"]}},"error":null,"hash":"c2972b56e1b8e6393f22bd96b1b01d68","cacheData":{"env":{}}}