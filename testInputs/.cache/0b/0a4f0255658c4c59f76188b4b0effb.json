{"id":"../node_modules/box2d.package.ts/Collision/b2CollideCircle.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":3,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideCircle.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":4,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideCircle.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Collision","loc":{"line":5,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideCircle.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"}],"generated":{"js":"\"use strict\";\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Collision_1 = require(\"./b2Collision\");\r\nvar b2CollideCircles_s_pA = new b2Math_1.b2Vec2();\r\nvar b2CollideCircles_s_pB = new b2Math_1.b2Vec2();\r\nfunction b2CollideCircles(manifold, circleA, xfA, circleB, xfB) {\r\n    manifold.pointCount = 0;\r\n    var pA = b2Math_1.b2Transform.MulXV(xfA, circleA.m_p, b2CollideCircles_s_pA);\r\n    var pB = b2Math_1.b2Transform.MulXV(xfB, circleB.m_p, b2CollideCircles_s_pB);\r\n    var distSqr = b2Math_1.b2Vec2.DistanceSquaredVV(pA, pB);\r\n    var radius = circleA.m_radius + circleB.m_radius;\r\n    if (distSqr > radius * radius) {\r\n        return;\r\n    }\r\n    manifold.type = b2Collision_1.b2ManifoldType.e_circles;\r\n    manifold.localPoint.Copy(circleA.m_p);\r\n    manifold.localNormal.SetZero();\r\n    manifold.pointCount = 1;\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    manifold.points[0].id.key = 0;\r\n}\r\nexports.b2CollideCircles = b2CollideCircles;\r\nvar b2CollidePolygonAndCircle_s_c = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygonAndCircle_s_cLocal = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygonAndCircle_s_faceCenter = new b2Math_1.b2Vec2();\r\nfunction b2CollidePolygonAndCircle(manifold, polygonA, xfA, circleB, xfB) {\r\n    manifold.pointCount = 0;\r\n    // Compute circle position in the frame of the polygon.\r\n    var c = b2Math_1.b2Transform.MulXV(xfB, circleB.m_p, b2CollidePolygonAndCircle_s_c);\r\n    var cLocal = b2Math_1.b2Transform.MulTXV(xfA, c, b2CollidePolygonAndCircle_s_cLocal);\r\n    // Find the min separating edge.\r\n    var normalIndex = 0;\r\n    var separation = (-b2Settings_1.b2_maxFloat);\r\n    var radius = polygonA.m_radius + circleB.m_radius;\r\n    var vertexCount = polygonA.m_count;\r\n    var vertices = polygonA.m_vertices;\r\n    var normals = polygonA.m_normals;\r\n    for (var i = 0; i < vertexCount; ++i) {\r\n        var s = b2Math_1.b2Vec2.DotVV(normals[i], b2Math_1.b2Vec2.SubVV(cLocal, vertices[i], b2Math_1.b2Vec2.s_t0));\r\n        if (s > radius) {\r\n            // Early out.\r\n            return;\r\n        }\r\n        if (s > separation) {\r\n            separation = s;\r\n            normalIndex = i;\r\n        }\r\n    }\r\n    // Vertices that subtend the incident face.\r\n    var vertIndex1 = normalIndex;\r\n    var vertIndex2 = (vertIndex1 + 1) % vertexCount;\r\n    var v1 = vertices[vertIndex1];\r\n    var v2 = vertices[vertIndex2];\r\n    // If the center is inside the polygon ...\r\n    if (separation < b2Settings_1.b2_epsilon) {\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_1.b2ManifoldType.e_faceA;\r\n        manifold.localNormal.Copy(normals[normalIndex]);\r\n        b2Math_1.b2Vec2.MidVV(v1, v2, manifold.localPoint);\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        manifold.points[0].id.key = 0;\r\n        return;\r\n    }\r\n    // Compute barycentric coordinates\r\n    var u1 = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cLocal, v1, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.SubVV(v2, v1, b2Math_1.b2Vec2.s_t1));\r\n    var u2 = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cLocal, v2, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.SubVV(v1, v2, b2Math_1.b2Vec2.s_t1));\r\n    if (u1 <= 0) {\r\n        if (b2Math_1.b2Vec2.DistanceSquaredVV(cLocal, v1) > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_1.b2ManifoldType.e_faceA;\r\n        b2Math_1.b2Vec2.SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();\r\n        manifold.localPoint.Copy(v1);\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        manifold.points[0].id.key = 0;\r\n    }\r\n    else if (u2 <= 0) {\r\n        if (b2Math_1.b2Vec2.DistanceSquaredVV(cLocal, v2) > radius * radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_1.b2ManifoldType.e_faceA;\r\n        b2Math_1.b2Vec2.SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();\r\n        manifold.localPoint.Copy(v2);\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        manifold.points[0].id.key = 0;\r\n    }\r\n    else {\r\n        var faceCenter = b2Math_1.b2Vec2.MidVV(v1, v2, b2CollidePolygonAndCircle_s_faceCenter);\r\n        var separation_1 = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(cLocal, faceCenter, b2Math_1.b2Vec2.s_t1), normals[vertIndex1]);\r\n        if (separation_1 > radius) {\r\n            return;\r\n        }\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_1.b2ManifoldType.e_faceA;\r\n        manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();\r\n        manifold.localPoint.Copy(faceCenter);\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        manifold.points[0].id.key = 0;\r\n    }\r\n}\r\nexports.b2CollidePolygonAndCircle = b2CollidePolygonAndCircle;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2CollideCircle.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2CollideCircle.ts"],"names":[],"mappings":"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","sourcesContent":["import { b2_maxFloat, b2_epsilon } from \"../Common/b2Settings\";\r\nimport { b2Vec2, b2Transform } from \"../Common/b2Math\";\r\nimport { b2Manifold, b2ManifoldType } from \"./b2Collision\";\r\nimport { b2CircleShape } from \"./Shapes/b2CircleShape\";\r\nimport { b2PolygonShape } from \"./Shapes/b2PolygonShape\";\r\n\r\nconst b2CollideCircles_s_pA: b2Vec2 = new b2Vec2();\r\nconst b2CollideCircles_s_pB: b2Vec2 = new b2Vec2();\r\nexport function b2CollideCircles(manifold: b2Manifold, circleA: b2CircleShape, xfA: b2Transform, circleB: b2CircleShape, xfB: b2Transform): void {\r\n  manifold.pointCount = 0;\r\n\r\n  const pA: b2Vec2 = b2Transform.MulXV(xfA, circleA.m_p, b2CollideCircles_s_pA);\r\n  const pB: b2Vec2 = b2Transform.MulXV(xfB, circleB.m_p, b2CollideCircles_s_pB);\r\n\r\n  const distSqr: number = b2Vec2.DistanceSquaredVV(pA, pB);\r\n  const radius: number = circleA.m_radius + circleB.m_radius;\r\n  if (distSqr > radius * radius) {\r\n    return;\r\n  }\r\n\r\n  manifold.type = b2ManifoldType.e_circles;\r\n  manifold.localPoint.Copy(circleA.m_p);\r\n  manifold.localNormal.SetZero();\r\n  manifold.pointCount = 1;\r\n\r\n  manifold.points[0].localPoint.Copy(circleB.m_p);\r\n  manifold.points[0].id.key = 0;\r\n}\r\n\r\nconst b2CollidePolygonAndCircle_s_c: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygonAndCircle_s_cLocal: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygonAndCircle_s_faceCenter: b2Vec2 = new b2Vec2();\r\nexport function b2CollidePolygonAndCircle(manifold: b2Manifold, polygonA: b2PolygonShape, xfA: b2Transform, circleB: b2CircleShape, xfB: b2Transform): void {\r\n  manifold.pointCount = 0;\r\n\r\n  // Compute circle position in the frame of the polygon.\r\n  const c: b2Vec2 = b2Transform.MulXV(xfB, circleB.m_p, b2CollidePolygonAndCircle_s_c);\r\n  const cLocal: b2Vec2 = b2Transform.MulTXV(xfA, c, b2CollidePolygonAndCircle_s_cLocal);\r\n\r\n  // Find the min separating edge.\r\n  let normalIndex: number = 0;\r\n  let separation: number = (-b2_maxFloat);\r\n  const radius: number = polygonA.m_radius + circleB.m_radius;\r\n  const vertexCount: number = polygonA.m_count;\r\n  const vertices: b2Vec2[] = polygonA.m_vertices;\r\n  const normals: b2Vec2[] = polygonA.m_normals;\r\n\r\n  for (let i: number = 0; i < vertexCount; ++i) {\r\n    const s: number = b2Vec2.DotVV(normals[i], b2Vec2.SubVV(cLocal, vertices[i], b2Vec2.s_t0));\r\n\r\n    if (s > radius) {\r\n      // Early out.\r\n      return;\r\n    }\r\n\r\n    if (s > separation) {\r\n      separation = s;\r\n      normalIndex = i;\r\n    }\r\n  }\r\n\r\n  // Vertices that subtend the incident face.\r\n  const vertIndex1: number = normalIndex;\r\n  const vertIndex2: number = (vertIndex1 + 1) % vertexCount;\r\n  const v1: b2Vec2 = vertices[vertIndex1];\r\n  const v2: b2Vec2 = vertices[vertIndex2];\r\n\r\n  // If the center is inside the polygon ...\r\n  if (separation < b2_epsilon) {\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_faceA;\r\n    manifold.localNormal.Copy(normals[normalIndex]);\r\n    b2Vec2.MidVV(v1, v2, manifold.localPoint);\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    manifold.points[0].id.key = 0;\r\n    return;\r\n  }\r\n\r\n  // Compute barycentric coordinates\r\n  const u1: number = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v1, b2Vec2.s_t0), b2Vec2.SubVV(v2, v1, b2Vec2.s_t1));\r\n  const u2: number = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, v2, b2Vec2.s_t0), b2Vec2.SubVV(v1, v2, b2Vec2.s_t1));\r\n  if (u1 <= 0) {\r\n    if (b2Vec2.DistanceSquaredVV(cLocal, v1) > radius * radius) {\r\n      return;\r\n    }\r\n\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_faceA;\r\n    b2Vec2.SubVV(cLocal, v1, manifold.localNormal).SelfNormalize();\r\n    manifold.localPoint.Copy(v1);\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    manifold.points[0].id.key = 0;\r\n  } else if (u2 <= 0) {\r\n    if (b2Vec2.DistanceSquaredVV(cLocal, v2) > radius * radius) {\r\n      return;\r\n    }\r\n\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_faceA;\r\n    b2Vec2.SubVV(cLocal, v2, manifold.localNormal).SelfNormalize();\r\n    manifold.localPoint.Copy(v2);\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    manifold.points[0].id.key = 0;\r\n  } else {\r\n    const faceCenter: b2Vec2 = b2Vec2.MidVV(v1, v2, b2CollidePolygonAndCircle_s_faceCenter);\r\n    const separation = b2Vec2.DotVV(b2Vec2.SubVV(cLocal, faceCenter, b2Vec2.s_t1), normals[vertIndex1]);\r\n    if (separation > radius) {\r\n      return;\r\n    }\r\n\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_faceA;\r\n    manifold.localNormal.Copy(normals[vertIndex1]).SelfNormalize();\r\n    manifold.localPoint.Copy(faceCenter);\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    manifold.points[0].id.key = 0;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"9e6ef0ea470956699519ea098c74b4fd","cacheData":{"env":{}}}