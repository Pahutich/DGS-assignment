{"id":"../node_modules/box2d.package.ts/Collision/b2CollidePolygon.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":4,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollidePolygon.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":5,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollidePolygon.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Collision","loc":{"line":7,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollidePolygon.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"}],"generated":{"js":"\"use strict\";\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Collision_1 = require(\"./b2Collision\");\r\nvar b2Collision_2 = require(\"./b2Collision\");\r\nvar b2EdgeSeparation_s_normal1World = new b2Math_1.b2Vec2();\r\nvar b2EdgeSeparation_s_normal1 = new b2Math_1.b2Vec2();\r\nvar b2EdgeSeparation_s_v1 = new b2Math_1.b2Vec2();\r\nvar b2EdgeSeparation_s_v2 = new b2Math_1.b2Vec2();\r\nfunction b2EdgeSeparation(poly1, xf1, edge1, poly2, xf2) {\r\n    // DEBUG: const count1: number = poly1.m_count;\r\n    var vertices1 = poly1.m_vertices;\r\n    var normals1 = poly1.m_normals;\r\n    var count2 = poly2.m_count;\r\n    var vertices2 = poly2.m_vertices;\r\n    // DEBUG: b2Assert(0 <= edge1 && edge1 < count1);\r\n    // Convert normal from poly1's frame into poly2's frame.\r\n    var normal1World = b2Math_1.b2Rot.MulRV(xf1.q, normals1[edge1], b2EdgeSeparation_s_normal1World);\r\n    var normal1 = b2Math_1.b2Rot.MulTRV(xf2.q, normal1World, b2EdgeSeparation_s_normal1);\r\n    // Find support vertex on poly2 for -normal.\r\n    var index = 0;\r\n    var minDot = b2Settings_1.b2_maxFloat;\r\n    for (var i = 0; i < count2; ++i) {\r\n        var dot = b2Math_1.b2Vec2.DotVV(vertices2[i], normal1);\r\n        if (dot < minDot) {\r\n            minDot = dot;\r\n            index = i;\r\n        }\r\n    }\r\n    var v1 = b2Math_1.b2Transform.MulXV(xf1, vertices1[edge1], b2EdgeSeparation_s_v1);\r\n    var v2 = b2Math_1.b2Transform.MulXV(xf2, vertices2[index], b2EdgeSeparation_s_v2);\r\n    var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(v2, v1, b2Math_1.b2Vec2.s_t0), normal1World);\r\n    return separation;\r\n}\r\nvar b2FindMaxSeparation_s_d = new b2Math_1.b2Vec2();\r\nvar b2FindMaxSeparation_s_dLocal1 = new b2Math_1.b2Vec2();\r\nfunction b2FindMaxSeparation(edgeIndex, poly1, xf1, poly2, xf2) {\r\n    var count1 = poly1.m_count;\r\n    var normals1 = poly1.m_normals;\r\n    // Vector pointing from the centroid of poly1 to the centroid of poly2.\r\n    var d = b2Math_1.b2Vec2.SubVV(b2Math_1.b2Transform.MulXV(xf2, poly2.m_centroid, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Transform.MulXV(xf1, poly1.m_centroid, b2Math_1.b2Vec2.s_t1), b2FindMaxSeparation_s_d);\r\n    var dLocal1 = b2Math_1.b2Rot.MulTRV(xf1.q, d, b2FindMaxSeparation_s_dLocal1);\r\n    // Find edge normal on poly1 that has the largest projection onto d.\r\n    var edge = 0;\r\n    var maxDot = (-b2Settings_1.b2_maxFloat);\r\n    for (var i = 0; i < count1; ++i) {\r\n        var dot = b2Math_1.b2Vec2.DotVV(normals1[i], dLocal1);\r\n        if (dot > maxDot) {\r\n            maxDot = dot;\r\n            edge = i;\r\n        }\r\n    }\r\n    // Get the separation for the edge normal.\r\n    var s = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);\r\n    // Check the separation for the previous edge normal.\r\n    var prevEdge = (edge + count1 - 1) % count1;\r\n    var sPrev = b2EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);\r\n    // Check the separation for the next edge normal.\r\n    var nextEdge = (edge + 1) % count1;\r\n    var sNext = b2EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);\r\n    // Find the best edge and the search direction.\r\n    var bestEdge = 0;\r\n    var bestSeparation = 0;\r\n    var increment = 0;\r\n    if (sPrev > s && sPrev > sNext) {\r\n        increment = -1;\r\n        bestEdge = prevEdge;\r\n        bestSeparation = sPrev;\r\n    }\r\n    else if (sNext > s) {\r\n        increment = 1;\r\n        bestEdge = nextEdge;\r\n        bestSeparation = sNext;\r\n    }\r\n    else {\r\n        edgeIndex[0] = edge;\r\n        return s;\r\n    }\r\n    // Perform a local search for the best edge normal.\r\n    while (true) {\r\n        if (increment === -1) {\r\n            edge = (bestEdge + count1 - 1) % count1;\r\n        }\r\n        else {\r\n            edge = (bestEdge + 1) % count1;\r\n        }\r\n        s = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);\r\n        if (s > bestSeparation) {\r\n            bestEdge = edge;\r\n            bestSeparation = s;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    edgeIndex[0] = bestEdge;\r\n    return bestSeparation;\r\n}\r\nvar b2FindIncidentEdge_s_normal1 = new b2Math_1.b2Vec2();\r\nfunction b2FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {\r\n    // DEBUG: const count1: number = poly1.m_count;\r\n    var normals1 = poly1.m_normals;\r\n    var count2 = poly2.m_count;\r\n    var vertices2 = poly2.m_vertices;\r\n    var normals2 = poly2.m_normals;\r\n    // DEBUG: b2Assert(0 <= edge1 && edge1 < count1);\r\n    // Get the normal of the reference edge in poly2's frame.\r\n    var normal1 = b2Math_1.b2Rot.MulTRV(xf2.q, b2Math_1.b2Rot.MulRV(xf1.q, normals1[edge1], b2Math_1.b2Vec2.s_t0), b2FindIncidentEdge_s_normal1);\r\n    // Find the incident edge on poly2.\r\n    var index = 0;\r\n    var minDot = b2Settings_1.b2_maxFloat;\r\n    for (var i = 0; i < count2; ++i) {\r\n        var dot = b2Math_1.b2Vec2.DotVV(normal1, normals2[i]);\r\n        if (dot < minDot) {\r\n            minDot = dot;\r\n            index = i;\r\n        }\r\n    }\r\n    // Build the clip vertices for the incident edge.\r\n    var i1 = index;\r\n    var i2 = (i1 + 1) % count2;\r\n    var c0 = c[0];\r\n    b2Math_1.b2Transform.MulXV(xf2, vertices2[i1], c0.v);\r\n    var cf0 = c0.id.cf;\r\n    cf0.indexA = edge1;\r\n    cf0.indexB = i1;\r\n    cf0.typeA = b2Collision_1.b2ContactFeatureType.e_face;\r\n    cf0.typeB = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n    var c1 = c[1];\r\n    b2Math_1.b2Transform.MulXV(xf2, vertices2[i2], c1.v);\r\n    var cf1 = c1.id.cf;\r\n    cf1.indexA = edge1;\r\n    cf1.indexB = i2;\r\n    cf1.typeA = b2Collision_1.b2ContactFeatureType.e_face;\r\n    cf1.typeB = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n}\r\nvar b2CollidePolygons_s_incidentEdge = b2Collision_2.b2ClipVertex.MakeArray(2);\r\nvar b2CollidePolygons_s_clipPoints1 = b2Collision_2.b2ClipVertex.MakeArray(2);\r\nvar b2CollidePolygons_s_clipPoints2 = b2Collision_2.b2ClipVertex.MakeArray(2);\r\nvar b2CollidePolygons_s_edgeA = [0];\r\nvar b2CollidePolygons_s_edgeB = [0];\r\nvar b2CollidePolygons_s_localTangent = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_localNormal = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_planePoint = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_normal = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_tangent = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_ntangent = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_v11 = new b2Math_1.b2Vec2();\r\nvar b2CollidePolygons_s_v12 = new b2Math_1.b2Vec2();\r\nfunction b2CollidePolygons(manifold, polyA, xfA, polyB, xfB) {\r\n    manifold.pointCount = 0;\r\n    var totalRadius = polyA.m_radius + polyB.m_radius;\r\n    var edgeA = b2CollidePolygons_s_edgeA;\r\n    edgeA[0] = 0;\r\n    var separationA = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);\r\n    if (separationA > totalRadius) {\r\n        return;\r\n    }\r\n    var edgeB = b2CollidePolygons_s_edgeB;\r\n    edgeB[0] = 0;\r\n    var separationB = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);\r\n    if (separationB > totalRadius) {\r\n        return;\r\n    }\r\n    var poly1; // reference polygon\r\n    var poly2; // incident polygon\r\n    var xf1, xf2;\r\n    var edge1 = 0; // reference edge\r\n    var flip = 0;\r\n    var k_relativeTol = 0.98;\r\n    var k_absoluteTol = 0.001;\r\n    if (separationB > k_relativeTol * separationA + k_absoluteTol) {\r\n        poly1 = polyB;\r\n        poly2 = polyA;\r\n        xf1 = xfB;\r\n        xf2 = xfA;\r\n        edge1 = edgeB[0];\r\n        manifold.type = b2Collision_2.b2ManifoldType.e_faceB;\r\n        flip = 1;\r\n    }\r\n    else {\r\n        poly1 = polyA;\r\n        poly2 = polyB;\r\n        xf1 = xfA;\r\n        xf2 = xfB;\r\n        edge1 = edgeA[0];\r\n        manifold.type = b2Collision_2.b2ManifoldType.e_faceA;\r\n        flip = 0;\r\n    }\r\n    var incidentEdge = b2CollidePolygons_s_incidentEdge;\r\n    b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\r\n    var count1 = poly1.m_count;\r\n    var vertices1 = poly1.m_vertices;\r\n    var iv1 = edge1;\r\n    var iv2 = (edge1 + 1) % count1;\r\n    var local_v11 = vertices1[iv1];\r\n    var local_v12 = vertices1[iv2];\r\n    var localTangent = b2Math_1.b2Vec2.SubVV(local_v12, local_v11, b2CollidePolygons_s_localTangent);\r\n    localTangent.Normalize();\r\n    var localNormal = b2Math_1.b2Vec2.CrossVOne(localTangent, b2CollidePolygons_s_localNormal);\r\n    var planePoint = b2Math_1.b2Vec2.MidVV(local_v11, local_v12, b2CollidePolygons_s_planePoint);\r\n    var tangent = b2Math_1.b2Rot.MulRV(xf1.q, localTangent, b2CollidePolygons_s_tangent);\r\n    var normal = b2Math_1.b2Vec2.CrossVOne(tangent, b2CollidePolygons_s_normal);\r\n    var v11 = b2Math_1.b2Transform.MulXV(xf1, local_v11, b2CollidePolygons_s_v11);\r\n    var v12 = b2Math_1.b2Transform.MulXV(xf1, local_v12, b2CollidePolygons_s_v12);\r\n    // Face offset.\r\n    var frontOffset = b2Math_1.b2Vec2.DotVV(normal, v11);\r\n    // Side offsets, extended by polytope skin thickness.\r\n    var sideOffset1 = -b2Math_1.b2Vec2.DotVV(tangent, v11) + totalRadius;\r\n    var sideOffset2 = b2Math_1.b2Vec2.DotVV(tangent, v12) + totalRadius;\r\n    // Clip incident edge against extruded edge1 side edges.\r\n    var clipPoints1 = b2CollidePolygons_s_clipPoints1;\r\n    var clipPoints2 = b2CollidePolygons_s_clipPoints2;\r\n    var np;\r\n    // Clip to box side 1\r\n    var ntangent = b2Math_1.b2Vec2.NegV(tangent, b2CollidePolygons_s_ntangent);\r\n    np = b2Collision_2.b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);\r\n    if (np < 2) {\r\n        return;\r\n    }\r\n    // Clip to negative box side 1\r\n    np = b2Collision_2.b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\r\n    if (np < 2) {\r\n        return;\r\n    }\r\n    // Now clipPoints2 contains the clipped points.\r\n    manifold.localNormal.Copy(localNormal);\r\n    manifold.localPoint.Copy(planePoint);\r\n    var pointCount = 0;\r\n    for (var i = 0; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n        var cv = clipPoints2[i];\r\n        var separation = b2Math_1.b2Vec2.DotVV(normal, cv.v) - frontOffset;\r\n        if (separation <= totalRadius) {\r\n            var cp = manifold.points[pointCount];\r\n            b2Math_1.b2Transform.MulTXV(xf2, cv.v, cp.localPoint);\r\n            cp.id.Copy(cv.id);\r\n            if (flip) {\r\n                // Swap features\r\n                var cf = cp.id.cf;\r\n                cp.id.cf.indexA = cf.indexB;\r\n                cp.id.cf.indexB = cf.indexA;\r\n                cp.id.cf.typeA = cf.typeB;\r\n                cp.id.cf.typeB = cf.typeA;\r\n            }\r\n            ++pointCount;\r\n        }\r\n    }\r\n    manifold.pointCount = pointCount;\r\n}\r\nexports.b2CollidePolygons = b2CollidePolygons;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2CollidePolygon.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2CollidePolygon.ts"],"names":[],"mappings":"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","sourcesContent":["// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_maxFloat, b2_maxManifoldPoints } from \"../Common/b2Settings\";\r\nimport { b2Vec2, b2Rot, b2Transform } from \"../Common/b2Math\";\r\nimport { b2ContactFeatureType, b2ContactFeature } from \"./b2Collision\";\r\nimport { b2Manifold, b2ManifoldType, b2ManifoldPoint, b2ClipVertex, b2ClipSegmentToLine } from \"./b2Collision\";\r\nimport { b2PolygonShape } from \"./Shapes/b2PolygonShape\";\r\n\r\nconst b2EdgeSeparation_s_normal1World: b2Vec2 = new b2Vec2();\r\nconst b2EdgeSeparation_s_normal1: b2Vec2 = new b2Vec2();\r\nconst b2EdgeSeparation_s_v1: b2Vec2 = new b2Vec2();\r\nconst b2EdgeSeparation_s_v2: b2Vec2 = new b2Vec2();\r\nfunction b2EdgeSeparation(poly1: b2PolygonShape, xf1: b2Transform, edge1: number, poly2: b2PolygonShape, xf2: b2Transform): number {\r\n  // DEBUG: const count1: number = poly1.m_count;\r\n  const vertices1: b2Vec2[] = poly1.m_vertices;\r\n  const normals1: b2Vec2[] = poly1.m_normals;\r\n\r\n  const count2: number = poly2.m_count;\r\n  const vertices2: b2Vec2[] = poly2.m_vertices;\r\n\r\n  // DEBUG: b2Assert(0 <= edge1 && edge1 < count1);\r\n\r\n  // Convert normal from poly1's frame into poly2's frame.\r\n  const normal1World: b2Vec2 = b2Rot.MulRV(xf1.q, normals1[edge1], b2EdgeSeparation_s_normal1World);\r\n  const normal1: b2Vec2 = b2Rot.MulTRV(xf2.q, normal1World, b2EdgeSeparation_s_normal1);\r\n\r\n  // Find support vertex on poly2 for -normal.\r\n  let index: number = 0;\r\n  let minDot: number = b2_maxFloat;\r\n\r\n  for (let i: number = 0; i < count2; ++i) {\r\n    const dot: number = b2Vec2.DotVV(vertices2[i], normal1);\r\n    if (dot < minDot) {\r\n      minDot = dot;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  const v1: b2Vec2 = b2Transform.MulXV(xf1, vertices1[edge1], b2EdgeSeparation_s_v1);\r\n  const v2: b2Vec2 = b2Transform.MulXV(xf2, vertices2[index], b2EdgeSeparation_s_v2);\r\n  const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(v2, v1, b2Vec2.s_t0), normal1World);\r\n  return separation;\r\n}\r\n\r\nconst b2FindMaxSeparation_s_d: b2Vec2 = new b2Vec2();\r\nconst b2FindMaxSeparation_s_dLocal1: b2Vec2 = new b2Vec2();\r\nfunction b2FindMaxSeparation(edgeIndex: [number], poly1: b2PolygonShape, xf1: b2Transform, poly2: b2PolygonShape, xf2: b2Transform): number {\r\n  const count1: number = poly1.m_count;\r\n  const normals1: b2Vec2[] = poly1.m_normals;\r\n\r\n  // Vector pointing from the centroid of poly1 to the centroid of poly2.\r\n  const d: b2Vec2 = b2Vec2.SubVV(b2Transform.MulXV(xf2, poly2.m_centroid, b2Vec2.s_t0), b2Transform.MulXV(xf1, poly1.m_centroid, b2Vec2.s_t1), b2FindMaxSeparation_s_d);\r\n  const dLocal1: b2Vec2 = b2Rot.MulTRV(xf1.q, d, b2FindMaxSeparation_s_dLocal1);\r\n\r\n  // Find edge normal on poly1 that has the largest projection onto d.\r\n  let edge: number = 0;\r\n  let maxDot: number = (-b2_maxFloat);\r\n  for (let i: number = 0; i < count1; ++i) {\r\n    const dot: number = b2Vec2.DotVV(normals1[i], dLocal1);\r\n    if (dot > maxDot) {\r\n      maxDot = dot;\r\n      edge = i;\r\n    }\r\n  }\r\n\r\n  // Get the separation for the edge normal.\r\n  let s: number = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);\r\n\r\n  // Check the separation for the previous edge normal.\r\n  const prevEdge = (edge + count1 - 1) % count1;\r\n  const sPrev = b2EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);\r\n\r\n  // Check the separation for the next edge normal.\r\n  const nextEdge = (edge + 1) % count1;\r\n  const sNext = b2EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);\r\n\r\n  // Find the best edge and the search direction.\r\n  let bestEdge: number = 0;\r\n  let bestSeparation: number = 0;\r\n  let increment: number = 0;\r\n  if (sPrev > s && sPrev > sNext) {\r\n    increment = -1;\r\n    bestEdge = prevEdge;\r\n    bestSeparation = sPrev;\r\n  } else if (sNext > s) {\r\n    increment = 1;\r\n    bestEdge = nextEdge;\r\n    bestSeparation = sNext;\r\n  } else {\r\n    edgeIndex[0] = edge;\r\n    return s;\r\n  }\r\n\r\n  // Perform a local search for the best edge normal.\r\n  while (true) {\r\n    if (increment === -1) {\r\n      edge = (bestEdge + count1 - 1) % count1;\r\n    } else {\r\n      edge = (bestEdge + 1) % count1;\r\n    }\r\n\r\n    s = b2EdgeSeparation(poly1, xf1, edge, poly2, xf2);\r\n\r\n    if (s > bestSeparation) {\r\n      bestEdge = edge;\r\n      bestSeparation = s;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  edgeIndex[0] = bestEdge;\r\n  return bestSeparation;\r\n}\r\n\r\nconst b2FindIncidentEdge_s_normal1: b2Vec2 = new b2Vec2();\r\nfunction b2FindIncidentEdge(c: b2ClipVertex[], poly1: b2PolygonShape, xf1: b2Transform, edge1: number, poly2: b2PolygonShape, xf2: b2Transform): void {\r\n  // DEBUG: const count1: number = poly1.m_count;\r\n  const normals1: b2Vec2[] = poly1.m_normals;\r\n\r\n  const count2: number = poly2.m_count;\r\n  const vertices2: b2Vec2[] = poly2.m_vertices;\r\n  const normals2: b2Vec2[] = poly2.m_normals;\r\n\r\n  // DEBUG: b2Assert(0 <= edge1 && edge1 < count1);\r\n\r\n  // Get the normal of the reference edge in poly2's frame.\r\n  const normal1: b2Vec2 = b2Rot.MulTRV(xf2.q, b2Rot.MulRV(xf1.q, normals1[edge1], b2Vec2.s_t0), b2FindIncidentEdge_s_normal1);\r\n\r\n  // Find the incident edge on poly2.\r\n  let index: number = 0;\r\n  let minDot: number = b2_maxFloat;\r\n  for (let i: number = 0; i < count2; ++i) {\r\n    const dot: number = b2Vec2.DotVV(normal1, normals2[i]);\r\n    if (dot < minDot) {\r\n      minDot = dot;\r\n      index = i;\r\n    }\r\n  }\r\n\r\n  // Build the clip vertices for the incident edge.\r\n  const i1: number = index;\r\n  const i2: number = (i1 + 1) % count2;\r\n\r\n  const c0: b2ClipVertex = c[0];\r\n  b2Transform.MulXV(xf2, vertices2[i1], c0.v);\r\n  const cf0: b2ContactFeature = c0.id.cf;\r\n  cf0.indexA = edge1;\r\n  cf0.indexB = i1;\r\n  cf0.typeA = b2ContactFeatureType.e_face;\r\n  cf0.typeB = b2ContactFeatureType.e_vertex;\r\n\r\n  const c1: b2ClipVertex = c[1];\r\n  b2Transform.MulXV(xf2, vertices2[i2], c1.v);\r\n  const cf1: b2ContactFeature = c1.id.cf;\r\n  cf1.indexA = edge1;\r\n  cf1.indexB = i2;\r\n  cf1.typeA = b2ContactFeatureType.e_face;\r\n  cf1.typeB = b2ContactFeatureType.e_vertex;\r\n}\r\n\r\nconst b2CollidePolygons_s_incidentEdge = b2ClipVertex.MakeArray(2);\r\nconst b2CollidePolygons_s_clipPoints1 = b2ClipVertex.MakeArray(2);\r\nconst b2CollidePolygons_s_clipPoints2 = b2ClipVertex.MakeArray(2);\r\nconst b2CollidePolygons_s_edgeA: [number] = [ 0 ];\r\nconst b2CollidePolygons_s_edgeB: [number] = [ 0 ];\r\nconst b2CollidePolygons_s_localTangent: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_localNormal: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_planePoint: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_normal: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_tangent: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_ntangent: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_v11: b2Vec2 = new b2Vec2();\r\nconst b2CollidePolygons_s_v12: b2Vec2 = new b2Vec2();\r\nexport function b2CollidePolygons(manifold: b2Manifold, polyA: b2PolygonShape, xfA: b2Transform, polyB: b2PolygonShape, xfB: b2Transform): void {\r\n  manifold.pointCount = 0;\r\n  const totalRadius: number = polyA.m_radius + polyB.m_radius;\r\n\r\n  const edgeA: [number] = b2CollidePolygons_s_edgeA; edgeA[0] = 0;\r\n  const separationA: number = b2FindMaxSeparation(edgeA, polyA, xfA, polyB, xfB);\r\n  if (separationA > totalRadius) {\r\n    return;\r\n  }\r\n\r\n  const edgeB: [number] = b2CollidePolygons_s_edgeB; edgeB[0] = 0;\r\n  const separationB: number = b2FindMaxSeparation(edgeB, polyB, xfB, polyA, xfA);\r\n  if (separationB > totalRadius) {\r\n    return;\r\n  }\r\n\r\n  let poly1: b2PolygonShape; // reference polygon\r\n  let poly2: b2PolygonShape; // incident polygon\r\n  let xf1: b2Transform, xf2: b2Transform;\r\n  let edge1: number = 0; // reference edge\r\n  let flip: number = 0;\r\n  const k_relativeTol: number = 0.98;\r\n  const k_absoluteTol: number = 0.001;\r\n\r\n  if (separationB > k_relativeTol * separationA + k_absoluteTol) {\r\n    poly1 = polyB;\r\n    poly2 = polyA;\r\n    xf1 = xfB;\r\n    xf2 = xfA;\r\n    edge1 = edgeB[0];\r\n    manifold.type = b2ManifoldType.e_faceB;\r\n    flip = 1;\r\n  } else {\r\n    poly1 = polyA;\r\n    poly2 = polyB;\r\n    xf1 = xfA;\r\n    xf2 = xfB;\r\n    edge1 = edgeA[0];\r\n    manifold.type = b2ManifoldType.e_faceA;\r\n    flip = 0;\r\n  }\r\n\r\n  const incidentEdge: b2ClipVertex[] = b2CollidePolygons_s_incidentEdge;\r\n  b2FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\r\n\r\n  const count1: number = poly1.m_count;\r\n  const vertices1: b2Vec2[] = poly1.m_vertices;\r\n\r\n  const iv1: number = edge1;\r\n  const iv2: number = (edge1 + 1) % count1;\r\n\r\n  const local_v11: b2Vec2 = vertices1[iv1];\r\n  const local_v12: b2Vec2 = vertices1[iv2];\r\n\r\n  const localTangent: b2Vec2 = b2Vec2.SubVV(local_v12, local_v11, b2CollidePolygons_s_localTangent);\r\n  localTangent.Normalize();\r\n\r\n  const localNormal: b2Vec2 = b2Vec2.CrossVOne(localTangent, b2CollidePolygons_s_localNormal);\r\n  const planePoint: b2Vec2 = b2Vec2.MidVV(local_v11, local_v12, b2CollidePolygons_s_planePoint);\r\n\r\n  const tangent: b2Vec2 = b2Rot.MulRV(xf1.q, localTangent, b2CollidePolygons_s_tangent);\r\n  const normal: b2Vec2 = b2Vec2.CrossVOne(tangent, b2CollidePolygons_s_normal);\r\n\r\n  const v11: b2Vec2 = b2Transform.MulXV(xf1, local_v11, b2CollidePolygons_s_v11);\r\n  const v12: b2Vec2 = b2Transform.MulXV(xf1, local_v12, b2CollidePolygons_s_v12);\r\n\r\n  // Face offset.\r\n  const frontOffset: number = b2Vec2.DotVV(normal, v11);\r\n\r\n  // Side offsets, extended by polytope skin thickness.\r\n  const sideOffset1: number = -b2Vec2.DotVV(tangent, v11) + totalRadius;\r\n  const sideOffset2: number = b2Vec2.DotVV(tangent, v12) + totalRadius;\r\n\r\n  // Clip incident edge against extruded edge1 side edges.\r\n  const clipPoints1: b2ClipVertex[] = b2CollidePolygons_s_clipPoints1;\r\n  const clipPoints2: b2ClipVertex[] = b2CollidePolygons_s_clipPoints2;\r\n  let np: number;\r\n\r\n  // Clip to box side 1\r\n  const ntangent: b2Vec2 = b2Vec2.NegV(tangent, b2CollidePolygons_s_ntangent);\r\n  np = b2ClipSegmentToLine(clipPoints1, incidentEdge, ntangent, sideOffset1, iv1);\r\n\r\n  if (np < 2) {\r\n    return;\r\n  }\r\n\r\n  // Clip to negative box side 1\r\n  np = b2ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2, iv2);\r\n\r\n  if (np < 2) {\r\n    return;\r\n  }\r\n\r\n  // Now clipPoints2 contains the clipped points.\r\n  manifold.localNormal.Copy(localNormal);\r\n  manifold.localPoint.Copy(planePoint);\r\n\r\n  let pointCount: number = 0;\r\n  for (let i: number = 0; i < b2_maxManifoldPoints; ++i) {\r\n    const cv: b2ClipVertex = clipPoints2[i];\r\n    const separation: number = b2Vec2.DotVV(normal, cv.v) - frontOffset;\r\n\r\n    if (separation <= totalRadius) {\r\n      const cp: b2ManifoldPoint = manifold.points[pointCount];\r\n      b2Transform.MulTXV(xf2, cv.v, cp.localPoint);\r\n      cp.id.Copy(cv.id);\r\n      if (flip) {\r\n        // Swap features\r\n        const cf: b2ContactFeature = cp.id.cf;\r\n        cp.id.cf.indexA = cf.indexB;\r\n        cp.id.cf.indexB = cf.indexA;\r\n        cp.id.cf.typeA = cf.typeB;\r\n        cp.id.cf.typeB = cf.typeA;\r\n      }\r\n      ++pointCount;\r\n    }\r\n  }\r\n\r\n  manifold.pointCount = pointCount;\r\n}\r\n"]}},"error":null,"hash":"3678cdc2a42a54a3dc4773b1e895463d","cacheData":{"env":{}}}