{"id":"../node_modules/box2d.package.ts/Collision/b2CollideEdge.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":4,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideEdge.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":5,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideEdge.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Collision","loc":{"line":7,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2CollideEdge.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"}],"generated":{"js":"\"use strict\";\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Collision_1 = require(\"./b2Collision\");\r\nvar b2Collision_2 = require(\"./b2Collision\");\r\nvar b2CollideEdgeAndCircle_s_Q = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_e = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_d = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_e1 = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_e2 = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_P = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_n = new b2Math_1.b2Vec2();\r\nvar b2CollideEdgeAndCircle_s_id = new b2Collision_1.b2ContactID();\r\nfunction b2CollideEdgeAndCircle(manifold, edgeA, xfA, circleB, xfB) {\r\n    manifold.pointCount = 0;\r\n    // Compute circle in frame of edge\r\n    var Q = b2Math_1.b2Transform.MulTXV(xfA, b2Math_1.b2Transform.MulXV(xfB, circleB.m_p, b2Math_1.b2Vec2.s_t0), b2CollideEdgeAndCircle_s_Q);\r\n    var A = edgeA.m_vertex1;\r\n    var B = edgeA.m_vertex2;\r\n    var e = b2Math_1.b2Vec2.SubVV(B, A, b2CollideEdgeAndCircle_s_e);\r\n    // Barycentric coordinates\r\n    var u = b2Math_1.b2Vec2.DotVV(e, b2Math_1.b2Vec2.SubVV(B, Q, b2Math_1.b2Vec2.s_t0));\r\n    var v = b2Math_1.b2Vec2.DotVV(e, b2Math_1.b2Vec2.SubVV(Q, A, b2Math_1.b2Vec2.s_t0));\r\n    var radius = edgeA.m_radius + circleB.m_radius;\r\n    // const cf: b2ContactFeature = new b2ContactFeature();\r\n    var id = b2CollideEdgeAndCircle_s_id;\r\n    id.cf.indexB = 0;\r\n    id.cf.typeB = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n    // Region A\r\n    if (v <= 0) {\r\n        var P_1 = A;\r\n        var d_1 = b2Math_1.b2Vec2.SubVV(Q, P_1, b2CollideEdgeAndCircle_s_d);\r\n        var dd_1 = b2Math_1.b2Vec2.DotVV(d_1, d_1);\r\n        if (dd_1 > radius * radius) {\r\n            return;\r\n        }\r\n        // Is there an edge connected to A?\r\n        if (edgeA.m_hasVertex0) {\r\n            var A1 = edgeA.m_vertex0;\r\n            var B1 = A;\r\n            var e1 = b2Math_1.b2Vec2.SubVV(B1, A1, b2CollideEdgeAndCircle_s_e1);\r\n            var u1 = b2Math_1.b2Vec2.DotVV(e1, b2Math_1.b2Vec2.SubVV(B1, Q, b2Math_1.b2Vec2.s_t0));\r\n            // Is the circle in Region AB of the previous edge?\r\n            if (u1 > 0) {\r\n                return;\r\n            }\r\n        }\r\n        id.cf.indexA = 0;\r\n        id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_2.b2ManifoldType.e_circles;\r\n        manifold.localNormal.SetZero();\r\n        manifold.localPoint.Copy(P_1);\r\n        manifold.points[0].id.Copy(id);\r\n        // manifold.points[0].id.key = 0;\r\n        // manifold.points[0].id.cf = cf;\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        return;\r\n    }\r\n    // Region B\r\n    if (u <= 0) {\r\n        var P_2 = B;\r\n        var d_2 = b2Math_1.b2Vec2.SubVV(Q, P_2, b2CollideEdgeAndCircle_s_d);\r\n        var dd_2 = b2Math_1.b2Vec2.DotVV(d_2, d_2);\r\n        if (dd_2 > radius * radius) {\r\n            return;\r\n        }\r\n        // Is there an edge connected to B?\r\n        if (edgeA.m_hasVertex3) {\r\n            var B2 = edgeA.m_vertex3;\r\n            var A2 = B;\r\n            var e2 = b2Math_1.b2Vec2.SubVV(B2, A2, b2CollideEdgeAndCircle_s_e2);\r\n            var v2 = b2Math_1.b2Vec2.DotVV(e2, b2Math_1.b2Vec2.SubVV(Q, A2, b2Math_1.b2Vec2.s_t0));\r\n            // Is the circle in Region AB of the next edge?\r\n            if (v2 > 0) {\r\n                return;\r\n            }\r\n        }\r\n        id.cf.indexA = 1;\r\n        id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n        manifold.pointCount = 1;\r\n        manifold.type = b2Collision_2.b2ManifoldType.e_circles;\r\n        manifold.localNormal.SetZero();\r\n        manifold.localPoint.Copy(P_2);\r\n        manifold.points[0].id.Copy(id);\r\n        // manifold.points[0].id.key = 0;\r\n        // manifold.points[0].id.cf = cf;\r\n        manifold.points[0].localPoint.Copy(circleB.m_p);\r\n        return;\r\n    }\r\n    // Region AB\r\n    var den = b2Math_1.b2Vec2.DotVV(e, e);\r\n    // DEBUG: b2Assert(den > 0);\r\n    var P = b2CollideEdgeAndCircle_s_P;\r\n    P.x = (1 / den) * (u * A.x + v * B.x);\r\n    P.y = (1 / den) * (u * A.y + v * B.y);\r\n    var d = b2Math_1.b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);\r\n    var dd = b2Math_1.b2Vec2.DotVV(d, d);\r\n    if (dd > radius * radius) {\r\n        return;\r\n    }\r\n    var n = b2CollideEdgeAndCircle_s_n.Set(-e.y, e.x);\r\n    if (b2Math_1.b2Vec2.DotVV(n, b2Math_1.b2Vec2.SubVV(Q, A, b2Math_1.b2Vec2.s_t0)) < 0) {\r\n        n.Set(-n.x, -n.y);\r\n    }\r\n    n.Normalize();\r\n    id.cf.indexA = 0;\r\n    id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_face;\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2Collision_2.b2ManifoldType.e_faceA;\r\n    manifold.localNormal.Copy(n);\r\n    manifold.localPoint.Copy(A);\r\n    manifold.points[0].id.Copy(id);\r\n    // manifold.points[0].id.key = 0;\r\n    // manifold.points[0].id.cf = cf;\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n}\r\nexports.b2CollideEdgeAndCircle = b2CollideEdgeAndCircle;\r\nvar b2EPAxisType;\r\n(function (b2EPAxisType) {\r\n    b2EPAxisType[b2EPAxisType[\"e_unknown\"] = 0] = \"e_unknown\";\r\n    b2EPAxisType[b2EPAxisType[\"e_edgeA\"] = 1] = \"e_edgeA\";\r\n    b2EPAxisType[b2EPAxisType[\"e_edgeB\"] = 2] = \"e_edgeB\";\r\n})(b2EPAxisType || (b2EPAxisType = {}));\r\nvar b2EPAxis = /** @class */ (function () {\r\n    function b2EPAxis() {\r\n        this.type = b2EPAxisType.e_unknown;\r\n        this.index = 0;\r\n        this.separation = 0;\r\n    }\r\n    return b2EPAxis;\r\n}());\r\nvar b2TempPolygon = /** @class */ (function () {\r\n    function b2TempPolygon() {\r\n        this.vertices = [];\r\n        this.normals = [];\r\n        this.count = 0;\r\n    }\r\n    return b2TempPolygon;\r\n}());\r\nvar b2ReferenceFace = /** @class */ (function () {\r\n    function b2ReferenceFace() {\r\n        this.i1 = 0;\r\n        this.i2 = 0;\r\n        this.v1 = new b2Math_1.b2Vec2();\r\n        this.v2 = new b2Math_1.b2Vec2();\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.sideNormal1 = new b2Math_1.b2Vec2();\r\n        this.sideOffset1 = 0;\r\n        this.sideNormal2 = new b2Math_1.b2Vec2();\r\n        this.sideOffset2 = 0;\r\n    }\r\n    return b2ReferenceFace;\r\n}());\r\nvar b2EPColliderVertexType;\r\n(function (b2EPColliderVertexType) {\r\n    b2EPColliderVertexType[b2EPColliderVertexType[\"e_isolated\"] = 0] = \"e_isolated\";\r\n    b2EPColliderVertexType[b2EPColliderVertexType[\"e_concave\"] = 1] = \"e_concave\";\r\n    b2EPColliderVertexType[b2EPColliderVertexType[\"e_convex\"] = 2] = \"e_convex\";\r\n})(b2EPColliderVertexType || (b2EPColliderVertexType = {}));\r\nvar b2EPCollider = /** @class */ (function () {\r\n    function b2EPCollider() {\r\n        this.m_polygonB = new b2TempPolygon();\r\n        this.m_xf = new b2Math_1.b2Transform();\r\n        this.m_centroidB = new b2Math_1.b2Vec2();\r\n        this.m_v0 = new b2Math_1.b2Vec2();\r\n        this.m_v1 = new b2Math_1.b2Vec2();\r\n        this.m_v2 = new b2Math_1.b2Vec2();\r\n        this.m_v3 = new b2Math_1.b2Vec2();\r\n        this.m_normal0 = new b2Math_1.b2Vec2();\r\n        this.m_normal1 = new b2Math_1.b2Vec2();\r\n        this.m_normal2 = new b2Math_1.b2Vec2();\r\n        this.m_normal = new b2Math_1.b2Vec2();\r\n        this.m_type1 = b2EPColliderVertexType.e_isolated;\r\n        this.m_type2 = b2EPColliderVertexType.e_isolated;\r\n        this.m_lowerLimit = new b2Math_1.b2Vec2();\r\n        this.m_upperLimit = new b2Math_1.b2Vec2();\r\n        this.m_radius = 0;\r\n        this.m_front = false;\r\n    }\r\n    b2EPCollider.prototype.Collide = function (manifold, edgeA, xfA, polygonB, xfB) {\r\n        b2Math_1.b2Transform.MulTXX(xfA, xfB, this.m_xf);\r\n        b2Math_1.b2Transform.MulXV(this.m_xf, polygonB.m_centroid, this.m_centroidB);\r\n        this.m_v0.Copy(edgeA.m_vertex0);\r\n        this.m_v1.Copy(edgeA.m_vertex1);\r\n        this.m_v2.Copy(edgeA.m_vertex2);\r\n        this.m_v3.Copy(edgeA.m_vertex3);\r\n        var hasVertex0 = edgeA.m_hasVertex0;\r\n        var hasVertex3 = edgeA.m_hasVertex3;\r\n        var edge1 = b2Math_1.b2Vec2.SubVV(this.m_v2, this.m_v1, b2EPCollider.s_edge1);\r\n        edge1.Normalize();\r\n        this.m_normal1.Set(edge1.y, -edge1.x);\r\n        var offset1 = b2Math_1.b2Vec2.DotVV(this.m_normal1, b2Math_1.b2Vec2.SubVV(this.m_centroidB, this.m_v1, b2Math_1.b2Vec2.s_t0));\r\n        var offset0 = 0;\r\n        var offset2 = 0;\r\n        var convex1 = false;\r\n        var convex2 = false;\r\n        // Is there a preceding edge?\r\n        if (hasVertex0) {\r\n            var edge0 = b2Math_1.b2Vec2.SubVV(this.m_v1, this.m_v0, b2EPCollider.s_edge0);\r\n            edge0.Normalize();\r\n            this.m_normal0.Set(edge0.y, -edge0.x);\r\n            convex1 = b2Math_1.b2Vec2.CrossVV(edge0, edge1) >= 0;\r\n            offset0 = b2Math_1.b2Vec2.DotVV(this.m_normal0, b2Math_1.b2Vec2.SubVV(this.m_centroidB, this.m_v0, b2Math_1.b2Vec2.s_t0));\r\n        }\r\n        // Is there a following edge?\r\n        if (hasVertex3) {\r\n            var edge2 = b2Math_1.b2Vec2.SubVV(this.m_v3, this.m_v2, b2EPCollider.s_edge2);\r\n            edge2.Normalize();\r\n            this.m_normal2.Set(edge2.y, -edge2.x);\r\n            convex2 = b2Math_1.b2Vec2.CrossVV(edge1, edge2) > 0;\r\n            offset2 = b2Math_1.b2Vec2.DotVV(this.m_normal2, b2Math_1.b2Vec2.SubVV(this.m_centroidB, this.m_v2, b2Math_1.b2Vec2.s_t0));\r\n        }\r\n        // Determine front or back collision. Determine collision normal limits.\r\n        if (hasVertex0 && hasVertex3) {\r\n            if (convex1 && convex2) {\r\n                this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal0);\r\n                    this.m_upperLimit.Copy(this.m_normal2);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n                }\r\n            }\r\n            else if (convex1) {\r\n                this.m_front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal0);\r\n                    this.m_upperLimit.Copy(this.m_normal1);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n                }\r\n            }\r\n            else if (convex2) {\r\n                this.m_front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal1);\r\n                    this.m_upperLimit.Copy(this.m_normal2);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n                }\r\n            }\r\n            else {\r\n                this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal1);\r\n                    this.m_upperLimit.Copy(this.m_normal1);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n                }\r\n            }\r\n        }\r\n        else if (hasVertex0) {\r\n            if (convex1) {\r\n                this.m_front = offset0 >= 0 || offset1 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal0);\r\n                    this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal1);\r\n                    this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n                }\r\n            }\r\n            else {\r\n                this.m_front = offset0 >= 0 && offset1 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal1);\r\n                    this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal1);\r\n                    this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n                }\r\n            }\r\n        }\r\n        else if (hasVertex3) {\r\n            if (convex2) {\r\n                this.m_front = offset1 >= 0 || offset2 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal2);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal1);\r\n                }\r\n            }\r\n            else {\r\n                this.m_front = offset1 >= 0 && offset2 >= 0;\r\n                if (this.m_front) {\r\n                    this.m_normal.Copy(this.m_normal1);\r\n                    this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal1);\r\n                }\r\n                else {\r\n                    this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                    this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n                    this.m_upperLimit.Copy(this.m_normal1);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            this.m_front = offset1 >= 0;\r\n            if (this.m_front) {\r\n                this.m_normal.Copy(this.m_normal1);\r\n                this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n                this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n            }\r\n            else {\r\n                this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n                this.m_lowerLimit.Copy(this.m_normal1);\r\n                this.m_upperLimit.Copy(this.m_normal1);\r\n            }\r\n        }\r\n        // Get polygonB in frameA\r\n        this.m_polygonB.count = polygonB.m_count;\r\n        for (var i = 0; i < polygonB.m_count; ++i) {\r\n            if (this.m_polygonB.vertices.length <= i) {\r\n                this.m_polygonB.vertices.push(new b2Math_1.b2Vec2());\r\n            }\r\n            if (this.m_polygonB.normals.length <= i) {\r\n                this.m_polygonB.normals.push(new b2Math_1.b2Vec2());\r\n            }\r\n            b2Math_1.b2Transform.MulXV(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);\r\n            b2Math_1.b2Rot.MulRV(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);\r\n        }\r\n        this.m_radius = polygonB.m_radius + edgeA.m_radius;\r\n        manifold.pointCount = 0;\r\n        var edgeAxis = this.ComputeEdgeSeparation(b2EPCollider.s_edgeAxis);\r\n        // If no valid normal can be found than this edge should not collide.\r\n        if (edgeAxis.type === b2EPAxisType.e_unknown) {\r\n            return;\r\n        }\r\n        if (edgeAxis.separation > this.m_radius) {\r\n            return;\r\n        }\r\n        var polygonAxis = this.ComputePolygonSeparation(b2EPCollider.s_polygonAxis);\r\n        if (polygonAxis.type !== b2EPAxisType.e_unknown && polygonAxis.separation > this.m_radius) {\r\n            return;\r\n        }\r\n        // Use hysteresis for jitter reduction.\r\n        var k_relativeTol = 0.98;\r\n        var k_absoluteTol = 0.001;\r\n        var primaryAxis;\r\n        if (polygonAxis.type === b2EPAxisType.e_unknown) {\r\n            primaryAxis = edgeAxis;\r\n        }\r\n        else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\r\n            primaryAxis = polygonAxis;\r\n        }\r\n        else {\r\n            primaryAxis = edgeAxis;\r\n        }\r\n        var ie = b2EPCollider.s_ie;\r\n        var rf = b2EPCollider.s_rf;\r\n        if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n            manifold.type = b2Collision_2.b2ManifoldType.e_faceA;\r\n            // Search for the polygon normal that is most anti-parallel to the edge normal.\r\n            var bestIndex = 0;\r\n            var bestValue = b2Math_1.b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[0]);\r\n            for (var i = 1; i < this.m_polygonB.count; ++i) {\r\n                var value = b2Math_1.b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[i]);\r\n                if (value < bestValue) {\r\n                    bestValue = value;\r\n                    bestIndex = i;\r\n                }\r\n            }\r\n            var i1 = bestIndex;\r\n            var i2 = (i1 + 1) % this.m_polygonB.count;\r\n            var ie0 = ie[0];\r\n            ie0.v.Copy(this.m_polygonB.vertices[i1]);\r\n            ie0.id.cf.indexA = 0;\r\n            ie0.id.cf.indexB = i1;\r\n            ie0.id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_face;\r\n            ie0.id.cf.typeB = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n            var ie1 = ie[1];\r\n            ie1.v.Copy(this.m_polygonB.vertices[i2]);\r\n            ie1.id.cf.indexA = 0;\r\n            ie1.id.cf.indexB = i2;\r\n            ie1.id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_face;\r\n            ie1.id.cf.typeB = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n            if (this.m_front) {\r\n                rf.i1 = 0;\r\n                rf.i2 = 1;\r\n                rf.v1.Copy(this.m_v1);\r\n                rf.v2.Copy(this.m_v2);\r\n                rf.normal.Copy(this.m_normal1);\r\n            }\r\n            else {\r\n                rf.i1 = 1;\r\n                rf.i2 = 0;\r\n                rf.v1.Copy(this.m_v2);\r\n                rf.v2.Copy(this.m_v1);\r\n                rf.normal.Copy(this.m_normal1).SelfNeg();\r\n            }\r\n        }\r\n        else {\r\n            manifold.type = b2Collision_2.b2ManifoldType.e_faceB;\r\n            var ie0 = ie[0];\r\n            ie0.v.Copy(this.m_v1);\r\n            ie0.id.cf.indexA = 0;\r\n            ie0.id.cf.indexB = primaryAxis.index;\r\n            ie0.id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n            ie0.id.cf.typeB = b2Collision_1.b2ContactFeatureType.e_face;\r\n            var ie1 = ie[1];\r\n            ie1.v.Copy(this.m_v2);\r\n            ie1.id.cf.indexA = 0;\r\n            ie1.id.cf.indexB = primaryAxis.index;\r\n            ie1.id.cf.typeA = b2Collision_1.b2ContactFeatureType.e_vertex;\r\n            ie1.id.cf.typeB = b2Collision_1.b2ContactFeatureType.e_face;\r\n            rf.i1 = primaryAxis.index;\r\n            rf.i2 = (rf.i1 + 1) % this.m_polygonB.count;\r\n            rf.v1.Copy(this.m_polygonB.vertices[rf.i1]);\r\n            rf.v2.Copy(this.m_polygonB.vertices[rf.i2]);\r\n            rf.normal.Copy(this.m_polygonB.normals[rf.i1]);\r\n        }\r\n        rf.sideNormal1.Set(rf.normal.y, -rf.normal.x);\r\n        rf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();\r\n        rf.sideOffset1 = b2Math_1.b2Vec2.DotVV(rf.sideNormal1, rf.v1);\r\n        rf.sideOffset2 = b2Math_1.b2Vec2.DotVV(rf.sideNormal2, rf.v2);\r\n        // Clip incident edge against extruded edge1 side edges.\r\n        var clipPoints1 = b2EPCollider.s_clipPoints1;\r\n        var clipPoints2 = b2EPCollider.s_clipPoints2;\r\n        var np = 0;\r\n        // Clip to box side 1\r\n        np = b2Collision_2.b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\r\n        if (np < b2Settings_1.b2_maxManifoldPoints) {\r\n            return;\r\n        }\r\n        // Clip to negative box side 1\r\n        np = b2Collision_2.b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\r\n        if (np < b2Settings_1.b2_maxManifoldPoints) {\r\n            return;\r\n        }\r\n        // Now clipPoints2 contains the clipped points.\r\n        if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n            manifold.localNormal.Copy(rf.normal);\r\n            manifold.localPoint.Copy(rf.v1);\r\n        }\r\n        else {\r\n            manifold.localNormal.Copy(polygonB.m_normals[rf.i1]);\r\n            manifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);\r\n        }\r\n        var pointCount = 0;\r\n        for (var i = 0; i < b2Settings_1.b2_maxManifoldPoints; ++i) {\r\n            var separation = void 0;\r\n            separation = b2Math_1.b2Vec2.DotVV(rf.normal, b2Math_1.b2Vec2.SubVV(clipPoints2[i].v, rf.v1, b2Math_1.b2Vec2.s_t0));\r\n            if (separation <= this.m_radius) {\r\n                var cp = manifold.points[pointCount];\r\n                if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n                    b2Math_1.b2Transform.MulTXV(this.m_xf, clipPoints2[i].v, cp.localPoint);\r\n                    cp.id.Copy(clipPoints2[i].id);\r\n                }\r\n                else {\r\n                    cp.localPoint.Copy(clipPoints2[i].v);\r\n                    cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\r\n                    cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\r\n                    cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\r\n                    cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\r\n                }\r\n                ++pointCount;\r\n            }\r\n        }\r\n        manifold.pointCount = pointCount;\r\n    };\r\n    b2EPCollider.prototype.ComputeEdgeSeparation = function (out) {\r\n        var axis = out;\r\n        axis.type = b2EPAxisType.e_edgeA;\r\n        axis.index = this.m_front ? 0 : 1;\r\n        axis.separation = b2Settings_1.b2_maxFloat;\r\n        for (var i = 0; i < this.m_polygonB.count; ++i) {\r\n            var s = b2Math_1.b2Vec2.DotVV(this.m_normal, b2Math_1.b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Math_1.b2Vec2.s_t0));\r\n            if (s < axis.separation) {\r\n                axis.separation = s;\r\n            }\r\n        }\r\n        return axis;\r\n    };\r\n    b2EPCollider.prototype.ComputePolygonSeparation = function (out) {\r\n        var axis = out;\r\n        axis.type = b2EPAxisType.e_unknown;\r\n        axis.index = -1;\r\n        axis.separation = -b2Settings_1.b2_maxFloat;\r\n        var perp = b2EPCollider.s_perp.Set(-this.m_normal.y, this.m_normal.x);\r\n        for (var i = 0; i < this.m_polygonB.count; ++i) {\r\n            var n = b2Math_1.b2Vec2.NegV(this.m_polygonB.normals[i], b2EPCollider.s_n);\r\n            var s1 = b2Math_1.b2Vec2.DotVV(n, b2Math_1.b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Math_1.b2Vec2.s_t0));\r\n            var s2 = b2Math_1.b2Vec2.DotVV(n, b2Math_1.b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v2, b2Math_1.b2Vec2.s_t0));\r\n            var s = b2Math_1.b2Min(s1, s2);\r\n            if (s > this.m_radius) {\r\n                // No collision\r\n                axis.type = b2EPAxisType.e_edgeB;\r\n                axis.index = i;\r\n                axis.separation = s;\r\n                return axis;\r\n            }\r\n            // Adjacency\r\n            if (b2Math_1.b2Vec2.DotVV(n, perp) >= 0) {\r\n                if (b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(n, this.m_upperLimit, b2Math_1.b2Vec2.s_t0), this.m_normal) < -b2Settings_1.b2_angularSlop) {\r\n                    continue;\r\n                }\r\n            }\r\n            else {\r\n                if (b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(n, this.m_lowerLimit, b2Math_1.b2Vec2.s_t0), this.m_normal) < -b2Settings_1.b2_angularSlop) {\r\n                    continue;\r\n                }\r\n            }\r\n            if (s > axis.separation) {\r\n                axis.type = b2EPAxisType.e_edgeB;\r\n                axis.index = i;\r\n                axis.separation = s;\r\n            }\r\n        }\r\n        return axis;\r\n    };\r\n    b2EPCollider.s_edge1 = new b2Math_1.b2Vec2();\r\n    b2EPCollider.s_edge0 = new b2Math_1.b2Vec2();\r\n    b2EPCollider.s_edge2 = new b2Math_1.b2Vec2();\r\n    b2EPCollider.s_ie = b2Collision_2.b2ClipVertex.MakeArray(2);\r\n    b2EPCollider.s_rf = new b2ReferenceFace();\r\n    b2EPCollider.s_clipPoints1 = b2Collision_2.b2ClipVertex.MakeArray(2);\r\n    b2EPCollider.s_clipPoints2 = b2Collision_2.b2ClipVertex.MakeArray(2);\r\n    b2EPCollider.s_edgeAxis = new b2EPAxis();\r\n    b2EPCollider.s_polygonAxis = new b2EPAxis();\r\n    b2EPCollider.s_n = new b2Math_1.b2Vec2();\r\n    b2EPCollider.s_perp = new b2Math_1.b2Vec2();\r\n    return b2EPCollider;\r\n}());\r\nvar b2CollideEdgeAndPolygon_s_collider = new b2EPCollider();\r\nfunction b2CollideEdgeAndPolygon(manifold, edgeA, xfA, polygonB, xfB) {\r\n    var collider = b2CollideEdgeAndPolygon_s_collider;\r\n    collider.Collide(manifold, edgeA, xfA, polygonB, xfB);\r\n}\r\nexports.b2CollideEdgeAndPolygon = b2CollideEdgeAndPolygon;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2CollideEdge.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2CollideEdge.ts"],"names":[],"mappings":"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","sourcesContent":["// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_maxFloat, b2_angularSlop, b2_maxManifoldPoints } from \"../Common/b2Settings\";\r\nimport { b2Min, b2Vec2, b2Rot, b2Transform } from \"../Common/b2Math\";\r\nimport { b2ContactFeatureType, b2ContactID } from \"./b2Collision\";\r\nimport { b2Manifold, b2ManifoldType, b2ManifoldPoint, b2ClipVertex, b2ClipSegmentToLine } from \"./b2Collision\";\r\nimport { b2CircleShape } from \"./Shapes/b2CircleShape\";\r\nimport { b2PolygonShape } from \"./Shapes/b2PolygonShape\";\r\nimport { b2EdgeShape } from \"./Shapes/b2EdgeShape\";\r\n\r\nconst b2CollideEdgeAndCircle_s_Q: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_e: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_d: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_e1: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_e2: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_P: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_n: b2Vec2 = new b2Vec2();\r\nconst b2CollideEdgeAndCircle_s_id: b2ContactID = new b2ContactID();\r\nexport function b2CollideEdgeAndCircle(manifold: b2Manifold, edgeA: b2EdgeShape, xfA: b2Transform, circleB: b2CircleShape, xfB: b2Transform): void {\r\n  manifold.pointCount = 0;\r\n\r\n  // Compute circle in frame of edge\r\n  const Q: b2Vec2 = b2Transform.MulTXV(xfA, b2Transform.MulXV(xfB, circleB.m_p, b2Vec2.s_t0), b2CollideEdgeAndCircle_s_Q);\r\n\r\n  const A: b2Vec2 = edgeA.m_vertex1;\r\n  const B: b2Vec2 = edgeA.m_vertex2;\r\n  const e: b2Vec2 = b2Vec2.SubVV(B, A, b2CollideEdgeAndCircle_s_e);\r\n\r\n  // Barycentric coordinates\r\n  const u: number = b2Vec2.DotVV(e, b2Vec2.SubVV(B, Q, b2Vec2.s_t0));\r\n  const v: number = b2Vec2.DotVV(e, b2Vec2.SubVV(Q, A, b2Vec2.s_t0));\r\n\r\n  const radius: number = edgeA.m_radius + circleB.m_radius;\r\n\r\n  // const cf: b2ContactFeature = new b2ContactFeature();\r\n  const id: b2ContactID = b2CollideEdgeAndCircle_s_id;\r\n  id.cf.indexB = 0;\r\n  id.cf.typeB = b2ContactFeatureType.e_vertex;\r\n\r\n  // Region A\r\n  if (v <= 0) {\r\n    const P: b2Vec2 = A;\r\n    const d: b2Vec2 = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);\r\n    const dd: number = b2Vec2.DotVV(d, d);\r\n    if (dd > radius * radius) {\r\n      return;\r\n    }\r\n\r\n    // Is there an edge connected to A?\r\n    if (edgeA.m_hasVertex0) {\r\n      const A1: b2Vec2 = edgeA.m_vertex0;\r\n      const B1: b2Vec2 = A;\r\n      const e1: b2Vec2 = b2Vec2.SubVV(B1, A1, b2CollideEdgeAndCircle_s_e1);\r\n      const u1: number = b2Vec2.DotVV(e1, b2Vec2.SubVV(B1, Q, b2Vec2.s_t0));\r\n\r\n      // Is the circle in Region AB of the previous edge?\r\n      if (u1 > 0) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    id.cf.indexA = 0;\r\n    id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_circles;\r\n    manifold.localNormal.SetZero();\r\n    manifold.localPoint.Copy(P);\r\n    manifold.points[0].id.Copy(id);\r\n    // manifold.points[0].id.key = 0;\r\n    // manifold.points[0].id.cf = cf;\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    return;\r\n  }\r\n\r\n  // Region B\r\n  if (u <= 0) {\r\n    const P: b2Vec2 = B;\r\n    const d: b2Vec2 = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);\r\n    const dd: number = b2Vec2.DotVV(d, d);\r\n    if (dd > radius * radius) {\r\n      return;\r\n    }\r\n\r\n    // Is there an edge connected to B?\r\n    if (edgeA.m_hasVertex3) {\r\n      const B2: b2Vec2 = edgeA.m_vertex3;\r\n      const A2: b2Vec2 = B;\r\n      const e2: b2Vec2 = b2Vec2.SubVV(B2, A2, b2CollideEdgeAndCircle_s_e2);\r\n      const v2: number = b2Vec2.DotVV(e2, b2Vec2.SubVV(Q, A2, b2Vec2.s_t0));\r\n\r\n      // Is the circle in Region AB of the next edge?\r\n      if (v2 > 0) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    id.cf.indexA = 1;\r\n    id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n    manifold.pointCount = 1;\r\n    manifold.type = b2ManifoldType.e_circles;\r\n    manifold.localNormal.SetZero();\r\n    manifold.localPoint.Copy(P);\r\n    manifold.points[0].id.Copy(id);\r\n    // manifold.points[0].id.key = 0;\r\n    // manifold.points[0].id.cf = cf;\r\n    manifold.points[0].localPoint.Copy(circleB.m_p);\r\n    return;\r\n  }\r\n\r\n  // Region AB\r\n  const den: number = b2Vec2.DotVV(e, e);\r\n  // DEBUG: b2Assert(den > 0);\r\n  const P: b2Vec2 = b2CollideEdgeAndCircle_s_P;\r\n  P.x = (1 / den) * (u * A.x + v * B.x);\r\n  P.y = (1 / den) * (u * A.y + v * B.y);\r\n  const d: b2Vec2 = b2Vec2.SubVV(Q, P, b2CollideEdgeAndCircle_s_d);\r\n  const dd: number = b2Vec2.DotVV(d, d);\r\n  if (dd > radius * radius) {\r\n    return;\r\n  }\r\n\r\n  const n: b2Vec2 = b2CollideEdgeAndCircle_s_n.Set(-e.y, e.x);\r\n  if (b2Vec2.DotVV(n, b2Vec2.SubVV(Q, A, b2Vec2.s_t0)) < 0) {\r\n    n.Set(-n.x, -n.y);\r\n  }\r\n  n.Normalize();\r\n\r\n  id.cf.indexA = 0;\r\n  id.cf.typeA = b2ContactFeatureType.e_face;\r\n  manifold.pointCount = 1;\r\n  manifold.type = b2ManifoldType.e_faceA;\r\n  manifold.localNormal.Copy(n);\r\n  manifold.localPoint.Copy(A);\r\n  manifold.points[0].id.Copy(id);\r\n  // manifold.points[0].id.key = 0;\r\n  // manifold.points[0].id.cf = cf;\r\n  manifold.points[0].localPoint.Copy(circleB.m_p);\r\n}\r\n\r\nenum b2EPAxisType {\r\n  e_unknown = 0,\r\n  e_edgeA = 1,\r\n  e_edgeB = 2,\r\n}\r\n\r\nclass b2EPAxis {\r\n  public type: b2EPAxisType = b2EPAxisType.e_unknown;\r\n  public index: number = 0;\r\n  public separation: number = 0;\r\n}\r\n\r\nclass b2TempPolygon {\r\n  public vertices: b2Vec2[] = [];\r\n  public normals: b2Vec2[] = [];\r\n  public count: number = 0;\r\n}\r\n\r\nclass b2ReferenceFace {\r\n  public i1: number = 0;\r\n  public i2: number = 0;\r\n  public readonly v1: b2Vec2 = new b2Vec2();\r\n  public readonly v2: b2Vec2 = new b2Vec2();\r\n  public readonly normal: b2Vec2 = new b2Vec2();\r\n  public readonly sideNormal1: b2Vec2 = new b2Vec2();\r\n  public sideOffset1: number = 0;\r\n  public readonly sideNormal2: b2Vec2 = new b2Vec2();\r\n  public sideOffset2: number = 0;\r\n}\r\n\r\nenum b2EPColliderVertexType {\r\n  e_isolated = 0,\r\n  e_concave = 1,\r\n  e_convex = 2,\r\n}\r\n\r\nclass b2EPCollider {\r\n  public readonly m_polygonB: b2TempPolygon = new b2TempPolygon();\r\n  public readonly m_xf: b2Transform = new b2Transform();\r\n  public readonly m_centroidB: b2Vec2 = new b2Vec2();\r\n  public readonly m_v0: b2Vec2 = new b2Vec2();\r\n  public readonly m_v1: b2Vec2 = new b2Vec2();\r\n  public readonly m_v2: b2Vec2 = new b2Vec2();\r\n  public readonly m_v3: b2Vec2 = new b2Vec2();\r\n  public readonly m_normal0: b2Vec2 = new b2Vec2();\r\n  public readonly m_normal1: b2Vec2 = new b2Vec2();\r\n  public readonly m_normal2: b2Vec2 = new b2Vec2();\r\n  public readonly m_normal: b2Vec2 = new b2Vec2();\r\n  public m_type1 = b2EPColliderVertexType.e_isolated;\r\n  public m_type2 = b2EPColliderVertexType.e_isolated;\r\n  public readonly m_lowerLimit: b2Vec2 = new b2Vec2();\r\n  public readonly m_upperLimit: b2Vec2 = new b2Vec2();\r\n  public m_radius: number = 0;\r\n  public m_front: boolean = false;\r\n\r\n  private static s_edge1 = new b2Vec2();\r\n  private static s_edge0 = new b2Vec2();\r\n  private static s_edge2 = new b2Vec2();\r\n  private static s_ie = b2ClipVertex.MakeArray(2);\r\n  private static s_rf = new b2ReferenceFace();\r\n  private static s_clipPoints1 = b2ClipVertex.MakeArray(2);\r\n  private static s_clipPoints2 = b2ClipVertex.MakeArray(2);\r\n  private static s_edgeAxis = new b2EPAxis();\r\n  private static s_polygonAxis = new b2EPAxis();\r\n  public Collide(manifold: b2Manifold, edgeA: b2EdgeShape, xfA: b2Transform, polygonB: b2PolygonShape, xfB: b2Transform): void {\r\n    b2Transform.MulTXX(xfA, xfB, this.m_xf);\r\n\r\n    b2Transform.MulXV(this.m_xf, polygonB.m_centroid, this.m_centroidB);\r\n\r\n    this.m_v0.Copy(edgeA.m_vertex0);\r\n    this.m_v1.Copy(edgeA.m_vertex1);\r\n    this.m_v2.Copy(edgeA.m_vertex2);\r\n    this.m_v3.Copy(edgeA.m_vertex3);\r\n\r\n    const hasVertex0: boolean = edgeA.m_hasVertex0;\r\n    const hasVertex3: boolean = edgeA.m_hasVertex3;\r\n\r\n    const edge1: b2Vec2 = b2Vec2.SubVV(this.m_v2, this.m_v1, b2EPCollider.s_edge1);\r\n    edge1.Normalize();\r\n    this.m_normal1.Set(edge1.y, -edge1.x);\r\n    const offset1: number = b2Vec2.DotVV(this.m_normal1, b2Vec2.SubVV(this.m_centroidB, this.m_v1, b2Vec2.s_t0));\r\n    let offset0: number = 0;\r\n    let offset2: number = 0;\r\n    let convex1: boolean = false;\r\n    let convex2: boolean = false;\r\n\r\n    // Is there a preceding edge?\r\n    if (hasVertex0) {\r\n      const edge0: b2Vec2 = b2Vec2.SubVV(this.m_v1, this.m_v0, b2EPCollider.s_edge0);\r\n      edge0.Normalize();\r\n      this.m_normal0.Set(edge0.y, -edge0.x);\r\n      convex1 = b2Vec2.CrossVV(edge0, edge1) >= 0;\r\n      offset0 = b2Vec2.DotVV(this.m_normal0, b2Vec2.SubVV(this.m_centroidB, this.m_v0, b2Vec2.s_t0));\r\n    }\r\n\r\n    // Is there a following edge?\r\n    if (hasVertex3) {\r\n      const edge2: b2Vec2 = b2Vec2.SubVV(this.m_v3, this.m_v2, b2EPCollider.s_edge2);\r\n      edge2.Normalize();\r\n      this.m_normal2.Set(edge2.y, -edge2.x);\r\n      convex2 = b2Vec2.CrossVV(edge1, edge2) > 0;\r\n      offset2 = b2Vec2.DotVV(this.m_normal2, b2Vec2.SubVV(this.m_centroidB, this.m_v2, b2Vec2.s_t0));\r\n    }\r\n\r\n    // Determine front or back collision. Determine collision normal limits.\r\n    if (hasVertex0 && hasVertex3) {\r\n      if (convex1 && convex2) {\r\n        this.m_front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal0);\r\n          this.m_upperLimit.Copy(this.m_normal2);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n        }\r\n      } else if (convex1) {\r\n        this.m_front = offset0 >= 0 || (offset1 >= 0 && offset2 >= 0);\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal0);\r\n          this.m_upperLimit.Copy(this.m_normal1);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n        }\r\n      } else if (convex2) {\r\n        this.m_front = offset2 >= 0 || (offset0 >= 0 && offset1 >= 0);\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal1);\r\n          this.m_upperLimit.Copy(this.m_normal2);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n        }\r\n      } else {\r\n        this.m_front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal1);\r\n          this.m_upperLimit.Copy(this.m_normal1);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n        }\r\n      }\r\n    } else if (hasVertex0) {\r\n      if (convex1) {\r\n        this.m_front = offset0 >= 0 || offset1 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal0);\r\n          this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal1);\r\n          this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n        }\r\n      } else {\r\n        this.m_front = offset0 >= 0 && offset1 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal1);\r\n          this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal1);\r\n          this.m_upperLimit.Copy(this.m_normal0).SelfNeg();\r\n        }\r\n      }\r\n    } else if (hasVertex3) {\r\n      if (convex2) {\r\n        this.m_front = offset1 >= 0 || offset2 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal2);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal1);\r\n        }\r\n      } else {\r\n        this.m_front = offset1 >= 0 && offset2 >= 0;\r\n        if (this.m_front) {\r\n          this.m_normal.Copy(this.m_normal1);\r\n          this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal1);\r\n        } else {\r\n          this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n          this.m_lowerLimit.Copy(this.m_normal2).SelfNeg();\r\n          this.m_upperLimit.Copy(this.m_normal1);\r\n        }\r\n      }\r\n    } else {\r\n      this.m_front = offset1 >= 0;\r\n      if (this.m_front) {\r\n        this.m_normal.Copy(this.m_normal1);\r\n        this.m_lowerLimit.Copy(this.m_normal1).SelfNeg();\r\n        this.m_upperLimit.Copy(this.m_normal1).SelfNeg();\r\n      } else {\r\n        this.m_normal.Copy(this.m_normal1).SelfNeg();\r\n        this.m_lowerLimit.Copy(this.m_normal1);\r\n        this.m_upperLimit.Copy(this.m_normal1);\r\n      }\r\n    }\r\n\r\n    // Get polygonB in frameA\r\n    this.m_polygonB.count = polygonB.m_count;\r\n    for (let i: number = 0; i < polygonB.m_count; ++i) {\r\n      if (this.m_polygonB.vertices.length <= i) { this.m_polygonB.vertices.push(new b2Vec2()); }\r\n      if (this.m_polygonB.normals.length <= i) { this.m_polygonB.normals.push(new b2Vec2()); }\r\n      b2Transform.MulXV(this.m_xf, polygonB.m_vertices[i], this.m_polygonB.vertices[i]);\r\n      b2Rot.MulRV(this.m_xf.q, polygonB.m_normals[i], this.m_polygonB.normals[i]);\r\n    }\r\n\r\n    this.m_radius = polygonB.m_radius + edgeA.m_radius;\r\n\r\n    manifold.pointCount = 0;\r\n\r\n    const edgeAxis: b2EPAxis = this.ComputeEdgeSeparation(b2EPCollider.s_edgeAxis);\r\n\r\n    // If no valid normal can be found than this edge should not collide.\r\n    if (edgeAxis.type === b2EPAxisType.e_unknown) {\r\n      return;\r\n    }\r\n\r\n    if (edgeAxis.separation > this.m_radius) {\r\n      return;\r\n    }\r\n\r\n    const polygonAxis: b2EPAxis = this.ComputePolygonSeparation(b2EPCollider.s_polygonAxis);\r\n    if (polygonAxis.type !== b2EPAxisType.e_unknown && polygonAxis.separation > this.m_radius) {\r\n      return;\r\n    }\r\n\r\n    // Use hysteresis for jitter reduction.\r\n    const k_relativeTol: number = 0.98;\r\n    const k_absoluteTol: number = 0.001;\r\n\r\n    let primaryAxis: b2EPAxis;\r\n    if (polygonAxis.type === b2EPAxisType.e_unknown) {\r\n      primaryAxis = edgeAxis;\r\n    } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\r\n      primaryAxis = polygonAxis;\r\n    } else {\r\n      primaryAxis = edgeAxis;\r\n    }\r\n\r\n    const ie: b2ClipVertex[] = b2EPCollider.s_ie;\r\n    const rf: b2ReferenceFace = b2EPCollider.s_rf;\r\n    if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n      manifold.type = b2ManifoldType.e_faceA;\r\n\r\n      // Search for the polygon normal that is most anti-parallel to the edge normal.\r\n      let bestIndex: number = 0;\r\n      let bestValue: number = b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[0]);\r\n      for (let i: number = 1; i < this.m_polygonB.count; ++i) {\r\n        const value: number = b2Vec2.DotVV(this.m_normal, this.m_polygonB.normals[i]);\r\n        if (value < bestValue) {\r\n          bestValue = value;\r\n          bestIndex = i;\r\n        }\r\n      }\r\n\r\n      const i1: number = bestIndex;\r\n      const i2: number = (i1 + 1) % this.m_polygonB.count;\r\n\r\n      const ie0: b2ClipVertex = ie[0];\r\n      ie0.v.Copy(this.m_polygonB.vertices[i1]);\r\n      ie0.id.cf.indexA = 0;\r\n      ie0.id.cf.indexB = i1;\r\n      ie0.id.cf.typeA = b2ContactFeatureType.e_face;\r\n      ie0.id.cf.typeB = b2ContactFeatureType.e_vertex;\r\n\r\n      const ie1: b2ClipVertex = ie[1];\r\n      ie1.v.Copy(this.m_polygonB.vertices[i2]);\r\n      ie1.id.cf.indexA = 0;\r\n      ie1.id.cf.indexB = i2;\r\n      ie1.id.cf.typeA = b2ContactFeatureType.e_face;\r\n      ie1.id.cf.typeB = b2ContactFeatureType.e_vertex;\r\n\r\n      if (this.m_front) {\r\n        rf.i1 = 0;\r\n        rf.i2 = 1;\r\n        rf.v1.Copy(this.m_v1);\r\n        rf.v2.Copy(this.m_v2);\r\n        rf.normal.Copy(this.m_normal1);\r\n      } else {\r\n        rf.i1 = 1;\r\n        rf.i2 = 0;\r\n        rf.v1.Copy(this.m_v2);\r\n        rf.v2.Copy(this.m_v1);\r\n        rf.normal.Copy(this.m_normal1).SelfNeg();\r\n      }\r\n    } else {\r\n      manifold.type = b2ManifoldType.e_faceB;\r\n\r\n      const ie0: b2ClipVertex = ie[0];\r\n      ie0.v.Copy(this.m_v1);\r\n      ie0.id.cf.indexA = 0;\r\n      ie0.id.cf.indexB = primaryAxis.index;\r\n      ie0.id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n      ie0.id.cf.typeB = b2ContactFeatureType.e_face;\r\n\r\n      const ie1: b2ClipVertex = ie[1];\r\n      ie1.v.Copy(this.m_v2);\r\n      ie1.id.cf.indexA = 0;\r\n      ie1.id.cf.indexB = primaryAxis.index;\r\n      ie1.id.cf.typeA = b2ContactFeatureType.e_vertex;\r\n      ie1.id.cf.typeB = b2ContactFeatureType.e_face;\r\n\r\n      rf.i1 = primaryAxis.index;\r\n      rf.i2 = (rf.i1 + 1) % this.m_polygonB.count;\r\n      rf.v1.Copy(this.m_polygonB.vertices[rf.i1]);\r\n      rf.v2.Copy(this.m_polygonB.vertices[rf.i2]);\r\n      rf.normal.Copy(this.m_polygonB.normals[rf.i1]);\r\n    }\r\n\r\n    rf.sideNormal1.Set(rf.normal.y, -rf.normal.x);\r\n    rf.sideNormal2.Copy(rf.sideNormal1).SelfNeg();\r\n    rf.sideOffset1 = b2Vec2.DotVV(rf.sideNormal1, rf.v1);\r\n    rf.sideOffset2 = b2Vec2.DotVV(rf.sideNormal2, rf.v2);\r\n\r\n    // Clip incident edge against extruded edge1 side edges.\r\n    const clipPoints1: b2ClipVertex[] = b2EPCollider.s_clipPoints1;\r\n    const clipPoints2: b2ClipVertex[] = b2EPCollider.s_clipPoints2;\r\n    let np: number = 0;\r\n\r\n    // Clip to box side 1\r\n    np = b2ClipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\r\n\r\n    if (np < b2_maxManifoldPoints) {\r\n      return;\r\n    }\r\n\r\n    // Clip to negative box side 1\r\n    np = b2ClipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\r\n\r\n    if (np < b2_maxManifoldPoints) {\r\n      return;\r\n    }\r\n\r\n    // Now clipPoints2 contains the clipped points.\r\n    if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n      manifold.localNormal.Copy(rf.normal);\r\n      manifold.localPoint.Copy(rf.v1);\r\n    } else {\r\n      manifold.localNormal.Copy(polygonB.m_normals[rf.i1]);\r\n      manifold.localPoint.Copy(polygonB.m_vertices[rf.i1]);\r\n    }\r\n\r\n    let pointCount: number = 0;\r\n    for (let i: number = 0; i < b2_maxManifoldPoints; ++i) {\r\n      let separation: number;\r\n\r\n      separation = b2Vec2.DotVV(rf.normal, b2Vec2.SubVV(clipPoints2[i].v, rf.v1, b2Vec2.s_t0));\r\n\r\n      if (separation <= this.m_radius) {\r\n        const cp: b2ManifoldPoint = manifold.points[pointCount];\r\n\r\n        if (primaryAxis.type === b2EPAxisType.e_edgeA) {\r\n          b2Transform.MulTXV(this.m_xf, clipPoints2[i].v, cp.localPoint);\r\n          cp.id.Copy(clipPoints2[i].id);\r\n        } else {\r\n          cp.localPoint.Copy(clipPoints2[i].v);\r\n          cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;\r\n          cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;\r\n          cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;\r\n          cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;\r\n        }\r\n\r\n        ++pointCount;\r\n      }\r\n    }\r\n\r\n    manifold.pointCount = pointCount;\r\n  }\r\n\r\n  public ComputeEdgeSeparation(out: b2EPAxis): b2EPAxis {\r\n    const axis: b2EPAxis = out;\r\n    axis.type = b2EPAxisType.e_edgeA;\r\n    axis.index = this.m_front ? 0 : 1;\r\n    axis.separation = b2_maxFloat;\r\n\r\n    for (let i: number = 0; i < this.m_polygonB.count; ++i) {\r\n      const s: number = b2Vec2.DotVV(this.m_normal, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Vec2.s_t0));\r\n      if (s < axis.separation) {\r\n        axis.separation = s;\r\n      }\r\n    }\r\n\r\n    return axis;\r\n  }\r\n\r\n  private static s_n = new b2Vec2();\r\n  private static s_perp = new b2Vec2();\r\n  public ComputePolygonSeparation(out: b2EPAxis): b2EPAxis {\r\n    const axis: b2EPAxis = out;\r\n    axis.type = b2EPAxisType.e_unknown;\r\n    axis.index = -1;\r\n    axis.separation = -b2_maxFloat;\r\n\r\n    const perp: b2Vec2 = b2EPCollider.s_perp.Set(-this.m_normal.y, this.m_normal.x);\r\n\r\n    for (let i: number = 0; i < this.m_polygonB.count; ++i) {\r\n      const n: b2Vec2 = b2Vec2.NegV(this.m_polygonB.normals[i], b2EPCollider.s_n);\r\n\r\n      const s1: number = b2Vec2.DotVV(n, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v1, b2Vec2.s_t0));\r\n      const s2: number = b2Vec2.DotVV(n, b2Vec2.SubVV(this.m_polygonB.vertices[i], this.m_v2, b2Vec2.s_t0));\r\n      const s: number = b2Min(s1, s2);\r\n\r\n      if (s > this.m_radius) {\r\n        // No collision\r\n        axis.type = b2EPAxisType.e_edgeB;\r\n        axis.index = i;\r\n        axis.separation = s;\r\n        return axis;\r\n      }\r\n\r\n      // Adjacency\r\n      if (b2Vec2.DotVV(n, perp) >= 0) {\r\n        if (b2Vec2.DotVV(b2Vec2.SubVV(n, this.m_upperLimit, b2Vec2.s_t0), this.m_normal) < -b2_angularSlop) {\r\n          continue;\r\n        }\r\n      } else {\r\n        if (b2Vec2.DotVV(b2Vec2.SubVV(n, this.m_lowerLimit, b2Vec2.s_t0), this.m_normal) < -b2_angularSlop) {\r\n          continue;\r\n        }\r\n      }\r\n\r\n      if (s > axis.separation) {\r\n        axis.type = b2EPAxisType.e_edgeB;\r\n        axis.index = i;\r\n        axis.separation = s;\r\n      }\r\n    }\r\n\r\n    return axis;\r\n  }\r\n}\r\n\r\nconst b2CollideEdgeAndPolygon_s_collider: b2EPCollider = new b2EPCollider();\r\nexport function b2CollideEdgeAndPolygon(manifold: b2Manifold, edgeA: b2EdgeShape, xfA: b2Transform, polygonB: b2PolygonShape, xfB: b2Transform): void {\r\n  const collider: b2EPCollider = b2CollideEdgeAndPolygon_s_collider;\r\n  collider.Collide(manifold, edgeA, xfA, polygonB, xfB);\r\n}\r\n"]}},"error":null,"hash":"8730b27765eb42539946245775307c46","cacheData":{"env":{}}}