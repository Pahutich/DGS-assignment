{"id":"../node_modules/box2d.package.ts/Collision/Shapes/b2PolygonShape.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":31,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2PolygonShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":32,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2PolygonShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Shape","loc":{"line":34,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2PolygonShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert, b2_epsilon_sq } from \"../../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Shape_1 = require(\"./b2Shape\");\r\nvar b2Shape_2 = require(\"./b2Shape\");\r\n/// A convex polygon. It is assumed that the interior of the polygon is to\r\n/// the left of each edge.\r\n/// In most cases you should not need many vertices for a convex polygon.\r\nvar b2PolygonShape = /** @class */ (function (_super) {\r\n    __extends(b2PolygonShape, _super);\r\n    function b2PolygonShape() {\r\n        var _this = _super.call(this, b2Shape_2.b2ShapeType.e_polygonShape, b2Settings_1.b2_polygonRadius) || this;\r\n        _this.m_centroid = new b2Math_1.b2Vec2(0, 0);\r\n        _this.m_vertices = [];\r\n        _this.m_normals = [];\r\n        _this.m_count = 0;\r\n        return _this;\r\n    }\r\n    /// Implement b2Shape.\r\n    b2PolygonShape.prototype.Clone = function () {\r\n        return new b2PolygonShape().Copy(this);\r\n    };\r\n    b2PolygonShape.prototype.Copy = function (other) {\r\n        _super.prototype.Copy.call(this, other);\r\n        // DEBUG: b2Assert(other instanceof b2PolygonShape);\r\n        this.m_centroid.Copy(other.m_centroid);\r\n        this.m_count = other.m_count;\r\n        this.m_vertices = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        this.m_normals = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            this.m_vertices[i].Copy(other.m_vertices[i]);\r\n            this.m_normals[i].Copy(other.m_normals[i]);\r\n        }\r\n        return this;\r\n    };\r\n    /// @see b2Shape::GetChildCount\r\n    b2PolygonShape.prototype.GetChildCount = function () {\r\n        return 1;\r\n    };\r\n    b2PolygonShape.prototype.Set = function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        if (typeof args[0][0] === \"number\") {\r\n            var vertices_1 = args[0];\r\n            if (vertices_1.length % 2 !== 0) {\r\n                throw new Error();\r\n            }\r\n            return this._Set(function (index) { return ({ x: vertices_1[index * 2], y: vertices_1[index * 2 + 1] }); }, vertices_1.length / 2);\r\n        }\r\n        else {\r\n            var vertices_2 = args[0];\r\n            var count = args[1] || vertices_2.length;\r\n            return this._Set(function (index) { return vertices_2[index]; }, count);\r\n        }\r\n    };\r\n    b2PolygonShape.prototype._Set = function (vertices, count) {\r\n        // DEBUG: b2Assert(3 <= count);\r\n        if (count < 3) {\r\n            return this.SetAsBox(1, 1);\r\n        }\r\n        var n = count;\r\n        // Perform welding and copy vertices into local buffer.\r\n        var ps = [];\r\n        for (var i = 0; i < n; ++i) {\r\n            var /*b2Vec2*/ v = vertices(i);\r\n            var /*bool*/ unique = true;\r\n            for (var /*int32*/ j = 0; j < ps.length; ++j) {\r\n                if (b2Math_1.b2Vec2.DistanceSquaredVV(v, ps[j]) < ((0.5 * b2Settings_1.b2_linearSlop) * (0.5 * b2Settings_1.b2_linearSlop))) {\r\n                    unique = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (unique) {\r\n                ps.push(v);\r\n            }\r\n        }\r\n        n = ps.length;\r\n        if (n < 3) {\r\n            // Polygon is degenerate.\r\n            // DEBUG: b2Assert(false);\r\n            return this.SetAsBox(1.0, 1.0);\r\n        }\r\n        // Create the convex hull using the Gift wrapping algorithm\r\n        // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\r\n        // Find the right most point on the hull\r\n        var i0 = 0;\r\n        var x0 = ps[0].x;\r\n        for (var i = 1; i < n; ++i) {\r\n            var x = ps[i].x;\r\n            if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\r\n                i0 = i;\r\n                x0 = x;\r\n            }\r\n        }\r\n        var hull = [];\r\n        var m = 0;\r\n        var ih = i0;\r\n        for (;;) {\r\n            hull[m] = ih;\r\n            var ie = 0;\r\n            for (var j = 1; j < n; ++j) {\r\n                if (ie === ih) {\r\n                    ie = j;\r\n                    continue;\r\n                }\r\n                var r = b2Math_1.b2Vec2.SubVV(ps[ie], ps[hull[m]], b2PolygonShape.Set_s_r);\r\n                var v = b2Math_1.b2Vec2.SubVV(ps[j], ps[hull[m]], b2PolygonShape.Set_s_v);\r\n                var c = b2Math_1.b2Vec2.CrossVV(r, v);\r\n                if (c < 0) {\r\n                    ie = j;\r\n                }\r\n                // Collinearity check\r\n                if (c === 0 && v.LengthSquared() > r.LengthSquared()) {\r\n                    ie = j;\r\n                }\r\n            }\r\n            ++m;\r\n            ih = ie;\r\n            if (ie === i0) {\r\n                break;\r\n            }\r\n        }\r\n        this.m_count = m;\r\n        this.m_vertices = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        this.m_normals = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        // Copy vertices.\r\n        for (var i = 0; i < m; ++i) {\r\n            this.m_vertices[i].Copy(ps[hull[i]]);\r\n        }\r\n        // Compute normals. Ensure the edges have non-zero length.\r\n        for (var i = 0; i < m; ++i) {\r\n            var vertexi1 = this.m_vertices[i];\r\n            var vertexi2 = this.m_vertices[(i + 1) % m];\r\n            var edge = b2Math_1.b2Vec2.SubVV(vertexi2, vertexi1, b2Math_1.b2Vec2.s_t0); // edge uses s_t0\r\n            // DEBUG: b2Assert(edge.LengthSquared() > b2_epsilon_sq);\r\n            b2Math_1.b2Vec2.CrossVOne(edge, this.m_normals[i]).SelfNormalize();\r\n        }\r\n        // Compute the polygon centroid.\r\n        b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);\r\n        return this;\r\n    };\r\n    /// Build vertices to represent an axis-aligned box or an oriented box.\r\n    /// @param hx the half-width.\r\n    /// @param hy the half-height.\r\n    /// @param center the center of the box in local coordinates.\r\n    /// @param angle the rotation of the box in local coordinates.\r\n    b2PolygonShape.prototype.SetAsBox = function (hx, hy, center, angle) {\r\n        if (angle === void 0) { angle = 0; }\r\n        this.m_count = 4;\r\n        this.m_vertices = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        this.m_normals = b2Math_1.b2Vec2.MakeArray(this.m_count);\r\n        this.m_vertices[0].Set((-hx), (-hy));\r\n        this.m_vertices[1].Set(hx, (-hy));\r\n        this.m_vertices[2].Set(hx, hy);\r\n        this.m_vertices[3].Set((-hx), hy);\r\n        this.m_normals[0].Set(0, (-1));\r\n        this.m_normals[1].Set(1, 0);\r\n        this.m_normals[2].Set(0, 1);\r\n        this.m_normals[3].Set((-1), 0);\r\n        this.m_centroid.SetZero();\r\n        if (center) {\r\n            this.m_centroid.Copy(center);\r\n            var xf = new b2Math_1.b2Transform();\r\n            xf.SetPosition(center);\r\n            xf.SetRotationAngle(angle);\r\n            // Transform vertices and normals.\r\n            for (var i = 0; i < this.m_count; ++i) {\r\n                b2Math_1.b2Transform.MulXV(xf, this.m_vertices[i], this.m_vertices[i]);\r\n                b2Math_1.b2Rot.MulRV(xf.q, this.m_normals[i], this.m_normals[i]);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    b2PolygonShape.prototype.TestPoint = function (xf, p) {\r\n        var pLocal = b2Math_1.b2Transform.MulTXV(xf, p, b2PolygonShape.TestPoint_s_pLocal);\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var dot = b2Math_1.b2Vec2.DotVV(this.m_normals[i], b2Math_1.b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Math_1.b2Vec2.s_t0));\r\n            if (dot > 0) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    b2PolygonShape.prototype.ComputeDistance = function (xf, p, normal, childIndex) {\r\n        var pLocal = b2Math_1.b2Transform.MulTXV(xf, p, b2PolygonShape.ComputeDistance_s_pLocal);\r\n        var maxDistance = -b2Settings_1.b2_maxFloat;\r\n        var normalForMaxDistance = b2PolygonShape.ComputeDistance_s_normalForMaxDistance.Copy(pLocal);\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var dot = b2Math_1.b2Vec2.DotVV(this.m_normals[i], b2Math_1.b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Math_1.b2Vec2.s_t0));\r\n            if (dot > maxDistance) {\r\n                maxDistance = dot;\r\n                normalForMaxDistance.Copy(this.m_normals[i]);\r\n            }\r\n        }\r\n        if (maxDistance > 0) {\r\n            var minDistance = b2PolygonShape.ComputeDistance_s_minDistance.Copy(normalForMaxDistance);\r\n            var minDistance2 = maxDistance * maxDistance;\r\n            for (var i = 0; i < this.m_count; ++i) {\r\n                var distance = b2Math_1.b2Vec2.SubVV(pLocal, this.m_vertices[i], b2PolygonShape.ComputeDistance_s_distance);\r\n                var distance2 = distance.LengthSquared();\r\n                if (minDistance2 > distance2) {\r\n                    minDistance.Copy(distance);\r\n                    minDistance2 = distance2;\r\n                }\r\n            }\r\n            b2Math_1.b2Rot.MulRV(xf.q, minDistance, normal);\r\n            normal.Normalize();\r\n            return Math.sqrt(minDistance2);\r\n        }\r\n        else {\r\n            b2Math_1.b2Rot.MulRV(xf.q, normalForMaxDistance, normal);\r\n            return maxDistance;\r\n        }\r\n    };\r\n    b2PolygonShape.prototype.RayCast = function (output, input, xf, childIndex) {\r\n        // Put the ray into the polygon's frame of reference.\r\n        var p1 = b2Math_1.b2Transform.MulTXV(xf, input.p1, b2PolygonShape.RayCast_s_p1);\r\n        var p2 = b2Math_1.b2Transform.MulTXV(xf, input.p2, b2PolygonShape.RayCast_s_p2);\r\n        var d = b2Math_1.b2Vec2.SubVV(p2, p1, b2PolygonShape.RayCast_s_d);\r\n        var lower = 0, upper = input.maxFraction;\r\n        var index = -1;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            // p = p1 + a * d\r\n            // dot(normal, p - v) = 0\r\n            // dot(normal, p1 - v) + a * dot(normal, d) = 0\r\n            var numerator = b2Math_1.b2Vec2.DotVV(this.m_normals[i], b2Math_1.b2Vec2.SubVV(this.m_vertices[i], p1, b2Math_1.b2Vec2.s_t0));\r\n            var denominator = b2Math_1.b2Vec2.DotVV(this.m_normals[i], d);\r\n            if (denominator === 0) {\r\n                if (numerator < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            else {\r\n                // Note: we want this predicate without division:\r\n                // lower < numerator / denominator, where denominator < 0\r\n                // Since denominator < 0, we have to flip the inequality:\r\n                // lower < numerator / denominator <==> denominator * lower > numerator.\r\n                if (denominator < 0 && numerator < lower * denominator) {\r\n                    // Increase lower.\r\n                    // The segment enters this half-space.\r\n                    lower = numerator / denominator;\r\n                    index = i;\r\n                }\r\n                else if (denominator > 0 && numerator < upper * denominator) {\r\n                    // Decrease upper.\r\n                    // The segment exits this half-space.\r\n                    upper = numerator / denominator;\r\n                }\r\n            }\r\n            // The use of epsilon here causes the assert on lower to trip\r\n            // in some cases. Apparently the use of epsilon was to make edge\r\n            // shapes work, but now those are handled separately.\r\n            // if (upper < lower - b2_epsilon)\r\n            if (upper < lower) {\r\n                return false;\r\n            }\r\n        }\r\n        // DEBUG: b2Assert(0 <= lower && lower <= input.maxFraction);\r\n        if (index >= 0) {\r\n            output.fraction = lower;\r\n            b2Math_1.b2Rot.MulRV(xf.q, this.m_normals[index], output.normal);\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    b2PolygonShape.prototype.ComputeAABB = function (aabb, xf, childIndex) {\r\n        var lower = b2Math_1.b2Transform.MulXV(xf, this.m_vertices[0], aabb.lowerBound);\r\n        var upper = aabb.upperBound.Copy(lower);\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var v = b2Math_1.b2Transform.MulXV(xf, this.m_vertices[i], b2PolygonShape.ComputeAABB_s_v);\r\n            b2Math_1.b2Vec2.MinV(v, lower, lower);\r\n            b2Math_1.b2Vec2.MaxV(v, upper, upper);\r\n        }\r\n        var r = this.m_radius;\r\n        lower.SelfSubXY(r, r);\r\n        upper.SelfAddXY(r, r);\r\n    };\r\n    b2PolygonShape.prototype.ComputeMass = function (massData, density) {\r\n        // Polygon mass, centroid, and inertia.\r\n        // Let rho be the polygon density in mass per unit area.\r\n        // Then:\r\n        // mass = rho * int(dA)\r\n        // centroid.x = (1/mass) * rho * int(x * dA)\r\n        // centroid.y = (1/mass) * rho * int(y * dA)\r\n        // I = rho * int((x*x + y*y) * dA)\r\n        //\r\n        // We can compute these integrals by summing all the integrals\r\n        // for each triangle of the polygon. To evaluate the integral\r\n        // for a single triangle, we make a change of variables to\r\n        // the (u,v) coordinates of the triangle:\r\n        // x = x0 + e1x * u + e2x * v\r\n        // y = y0 + e1y * u + e2y * v\r\n        // where 0 <= u && 0 <= v && u + v <= 1.\r\n        //\r\n        // We integrate u from [0,1-v] and then v from [0,1].\r\n        // We also need to use the Jacobian of the transformation:\r\n        // D = cross(e1, e2)\r\n        //\r\n        // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\r\n        //\r\n        // The rest of the derivation is handled by computer algebra.\r\n        // DEBUG: b2Assert(this.m_count >= 3);\r\n        var center = b2PolygonShape.ComputeMass_s_center.SetZero();\r\n        var area = 0;\r\n        var I = 0;\r\n        // s is the reference point for forming triangles.\r\n        // It's location doesn't change the result (except for rounding error).\r\n        var s = b2PolygonShape.ComputeMass_s_s.SetZero();\r\n        // This code would put the reference point inside the polygon.\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            s.SelfAdd(this.m_vertices[i]);\r\n        }\r\n        s.SelfMul(1 / this.m_count);\r\n        var k_inv3 = 1 / 3;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            // Triangle vertices.\r\n            var e1 = b2Math_1.b2Vec2.SubVV(this.m_vertices[i], s, b2PolygonShape.ComputeMass_s_e1);\r\n            var e2 = b2Math_1.b2Vec2.SubVV(this.m_vertices[(i + 1) % this.m_count], s, b2PolygonShape.ComputeMass_s_e2);\r\n            var D = b2Math_1.b2Vec2.CrossVV(e1, e2);\r\n            var triangleArea = 0.5 * D;\r\n            area += triangleArea;\r\n            // Area weighted centroid\r\n            center.SelfAdd(b2Math_1.b2Vec2.MulSV(triangleArea * k_inv3, b2Math_1.b2Vec2.AddVV(e1, e2, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.s_t1));\r\n            var ex1 = e1.x;\r\n            var ey1 = e1.y;\r\n            var ex2 = e2.x;\r\n            var ey2 = e2.y;\r\n            var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\r\n            var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\r\n            I += (0.25 * k_inv3 * D) * (intx2 + inty2);\r\n        }\r\n        // Total mass\r\n        massData.mass = density * area;\r\n        // Center of mass\r\n        // DEBUG: b2Assert(area > b2_epsilon);\r\n        center.SelfMul(1 / area);\r\n        b2Math_1.b2Vec2.AddVV(center, s, massData.center);\r\n        // Inertia tensor relative to the local origin (point s).\r\n        massData.I = density * I;\r\n        // Shift to center of mass then to original body origin.\r\n        massData.I += massData.mass * (b2Math_1.b2Vec2.DotVV(massData.center, massData.center) - b2Math_1.b2Vec2.DotVV(center, center));\r\n    };\r\n    b2PolygonShape.prototype.Validate = function () {\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var i1 = i;\r\n            var i2 = (i + 1) % this.m_count;\r\n            var p = this.m_vertices[i1];\r\n            var e = b2Math_1.b2Vec2.SubVV(this.m_vertices[i2], p, b2PolygonShape.Validate_s_e);\r\n            for (var j = 0; j < this.m_count; ++j) {\r\n                if (j === i1 || j === i2) {\r\n                    continue;\r\n                }\r\n                var v = b2Math_1.b2Vec2.SubVV(this.m_vertices[j], p, b2PolygonShape.Validate_s_v);\r\n                var c = b2Math_1.b2Vec2.CrossVV(e, v);\r\n                if (c < 0) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    b2PolygonShape.prototype.SetupDistanceProxy = function (proxy, index) {\r\n        proxy.m_vertices = this.m_vertices;\r\n        proxy.m_count = this.m_count;\r\n        proxy.m_radius = this.m_radius;\r\n    };\r\n    b2PolygonShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {\r\n        // Transform plane into shape co-ordinates\r\n        var normalL = b2Math_1.b2Rot.MulTRV(xf.q, normal, b2PolygonShape.ComputeSubmergedArea_s_normalL);\r\n        var offsetL = offset - b2Math_1.b2Vec2.DotVV(normal, xf.p);\r\n        var depths = [];\r\n        var diveCount = 0;\r\n        var intoIndex = -1;\r\n        var outoIndex = -1;\r\n        var lastSubmerged = false;\r\n        for (var i_1 = 0; i_1 < this.m_count; ++i_1) {\r\n            depths[i_1] = b2Math_1.b2Vec2.DotVV(normalL, this.m_vertices[i_1]) - offsetL;\r\n            var isSubmerged = depths[i_1] < (-b2Settings_1.b2_epsilon);\r\n            if (i_1 > 0) {\r\n                if (isSubmerged) {\r\n                    if (!lastSubmerged) {\r\n                        intoIndex = i_1 - 1;\r\n                        diveCount++;\r\n                    }\r\n                }\r\n                else {\r\n                    if (lastSubmerged) {\r\n                        outoIndex = i_1 - 1;\r\n                        diveCount++;\r\n                    }\r\n                }\r\n            }\r\n            lastSubmerged = isSubmerged;\r\n        }\r\n        switch (diveCount) {\r\n            case 0:\r\n                if (lastSubmerged) {\r\n                    // Completely submerged\r\n                    var md = b2PolygonShape.ComputeSubmergedArea_s_md;\r\n                    this.ComputeMass(md, 1);\r\n                    b2Math_1.b2Transform.MulXV(xf, md.center, c);\r\n                    return md.mass;\r\n                }\r\n                else {\r\n                    // Completely dry\r\n                    return 0;\r\n                }\r\n            case 1:\r\n                if (intoIndex === (-1)) {\r\n                    intoIndex = this.m_count - 1;\r\n                }\r\n                else {\r\n                    outoIndex = this.m_count - 1;\r\n                }\r\n                break;\r\n        }\r\n        var intoIndex2 = ((intoIndex + 1) % this.m_count);\r\n        var outoIndex2 = ((outoIndex + 1) % this.m_count);\r\n        var intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);\r\n        var outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);\r\n        var intoVec = b2PolygonShape.ComputeSubmergedArea_s_intoVec.Set(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);\r\n        var outoVec = b2PolygonShape.ComputeSubmergedArea_s_outoVec.Set(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);\r\n        // Initialize accumulator\r\n        var area = 0;\r\n        var center = b2PolygonShape.ComputeSubmergedArea_s_center.SetZero();\r\n        var p2 = this.m_vertices[intoIndex2];\r\n        var p3;\r\n        // An awkward loop from intoIndex2+1 to outIndex2\r\n        var i = intoIndex2;\r\n        while (i !== outoIndex2) {\r\n            i = (i + 1) % this.m_count;\r\n            if (i === outoIndex2) {\r\n                p3 = outoVec;\r\n            }\r\n            else {\r\n                p3 = this.m_vertices[i];\r\n            }\r\n            var triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));\r\n            area += triangleArea;\r\n            // Area weighted centroid\r\n            center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;\r\n            center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;\r\n            p2 = p3;\r\n        }\r\n        // Normalize and transform centroid\r\n        center.SelfMul(1 / area);\r\n        b2Math_1.b2Transform.MulXV(xf, center, c);\r\n        return area;\r\n    };\r\n    b2PolygonShape.prototype.Dump = function (log) {\r\n        log(\"    const shape: b2PolygonShape = new b2PolygonShape();\\n\");\r\n        log(\"    const vs: b2Vec2[] = [];\\n\");\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            log(\"    vs[%d] = new b2Vec2(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n        }\r\n        log(\"    shape.Set(vs, %d);\\n\", this.m_count);\r\n    };\r\n    b2PolygonShape.ComputeCentroid = function (vs, count, out) {\r\n        // DEBUG: b2Assert(count >= 3);\r\n        var c = out;\r\n        c.SetZero();\r\n        var area = 0;\r\n        // s is the reference point for forming triangles.\r\n        // It's location doesn't change the result (except for rounding error).\r\n        var pRef = b2PolygonShape.ComputeCentroid_s_pRef.SetZero();\r\n        /*\r\n    #if 0\r\n        // This code would put the reference point inside the polygon.\r\n        for (let i: number = 0; i < count; ++i) {\r\n          pRef.SelfAdd(vs[i]);\r\n        }\r\n        pRef.SelfMul(1 / count);\r\n    #endif\r\n        */\r\n        var inv3 = 1 / 3;\r\n        for (var i = 0; i < count; ++i) {\r\n            // Triangle vertices.\r\n            var p1 = pRef;\r\n            var p2 = vs[i];\r\n            var p3 = vs[(i + 1) % count];\r\n            var e1 = b2Math_1.b2Vec2.SubVV(p2, p1, b2PolygonShape.ComputeCentroid_s_e1);\r\n            var e2 = b2Math_1.b2Vec2.SubVV(p3, p1, b2PolygonShape.ComputeCentroid_s_e2);\r\n            var D = b2Math_1.b2Vec2.CrossVV(e1, e2);\r\n            var triangleArea = 0.5 * D;\r\n            area += triangleArea;\r\n            // Area weighted centroid\r\n            c.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);\r\n            c.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);\r\n        }\r\n        // Centroid\r\n        // DEBUG: b2Assert(area > b2_epsilon);\r\n        c.SelfMul(1 / area);\r\n        return c;\r\n    };\r\n    /// Create a convex hull from the given array of points.\r\n    /// @warning the points may be re-ordered, even if they form a convex polygon\r\n    /// @warning collinear points are handled but not removed. Collinear points\r\n    /// may lead to poor stacking behavior.\r\n    b2PolygonShape.Set_s_r = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.Set_s_v = new b2Math_1.b2Vec2();\r\n    /// @see b2Shape::TestPoint\r\n    b2PolygonShape.TestPoint_s_pLocal = new b2Math_1.b2Vec2();\r\n    // #if B2_ENABLE_PARTICLE\r\n    /// @see b2Shape::ComputeDistance\r\n    b2PolygonShape.ComputeDistance_s_pLocal = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeDistance_s_normalForMaxDistance = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeDistance_s_minDistance = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeDistance_s_distance = new b2Math_1.b2Vec2();\r\n    // #endif\r\n    /// Implement b2Shape.\r\n    b2PolygonShape.RayCast_s_p1 = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.RayCast_s_p2 = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.RayCast_s_d = new b2Math_1.b2Vec2();\r\n    /// @see b2Shape::ComputeAABB\r\n    b2PolygonShape.ComputeAABB_s_v = new b2Math_1.b2Vec2();\r\n    /// @see b2Shape::ComputeMass\r\n    b2PolygonShape.ComputeMass_s_center = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeMass_s_s = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeMass_s_e1 = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeMass_s_e2 = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.Validate_s_e = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.Validate_s_v = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeSubmergedArea_s_normalL = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeSubmergedArea_s_md = new b2Shape_1.b2MassData();\r\n    b2PolygonShape.ComputeSubmergedArea_s_intoVec = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeSubmergedArea_s_outoVec = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeSubmergedArea_s_center = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeCentroid_s_pRef = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeCentroid_s_e1 = new b2Math_1.b2Vec2();\r\n    b2PolygonShape.ComputeCentroid_s_e2 = new b2Math_1.b2Vec2();\r\n    return b2PolygonShape;\r\n}(b2Shape_2.b2Shape));\r\nexports.b2PolygonShape = b2PolygonShape;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2PolygonShape.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/Shapes/b2PolygonShape.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert, b2_epsilon_sq } from \"../../Common/b2Settings\";\r\nimport { b2_epsilon, b2_maxFloat, b2_linearSlop, b2_polygonRadius } from \"../../Common/b2Settings\";\r\nimport { b2Vec2, b2Rot, b2Transform, XY } from \"../../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../b2Collision\";\r\nimport { b2DistanceProxy } from \"../b2Distance\";\r\nimport { b2MassData } from \"./b2Shape\";\r\nimport { b2Shape, b2ShapeType } from \"./b2Shape\";\r\n\r\n/// A convex polygon. It is assumed that the interior of the polygon is to\r\n/// the left of each edge.\r\n/// In most cases you should not need many vertices for a convex polygon.\r\nexport class b2PolygonShape extends b2Shape {\r\n  public readonly m_centroid: b2Vec2 = new b2Vec2(0, 0);\r\n  public m_vertices: b2Vec2[] = [];\r\n  public m_normals: b2Vec2[] = [];\r\n  public m_count: number = 0;\r\n\r\n  constructor() {\r\n    super(b2ShapeType.e_polygonShape, b2_polygonRadius);\r\n  }\r\n\r\n  /// Implement b2Shape.\r\n  public Clone(): b2PolygonShape {\r\n    return new b2PolygonShape().Copy(this);\r\n  }\r\n\r\n  public Copy(other: b2PolygonShape): b2PolygonShape {\r\n    super.Copy(other);\r\n\r\n    // DEBUG: b2Assert(other instanceof b2PolygonShape);\r\n\r\n    this.m_centroid.Copy(other.m_centroid);\r\n    this.m_count = other.m_count;\r\n    this.m_vertices = b2Vec2.MakeArray(this.m_count);\r\n    this.m_normals = b2Vec2.MakeArray(this.m_count);\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      this.m_vertices[i].Copy(other.m_vertices[i]);\r\n      this.m_normals[i].Copy(other.m_normals[i]);\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /// @see b2Shape::GetChildCount\r\n  public GetChildCount(): number {\r\n    return 1;\r\n  }\r\n\r\n  /// Create a convex hull from the given array of points.\r\n  /// @warning the points may be re-ordered, even if they form a convex polygon\r\n  /// @warning collinear points are handled but not removed. Collinear points\r\n  /// may lead to poor stacking behavior.\r\n  private static Set_s_r = new b2Vec2();\r\n  private static Set_s_v = new b2Vec2();\r\n  public Set(vertices: XY[]): b2PolygonShape;\r\n  public Set(vertices: XY[], count: number): b2PolygonShape;\r\n  public Set(vertices: number[]): b2PolygonShape;\r\n  public Set(...args: any[]): b2PolygonShape {\r\n    if (typeof args[0][0] === \"number\") {\r\n      const vertices: number[] = args[0];\r\n      if (vertices.length % 2 !== 0) { throw new Error(); }\r\n      return this._Set((index: number): XY => ({ x: vertices[index * 2], y: vertices[index * 2 + 1] }), vertices.length / 2);\r\n    } else {\r\n      const vertices: XY[] = args[0];\r\n      const count: number = args[1] || vertices.length\r\n      return this._Set((index: number): XY => vertices[index], count);\r\n    }\r\n  }\r\n  public _Set(vertices: (index: number) => XY, count: number): b2PolygonShape {\r\n\r\n    // DEBUG: b2Assert(3 <= count);\r\n    if (count < 3) {\r\n      return this.SetAsBox(1, 1);\r\n    }\r\n\r\n    let n: number = count;\r\n\r\n    // Perform welding and copy vertices into local buffer.\r\n    const ps: XY[] = [];\r\n    for (let i = 0; i < n; ++i) {\r\n      const /*b2Vec2*/ v = vertices(i);\r\n\r\n      let /*bool*/ unique = true;\r\n      for (let /*int32*/ j = 0; j < ps.length; ++j) {\r\n        if (b2Vec2.DistanceSquaredVV(v, ps[j]) < ((0.5 * b2_linearSlop) * (0.5 * b2_linearSlop))) {\r\n          unique = false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (unique) {\r\n        ps.push(v);\r\n      }\r\n    }\r\n\r\n    n = ps.length;\r\n    if (n < 3) {\r\n      // Polygon is degenerate.\r\n      // DEBUG: b2Assert(false);\r\n      return this.SetAsBox(1.0, 1.0);\r\n    }\r\n\r\n    // Create the convex hull using the Gift wrapping algorithm\r\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\r\n\r\n    // Find the right most point on the hull\r\n    let i0: number = 0;\r\n    let x0: number = ps[0].x;\r\n    for (let i: number = 1; i < n; ++i) {\r\n      const x: number = ps[i].x;\r\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\r\n        i0 = i;\r\n        x0 = x;\r\n      }\r\n    }\r\n\r\n    const hull: number[] = [];\r\n    let m: number = 0;\r\n    let ih: number = i0;\r\n\r\n    for (; ; ) {\r\n      hull[m] = ih;\r\n\r\n      let ie: number = 0;\r\n      for (let j: number = 1; j < n; ++j) {\r\n        if (ie === ih) {\r\n          ie = j;\r\n          continue;\r\n        }\r\n\r\n        const r: b2Vec2 = b2Vec2.SubVV(ps[ie], ps[hull[m]], b2PolygonShape.Set_s_r);\r\n        const v: b2Vec2 = b2Vec2.SubVV(ps[j], ps[hull[m]], b2PolygonShape.Set_s_v);\r\n        const c: number = b2Vec2.CrossVV(r, v);\r\n        if (c < 0) {\r\n          ie = j;\r\n        }\r\n\r\n        // Collinearity check\r\n        if (c === 0 && v.LengthSquared() > r.LengthSquared()) {\r\n          ie = j;\r\n        }\r\n      }\r\n\r\n      ++m;\r\n      ih = ie;\r\n\r\n      if (ie === i0) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this.m_count = m;\r\n    this.m_vertices = b2Vec2.MakeArray(this.m_count);\r\n    this.m_normals = b2Vec2.MakeArray(this.m_count);\r\n\r\n    // Copy vertices.\r\n    for (let i: number = 0; i < m; ++i) {\r\n      this.m_vertices[i].Copy(ps[hull[i]]);\r\n    }\r\n\r\n    // Compute normals. Ensure the edges have non-zero length.\r\n    for (let i: number = 0; i < m; ++i) {\r\n      const vertexi1: b2Vec2 = this.m_vertices[i];\r\n      const vertexi2: b2Vec2 = this.m_vertices[(i + 1) % m];\r\n      const edge: b2Vec2 = b2Vec2.SubVV(vertexi2, vertexi1, b2Vec2.s_t0); // edge uses s_t0\r\n      // DEBUG: b2Assert(edge.LengthSquared() > b2_epsilon_sq);\r\n      b2Vec2.CrossVOne(edge, this.m_normals[i]).SelfNormalize();\r\n    }\r\n\r\n    // Compute the polygon centroid.\r\n    b2PolygonShape.ComputeCentroid(this.m_vertices, m, this.m_centroid);\r\n\r\n    return this;\r\n  }\r\n\r\n  /// Build vertices to represent an axis-aligned box or an oriented box.\r\n  /// @param hx the half-width.\r\n  /// @param hy the half-height.\r\n  /// @param center the center of the box in local coordinates.\r\n  /// @param angle the rotation of the box in local coordinates.\r\n  public SetAsBox(hx: number, hy: number, center?: XY, angle: number = 0): b2PolygonShape {\r\n    this.m_count = 4;\r\n    this.m_vertices = b2Vec2.MakeArray(this.m_count);\r\n    this.m_normals = b2Vec2.MakeArray(this.m_count);\r\n    this.m_vertices[0].Set((-hx), (-hy));\r\n    this.m_vertices[1].Set(hx, (-hy));\r\n    this.m_vertices[2].Set(hx, hy);\r\n    this.m_vertices[3].Set((-hx), hy);\r\n    this.m_normals[0].Set(0, (-1));\r\n    this.m_normals[1].Set(1, 0);\r\n    this.m_normals[2].Set(0, 1);\r\n    this.m_normals[3].Set((-1), 0);\r\n    this.m_centroid.SetZero();\r\n\r\n    if (center) {\r\n      this.m_centroid.Copy(center);\r\n\r\n      const xf: b2Transform = new b2Transform();\r\n      xf.SetPosition(center);\r\n      xf.SetRotationAngle(angle);\r\n\r\n      // Transform vertices and normals.\r\n      for (let i: number = 0; i < this.m_count; ++i) {\r\n        b2Transform.MulXV(xf, this.m_vertices[i], this.m_vertices[i]);\r\n        b2Rot.MulRV(xf.q, this.m_normals[i], this.m_normals[i]);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /// @see b2Shape::TestPoint\r\n  private static TestPoint_s_pLocal = new b2Vec2();\r\n  public TestPoint(xf: b2Transform, p: XY): boolean {\r\n    const pLocal: b2Vec2 = b2Transform.MulTXV(xf, p, b2PolygonShape.TestPoint_s_pLocal);\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const dot: number = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));\r\n      if (dot > 0) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  /// @see b2Shape::ComputeDistance\r\n  private static ComputeDistance_s_pLocal = new b2Vec2();\r\n  private static ComputeDistance_s_normalForMaxDistance = new b2Vec2();\r\n  private static ComputeDistance_s_minDistance = new b2Vec2();\r\n  private static ComputeDistance_s_distance = new b2Vec2();\r\n  public ComputeDistance(xf: b2Transform, p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    const pLocal = b2Transform.MulTXV(xf, p, b2PolygonShape.ComputeDistance_s_pLocal);\r\n    let maxDistance = -b2_maxFloat;\r\n    const normalForMaxDistance = b2PolygonShape.ComputeDistance_s_normalForMaxDistance.Copy(pLocal);\r\n\r\n    for (let i = 0; i < this.m_count; ++i) {\r\n      const dot = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(pLocal, this.m_vertices[i], b2Vec2.s_t0));\r\n      if (dot > maxDistance) {\r\n        maxDistance = dot;\r\n        normalForMaxDistance.Copy(this.m_normals[i]);\r\n      }\r\n    }\r\n\r\n    if (maxDistance > 0) {\r\n      const minDistance = b2PolygonShape.ComputeDistance_s_minDistance.Copy(normalForMaxDistance);\r\n      let minDistance2 = maxDistance * maxDistance;\r\n      for (let i = 0; i < this.m_count; ++i) {\r\n        const distance = b2Vec2.SubVV(pLocal, this.m_vertices[i], b2PolygonShape.ComputeDistance_s_distance);\r\n        const distance2 = distance.LengthSquared();\r\n        if (minDistance2 > distance2) {\r\n          minDistance.Copy(distance);\r\n          minDistance2 = distance2;\r\n        }\r\n      }\r\n\r\n      b2Rot.MulRV(xf.q, minDistance, normal);\r\n      normal.Normalize();\r\n      return Math.sqrt(minDistance2);\r\n    } else {\r\n      b2Rot.MulRV(xf.q, normalForMaxDistance, normal);\r\n      return maxDistance;\r\n    }\r\n  }\r\n  // #endif\r\n\r\n  /// Implement b2Shape.\r\n  private static RayCast_s_p1 = new b2Vec2();\r\n  private static RayCast_s_p2 = new b2Vec2();\r\n  private static RayCast_s_d = new b2Vec2();\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, xf: b2Transform, childIndex: number): boolean {\r\n    // Put the ray into the polygon's frame of reference.\r\n    const p1: b2Vec2 = b2Transform.MulTXV(xf, input.p1, b2PolygonShape.RayCast_s_p1);\r\n    const p2: b2Vec2 = b2Transform.MulTXV(xf, input.p2, b2PolygonShape.RayCast_s_p2);\r\n    const d: b2Vec2 = b2Vec2.SubVV(p2, p1, b2PolygonShape.RayCast_s_d);\r\n\r\n    let lower: number = 0, upper = input.maxFraction;\r\n\r\n    let index: number = -1;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      // p = p1 + a * d\r\n      // dot(normal, p - v) = 0\r\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\r\n      const numerator: number = b2Vec2.DotVV(this.m_normals[i], b2Vec2.SubVV(this.m_vertices[i], p1, b2Vec2.s_t0));\r\n      const denominator: number = b2Vec2.DotVV(this.m_normals[i], d);\r\n\r\n      if (denominator === 0) {\r\n        if (numerator < 0) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Note: we want this predicate without division:\r\n        // lower < numerator / denominator, where denominator < 0\r\n        // Since denominator < 0, we have to flip the inequality:\r\n        // lower < numerator / denominator <==> denominator * lower > numerator.\r\n        if (denominator < 0 && numerator < lower * denominator) {\r\n          // Increase lower.\r\n          // The segment enters this half-space.\r\n          lower = numerator / denominator;\r\n          index = i;\r\n        } else if (denominator > 0 && numerator < upper * denominator) {\r\n          // Decrease upper.\r\n          // The segment exits this half-space.\r\n          upper = numerator / denominator;\r\n        }\r\n      }\r\n\r\n      // The use of epsilon here causes the assert on lower to trip\r\n      // in some cases. Apparently the use of epsilon was to make edge\r\n      // shapes work, but now those are handled separately.\r\n      // if (upper < lower - b2_epsilon)\r\n      if (upper < lower) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    // DEBUG: b2Assert(0 <= lower && lower <= input.maxFraction);\r\n\r\n    if (index >= 0) {\r\n      output.fraction = lower;\r\n      b2Rot.MulRV(xf.q, this.m_normals[index], output.normal);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /// @see b2Shape::ComputeAABB\r\n  private static ComputeAABB_s_v = new b2Vec2();\r\n  public ComputeAABB(aabb: b2AABB, xf: b2Transform, childIndex: number): void {\r\n    const lower: b2Vec2 = b2Transform.MulXV(xf, this.m_vertices[0], aabb.lowerBound);\r\n    const upper: b2Vec2 = aabb.upperBound.Copy(lower);\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const v: b2Vec2 = b2Transform.MulXV(xf, this.m_vertices[i], b2PolygonShape.ComputeAABB_s_v);\r\n      b2Vec2.MinV(v, lower, lower);\r\n      b2Vec2.MaxV(v, upper, upper);\r\n    }\r\n\r\n    const r: number = this.m_radius;\r\n    lower.SelfSubXY(r, r);\r\n    upper.SelfAddXY(r, r);\r\n  }\r\n\r\n  /// @see b2Shape::ComputeMass\r\n  private static ComputeMass_s_center = new b2Vec2();\r\n  private static ComputeMass_s_s = new b2Vec2();\r\n  private static ComputeMass_s_e1 = new b2Vec2();\r\n  private static ComputeMass_s_e2 = new b2Vec2();\r\n  public ComputeMass(massData: b2MassData, density: number): void {\r\n    // Polygon mass, centroid, and inertia.\r\n    // Let rho be the polygon density in mass per unit area.\r\n    // Then:\r\n    // mass = rho * int(dA)\r\n    // centroid.x = (1/mass) * rho * int(x * dA)\r\n    // centroid.y = (1/mass) * rho * int(y * dA)\r\n    // I = rho * int((x*x + y*y) * dA)\r\n    //\r\n    // We can compute these integrals by summing all the integrals\r\n    // for each triangle of the polygon. To evaluate the integral\r\n    // for a single triangle, we make a change of variables to\r\n    // the (u,v) coordinates of the triangle:\r\n    // x = x0 + e1x * u + e2x * v\r\n    // y = y0 + e1y * u + e2y * v\r\n    // where 0 <= u && 0 <= v && u + v <= 1.\r\n    //\r\n    // We integrate u from [0,1-v] and then v from [0,1].\r\n    // We also need to use the Jacobian of the transformation:\r\n    // D = cross(e1, e2)\r\n    //\r\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\r\n    //\r\n    // The rest of the derivation is handled by computer algebra.\r\n\r\n    // DEBUG: b2Assert(this.m_count >= 3);\r\n\r\n    const center: b2Vec2 = b2PolygonShape.ComputeMass_s_center.SetZero();\r\n    let area: number = 0;\r\n    let I: number = 0;\r\n\r\n    // s is the reference point for forming triangles.\r\n    // It's location doesn't change the result (except for rounding error).\r\n    const s: b2Vec2 = b2PolygonShape.ComputeMass_s_s.SetZero();\r\n\r\n    // This code would put the reference point inside the polygon.\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      s.SelfAdd(this.m_vertices[i]);\r\n    }\r\n    s.SelfMul(1 / this.m_count);\r\n\r\n    const k_inv3: number = 1 / 3;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      // Triangle vertices.\r\n      const e1: b2Vec2 = b2Vec2.SubVV(this.m_vertices[i], s, b2PolygonShape.ComputeMass_s_e1);\r\n      const e2: b2Vec2 = b2Vec2.SubVV(this.m_vertices[(i + 1) % this.m_count], s, b2PolygonShape.ComputeMass_s_e2);\r\n\r\n      const D: number = b2Vec2.CrossVV(e1, e2);\r\n\r\n      const triangleArea: number = 0.5 * D;\r\n      area += triangleArea;\r\n\r\n      // Area weighted centroid\r\n      center.SelfAdd(b2Vec2.MulSV(triangleArea * k_inv3, b2Vec2.AddVV(e1, e2, b2Vec2.s_t0), b2Vec2.s_t1));\r\n\r\n      const ex1: number = e1.x;\r\n      const ey1: number = e1.y;\r\n      const ex2: number = e2.x;\r\n      const ey2: number = e2.y;\r\n\r\n      const intx2: number = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\r\n      const inty2: number = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\r\n\r\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\r\n    }\r\n\r\n    // Total mass\r\n    massData.mass = density * area;\r\n\r\n    // Center of mass\r\n    // DEBUG: b2Assert(area > b2_epsilon);\r\n    center.SelfMul(1 / area);\r\n    b2Vec2.AddVV(center, s, massData.center);\r\n\r\n    // Inertia tensor relative to the local origin (point s).\r\n    massData.I = density * I;\r\n\r\n    // Shift to center of mass then to original body origin.\r\n    massData.I += massData.mass * (b2Vec2.DotVV(massData.center, massData.center) - b2Vec2.DotVV(center, center));\r\n  }\r\n\r\n  private static Validate_s_e = new b2Vec2();\r\n  private static Validate_s_v = new b2Vec2();\r\n  public Validate(): boolean {\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const i1 = i;\r\n      const i2 = (i + 1) % this.m_count;\r\n      const p: b2Vec2 = this.m_vertices[i1];\r\n      const e: b2Vec2 = b2Vec2.SubVV(this.m_vertices[i2], p, b2PolygonShape.Validate_s_e);\r\n\r\n      for (let j: number = 0; j < this.m_count; ++j) {\r\n        if (j === i1 || j === i2) {\r\n          continue;\r\n        }\r\n\r\n        const v: b2Vec2 = b2Vec2.SubVV(this.m_vertices[j], p, b2PolygonShape.Validate_s_v);\r\n        const c: number = b2Vec2.CrossVV(e, v);\r\n        if (c < 0) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public SetupDistanceProxy(proxy: b2DistanceProxy, index: number): void {\r\n    proxy.m_vertices = this.m_vertices;\r\n    proxy.m_count = this.m_count;\r\n    proxy.m_radius = this.m_radius;\r\n  }\r\n\r\n  private static ComputeSubmergedArea_s_normalL = new b2Vec2();\r\n  private static ComputeSubmergedArea_s_md = new b2MassData();\r\n  private static ComputeSubmergedArea_s_intoVec = new b2Vec2();\r\n  private static ComputeSubmergedArea_s_outoVec = new b2Vec2();\r\n  private static ComputeSubmergedArea_s_center = new b2Vec2();\r\n  public ComputeSubmergedArea(normal: b2Vec2, offset: number, xf: b2Transform, c: b2Vec2): number {\r\n    // Transform plane into shape co-ordinates\r\n    const normalL: b2Vec2 = b2Rot.MulTRV(xf.q, normal, b2PolygonShape.ComputeSubmergedArea_s_normalL);\r\n    const offsetL: number = offset - b2Vec2.DotVV(normal, xf.p);\r\n\r\n    const depths: number[] = [];\r\n    let diveCount: number = 0;\r\n    let intoIndex: number = -1;\r\n    let outoIndex: number = -1;\r\n\r\n    let lastSubmerged: boolean = false;\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      depths[i] = b2Vec2.DotVV(normalL, this.m_vertices[i]) - offsetL;\r\n      const isSubmerged: boolean = depths[i] < (-b2_epsilon);\r\n      if (i > 0) {\r\n        if (isSubmerged) {\r\n          if (!lastSubmerged) {\r\n            intoIndex = i - 1;\r\n            diveCount++;\r\n          }\r\n        } else {\r\n          if (lastSubmerged) {\r\n            outoIndex = i - 1;\r\n            diveCount++;\r\n          }\r\n        }\r\n      }\r\n      lastSubmerged = isSubmerged;\r\n    }\r\n    switch (diveCount) {\r\n    case 0:\r\n      if (lastSubmerged) {\r\n        // Completely submerged\r\n        const md: b2MassData = b2PolygonShape.ComputeSubmergedArea_s_md;\r\n        this.ComputeMass(md, 1);\r\n        b2Transform.MulXV(xf, md.center, c);\r\n        return md.mass;\r\n      } else {\r\n        // Completely dry\r\n        return 0;\r\n      }\r\n    case 1:\r\n      if (intoIndex === (-1)) {\r\n        intoIndex = this.m_count - 1;\r\n      } else {\r\n        outoIndex = this.m_count - 1;\r\n      }\r\n      break;\r\n    }\r\n    const intoIndex2: number = ((intoIndex + 1) % this.m_count);\r\n    const outoIndex2: number = ((outoIndex + 1) % this.m_count);\r\n    const intoLamdda: number = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);\r\n    const outoLamdda: number = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);\r\n\r\n    const intoVec: b2Vec2 = b2PolygonShape.ComputeSubmergedArea_s_intoVec.Set(\r\n      this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda,\r\n      this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);\r\n    const outoVec: b2Vec2 = b2PolygonShape.ComputeSubmergedArea_s_outoVec.Set(\r\n      this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda,\r\n      this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);\r\n\r\n    // Initialize accumulator\r\n    let area: number = 0;\r\n    const center: b2Vec2 = b2PolygonShape.ComputeSubmergedArea_s_center.SetZero();\r\n    let p2: b2Vec2 = this.m_vertices[intoIndex2];\r\n    let p3: b2Vec2;\r\n\r\n    // An awkward loop from intoIndex2+1 to outIndex2\r\n    let i: number = intoIndex2;\r\n    while (i !== outoIndex2) {\r\n      i = (i + 1) % this.m_count;\r\n      if (i === outoIndex2) {\r\n        p3 = outoVec;\r\n      } else {\r\n        p3  = this.m_vertices[i];\r\n      }\r\n\r\n      const triangleArea: number = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));\r\n      area += triangleArea;\r\n      // Area weighted centroid\r\n      center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;\r\n      center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;\r\n\r\n      p2 = p3;\r\n    }\r\n\r\n    // Normalize and transform centroid\r\n    center.SelfMul(1 / area);\r\n    b2Transform.MulXV(xf, center, c);\r\n\r\n    return area;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    log(\"    const shape: b2PolygonShape = new b2PolygonShape();\\n\");\r\n    log(\"    const vs: b2Vec2[] = [];\\n\");\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      log(\"    vs[%d] = new b2Vec2(%.15f, %.15f);\\n\", i, this.m_vertices[i].x, this.m_vertices[i].y);\r\n    }\r\n    log(\"    shape.Set(vs, %d);\\n\", this.m_count);\r\n  }\r\n\r\n  private static ComputeCentroid_s_pRef = new b2Vec2();\r\n  private static ComputeCentroid_s_e1 = new b2Vec2();\r\n  private static ComputeCentroid_s_e2 = new b2Vec2();\r\n  public static ComputeCentroid(vs: b2Vec2[], count: number, out: b2Vec2): b2Vec2 {\r\n    // DEBUG: b2Assert(count >= 3);\r\n\r\n    const c: b2Vec2 = out; c.SetZero();\r\n    let area: number = 0;\r\n\r\n    // s is the reference point for forming triangles.\r\n    // It's location doesn't change the result (except for rounding error).\r\n    const pRef: b2Vec2 = b2PolygonShape.ComputeCentroid_s_pRef.SetZero();\r\n    /*\r\n#if 0\r\n    // This code would put the reference point inside the polygon.\r\n    for (let i: number = 0; i < count; ++i) {\r\n      pRef.SelfAdd(vs[i]);\r\n    }\r\n    pRef.SelfMul(1 / count);\r\n#endif\r\n    */\r\n\r\n    const inv3: number = 1 / 3;\r\n\r\n    for (let i: number = 0; i < count; ++i) {\r\n      // Triangle vertices.\r\n      const p1: b2Vec2 = pRef;\r\n      const p2: b2Vec2 = vs[i];\r\n      const p3: b2Vec2 = vs[(i + 1) % count];\r\n\r\n      const e1: b2Vec2 = b2Vec2.SubVV(p2, p1, b2PolygonShape.ComputeCentroid_s_e1);\r\n      const e2: b2Vec2 = b2Vec2.SubVV(p3, p1, b2PolygonShape.ComputeCentroid_s_e2);\r\n\r\n      const D: number = b2Vec2.CrossVV(e1, e2);\r\n\r\n      const triangleArea: number = 0.5 * D;\r\n      area += triangleArea;\r\n\r\n      // Area weighted centroid\r\n      c.x += triangleArea * inv3 * (p1.x + p2.x + p3.x);\r\n      c.y += triangleArea * inv3 * (p1.y + p2.y + p3.y);\r\n    }\r\n\r\n    // Centroid\r\n    // DEBUG: b2Assert(area > b2_epsilon);\r\n    c.SelfMul(1 / area);\r\n    return c;\r\n  }\r\n\r\n  /*\r\n  public static ComputeOBB(obb, vs, count) {\r\n    const i: number = 0;\r\n    const p: Array = [count + 1];\r\n    for (i = 0; i < count; ++i) {\r\n      p[i] = vs[i];\r\n    }\r\n    p[count] = p[0];\r\n    const minArea = b2_maxFloat;\r\n    for (i = 1; i <= count; ++i) {\r\n      const root = p[i - 1];\r\n      const uxX = p[i].x - root.x;\r\n      const uxY = p[i].y - root.y;\r\n      const length = b2Sqrt(uxX * uxX + uxY * uxY);\r\n      uxX /= length;\r\n      uxY /= length;\r\n      const uyX = (-uxY);\r\n      const uyY = uxX;\r\n      const lowerX = b2_maxFloat;\r\n      const lowerY = b2_maxFloat;\r\n      const upperX = (-b2_maxFloat);\r\n      const upperY = (-b2_maxFloat);\r\n      for (let j: number = 0; j < count; ++j) {\r\n        const dX = p[j].x - root.x;\r\n        const dY = p[j].y - root.y;\r\n        const rX = (uxX * dX + uxY * dY);\r\n        const rY = (uyX * dX + uyY * dY);\r\n        if (rX < lowerX) lowerX = rX;\r\n        if (rY < lowerY) lowerY = rY;\r\n        if (rX > upperX) upperX = rX;\r\n        if (rY > upperY) upperY = rY;\r\n      }\r\n      const area = (upperX - lowerX) * (upperY - lowerY);\r\n      if (area < 0.95 * minArea) {\r\n        minArea = area;\r\n        obb.R.ex.x = uxX;\r\n        obb.R.ex.y = uxY;\r\n        obb.R.ey.x = uyX;\r\n        obb.R.ey.y = uyY;\r\n        const center_x: number = 0.5 * (lowerX + upperX);\r\n        const center_y: number = 0.5 * (lowerY + upperY);\r\n        const tMat = obb.R;\r\n        obb.center.x = root.x + (tMat.ex.x * center_x + tMat.ey.x * center_y);\r\n        obb.center.y = root.y + (tMat.ex.y * center_x + tMat.ey.y * center_y);\r\n        obb.extents.x = 0.5 * (upperX - lowerX);\r\n        obb.extents.y = 0.5 * (upperY - lowerY);\r\n      }\r\n    }\r\n  }\r\n  */\r\n}\r\n"]}},"error":null,"hash":"14b474def7a08a327cd3b1af8719822e","cacheData":{"env":{}}}