{"id":"../node_modules/box2d.package.ts/Dynamics/b2ContactManager.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Collision/b2BroadPhase","loc":{"line":21,"column":29},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2BroadPhase.ts"},{"name":"../Collision/b2Collision","loc":{"line":22,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"./Contacts/b2ContactFactory","loc":{"line":23,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactFactory.ts"},{"name":"./b2Body","loc":{"line":24,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts"},{"name":"./b2WorldCallbacks","loc":{"line":25,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2ContactManager.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2BroadPhase_1 = require(\"../Collision/b2BroadPhase\");\r\nvar b2Collision_1 = require(\"../Collision/b2Collision\");\r\nvar b2ContactFactory_1 = require(\"./Contacts/b2ContactFactory\");\r\nvar b2Body_1 = require(\"./b2Body\");\r\nvar b2WorldCallbacks_1 = require(\"./b2WorldCallbacks\");\r\n// Delegate of b2World.\r\nvar b2ContactManager = /** @class */ (function () {\r\n    function b2ContactManager() {\r\n        this.m_broadPhase = new b2BroadPhase_1.b2BroadPhase();\r\n        this.m_contactList = null;\r\n        this.m_contactCount = 0;\r\n        this.m_contactFilter = b2WorldCallbacks_1.b2ContactFilter.b2_defaultFilter;\r\n        this.m_contactListener = b2WorldCallbacks_1.b2ContactListener.b2_defaultListener;\r\n        this.m_contactFactory = new b2ContactFactory_1.b2ContactFactory();\r\n    }\r\n    // Broad-phase callback.\r\n    b2ContactManager.prototype.AddPair = function (proxyA, proxyB) {\r\n        // DEBUG: b2Assert(proxyA instanceof b2FixtureProxy);\r\n        // DEBUG: b2Assert(proxyB instanceof b2FixtureProxy);\r\n        var fixtureA = proxyA.fixture;\r\n        var fixtureB = proxyB.fixture;\r\n        var indexA = proxyA.childIndex;\r\n        var indexB = proxyB.childIndex;\r\n        var bodyA = fixtureA.GetBody();\r\n        var bodyB = fixtureB.GetBody();\r\n        // Are the fixtures on the same body?\r\n        if (bodyA === bodyB) {\r\n            return;\r\n        }\r\n        // TODO_ERIN use a hash table to remove a potential bottleneck when both\r\n        // bodies have a lot of contacts.\r\n        // Does a contact already exist?\r\n        var edge = bodyB.GetContactList();\r\n        while (edge) {\r\n            if (edge.other === bodyA) {\r\n                var fA = edge.contact.GetFixtureA();\r\n                var fB = edge.contact.GetFixtureB();\r\n                var iA = edge.contact.GetChildIndexA();\r\n                var iB = edge.contact.GetChildIndexB();\r\n                if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB) {\r\n                    // A contact already exists.\r\n                    return;\r\n                }\r\n                if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA) {\r\n                    // A contact already exists.\r\n                    return;\r\n                }\r\n            }\r\n            edge = edge.next;\r\n        }\r\n        // Check user filtering.\r\n        if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {\r\n            return;\r\n        }\r\n        // Call the factory.\r\n        var c = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);\r\n        if (c === null) {\r\n            return;\r\n        }\r\n        // Contact creation may swap fixtures.\r\n        fixtureA = c.GetFixtureA();\r\n        fixtureB = c.GetFixtureB();\r\n        indexA = c.GetChildIndexA();\r\n        indexB = c.GetChildIndexB();\r\n        bodyA = fixtureA.m_body;\r\n        bodyB = fixtureB.m_body;\r\n        // Insert into the world.\r\n        c.m_prev = null;\r\n        c.m_next = this.m_contactList;\r\n        if (this.m_contactList !== null) {\r\n            this.m_contactList.m_prev = c;\r\n        }\r\n        this.m_contactList = c;\r\n        // Connect to island graph.\r\n        // Connect to body A\r\n        c.m_nodeA.other = bodyB;\r\n        c.m_nodeA.prev = null;\r\n        c.m_nodeA.next = bodyA.m_contactList;\r\n        if (bodyA.m_contactList !== null) {\r\n            bodyA.m_contactList.prev = c.m_nodeA;\r\n        }\r\n        bodyA.m_contactList = c.m_nodeA;\r\n        // Connect to body B\r\n        c.m_nodeB.other = bodyA;\r\n        c.m_nodeB.prev = null;\r\n        c.m_nodeB.next = bodyB.m_contactList;\r\n        if (bodyB.m_contactList !== null) {\r\n            bodyB.m_contactList.prev = c.m_nodeB;\r\n        }\r\n        bodyB.m_contactList = c.m_nodeB;\r\n        // Wake up the bodies\r\n        if (!fixtureA.IsSensor() && !fixtureB.IsSensor()) {\r\n            bodyA.SetAwake(true);\r\n            bodyB.SetAwake(true);\r\n        }\r\n        ++this.m_contactCount;\r\n    };\r\n    b2ContactManager.prototype.FindNewContacts = function () {\r\n        var _this = this;\r\n        this.m_broadPhase.UpdatePairs(function (proxyA, proxyB) {\r\n            _this.AddPair(proxyA, proxyB);\r\n        });\r\n    };\r\n    b2ContactManager.prototype.Destroy = function (c) {\r\n        var fixtureA = c.GetFixtureA();\r\n        var fixtureB = c.GetFixtureB();\r\n        var bodyA = fixtureA.GetBody();\r\n        var bodyB = fixtureB.GetBody();\r\n        if (this.m_contactListener && c.IsTouching()) {\r\n            this.m_contactListener.EndContact(c);\r\n        }\r\n        // Remove from the world.\r\n        if (c.m_prev) {\r\n            c.m_prev.m_next = c.m_next;\r\n        }\r\n        if (c.m_next) {\r\n            c.m_next.m_prev = c.m_prev;\r\n        }\r\n        if (c === this.m_contactList) {\r\n            this.m_contactList = c.m_next;\r\n        }\r\n        // Remove from body 1\r\n        if (c.m_nodeA.prev) {\r\n            c.m_nodeA.prev.next = c.m_nodeA.next;\r\n        }\r\n        if (c.m_nodeA.next) {\r\n            c.m_nodeA.next.prev = c.m_nodeA.prev;\r\n        }\r\n        if (c.m_nodeA === bodyA.m_contactList) {\r\n            bodyA.m_contactList = c.m_nodeA.next;\r\n        }\r\n        // Remove from body 2\r\n        if (c.m_nodeB.prev) {\r\n            c.m_nodeB.prev.next = c.m_nodeB.next;\r\n        }\r\n        if (c.m_nodeB.next) {\r\n            c.m_nodeB.next.prev = c.m_nodeB.prev;\r\n        }\r\n        if (c.m_nodeB === bodyB.m_contactList) {\r\n            bodyB.m_contactList = c.m_nodeB.next;\r\n        }\r\n        // moved this from b2ContactFactory:Destroy\r\n        if (c.m_manifold.pointCount > 0 &&\r\n            !fixtureA.IsSensor() &&\r\n            !fixtureB.IsSensor()) {\r\n            fixtureA.GetBody().SetAwake(true);\r\n            fixtureB.GetBody().SetAwake(true);\r\n        }\r\n        // Call the factory.\r\n        this.m_contactFactory.Destroy(c);\r\n        --this.m_contactCount;\r\n    };\r\n    // This is the top level collision call for the time step. Here\r\n    // all the narrow phase collision is processed for the world\r\n    // contact list.\r\n    b2ContactManager.prototype.Collide = function () {\r\n        // Update awake contacts.\r\n        var c = this.m_contactList;\r\n        while (c) {\r\n            var fixtureA = c.GetFixtureA();\r\n            var fixtureB = c.GetFixtureB();\r\n            var indexA = c.GetChildIndexA();\r\n            var indexB = c.GetChildIndexB();\r\n            var bodyA = fixtureA.GetBody();\r\n            var bodyB = fixtureB.GetBody();\r\n            // Is this contact flagged for filtering?\r\n            if (c.m_filterFlag) {\r\n                // Check user filtering.\r\n                if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {\r\n                    var cNuke = c;\r\n                    c = cNuke.m_next;\r\n                    this.Destroy(cNuke);\r\n                    continue;\r\n                }\r\n                // Clear the filtering flag.\r\n                c.m_filterFlag = false;\r\n            }\r\n            var activeA = bodyA.IsAwake() && bodyA.m_type !== b2Body_1.b2BodyType.b2_staticBody;\r\n            var activeB = bodyB.IsAwake() && bodyB.m_type !== b2Body_1.b2BodyType.b2_staticBody;\r\n            // At least one body must be awake and it must be dynamic or kinematic.\r\n            if (!activeA && !activeB) {\r\n                c = c.m_next;\r\n                continue;\r\n            }\r\n            var treeNodeA = fixtureA.m_proxies[indexA].treeNode;\r\n            var treeNodeB = fixtureB.m_proxies[indexB].treeNode;\r\n            var overlap = b2Collision_1.b2TestOverlapAABB(treeNodeA.aabb, treeNodeB.aabb);\r\n            // Here we destroy contacts that cease to overlap in the broad-phase.\r\n            if (!overlap) {\r\n                var cNuke = c;\r\n                c = cNuke.m_next;\r\n                this.Destroy(cNuke);\r\n                continue;\r\n            }\r\n            // The contact persists.\r\n            c.Update(this.m_contactListener);\r\n            c = c.m_next;\r\n        }\r\n    };\r\n    return b2ContactManager;\r\n}());\r\nexports.b2ContactManager = b2ContactManager;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2ContactManager.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2ContactManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2BroadPhase } from \"../Collision/b2BroadPhase\";\r\nimport { b2TreeNode } from \"../Collision/b2DynamicTree\";\r\nimport { b2TestOverlapAABB } from \"../Collision/b2Collision\";\r\nimport { b2Contact, b2ContactEdge } from \"./Contacts/b2Contact\";\r\nimport { b2ContactFactory } from \"./Contacts/b2ContactFactory\";\r\nimport { b2Body, b2BodyType } from \"./b2Body\";\r\nimport { b2Fixture, b2FixtureProxy } from \"./b2Fixture\";\r\nimport { b2ContactFilter, b2ContactListener } from \"./b2WorldCallbacks\";\r\n\r\n// Delegate of b2World.\r\nexport class b2ContactManager {\r\n  public readonly m_broadPhase: b2BroadPhase<b2FixtureProxy> = new b2BroadPhase<b2FixtureProxy>();\r\n  public m_contactList: b2Contact | null = null;\r\n  public m_contactCount: number = 0;\r\n  public m_contactFilter: b2ContactFilter = b2ContactFilter.b2_defaultFilter;\r\n  public m_contactListener: b2ContactListener = b2ContactListener.b2_defaultListener;\r\n\r\n  public readonly m_contactFactory: b2ContactFactory = new b2ContactFactory();\r\n\r\n  // Broad-phase callback.\r\n  public AddPair(proxyA: b2FixtureProxy, proxyB: b2FixtureProxy): void {\r\n    // DEBUG: b2Assert(proxyA instanceof b2FixtureProxy);\r\n    // DEBUG: b2Assert(proxyB instanceof b2FixtureProxy);\r\n\r\n    let fixtureA: b2Fixture = proxyA.fixture;\r\n    let fixtureB: b2Fixture = proxyB.fixture;\r\n\r\n    let indexA: number = proxyA.childIndex;\r\n    let indexB: number = proxyB.childIndex;\r\n\r\n    let bodyA: b2Body = fixtureA.GetBody();\r\n    let bodyB: b2Body = fixtureB.GetBody();\r\n\r\n    // Are the fixtures on the same body?\r\n    if (bodyA === bodyB) {\r\n      return;\r\n    }\r\n\r\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\r\n    // bodies have a lot of contacts.\r\n    // Does a contact already exist?\r\n    let edge: b2ContactEdge | null = bodyB.GetContactList();\r\n    while (edge) {\r\n      if (edge.other === bodyA) {\r\n        const fA: b2Fixture = edge.contact.GetFixtureA();\r\n        const fB: b2Fixture = edge.contact.GetFixtureB();\r\n        const iA: number = edge.contact.GetChildIndexA();\r\n        const iB: number = edge.contact.GetChildIndexB();\r\n\r\n        if (fA === fixtureA && fB === fixtureB && iA === indexA && iB === indexB) {\r\n          // A contact already exists.\r\n          return;\r\n        }\r\n\r\n        if (fA === fixtureB && fB === fixtureA && iA === indexB && iB === indexA) {\r\n          // A contact already exists.\r\n          return;\r\n        }\r\n      }\r\n\r\n      edge = edge.next;\r\n    }\r\n\r\n    // Check user filtering.\r\n    if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {\r\n      return;\r\n    }\r\n\r\n    // Call the factory.\r\n    const c: b2Contact | null = this.m_contactFactory.Create(fixtureA, indexA, fixtureB, indexB);\r\n    if (c === null) {\r\n      return;\r\n    }\r\n\r\n    // Contact creation may swap fixtures.\r\n    fixtureA = c.GetFixtureA();\r\n    fixtureB = c.GetFixtureB();\r\n    indexA = c.GetChildIndexA();\r\n    indexB = c.GetChildIndexB();\r\n    bodyA = fixtureA.m_body;\r\n    bodyB = fixtureB.m_body;\r\n\r\n    // Insert into the world.\r\n    c.m_prev = null;\r\n    c.m_next = this.m_contactList;\r\n    if (this.m_contactList !== null) {\r\n      this.m_contactList.m_prev = c;\r\n    }\r\n    this.m_contactList = c;\r\n\r\n    // Connect to island graph.\r\n\r\n    // Connect to body A\r\n    c.m_nodeA.other = bodyB;\r\n\r\n    c.m_nodeA.prev = null;\r\n    c.m_nodeA.next = bodyA.m_contactList;\r\n    if (bodyA.m_contactList !== null) {\r\n      bodyA.m_contactList.prev = c.m_nodeA;\r\n    }\r\n    bodyA.m_contactList = c.m_nodeA;\r\n\r\n    // Connect to body B\r\n    c.m_nodeB.other = bodyA;\r\n\r\n    c.m_nodeB.prev = null;\r\n    c.m_nodeB.next = bodyB.m_contactList;\r\n    if (bodyB.m_contactList !== null) {\r\n      bodyB.m_contactList.prev = c.m_nodeB;\r\n    }\r\n    bodyB.m_contactList = c.m_nodeB;\r\n\r\n    // Wake up the bodies\r\n    if (!fixtureA.IsSensor() && !fixtureB.IsSensor()) {\r\n      bodyA.SetAwake(true);\r\n      bodyB.SetAwake(true);\r\n    }\r\n\r\n    ++this.m_contactCount;\r\n  }\r\n\r\n  public FindNewContacts(): void {\r\n    this.m_broadPhase.UpdatePairs((proxyA: b2FixtureProxy, proxyB: b2FixtureProxy): void => {\r\n      this.AddPair(proxyA, proxyB);\r\n    });\r\n  }\r\n\r\n  public Destroy(c: b2Contact): void {\r\n    const fixtureA: b2Fixture = c.GetFixtureA();\r\n    const fixtureB: b2Fixture = c.GetFixtureB();\r\n    const bodyA: b2Body = fixtureA.GetBody();\r\n    const bodyB: b2Body = fixtureB.GetBody();\r\n\r\n    if (this.m_contactListener && c.IsTouching()) {\r\n      this.m_contactListener.EndContact(c);\r\n    }\r\n\r\n    // Remove from the world.\r\n    if (c.m_prev) {\r\n      c.m_prev.m_next = c.m_next;\r\n    }\r\n\r\n    if (c.m_next) {\r\n      c.m_next.m_prev = c.m_prev;\r\n    }\r\n\r\n    if (c === this.m_contactList) {\r\n      this.m_contactList = c.m_next;\r\n    }\r\n\r\n    // Remove from body 1\r\n    if (c.m_nodeA.prev) {\r\n      c.m_nodeA.prev.next = c.m_nodeA.next;\r\n    }\r\n\r\n    if (c.m_nodeA.next) {\r\n      c.m_nodeA.next.prev = c.m_nodeA.prev;\r\n    }\r\n\r\n    if (c.m_nodeA === bodyA.m_contactList) {\r\n      bodyA.m_contactList = c.m_nodeA.next;\r\n    }\r\n\r\n    // Remove from body 2\r\n    if (c.m_nodeB.prev) {\r\n      c.m_nodeB.prev.next = c.m_nodeB.next;\r\n    }\r\n\r\n    if (c.m_nodeB.next) {\r\n      c.m_nodeB.next.prev = c.m_nodeB.prev;\r\n    }\r\n\r\n    if (c.m_nodeB === bodyB.m_contactList) {\r\n      bodyB.m_contactList = c.m_nodeB.next;\r\n    }\r\n\r\n    // moved this from b2ContactFactory:Destroy\r\n    if (c.m_manifold.pointCount > 0 &&\r\n      !fixtureA.IsSensor() &&\r\n      !fixtureB.IsSensor()) {\r\n      fixtureA.GetBody().SetAwake(true);\r\n      fixtureB.GetBody().SetAwake(true);\r\n    }\r\n\r\n    // Call the factory.\r\n    this.m_contactFactory.Destroy(c);\r\n    --this.m_contactCount;\r\n  }\r\n\r\n  // This is the top level collision call for the time step. Here\r\n  // all the narrow phase collision is processed for the world\r\n  // contact list.\r\n  public Collide(): void {\r\n    // Update awake contacts.\r\n    let c: b2Contact | null = this.m_contactList;\r\n    while (c) {\r\n      const fixtureA: b2Fixture = c.GetFixtureA();\r\n      const fixtureB: b2Fixture = c.GetFixtureB();\r\n      const indexA: number = c.GetChildIndexA();\r\n      const indexB: number = c.GetChildIndexB();\r\n      const bodyA: b2Body = fixtureA.GetBody();\r\n      const bodyB: b2Body = fixtureB.GetBody();\r\n\r\n      // Is this contact flagged for filtering?\r\n      if (c.m_filterFlag) {\r\n        // Check user filtering.\r\n        if (this.m_contactFilter && !this.m_contactFilter.ShouldCollide(fixtureA, fixtureB)) {\r\n          const cNuke: b2Contact = c;\r\n          c = cNuke.m_next;\r\n          this.Destroy(cNuke);\r\n          continue;\r\n        }\r\n\r\n        // Clear the filtering flag.\r\n        c.m_filterFlag = false;\r\n      }\r\n\r\n      const activeA: boolean = bodyA.IsAwake() && bodyA.m_type !== b2BodyType.b2_staticBody;\r\n      const activeB: boolean = bodyB.IsAwake() && bodyB.m_type !== b2BodyType.b2_staticBody;\r\n\r\n      // At least one body must be awake and it must be dynamic or kinematic.\r\n      if (!activeA && !activeB) {\r\n        c = c.m_next;\r\n        continue;\r\n      }\r\n\r\n      const treeNodeA: b2TreeNode<b2FixtureProxy> = fixtureA.m_proxies[indexA].treeNode;\r\n      const treeNodeB: b2TreeNode<b2FixtureProxy> = fixtureB.m_proxies[indexB].treeNode;\r\n      const overlap: boolean = b2TestOverlapAABB(treeNodeA.aabb, treeNodeB.aabb);\r\n\r\n      // Here we destroy contacts that cease to overlap in the broad-phase.\r\n      if (!overlap) {\r\n        const cNuke: b2Contact = c;\r\n        c = cNuke.m_next;\r\n        this.Destroy(cNuke);\r\n        continue;\r\n      }\r\n\r\n      // The contact persists.\r\n      c.Update(this.m_contactListener);\r\n      c = c.m_next;\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"9b56e7b40b7cbea8c9ac5076570724a7","cacheData":{"env":{}}}