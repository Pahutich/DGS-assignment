{"id":"../node_modules/box2d.package.ts/Dynamics/b2Body.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":22,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":23,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Collision/Shapes/b2Shape","loc":{"line":24,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"},{"name":"./b2Fixture","loc":{"line":25,"column":26},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Fixture.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\n// DEBUG: import { b2IsValid } from \"../Common/b2Math\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Shape_1 = require(\"../Collision/Shapes/b2Shape\");\r\nvar b2Fixture_1 = require(\"./b2Fixture\");\r\n// #endif\r\n/// The body type.\r\n/// static: zero mass, zero velocity, may be manually moved\r\n/// kinematic: zero mass, non-zero velocity set by user, moved by solver\r\n/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver\r\nvar b2BodyType;\r\n(function (b2BodyType) {\r\n    b2BodyType[b2BodyType[\"b2_unknown\"] = -1] = \"b2_unknown\";\r\n    b2BodyType[b2BodyType[\"b2_staticBody\"] = 0] = \"b2_staticBody\";\r\n    b2BodyType[b2BodyType[\"b2_kinematicBody\"] = 1] = \"b2_kinematicBody\";\r\n    b2BodyType[b2BodyType[\"b2_dynamicBody\"] = 2] = \"b2_dynamicBody\";\r\n    // TODO_ERIN\r\n    // b2_bulletBody = 3\r\n})(b2BodyType = exports.b2BodyType || (exports.b2BodyType = {}));\r\n/// A body definition holds all the data needed to construct a rigid body.\r\n/// You can safely re-use body definitions. Shapes are added to a body after construction.\r\nvar b2BodyDef = /** @class */ (function () {\r\n    function b2BodyDef() {\r\n        /// The body type: static, kinematic, or dynamic.\r\n        /// Note: if a dynamic body would have zero mass, the mass is set to one.\r\n        this.type = b2BodyType.b2_staticBody;\r\n        /// The world position of the body. Avoid creating bodies at the origin\r\n        /// since this can lead to many overlapping shapes.\r\n        this.position = new b2Math_1.b2Vec2(0, 0);\r\n        /// The world angle of the body in radians.\r\n        this.angle = 0;\r\n        /// The linear velocity of the body's origin in world co-ordinates.\r\n        this.linearVelocity = new b2Math_1.b2Vec2(0, 0);\r\n        /// The angular velocity of the body.\r\n        this.angularVelocity = 0;\r\n        /// Linear damping is use to reduce the linear velocity. The damping parameter\r\n        /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n        /// time step when the damping parameter is large.\r\n        this.linearDamping = 0;\r\n        /// Angular damping is use to reduce the angular velocity. The damping parameter\r\n        /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n        /// time step when the damping parameter is large.\r\n        this.angularDamping = 0;\r\n        /// Set this flag to false if this body should never fall asleep. Note that\r\n        /// this increases CPU usage.\r\n        this.allowSleep = true;\r\n        /// Is this body initially awake or sleeping?\r\n        this.awake = true;\r\n        /// Should this body be prevented from rotating? Useful for characters.\r\n        this.fixedRotation = false;\r\n        /// Is this a fast moving body that should be prevented from tunneling through\r\n        /// other moving bodies? Note that all bodies are prevented from tunneling through\r\n        /// kinematic and static bodies. This setting is only considered on dynamic bodies.\r\n        /// @warning You should use this flag sparingly since it increases processing time.\r\n        this.bullet = false;\r\n        /// Does this body start out active?\r\n        this.active = true;\r\n        /// Use this to store application specific body data.\r\n        this.userData = null;\r\n        /// Scale the gravity applied to this body.\r\n        this.gravityScale = 1;\r\n    }\r\n    return b2BodyDef;\r\n}());\r\nexports.b2BodyDef = b2BodyDef;\r\n/// A rigid body. These are created via b2World::CreateBody.\r\nvar b2Body = /** @class */ (function () {\r\n    // #endif\r\n    function b2Body(bd, world) {\r\n        this.m_type = b2BodyType.b2_staticBody;\r\n        this.m_islandFlag = false;\r\n        this.m_awakeFlag = false;\r\n        this.m_autoSleepFlag = false;\r\n        this.m_bulletFlag = false;\r\n        this.m_fixedRotationFlag = false;\r\n        this.m_activeFlag = false;\r\n        this.m_toiFlag = false;\r\n        this.m_islandIndex = 0;\r\n        this.m_xf = new b2Math_1.b2Transform(); // the body origin transform\r\n        // #if B2_ENABLE_PARTICLE\r\n        this.m_xf0 = new b2Math_1.b2Transform();\r\n        // #endif\r\n        this.m_sweep = new b2Math_1.b2Sweep(); // the swept motion for CCD\r\n        this.m_linearVelocity = new b2Math_1.b2Vec2();\r\n        this.m_angularVelocity = 0;\r\n        this.m_force = new b2Math_1.b2Vec2();\r\n        this.m_torque = 0;\r\n        this.m_prev = null;\r\n        this.m_next = null;\r\n        this.m_fixtureList = null;\r\n        this.m_fixtureCount = 0;\r\n        this.m_jointList = null;\r\n        this.m_contactList = null;\r\n        this.m_mass = 1;\r\n        this.m_invMass = 1;\r\n        // Rotational inertia about the center of mass.\r\n        this.m_I = 0;\r\n        this.m_invI = 0;\r\n        this.m_linearDamping = 0;\r\n        this.m_angularDamping = 0;\r\n        this.m_gravityScale = 1;\r\n        this.m_sleepTime = 0;\r\n        this.m_userData = null;\r\n        // #if B2_ENABLE_CONTROLLER\r\n        this.m_controllerList = null;\r\n        this.m_controllerCount = 0;\r\n        this.m_bulletFlag = b2Settings_1.b2Maybe(bd.bullet, false);\r\n        this.m_fixedRotationFlag = b2Settings_1.b2Maybe(bd.fixedRotation, false);\r\n        this.m_autoSleepFlag = b2Settings_1.b2Maybe(bd.allowSleep, true);\r\n        this.m_awakeFlag = b2Settings_1.b2Maybe(bd.awake, true);\r\n        this.m_activeFlag = b2Settings_1.b2Maybe(bd.active, true);\r\n        this.m_world = world;\r\n        this.m_xf.p.Copy(b2Settings_1.b2Maybe(bd.position, b2Math_1.b2Vec2.ZERO));\r\n        // DEBUG: b2Assert(this.m_xf.p.IsValid());\r\n        this.m_xf.q.SetAngle(b2Settings_1.b2Maybe(bd.angle, 0));\r\n        // DEBUG: b2Assert(b2IsValid(this.m_xf.q.GetAngle()));\r\n        // #if B2_ENABLE_PARTICLE\r\n        this.m_xf0.Copy(this.m_xf);\r\n        // #endif\r\n        this.m_sweep.localCenter.SetZero();\r\n        this.m_sweep.c0.Copy(this.m_xf.p);\r\n        this.m_sweep.c.Copy(this.m_xf.p);\r\n        this.m_sweep.a0 = this.m_sweep.a = this.m_xf.q.GetAngle();\r\n        this.m_sweep.alpha0 = 0;\r\n        this.m_linearVelocity.Copy(b2Settings_1.b2Maybe(bd.linearVelocity, b2Math_1.b2Vec2.ZERO));\r\n        // DEBUG: b2Assert(this.m_linearVelocity.IsValid());\r\n        this.m_angularVelocity = b2Settings_1.b2Maybe(bd.angularVelocity, 0);\r\n        // DEBUG: b2Assert(b2IsValid(this.m_angularVelocity));\r\n        this.m_linearDamping = b2Settings_1.b2Maybe(bd.linearDamping, 0);\r\n        this.m_angularDamping = b2Settings_1.b2Maybe(bd.angularDamping, 0);\r\n        this.m_gravityScale = b2Settings_1.b2Maybe(bd.gravityScale, 1);\r\n        // DEBUG: b2Assert(b2IsValid(this.m_gravityScale) && this.m_gravityScale >= 0);\r\n        // DEBUG: b2Assert(b2IsValid(this.m_angularDamping) && this.m_angularDamping >= 0);\r\n        // DEBUG: b2Assert(b2IsValid(this.m_linearDamping) && this.m_linearDamping >= 0);\r\n        this.m_force.SetZero();\r\n        this.m_torque = 0;\r\n        this.m_sleepTime = 0;\r\n        this.m_type = b2Settings_1.b2Maybe(bd.type, b2BodyType.b2_staticBody);\r\n        if (bd.type === b2BodyType.b2_dynamicBody) {\r\n            this.m_mass = 1;\r\n            this.m_invMass = 1;\r\n        }\r\n        else {\r\n            this.m_mass = 0;\r\n            this.m_invMass = 0;\r\n        }\r\n        this.m_I = 0;\r\n        this.m_invI = 0;\r\n        this.m_userData = bd.userData;\r\n        this.m_fixtureList = null;\r\n        this.m_fixtureCount = 0;\r\n        // #if B2_ENABLE_CONTROLLER\r\n        this.m_controllerList = null;\r\n        this.m_controllerCount = 0;\r\n        // #endif\r\n    }\r\n    b2Body.prototype.CreateFixture = function (a, b) {\r\n        if (b === void 0) { b = 0; }\r\n        if (a instanceof b2Shape_1.b2Shape) {\r\n            return this.CreateFixtureShapeDensity(a, b);\r\n        }\r\n        else {\r\n            return this.CreateFixtureDef(a);\r\n        }\r\n    };\r\n    /// Creates a fixture and attach it to this body. Use this function if you need\r\n    /// to set some fixture parameters, like friction. Otherwise you can create the\r\n    /// fixture directly from a shape.\r\n    /// If the density is non-zero, this function automatically updates the mass of the body.\r\n    /// Contacts are not created until the next time step.\r\n    /// @param def the fixture definition.\r\n    /// @warning This function is locked during callbacks.\r\n    b2Body.prototype.CreateFixtureDef = function (def) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        var fixture = new b2Fixture_1.b2Fixture(this, def);\r\n        if (this.m_activeFlag) {\r\n            fixture.CreateProxies();\r\n        }\r\n        fixture.m_next = this.m_fixtureList;\r\n        this.m_fixtureList = fixture;\r\n        ++this.m_fixtureCount;\r\n        // fixture.m_body = this;\r\n        // Adjust mass properties if needed.\r\n        if (fixture.m_density > 0) {\r\n            this.ResetMassData();\r\n        }\r\n        // Let the world know we have a new fixture. This will cause new contacts\r\n        // to be created at the beginning of the next time step.\r\n        this.m_world.m_newFixture = true;\r\n        return fixture;\r\n    };\r\n    b2Body.prototype.CreateFixtureShapeDensity = function (shape, density) {\r\n        if (density === void 0) { density = 0; }\r\n        var def = b2Body.CreateFixtureShapeDensity_s_def;\r\n        def.shape = shape;\r\n        def.density = density;\r\n        return this.CreateFixtureDef(def);\r\n    };\r\n    /// Destroy a fixture. This removes the fixture from the broad-phase and\r\n    /// destroys all contacts associated with this fixture. This will\r\n    /// automatically adjust the mass of the body if the body is dynamic and the\r\n    /// fixture has positive density.\r\n    /// All fixtures attached to a body are implicitly destroyed when the body is destroyed.\r\n    /// @param fixture the fixture to be removed.\r\n    /// @warning This function is locked during callbacks.\r\n    b2Body.prototype.DestroyFixture = function (fixture) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        // DEBUG: b2Assert(fixture.m_body === this);\r\n        // Remove the fixture from this body's singly linked list.\r\n        // DEBUG: b2Assert(this.m_fixtureCount > 0);\r\n        var node = this.m_fixtureList;\r\n        var ppF = null;\r\n        // DEBUG: let found: boolean = false;\r\n        while (node !== null) {\r\n            if (node === fixture) {\r\n                if (ppF) {\r\n                    ppF.m_next = fixture.m_next;\r\n                }\r\n                else {\r\n                    this.m_fixtureList = fixture.m_next;\r\n                }\r\n                // DEBUG: found = true;\r\n                break;\r\n            }\r\n            ppF = node;\r\n            node = node.m_next;\r\n        }\r\n        // You tried to remove a shape that is not attached to this body.\r\n        // DEBUG: b2Assert(found);\r\n        // Destroy any contacts associated with the fixture.\r\n        var edge = this.m_contactList;\r\n        while (edge) {\r\n            var c = edge.contact;\r\n            edge = edge.next;\r\n            var fixtureA = c.GetFixtureA();\r\n            var fixtureB = c.GetFixtureB();\r\n            if (fixture === fixtureA || fixture === fixtureB) {\r\n                // This destroys the contact and removes it from\r\n                // this body's contact list.\r\n                this.m_world.m_contactManager.Destroy(c);\r\n            }\r\n        }\r\n        if (this.m_activeFlag) {\r\n            fixture.DestroyProxies();\r\n        }\r\n        // fixture.m_body = null;\r\n        fixture.m_next = null;\r\n        fixture.Reset();\r\n        --this.m_fixtureCount;\r\n        // Reset the mass data.\r\n        this.ResetMassData();\r\n    };\r\n    /// Set the position of the body's origin and rotation.\r\n    /// This breaks any contacts and wakes the other bodies.\r\n    /// Manipulating a body's transform may cause non-physical behavior.\r\n    /// @param position the world position of the body's local origin.\r\n    /// @param angle the world rotation in radians.\r\n    b2Body.prototype.SetTransformVec = function (position, angle) {\r\n        this.SetTransformXY(position.x, position.y, angle);\r\n    };\r\n    b2Body.prototype.SetTransformXY = function (x, y, angle) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        this.m_xf.q.SetAngle(angle);\r\n        this.m_xf.p.Set(x, y);\r\n        // #if B2_ENABLE_PARTICLE\r\n        this.m_xf0.Copy(this.m_xf);\r\n        // #endif\r\n        b2Math_1.b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n        this.m_sweep.a = angle;\r\n        this.m_sweep.c0.Copy(this.m_sweep.c);\r\n        this.m_sweep.a0 = angle;\r\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n            f.SynchronizeProxies(this.m_xf, this.m_xf, b2Math_1.b2Vec2.ZERO);\r\n        }\r\n        this.m_world.m_contactManager.FindNewContacts();\r\n    };\r\n    b2Body.prototype.SetTransform = function (xf) {\r\n        this.SetTransformVec(xf.p, xf.GetAngle());\r\n    };\r\n    b2Body.prototype.SetTransformWithAngle = function (xf, angle) {\r\n        this.SetTransformVec(xf.p, angle);\r\n    };\r\n    /// Get the body transform for the body's origin.\r\n    /// @return the world transform of the body's origin.\r\n    b2Body.prototype.GetTransform = function () {\r\n        return this.m_xf;\r\n    };\r\n    /// Get the world body origin position.\r\n    /// @return the world position of the body's origin.\r\n    b2Body.prototype.GetPosition = function () {\r\n        return this.m_xf.p;\r\n    };\r\n    b2Body.prototype.SetPosition = function (position) {\r\n        this.SetTransformVec(position, this.GetAngle());\r\n    };\r\n    b2Body.prototype.SetPositionXY = function (x, y) {\r\n        this.SetTransformXY(x, y, this.GetAngle());\r\n    };\r\n    /// Get the angle in radians.\r\n    /// @return the current world rotation angle in radians.\r\n    b2Body.prototype.GetAngle = function () {\r\n        return this.m_sweep.a;\r\n    };\r\n    b2Body.prototype.SetAngle = function (angle) {\r\n        this.SetTransformVec(this.GetPosition(), angle);\r\n    };\r\n    /// Get the world position of the center of mass.\r\n    b2Body.prototype.GetWorldCenter = function () {\r\n        return this.m_sweep.c;\r\n    };\r\n    /// Get the local position of the center of mass.\r\n    b2Body.prototype.GetLocalCenter = function () {\r\n        return this.m_sweep.localCenter;\r\n    };\r\n    /// Set the linear velocity of the center of mass.\r\n    /// @param v the new linear velocity of the center of mass.\r\n    b2Body.prototype.SetLinearVelocity = function (v) {\r\n        if (this.m_type === b2BodyType.b2_staticBody) {\r\n            return;\r\n        }\r\n        if (b2Math_1.b2Vec2.DotVV(v, v) > 0) {\r\n            this.SetAwake(true);\r\n        }\r\n        this.m_linearVelocity.Copy(v);\r\n    };\r\n    /// Get the linear velocity of the center of mass.\r\n    /// @return the linear velocity of the center of mass.\r\n    b2Body.prototype.GetLinearVelocity = function () {\r\n        return this.m_linearVelocity;\r\n    };\r\n    /// Set the angular velocity.\r\n    /// @param omega the new angular velocity in radians/second.\r\n    b2Body.prototype.SetAngularVelocity = function (w) {\r\n        if (this.m_type === b2BodyType.b2_staticBody) {\r\n            return;\r\n        }\r\n        if (w * w > 0) {\r\n            this.SetAwake(true);\r\n        }\r\n        this.m_angularVelocity = w;\r\n    };\r\n    /// Get the angular velocity.\r\n    /// @return the angular velocity in radians/second.\r\n    b2Body.prototype.GetAngularVelocity = function () {\r\n        return this.m_angularVelocity;\r\n    };\r\n    b2Body.prototype.GetDefinition = function (bd) {\r\n        bd.type = this.GetType();\r\n        bd.allowSleep = this.m_autoSleepFlag;\r\n        bd.angle = this.GetAngle();\r\n        bd.angularDamping = this.m_angularDamping;\r\n        bd.gravityScale = this.m_gravityScale;\r\n        bd.angularVelocity = this.m_angularVelocity;\r\n        bd.fixedRotation = this.m_fixedRotationFlag;\r\n        bd.bullet = this.m_bulletFlag;\r\n        bd.awake = this.m_awakeFlag;\r\n        bd.linearDamping = this.m_linearDamping;\r\n        bd.linearVelocity.Copy(this.GetLinearVelocity());\r\n        bd.position.Copy(this.GetPosition());\r\n        bd.userData = this.GetUserData();\r\n        return bd;\r\n    };\r\n    /// Apply a force at a world point. If the force is not\r\n    /// applied at the center of mass, it will generate a torque and\r\n    /// affect the angular velocity. This wakes up the body.\r\n    /// @param force the world force vector, usually in Newtons (N).\r\n    /// @param point the world position of the point of application.\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyForce = function (force, point, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_force.x += force.x;\r\n            this.m_force.y += force.y;\r\n            this.m_torque +=\r\n                (point.x - this.m_sweep.c.x) * force.y -\r\n                    (point.y - this.m_sweep.c.y) * force.x;\r\n        }\r\n    };\r\n    /// Apply a force to the center of mass. This wakes up the body.\r\n    /// @param force the world force vector, usually in Newtons (N).\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyForceToCenter = function (force, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_force.x += force.x;\r\n            this.m_force.y += force.y;\r\n        }\r\n    };\r\n    /// Apply a torque. This affects the angular velocity\r\n    /// without affecting the linear velocity of the center of mass.\r\n    /// @param torque about the z-axis (out of the screen), usually in N-m.\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyTorque = function (torque, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_torque += torque;\r\n        }\r\n    };\r\n    /// Apply an impulse at a point. This immediately modifies the velocity.\r\n    /// It also modifies the angular velocity if the point of application\r\n    /// is not at the center of mass. This wakes up the body.\r\n    /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n    /// @param point the world position of the point of application.\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyLinearImpulse = function (impulse, point, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_linearVelocity.x += this.m_invMass * impulse.x;\r\n            this.m_linearVelocity.y += this.m_invMass * impulse.y;\r\n            this.m_angularVelocity +=\r\n                this.m_invI *\r\n                    ((point.x - this.m_sweep.c.x) * impulse.y -\r\n                        (point.y - this.m_sweep.c.y) * impulse.x);\r\n        }\r\n    };\r\n    /// Apply an impulse at the center of gravity. This immediately modifies the velocity.\r\n    /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyLinearImpulseToCenter = function (impulse, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_linearVelocity.x += this.m_invMass * impulse.x;\r\n            this.m_linearVelocity.y += this.m_invMass * impulse.y;\r\n        }\r\n    };\r\n    /// Apply an angular impulse.\r\n    /// @param impulse the angular impulse in units of kg*m*m/s\r\n    /// @param wake also wake up the body\r\n    b2Body.prototype.ApplyAngularImpulse = function (impulse, wake) {\r\n        if (wake === void 0) { wake = true; }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        if (wake && !this.m_awakeFlag) {\r\n            this.SetAwake(true);\r\n        }\r\n        // Don't accumulate a force if the body is sleeping.\r\n        if (this.m_awakeFlag) {\r\n            this.m_angularVelocity += this.m_invI * impulse;\r\n        }\r\n    };\r\n    /// Get the total mass of the body.\r\n    /// @return the mass, usually in kilograms (kg).\r\n    b2Body.prototype.GetMass = function () {\r\n        return this.m_mass;\r\n    };\r\n    /// Get the rotational inertia of the body about the local origin.\r\n    /// @return the rotational inertia, usually in kg-m^2.\r\n    b2Body.prototype.GetInertia = function () {\r\n        return (this.m_I +\r\n            this.m_mass *\r\n                b2Math_1.b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter));\r\n    };\r\n    /// Get the mass data of the body.\r\n    /// @return a struct containing the mass, inertia and center of the body.\r\n    b2Body.prototype.GetMassData = function (data) {\r\n        data.mass = this.m_mass;\r\n        data.I =\r\n            this.m_I +\r\n                this.m_mass *\r\n                    b2Math_1.b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);\r\n        data.center.Copy(this.m_sweep.localCenter);\r\n        return data;\r\n    };\r\n    b2Body.prototype.SetMassData = function (massData) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n            return;\r\n        }\r\n        this.m_invMass = 0;\r\n        this.m_I = 0;\r\n        this.m_invI = 0;\r\n        this.m_mass = massData.mass;\r\n        if (this.m_mass <= 0) {\r\n            this.m_mass = 1;\r\n        }\r\n        this.m_invMass = 1 / this.m_mass;\r\n        if (massData.I > 0 && !this.m_fixedRotationFlag) {\r\n            this.m_I =\r\n                massData.I -\r\n                    this.m_mass * b2Math_1.b2Vec2.DotVV(massData.center, massData.center);\r\n            // DEBUG: b2Assert(this.m_I > 0);\r\n            this.m_invI = 1 / this.m_I;\r\n        }\r\n        // Move center of mass.\r\n        var oldCenter = b2Body.SetMassData_s_oldCenter.Copy(this.m_sweep.c);\r\n        this.m_sweep.localCenter.Copy(massData.center);\r\n        b2Math_1.b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n        this.m_sweep.c0.Copy(this.m_sweep.c);\r\n        // Update center of mass velocity.\r\n        b2Math_1.b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Math_1.b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Math_1.b2Vec2.s_t0), this.m_linearVelocity);\r\n    };\r\n    b2Body.prototype.ResetMassData = function () {\r\n        // Compute mass data from shapes. Each shape has its own density.\r\n        this.m_mass = 0;\r\n        this.m_invMass = 0;\r\n        this.m_I = 0;\r\n        this.m_invI = 0;\r\n        this.m_sweep.localCenter.SetZero();\r\n        // Static and kinematic bodies have zero mass.\r\n        if (this.m_type === b2BodyType.b2_staticBody ||\r\n            this.m_type === b2BodyType.b2_kinematicBody) {\r\n            this.m_sweep.c0.Copy(this.m_xf.p);\r\n            this.m_sweep.c.Copy(this.m_xf.p);\r\n            this.m_sweep.a0 = this.m_sweep.a;\r\n            return;\r\n        }\r\n        // DEBUG: b2Assert(this.m_type === b2BodyType.b2_dynamicBody);\r\n        // Accumulate mass over all fixtures.\r\n        var localCenter = b2Body.ResetMassData_s_localCenter.SetZero();\r\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n            if (f.m_density === 0) {\r\n                continue;\r\n            }\r\n            var massData = f.GetMassData(b2Body.ResetMassData_s_massData);\r\n            this.m_mass += massData.mass;\r\n            localCenter.x += massData.center.x * massData.mass;\r\n            localCenter.y += massData.center.y * massData.mass;\r\n            this.m_I += massData.I;\r\n        }\r\n        // Compute center of mass.\r\n        if (this.m_mass > 0) {\r\n            this.m_invMass = 1 / this.m_mass;\r\n            localCenter.x *= this.m_invMass;\r\n            localCenter.y *= this.m_invMass;\r\n        }\r\n        else {\r\n            // Force all dynamic bodies to have a positive mass.\r\n            this.m_mass = 1;\r\n            this.m_invMass = 1;\r\n        }\r\n        if (this.m_I > 0 && !this.m_fixedRotationFlag) {\r\n            // Center the inertia about the center of mass.\r\n            this.m_I -= this.m_mass * b2Math_1.b2Vec2.DotVV(localCenter, localCenter);\r\n            // DEBUG: b2Assert(this.m_I > 0);\r\n            this.m_invI = 1 / this.m_I;\r\n        }\r\n        else {\r\n            this.m_I = 0;\r\n            this.m_invI = 0;\r\n        }\r\n        // Move center of mass.\r\n        var oldCenter = b2Body.ResetMassData_s_oldCenter.Copy(this.m_sweep.c);\r\n        this.m_sweep.localCenter.Copy(localCenter);\r\n        b2Math_1.b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n        this.m_sweep.c0.Copy(this.m_sweep.c);\r\n        // Update center of mass velocity.\r\n        b2Math_1.b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Math_1.b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Math_1.b2Vec2.s_t0), this.m_linearVelocity);\r\n    };\r\n    /// Get the world coordinates of a point given the local coordinates.\r\n    /// @param localPoint a point on the body measured relative the the body's origin.\r\n    /// @return the same point expressed in world coordinates.\r\n    b2Body.prototype.GetWorldPoint = function (localPoint, out) {\r\n        return b2Math_1.b2Transform.MulXV(this.m_xf, localPoint, out);\r\n    };\r\n    /// Get the world coordinates of a vector given the local coordinates.\r\n    /// @param localVector a vector fixed in the body.\r\n    /// @return the same vector expressed in world coordinates.\r\n    b2Body.prototype.GetWorldVector = function (localVector, out) {\r\n        return b2Math_1.b2Rot.MulRV(this.m_xf.q, localVector, out);\r\n    };\r\n    /// Gets a local point relative to the body's origin given a world point.\r\n    /// @param a point in world coordinates.\r\n    /// @return the corresponding local point relative to the body's origin.\r\n    b2Body.prototype.GetLocalPoint = function (worldPoint, out) {\r\n        return b2Math_1.b2Transform.MulTXV(this.m_xf, worldPoint, out);\r\n    };\r\n    /// Gets a local vector given a world vector.\r\n    /// @param a vector in world coordinates.\r\n    /// @return the corresponding local vector.\r\n    b2Body.prototype.GetLocalVector = function (worldVector, out) {\r\n        return b2Math_1.b2Rot.MulTRV(this.m_xf.q, worldVector, out);\r\n    };\r\n    /// Get the world linear velocity of a world point attached to this body.\r\n    /// @param a point in world coordinates.\r\n    /// @return the world velocity of a point.\r\n    b2Body.prototype.GetLinearVelocityFromWorldPoint = function (worldPoint, out) {\r\n        return b2Math_1.b2Vec2.AddVCrossSV(this.m_linearVelocity, this.m_angularVelocity, b2Math_1.b2Vec2.SubVV(worldPoint, this.m_sweep.c, b2Math_1.b2Vec2.s_t0), out);\r\n    };\r\n    /// Get the world velocity of a local point.\r\n    /// @param a point in local coordinates.\r\n    /// @return the world velocity of a point.\r\n    b2Body.prototype.GetLinearVelocityFromLocalPoint = function (localPoint, out) {\r\n        return this.GetLinearVelocityFromWorldPoint(this.GetWorldPoint(localPoint, out), out);\r\n    };\r\n    /// Get the linear damping of the body.\r\n    b2Body.prototype.GetLinearDamping = function () {\r\n        return this.m_linearDamping;\r\n    };\r\n    /// Set the linear damping of the body.\r\n    b2Body.prototype.SetLinearDamping = function (linearDamping) {\r\n        this.m_linearDamping = linearDamping;\r\n    };\r\n    /// Get the angular damping of the body.\r\n    b2Body.prototype.GetAngularDamping = function () {\r\n        return this.m_angularDamping;\r\n    };\r\n    /// Set the angular damping of the body.\r\n    b2Body.prototype.SetAngularDamping = function (angularDamping) {\r\n        this.m_angularDamping = angularDamping;\r\n    };\r\n    /// Get the gravity scale of the body.\r\n    b2Body.prototype.GetGravityScale = function () {\r\n        return this.m_gravityScale;\r\n    };\r\n    /// Set the gravity scale of the body.\r\n    b2Body.prototype.SetGravityScale = function (scale) {\r\n        this.m_gravityScale = scale;\r\n    };\r\n    /// Set the type of this body. This may alter the mass and velocity.\r\n    b2Body.prototype.SetType = function (type) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        if (this.m_type === type) {\r\n            return;\r\n        }\r\n        this.m_type = type;\r\n        this.ResetMassData();\r\n        if (this.m_type === b2BodyType.b2_staticBody) {\r\n            this.m_linearVelocity.SetZero();\r\n            this.m_angularVelocity = 0;\r\n            this.m_sweep.a0 = this.m_sweep.a;\r\n            this.m_sweep.c0.Copy(this.m_sweep.c);\r\n            this.SynchronizeFixtures();\r\n        }\r\n        this.SetAwake(true);\r\n        this.m_force.SetZero();\r\n        this.m_torque = 0;\r\n        // Delete the attached contacts.\r\n        var ce = this.m_contactList;\r\n        while (ce) {\r\n            var ce0 = ce;\r\n            ce = ce.next;\r\n            this.m_world.m_contactManager.Destroy(ce0.contact);\r\n        }\r\n        this.m_contactList = null;\r\n        // Touch the proxies so that new contacts will be created (when appropriate)\r\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n            f.TouchProxies();\r\n        }\r\n    };\r\n    /// Get the type of this body.\r\n    b2Body.prototype.GetType = function () {\r\n        return this.m_type;\r\n    };\r\n    /// Should this body be treated like a bullet for continuous collision detection?\r\n    b2Body.prototype.SetBullet = function (flag) {\r\n        this.m_bulletFlag = flag;\r\n    };\r\n    /// Is this body treated like a bullet for continuous collision detection?\r\n    b2Body.prototype.IsBullet = function () {\r\n        return this.m_bulletFlag;\r\n    };\r\n    /// You can disable sleeping on this body. If you disable sleeping, the\r\n    /// body will be woken.\r\n    b2Body.prototype.SetSleepingAllowed = function (flag) {\r\n        this.m_autoSleepFlag = flag;\r\n        if (!flag) {\r\n            this.SetAwake(true);\r\n        }\r\n    };\r\n    /// Is this body allowed to sleep\r\n    b2Body.prototype.IsSleepingAllowed = function () {\r\n        return this.m_autoSleepFlag;\r\n    };\r\n    /// Set the sleep state of the body. A sleeping body has very\r\n    /// low CPU cost.\r\n    /// @param flag set to true to wake the body, false to put it to sleep.\r\n    b2Body.prototype.SetAwake = function (flag) {\r\n        if (flag) {\r\n            this.m_awakeFlag = true;\r\n            this.m_sleepTime = 0;\r\n        }\r\n        else {\r\n            this.m_awakeFlag = false;\r\n            this.m_sleepTime = 0;\r\n            this.m_linearVelocity.SetZero();\r\n            this.m_angularVelocity = 0;\r\n            this.m_force.SetZero();\r\n            this.m_torque = 0;\r\n        }\r\n    };\r\n    /// Get the sleeping state of this body.\r\n    /// @return true if the body is sleeping.\r\n    b2Body.prototype.IsAwake = function () {\r\n        return this.m_awakeFlag;\r\n    };\r\n    /// Set the active state of the body. An inactive body is not\r\n    /// simulated and cannot be collided with or woken up.\r\n    /// If you pass a flag of true, all fixtures will be added to the\r\n    /// broad-phase.\r\n    /// If you pass a flag of false, all fixtures will be removed from\r\n    /// the broad-phase and all contacts will be destroyed.\r\n    /// Fixtures and joints are otherwise unaffected. You may continue\r\n    /// to create/destroy fixtures and joints on inactive bodies.\r\n    /// Fixtures on an inactive body are implicitly inactive and will\r\n    /// not participate in collisions, ray-casts, or queries.\r\n    /// Joints connected to an inactive body are implicitly inactive.\r\n    /// An inactive body is still owned by a b2World object and remains\r\n    /// in the body list.\r\n    b2Body.prototype.SetActive = function (flag) {\r\n        if (this.m_world.IsLocked()) {\r\n            throw new Error();\r\n        }\r\n        if (flag === this.IsActive()) {\r\n            return;\r\n        }\r\n        this.m_activeFlag = flag;\r\n        if (flag) {\r\n            // Create all proxies.\r\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n                f.CreateProxies();\r\n            }\r\n            // Contacts are created the next time step.\r\n        }\r\n        else {\r\n            // Destroy all proxies.\r\n            for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n                f.DestroyProxies();\r\n            }\r\n            // Destroy the attached contacts.\r\n            var ce = this.m_contactList;\r\n            while (ce) {\r\n                var ce0 = ce;\r\n                ce = ce.next;\r\n                this.m_world.m_contactManager.Destroy(ce0.contact);\r\n            }\r\n            this.m_contactList = null;\r\n        }\r\n    };\r\n    /// Get the active state of the body.\r\n    b2Body.prototype.IsActive = function () {\r\n        return this.m_activeFlag;\r\n    };\r\n    /// Set this body to have fixed rotation. This causes the mass\r\n    /// to be reset.\r\n    b2Body.prototype.SetFixedRotation = function (flag) {\r\n        if (this.m_fixedRotationFlag === flag) {\r\n            return;\r\n        }\r\n        this.m_fixedRotationFlag = flag;\r\n        this.m_angularVelocity = 0;\r\n        this.ResetMassData();\r\n    };\r\n    /// Does this body have fixed rotation?\r\n    b2Body.prototype.IsFixedRotation = function () {\r\n        return this.m_fixedRotationFlag;\r\n    };\r\n    /// Get the list of all fixtures attached to this body.\r\n    b2Body.prototype.GetFixtureList = function () {\r\n        return this.m_fixtureList;\r\n    };\r\n    /// Get the list of all joints attached to this body.\r\n    b2Body.prototype.GetJointList = function () {\r\n        return this.m_jointList;\r\n    };\r\n    /// Get the list of all contacts attached to this body.\r\n    /// @warning this list changes during the time step and you may\r\n    /// miss some collisions if you don't use b2ContactListener.\r\n    b2Body.prototype.GetContactList = function () {\r\n        return this.m_contactList;\r\n    };\r\n    /// Get the next body in the world's body list.\r\n    b2Body.prototype.GetNext = function () {\r\n        return this.m_next;\r\n    };\r\n    /// Get the user data pointer that was provided in the body definition.\r\n    b2Body.prototype.GetUserData = function () {\r\n        return this.m_userData;\r\n    };\r\n    /// Set the user data. Use this to store your application specific data.\r\n    b2Body.prototype.SetUserData = function (data) {\r\n        this.m_userData = data;\r\n    };\r\n    /// Get the parent world of this body.\r\n    b2Body.prototype.GetWorld = function () {\r\n        return this.m_world;\r\n    };\r\n    /// Dump this body to a log file\r\n    b2Body.prototype.Dump = function (log) {\r\n        var bodyIndex = this.m_islandIndex;\r\n        log(\"{\\n\");\r\n        log(\"  const bd: b2BodyDef = new b2BodyDef();\\n\");\r\n        var type_str = \"\";\r\n        switch (this.m_type) {\r\n            case b2BodyType.b2_staticBody:\r\n                type_str = \"b2BodyType.b2_staticBody\";\r\n                break;\r\n            case b2BodyType.b2_kinematicBody:\r\n                type_str = \"b2BodyType.b2_kinematicBody\";\r\n                break;\r\n            case b2BodyType.b2_dynamicBody:\r\n                type_str = \"b2BodyType.b2_dynamicBody\";\r\n                break;\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                break;\r\n        }\r\n        log(\"  bd.type = %s;\\n\", type_str);\r\n        log(\"  bd.position.Set(%.15f, %.15f);\\n\", this.m_xf.p.x, this.m_xf.p.y);\r\n        log(\"  bd.angle = %.15f;\\n\", this.m_sweep.a);\r\n        log(\"  bd.linearVelocity.Set(%.15f, %.15f);\\n\", this.m_linearVelocity.x, this.m_linearVelocity.y);\r\n        log(\"  bd.angularVelocity = %.15f;\\n\", this.m_angularVelocity);\r\n        log(\"  bd.linearDamping = %.15f;\\n\", this.m_linearDamping);\r\n        log(\"  bd.angularDamping = %.15f;\\n\", this.m_angularDamping);\r\n        log(\"  bd.allowSleep = %s;\\n\", this.m_autoSleepFlag ? \"true\" : \"false\");\r\n        log(\"  bd.awake = %s;\\n\", this.m_awakeFlag ? \"true\" : \"false\");\r\n        log(\"  bd.fixedRotation = %s;\\n\", this.m_fixedRotationFlag ? \"true\" : \"false\");\r\n        log(\"  bd.bullet = %s;\\n\", this.m_bulletFlag ? \"true\" : \"false\");\r\n        log(\"  bd.active = %s;\\n\", this.m_activeFlag ? \"true\" : \"false\");\r\n        log(\"  bd.gravityScale = %.15f;\\n\", this.m_gravityScale);\r\n        log(\"\\n\");\r\n        log(\"  bodies[%d] = this.m_world.CreateBody(bd);\\n\", this.m_islandIndex);\r\n        log(\"\\n\");\r\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n            log(\"  {\\n\");\r\n            f.Dump(log, bodyIndex);\r\n            log(\"  }\\n\");\r\n        }\r\n        log(\"}\\n\");\r\n    };\r\n    b2Body.prototype.SynchronizeFixtures = function () {\r\n        var xf1 = b2Body.SynchronizeFixtures_s_xf1;\r\n        xf1.q.SetAngle(this.m_sweep.a0);\r\n        b2Math_1.b2Rot.MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);\r\n        b2Math_1.b2Vec2.SubVV(this.m_sweep.c0, xf1.p, xf1.p);\r\n        // const displacement: b2Vec2 = b2Vec2.SubVV(this.m_xf.p, xf1.p, b2Body.SynchronizeFixtures_s_displacement);\r\n        var displacement = b2Math_1.b2Vec2.SubVV(this.m_sweep.c, this.m_sweep.c0, b2Body.SynchronizeFixtures_s_displacement);\r\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\r\n            f.SynchronizeProxies(xf1, this.m_xf, displacement);\r\n        }\r\n    };\r\n    b2Body.prototype.SynchronizeTransform = function () {\r\n        this.m_xf.q.SetAngle(this.m_sweep.a);\r\n        b2Math_1.b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n        b2Math_1.b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n    };\r\n    // This is used to prevent connected bodies from colliding.\r\n    // It may lie, depending on the collideConnected flag.\r\n    b2Body.prototype.ShouldCollide = function (other) {\r\n        // At least one body should be dynamic or kinematic.\r\n        if (this.m_type === b2BodyType.b2_staticBody &&\r\n            other.m_type === b2BodyType.b2_staticBody) {\r\n            return false;\r\n        }\r\n        return this.ShouldCollideConnected(other);\r\n    };\r\n    b2Body.prototype.ShouldCollideConnected = function (other) {\r\n        // Does a joint prevent collision?\r\n        for (var jn = this.m_jointList; jn; jn = jn.next) {\r\n            if (jn.other === other) {\r\n                if (!jn.joint.m_collideConnected) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n    b2Body.prototype.Advance = function (alpha) {\r\n        // Advance to the new safe time. This doesn't sync the broad-phase.\r\n        this.m_sweep.Advance(alpha);\r\n        this.m_sweep.c.Copy(this.m_sweep.c0);\r\n        this.m_sweep.a = this.m_sweep.a0;\r\n        this.m_xf.q.SetAngle(this.m_sweep.a);\r\n        b2Math_1.b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n        b2Math_1.b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n    };\r\n    // #if B2_ENABLE_CONTROLLER\r\n    b2Body.prototype.GetControllerList = function () {\r\n        return this.m_controllerList;\r\n    };\r\n    b2Body.prototype.GetControllerCount = function () {\r\n        return this.m_controllerCount;\r\n    };\r\n    /// Creates a fixture from a shape and attach it to this body.\r\n    /// This is a convenience function. Use b2FixtureDef if you need to set parameters\r\n    /// like friction, restitution, user data, or filtering.\r\n    /// If the density is non-zero, this function automatically updates the mass of the body.\r\n    /// @param shape the shape to be cloned.\r\n    /// @param density the shape density (set to zero for static bodies).\r\n    /// @warning This function is locked during callbacks.\r\n    b2Body.CreateFixtureShapeDensity_s_def = new b2Fixture_1.b2FixtureDef();\r\n    /// Set the mass properties to override the mass properties of the fixtures.\r\n    /// Note that this changes the center of mass position.\r\n    /// Note that creating or destroying fixtures can also alter the mass.\r\n    /// This function has no effect if the body isn't dynamic.\r\n    /// @param massData the mass properties.\r\n    b2Body.SetMassData_s_oldCenter = new b2Math_1.b2Vec2();\r\n    /// This resets the mass properties to the sum of the mass properties of the fixtures.\r\n    /// This normally does not need to be called unless you called SetMassData to override\r\n    /// the mass and you later want to reset the mass.\r\n    b2Body.ResetMassData_s_localCenter = new b2Math_1.b2Vec2();\r\n    b2Body.ResetMassData_s_oldCenter = new b2Math_1.b2Vec2();\r\n    b2Body.ResetMassData_s_massData = new b2Shape_1.b2MassData();\r\n    b2Body.SynchronizeFixtures_s_xf1 = new b2Math_1.b2Transform();\r\n    b2Body.SynchronizeFixtures_s_displacement = new b2Math_1.b2Vec2();\r\n    return b2Body;\r\n}());\r\nexports.b2Body = b2Body;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Body.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2Body.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;GAgBG;;AAEH,0DAA0D;AAC1D,uDAAuD;AACvD,mDAA+C;AAC/C,2CAA2E;AAC3E,uDAAkE;AAGlE,yCAAqE;AAIrE,SAAS;AAET,kBAAkB;AAClB,2DAA2D;AAC3D,wEAAwE;AACxE,mFAAmF;AACnF,IAAY,UAQX;AARD,WAAY,UAAU;IACpB,wDAAe,CAAA;IACf,6DAAiB,CAAA;IACjB,mEAAoB,CAAA;IACpB,+DAAkB,CAAA;IAElB,YAAY;IACZ,oBAAoB;AACtB,CAAC,EARW,UAAU,GAAV,kBAAU,KAAV,kBAAU,QAQrB;AA0DD,0EAA0E;AAC1E,0FAA0F;AAC1F;IAAA;QACE,iDAAiD;QACjD,yEAAyE;QAClE,SAAI,GAAe,UAAU,CAAC,aAAa,CAAC;QAEnD,uEAAuE;QACvE,mDAAmD;QACnC,aAAQ,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAEpD,2CAA2C;QACpC,UAAK,GAAW,CAAC,CAAC;QAEzB,mEAAmE;QACnD,mBAAc,GAAW,IAAI,eAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QAE1D,qCAAqC;QAC9B,oBAAe,GAAW,CAAC,CAAC;QAEnC,8EAA8E;QAC9E,2EAA2E;QAC3E,kDAAkD;QAC3C,kBAAa,GAAW,CAAC,CAAC;QAEjC,gFAAgF;QAChF,2EAA2E;QAC3E,kDAAkD;QAC3C,mBAAc,GAAW,CAAC,CAAC;QAElC,2EAA2E;QAC3E,6BAA6B;QACtB,eAAU,GAAY,IAAI,CAAC;QAElC,6CAA6C;QACtC,UAAK,GAAY,IAAI,CAAC;QAE7B,uEAAuE;QAChE,kBAAa,GAAY,KAAK,CAAC;QAEtC,8EAA8E;QAC9E,kFAAkF;QAClF,mFAAmF;QACnF,mFAAmF;QAC5E,WAAM,GAAY,KAAK,CAAC;QAE/B,oCAAoC;QAC7B,WAAM,GAAY,IAAI,CAAC;QAE9B,qDAAqD;QAC9C,aAAQ,GAAQ,IAAI,CAAC;QAE5B,2CAA2C;QACpC,iBAAY,GAAW,CAAC,CAAC;IAClC,CAAC;IAAD,gBAAC;AAAD,CAAC,AApDD,IAoDC;AApDY,8BAAS;AAsDtB,4DAA4D;AAC5D;IAqDE,SAAS;IAET,gBAAY,EAAc,EAAE,KAAc;QAtDnC,WAAM,GAAe,UAAU,CAAC,aAAa,CAAC;QAE9C,iBAAY,GAAY,KAAK,CAAC;QAC9B,gBAAW,GAAY,KAAK,CAAC;QAC7B,oBAAe,GAAY,KAAK,CAAC;QACjC,iBAAY,GAAY,KAAK,CAAC;QAC9B,wBAAmB,GAAY,KAAK,CAAC;QACrC,iBAAY,GAAY,KAAK,CAAC;QAC9B,cAAS,GAAY,KAAK,CAAC;QAE3B,kBAAa,GAAW,CAAC,CAAC;QAEjB,SAAI,GAAgB,IAAI,oBAAW,EAAE,CAAC,CAAC,4BAA4B;QACnF,yBAAyB;QACT,UAAK,GAAgB,IAAI,oBAAW,EAAE,CAAC;QACvD,SAAS;QACO,YAAO,GAAY,IAAI,gBAAO,EAAE,CAAC,CAAC,2BAA2B;QAE7D,qBAAgB,GAAW,IAAI,eAAM,EAAE,CAAC;QACjD,sBAAiB,GAAW,CAAC,CAAC;QAErB,YAAO,GAAW,IAAI,eAAM,EAAE,CAAC;QACxC,aAAQ,GAAW,CAAC,CAAC;QAGrB,WAAM,GAAkB,IAAI,CAAC;QAC7B,WAAM,GAAkB,IAAI,CAAC;QAE7B,kBAAa,GAAqB,IAAI,CAAC;QACvC,mBAAc,GAAW,CAAC,CAAC;QAE3B,gBAAW,GAAuB,IAAI,CAAC;QACvC,kBAAa,GAAyB,IAAI,CAAC;QAE3C,WAAM,GAAW,CAAC,CAAC;QACnB,cAAS,GAAW,CAAC,CAAC;QAE7B,+CAA+C;QACxC,QAAG,GAAW,CAAC,CAAC;QAChB,WAAM,GAAW,CAAC,CAAC;QAEnB,oBAAe,GAAW,CAAC,CAAC;QAC5B,qBAAgB,GAAW,CAAC,CAAC;QAC7B,mBAAc,GAAW,CAAC,CAAC;QAE3B,gBAAW,GAAW,CAAC,CAAC;QAExB,eAAU,GAAQ,IAAI,CAAC;QAE9B,2BAA2B;QACpB,qBAAgB,GAA4B,IAAI,CAAC;QACjD,sBAAiB,GAAW,CAAC,CAAC;QAInC,IAAI,CAAC,YAAY,GAAG,oBAAO,CAAC,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,CAAC;QAC9C,IAAI,CAAC,mBAAmB,GAAG,oBAAO,CAAC,EAAE,CAAC,aAAa,EAAE,KAAK,CAAC,CAAC;QAC5D,IAAI,CAAC,eAAe,GAAG,oBAAO,CAAC,EAAE,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;QACpD,IAAI,CAAC,WAAW,GAAG,oBAAO,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAC3C,IAAI,CAAC,YAAY,GAAG,oBAAO,CAAC,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;QAE7C,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QAErB,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAO,CAAC,EAAE,CAAC,QAAQ,EAAE,eAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QACpD,0CAA0C;QAC1C,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,oBAAO,CAAC,EAAE,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC,CAAC;QAC3C,sDAAsD;QACtD,yBAAyB;QACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC3B,SAAS;QAET,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;QACnC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAClC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC1D,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QAExB,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,oBAAO,CAAC,EAAE,CAAC,cAAc,EAAE,eAAM,CAAC,IAAI,CAAC,CAAC,CAAC;QACpE,oDAAoD;QACpD,IAAI,CAAC,iBAAiB,GAAG,oBAAO,CAAC,EAAE,CAAC,eAAe,EAAE,CAAC,CAAC,CAAC;QACxD,sDAAsD;QAEtD,IAAI,CAAC,eAAe,GAAG,oBAAO,CAAC,EAAE,CAAC,aAAa,EAAE,CAAC,CAAC,CAAC;QACpD,IAAI,CAAC,gBAAgB,GAAG,oBAAO,CAAC,EAAE,CAAC,cAAc,EAAE,CAAC,CAAC,CAAC;QACtD,IAAI,CAAC,cAAc,GAAG,oBAAO,CAAC,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC;QAClD,+EAA+E;QAC/E,mFAAmF;QACnF,iFAAiF;QAEjF,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;QAElB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;QAErB,IAAI,CAAC,MAAM,GAAG,oBAAO,CAAC,EAAE,CAAC,IAAI,EAAE,UAAU,CAAC,aAAa,CAAC,CAAC;QAEzD,IAAI,EAAE,CAAC,IAAI,KAAK,UAAU,CAAC,cAAc,EAAE;YACzC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAChB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACpB;aAAM;YACL,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAChB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACpB;QAED,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAEhB,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC,QAAQ,CAAC;QAE9B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;QAExB,2BAA2B;QAC3B,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;QAC7B,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;QAC3B,SAAS;IACX,CAAC;IAKM,8BAAa,GAApB,UAAqB,CAA0B,EAAE,CAAa;QAAb,kBAAA,EAAA,KAAa;QAC5D,IAAI,CAAC,YAAY,iBAAO,EAAE;YACxB,OAAO,IAAI,CAAC,yBAAyB,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SAC7C;aAAM;YACL,OAAO,IAAI,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC;SACjC;IACH,CAAC;IAED,+EAA+E;IAC/E,+EAA+E;IAC/E,kCAAkC;IAClC,yFAAyF;IACzF,sDAAsD;IACtD,sCAAsC;IACtC,sDAAsD;IAC/C,iCAAgB,GAAvB,UAAwB,GAAkB;QACxC,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,IAAM,OAAO,GAAc,IAAI,qBAAS,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAEpD,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,CAAC,aAAa,EAAE,CAAC;SACzB;QAED,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC;QACpC,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC;QAC7B,EAAE,IAAI,CAAC,cAAc,CAAC;QAEtB,yBAAyB;QAEzB,oCAAoC;QACpC,IAAI,OAAO,CAAC,SAAS,GAAG,CAAC,EAAE;YACzB,IAAI,CAAC,aAAa,EAAE,CAAC;SACtB;QAED,yEAAyE;QACzE,wDAAwD;QACxD,IAAI,CAAC,OAAO,CAAC,YAAY,GAAG,IAAI,CAAC;QAEjC,OAAO,OAAO,CAAC;IACjB,CAAC;IAUM,0CAAyB,GAAhC,UACE,KAAc,EACd,OAAmB;QAAnB,wBAAA,EAAA,WAAmB;QAEnB,IAAM,GAAG,GAAiB,MAAM,CAAC,+BAA+B,CAAC;QACjE,GAAG,CAAC,KAAK,GAAG,KAAK,CAAC;QAClB,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC;QACtB,OAAO,IAAI,CAAC,gBAAgB,CAAC,GAAG,CAAC,CAAC;IACpC,CAAC;IAED,wEAAwE;IACxE,iEAAiE;IACjE,4EAA4E;IAC5E,iCAAiC;IACjC,wFAAwF;IACxF,6CAA6C;IAC7C,sDAAsD;IAC/C,+BAAc,GAArB,UAAsB,OAAkB;QACtC,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,4CAA4C;QAE5C,0DAA0D;QAC1D,4CAA4C;QAC5C,IAAI,IAAI,GAAqB,IAAI,CAAC,aAAa,CAAC;QAChD,IAAI,GAAG,GAAqB,IAAI,CAAC;QACjC,qCAAqC;QACrC,OAAO,IAAI,KAAK,IAAI,EAAE;YACpB,IAAI,IAAI,KAAK,OAAO,EAAE;gBACpB,IAAI,GAAG,EAAE;oBACP,GAAG,CAAC,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;iBAC7B;qBAAM;oBACL,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC;iBACrC;gBACD,uBAAuB;gBACvB,MAAM;aACP;YAED,GAAG,GAAG,IAAI,CAAC;YACX,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;SACpB;QAED,iEAAiE;QACjE,0BAA0B;QAE1B,oDAAoD;QACpD,IAAI,IAAI,GAAyB,IAAI,CAAC,aAAa,CAAC;QACpD,OAAO,IAAI,EAAE;YACX,IAAM,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC;YACvB,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;YAEjB,IAAM,QAAQ,GAAc,CAAC,CAAC,WAAW,EAAE,CAAC;YAC5C,IAAM,QAAQ,GAAc,CAAC,CAAC,WAAW,EAAE,CAAC;YAE5C,IAAI,OAAO,KAAK,QAAQ,IAAI,OAAO,KAAK,QAAQ,EAAE;gBAChD,gDAAgD;gBAChD,4BAA4B;gBAC5B,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;aAC1C;SACF;QAED,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,CAAC,cAAc,EAAE,CAAC;SAC1B;QAED,yBAAyB;QACzB,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;QACtB,OAAO,CAAC,KAAK,EAAE,CAAC;QAEhB,EAAE,IAAI,CAAC,cAAc,CAAC;QAEtB,uBAAuB;QACvB,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED,uDAAuD;IACvD,wDAAwD;IACxD,oEAAoE;IACpE,kEAAkE;IAClE,+CAA+C;IACxC,gCAAe,GAAtB,UAAuB,QAAY,EAAE,KAAa;QAChD,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACrD,CAAC;IAEM,+BAAc,GAArB,UAAsB,CAAS,EAAE,CAAS,EAAE,KAAa;QACvD,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC5B,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACtB,yBAAyB;QACzB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAC3B,SAAS;QAET,oBAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,KAAK,CAAC;QAEvB,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,KAAK,CAAC;QAExB,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;YAClE,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,eAAM,CAAC,IAAI,CAAC,CAAC;SACzD;QAED,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,eAAe,EAAE,CAAC;IAClD,CAAC;IAEM,6BAAY,GAAnB,UAAoB,EAAe;QACjC,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC5C,CAAC;IAEM,sCAAqB,GAA5B,UAA6B,EAAe,EAAE,KAAa;QACzD,IAAI,CAAC,eAAe,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IACpC,CAAC;IAED,iDAAiD;IACjD,qDAAqD;IAC9C,6BAAY,GAAnB;QACE,OAAO,IAAI,CAAC,IAAI,CAAC;IACnB,CAAC;IAED,uCAAuC;IACvC,oDAAoD;IAC7C,4BAAW,GAAlB;QACE,OAAO,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;IACrB,CAAC;IAEM,4BAAW,GAAlB,UAAmB,QAAY;QAC7B,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAClD,CAAC;IAEM,8BAAa,GAApB,UAAqB,CAAS,EAAE,CAAS;QACvC,IAAI,CAAC,cAAc,CAAC,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC7C,CAAC;IAED,6BAA6B;IAC7B,wDAAwD;IACjD,yBAAQ,GAAf;QACE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IACxB,CAAC;IAEM,yBAAQ,GAAf,UAAgB,KAAa;QAC3B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,WAAW,EAAE,EAAE,KAAK,CAAC,CAAC;IAClD,CAAC;IAED,iDAAiD;IAC1C,+BAAc,GAArB;QACE,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IACxB,CAAC;IAED,iDAAiD;IAC1C,+BAAc,GAArB;QACE,OAAO,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC;IAClC,CAAC;IAED,kDAAkD;IAClD,2DAA2D;IACpD,kCAAiB,GAAxB,UAAyB,CAAK;QAC5B,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa,EAAE;YAC5C,OAAO;SACR;QAED,IAAI,eAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,EAAE;YAC1B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IAChC,CAAC;IAED,kDAAkD;IAClD,sDAAsD;IAC/C,kCAAiB,GAAxB;QACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,6BAA6B;IAC7B,4DAA4D;IACrD,mCAAkB,GAAzB,UAA0B,CAAS;QACjC,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa,EAAE;YAC5C,OAAO;SACR;QAED,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;YACb,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;IAC7B,CAAC;IAED,6BAA6B;IAC7B,mDAAmD;IAC5C,mCAAkB,GAAzB;QACE,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAChC,CAAC;IAEM,8BAAa,GAApB,UAAqB,EAAa;QAChC,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,OAAO,EAAE,CAAC;QACzB,EAAE,CAAC,UAAU,GAAG,IAAI,CAAC,eAAe,CAAC;QACrC,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;QAC3B,EAAE,CAAC,cAAc,GAAG,IAAI,CAAC,gBAAgB,CAAC;QAC1C,EAAE,CAAC,YAAY,GAAG,IAAI,CAAC,cAAc,CAAC;QACtC,EAAE,CAAC,eAAe,GAAG,IAAI,CAAC,iBAAiB,CAAC;QAC5C,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC;QAC5C,EAAE,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC;QAC9B,EAAE,CAAC,KAAK,GAAG,IAAI,CAAC,WAAW,CAAC;QAC5B,EAAE,CAAC,aAAa,GAAG,IAAI,CAAC,eAAe,CAAC;QACxC,EAAE,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC;QACjD,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC;QACrC,EAAE,CAAC,QAAQ,GAAG,IAAI,CAAC,WAAW,EAAE,CAAC;QACjC,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,uDAAuD;IACvD,gEAAgE;IAChE,wDAAwD;IACxD,gEAAgE;IAChE,gEAAgE;IAChE,qCAAqC;IAC9B,2BAAU,GAAjB,UAAkB,KAAS,EAAE,KAAS,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QAC1D,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,QAAQ;gBACX,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;oBACtC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC;SAC1C;IACH,CAAC;IAED,gEAAgE;IAChE,gEAAgE;IAChE,qCAAqC;IAC9B,mCAAkB,GAAzB,UAA0B,KAAS,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QACvD,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;YAC1B,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;SAC3B;IACH,CAAC;IAED,qDAAqD;IACrD,gEAAgE;IAChE,uEAAuE;IACvE,qCAAqC;IAC9B,4BAAW,GAAlB,UAAmB,MAAc,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QACrD,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,QAAQ,IAAI,MAAM,CAAC;SACzB;IACH,CAAC;IAED,wEAAwE;IACxE,qEAAqE;IACrE,yDAAyD;IACzD,4EAA4E;IAC5E,gEAAgE;IAChE,qCAAqC;IAC9B,mCAAkB,GAAzB,UACE,OAAW,EACX,KAAS,EACT,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QAEpB,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,iBAAiB;gBACpB,IAAI,CAAC,MAAM;oBACX,CAAC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC;wBACvC,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;SAC/C;IACH,CAAC;IAED,sFAAsF;IACtF,4EAA4E;IAC5E,qCAAqC;IAC9B,2CAA0B,GAAjC,UAAkC,OAAW,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QACjE,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC;YACtD,IAAI,CAAC,gBAAgB,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC;SACvD;IACH,CAAC;IAED,6BAA6B;IAC7B,2DAA2D;IAC3D,qCAAqC;IAC9B,oCAAmB,GAA1B,UAA2B,OAAe,EAAE,IAAoB;QAApB,qBAAA,EAAA,WAAoB;QAC9D,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YAC7B,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;QAED,oDAAoD;QACpD,IAAI,IAAI,CAAC,WAAW,EAAE;YACpB,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,MAAM,GAAG,OAAO,CAAC;SACjD;IACH,CAAC;IAED,mCAAmC;IACnC,gDAAgD;IACzC,wBAAO,GAAd;QACE,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,kEAAkE;IAClE,sDAAsD;IAC/C,2BAAU,GAAjB;QACE,OAAO,CACL,IAAI,CAAC,GAAG;YACR,IAAI,CAAC,MAAM;gBACT,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CACnE,CAAC;IACJ,CAAC;IAED,kCAAkC;IAClC,yEAAyE;IAClE,4BAAW,GAAlB,UAAmB,IAAgB;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC;QACxB,IAAI,CAAC,CAAC;YACJ,IAAI,CAAC,GAAG;gBACR,IAAI,CAAC,MAAM;oBACT,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QACrE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;QAC3C,OAAO,IAAI,CAAC;IACd,CAAC;IAQM,4BAAW,GAAlB,UAAmB,QAAoB;QACrC,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,cAAc,EAAE;YAC7C,OAAO;SACR;QAED,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAEhB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC;QAC5B,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE;YACpB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SACjB;QAED,IAAI,CAAC,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;QAEjC,IAAI,QAAQ,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE;YAC/C,IAAI,CAAC,GAAG;gBACN,QAAQ,CAAC,CAAC;oBACV,IAAI,CAAC,MAAM,GAAG,eAAM,CAAC,KAAK,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC;YAC/D,iCAAiC;YACjC,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC;SAC5B;QAED,uBAAuB;QACvB,IAAM,SAAS,GAAW,MAAM,CAAC,uBAAuB,CAAC,IAAI,CAC3D,IAAI,CAAC,OAAO,CAAC,CAAC,CACf,CAAC;QACF,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAC/C,oBAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAErC,kCAAkC;QAClC,eAAM,CAAC,WAAW,CAChB,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,iBAAiB,EACtB,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,SAAS,EAAE,eAAM,CAAC,IAAI,CAAC,EACpD,IAAI,CAAC,gBAAgB,CACtB,CAAC;IACJ,CAAC;IAQM,8BAAa,GAApB;QACE,iEAAiE;QACjE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;QACnB,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;QAChB,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;QAEnC,8CAA8C;QAC9C,IACE,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa;YACxC,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,gBAAgB,EAC3C;YACA,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YAClC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACjC,OAAO;SACR;QAED,8DAA8D;QAE9D,qCAAqC;QACrC,IAAM,WAAW,GAAW,MAAM,CAAC,2BAA2B,CAAC,OAAO,EAAE,CAAC;QACzE,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;YAClE,IAAI,CAAC,CAAC,SAAS,KAAK,CAAC,EAAE;gBACrB,SAAS;aACV;YAED,IAAM,QAAQ,GAAe,CAAC,CAAC,WAAW,CACxC,MAAM,CAAC,wBAAwB,CAChC,CAAC;YACF,IAAI,CAAC,MAAM,IAAI,QAAQ,CAAC,IAAI,CAAC;YAC7B,WAAW,CAAC,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC;YACnD,WAAW,CAAC,CAAC,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAC;YACnD,IAAI,CAAC,GAAG,IAAI,QAAQ,CAAC,CAAC,CAAC;SACxB;QAED,0BAA0B;QAC1B,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE;YACnB,IAAI,CAAC,SAAS,GAAG,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;YACjC,WAAW,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC;YAChC,WAAW,CAAC,CAAC,IAAI,IAAI,CAAC,SAAS,CAAC;SACjC;aAAM;YACL,oDAAoD;YACpD,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;YAChB,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;SACpB;QAED,IAAI,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE;YAC7C,+CAA+C;YAC/C,IAAI,CAAC,GAAG,IAAI,IAAI,CAAC,MAAM,GAAG,eAAM,CAAC,KAAK,CAAC,WAAW,EAAE,WAAW,CAAC,CAAC;YACjE,iCAAiC;YACjC,IAAI,CAAC,MAAM,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC;SAC5B;aAAM;YACL,IAAI,CAAC,GAAG,GAAG,CAAC,CAAC;YACb,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC;SACjB;QAED,uBAAuB;QACvB,IAAM,SAAS,GAAW,MAAM,CAAC,yBAAyB,CAAC,IAAI,CAC7D,IAAI,CAAC,OAAO,CAAC,CAAC,CACf,CAAC;QACF,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;QAC3C,oBAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACvE,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAErC,kCAAkC;QAClC,eAAM,CAAC,WAAW,CAChB,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,iBAAiB,EACtB,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,SAAS,EAAE,eAAM,CAAC,IAAI,CAAC,EACpD,IAAI,CAAC,gBAAgB,CACtB,CAAC;IACJ,CAAC;IAED,qEAAqE;IACrE,kFAAkF;IAClF,0DAA0D;IACnD,8BAAa,GAApB,UAAmC,UAAc,EAAE,GAAM;QACvD,OAAO,oBAAW,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;IACvD,CAAC;IAED,sEAAsE;IACtE,kDAAkD;IAClD,2DAA2D;IACpD,+BAAc,GAArB,UAAoC,WAAe,EAAE,GAAM;QACzD,OAAO,cAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;IACpD,CAAC;IAED,yEAAyE;IACzE,wCAAwC;IACxC,wEAAwE;IACjE,8BAAa,GAApB,UAAmC,UAAc,EAAE,GAAM;QACvD,OAAO,oBAAW,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,CAAC,CAAC;IACxD,CAAC;IAED,6CAA6C;IAC7C,yCAAyC;IACzC,2CAA2C;IACpC,+BAAc,GAArB,UAAoC,WAAe,EAAE,GAAM;QACzD,OAAO,cAAK,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,WAAW,EAAE,GAAG,CAAC,CAAC;IACrD,CAAC;IAED,yEAAyE;IACzE,wCAAwC;IACxC,0CAA0C;IACnC,gDAA+B,GAAtC,UACE,UAAc,EACd,GAAM;QAEN,OAAO,eAAM,CAAC,WAAW,CACvB,IAAI,CAAC,gBAAgB,EACrB,IAAI,CAAC,iBAAiB,EACtB,eAAM,CAAC,KAAK,CAAC,UAAU,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,eAAM,CAAC,IAAI,CAAC,EACrD,GAAG,CACJ,CAAC;IACJ,CAAC;IAED,4CAA4C;IAC5C,wCAAwC;IACxC,0CAA0C;IACnC,gDAA+B,GAAtC,UACE,UAAc,EACd,GAAM;QAEN,OAAO,IAAI,CAAC,+BAA+B,CACzC,IAAI,CAAC,aAAa,CAAC,UAAU,EAAE,GAAG,CAAC,EACnC,GAAG,CACJ,CAAC;IACJ,CAAC;IAED,uCAAuC;IAChC,iCAAgB,GAAvB;QACE,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED,uCAAuC;IAChC,iCAAgB,GAAvB,UAAwB,aAAqB;QAC3C,IAAI,CAAC,eAAe,GAAG,aAAa,CAAC;IACvC,CAAC;IAED,wCAAwC;IACjC,kCAAiB,GAAxB;QACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED,wCAAwC;IACjC,kCAAiB,GAAxB,UAAyB,cAAsB;QAC7C,IAAI,CAAC,gBAAgB,GAAG,cAAc,CAAC;IACzC,CAAC;IAED,sCAAsC;IAC/B,gCAAe,GAAtB;QACE,OAAO,IAAI,CAAC,cAAc,CAAC;IAC7B,CAAC;IAED,sCAAsC;IAC/B,gCAAe,GAAtB,UAAuB,KAAa;QAClC,IAAI,CAAC,cAAc,GAAG,KAAK,CAAC;IAC9B,CAAC;IAED,oEAAoE;IAC7D,wBAAO,GAAd,UAAe,IAAgB;QAC7B,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,EAAE;YACxB,OAAO;SACR;QAED,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QAEnB,IAAI,CAAC,aAAa,EAAE,CAAC;QAErB,IAAI,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa,EAAE;YAC5C,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;YAChC,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,OAAO,CAAC,EAAE,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YACrC,IAAI,CAAC,mBAAmB,EAAE,CAAC;SAC5B;QAED,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QAEpB,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;QAElB,gCAAgC;QAChC,IAAI,EAAE,GAAyB,IAAI,CAAC,aAAa,CAAC;QAClD,OAAO,EAAE,EAAE;YACT,IAAM,GAAG,GAAkB,EAAE,CAAC;YAC9B,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC;YACb,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;SACpD;QACD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;QAE1B,4EAA4E;QAC5E,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;YAClE,CAAC,CAAC,YAAY,EAAE,CAAC;SAClB;IACH,CAAC;IAED,8BAA8B;IACvB,wBAAO,GAAd;QACE,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,iFAAiF;IAC1E,0BAAS,GAAhB,UAAiB,IAAa;QAC5B,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;IAC3B,CAAC;IAED,0EAA0E;IACnE,yBAAQ,GAAf;QACE,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,uEAAuE;IACvE,uBAAuB;IAChB,mCAAkB,GAAzB,UAA0B,IAAa;QACrC,IAAI,CAAC,eAAe,GAAG,IAAI,CAAC;QAC5B,IAAI,CAAC,IAAI,EAAE;YACT,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;SACrB;IACH,CAAC;IAED,iCAAiC;IAC1B,kCAAiB,GAAxB;QACE,OAAO,IAAI,CAAC,eAAe,CAAC;IAC9B,CAAC;IAED,6DAA6D;IAC7D,iBAAiB;IACjB,uEAAuE;IAChE,yBAAQ,GAAf,UAAgB,IAAa;QAC3B,IAAI,IAAI,EAAE;YACR,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YACxB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;SACtB;aAAM;YACL,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;YACzB,IAAI,CAAC,WAAW,GAAG,CAAC,CAAC;YACrB,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;YAChC,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;YAC3B,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;YACvB,IAAI,CAAC,QAAQ,GAAG,CAAC,CAAC;SACnB;IACH,CAAC;IAED,wCAAwC;IACxC,yCAAyC;IAClC,wBAAO,GAAd;QACE,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,6DAA6D;IAC7D,sDAAsD;IACtD,iEAAiE;IACjE,gBAAgB;IAChB,kEAAkE;IAClE,uDAAuD;IACvD,kEAAkE;IAClE,6DAA6D;IAC7D,iEAAiE;IACjE,yDAAyD;IACzD,iEAAiE;IACjE,mEAAmE;IACnE,qBAAqB;IACd,0BAAS,GAAhB,UAAiB,IAAa;QAC5B,IAAI,IAAI,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE;YAC3B,MAAM,IAAI,KAAK,EAAE,CAAC;SACnB;QAED,IAAI,IAAI,KAAK,IAAI,CAAC,QAAQ,EAAE,EAAE;YAC5B,OAAO;SACR;QAED,IAAI,CAAC,YAAY,GAAG,IAAI,CAAC;QAEzB,IAAI,IAAI,EAAE;YACR,sBAAsB;YACtB,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;gBAClE,CAAC,CAAC,aAAa,EAAE,CAAC;aACnB;YACD,2CAA2C;SAC5C;aAAM;YACL,uBAAuB;YACvB,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;gBAClE,CAAC,CAAC,cAAc,EAAE,CAAC;aACpB;YACD,iCAAiC;YACjC,IAAI,EAAE,GAAyB,IAAI,CAAC,aAAa,CAAC;YAClD,OAAO,EAAE,EAAE;gBACT,IAAM,GAAG,GAAkB,EAAE,CAAC;gBAC9B,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC;gBACb,IAAI,CAAC,OAAO,CAAC,gBAAgB,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;aACpD;YACD,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;IACH,CAAC;IAED,qCAAqC;IAC9B,yBAAQ,GAAf;QACE,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED,8DAA8D;IAC9D,gBAAgB;IACT,iCAAgB,GAAvB,UAAwB,IAAa;QACnC,IAAI,IAAI,CAAC,mBAAmB,KAAK,IAAI,EAAE;YACrC,OAAO;SACR;QAED,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;QAEhC,IAAI,CAAC,iBAAiB,GAAG,CAAC,CAAC;QAE3B,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAED,uCAAuC;IAChC,gCAAe,GAAtB;QACE,OAAO,IAAI,CAAC,mBAAmB,CAAC;IAClC,CAAC;IAED,uDAAuD;IAChD,+BAAc,GAArB;QACE,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAED,qDAAqD;IAC9C,6BAAY,GAAnB;QACE,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,uDAAuD;IACvD,+DAA+D;IAC/D,4DAA4D;IACrD,+BAAc,GAArB;QACE,OAAO,IAAI,CAAC,aAAa,CAAC;IAC5B,CAAC;IAED,+CAA+C;IACxC,wBAAO,GAAd;QACE,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,uEAAuE;IAChE,4BAAW,GAAlB;QACE,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,wEAAwE;IACjE,4BAAW,GAAlB,UAAmB,IAAS;QAC1B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IACzB,CAAC;IAED,sCAAsC;IAC/B,yBAAQ,GAAf;QACE,OAAO,IAAI,CAAC,OAAO,CAAC;IACtB,CAAC;IAED,gCAAgC;IACzB,qBAAI,GAAX,UAAY,GAA6C;QACvD,IAAM,SAAS,GAAW,IAAI,CAAC,aAAa,CAAC;QAE7C,GAAG,CAAC,KAAK,CAAC,CAAC;QACX,GAAG,CAAC,4CAA4C,CAAC,CAAC;QAClD,IAAI,QAAQ,GAAW,EAAE,CAAC;QAC1B,QAAQ,IAAI,CAAC,MAAM,EAAE;YACnB,KAAK,UAAU,CAAC,aAAa;gBAC3B,QAAQ,GAAG,0BAA0B,CAAC;gBACtC,MAAM;YACR,KAAK,UAAU,CAAC,gBAAgB;gBAC9B,QAAQ,GAAG,6BAA6B,CAAC;gBACzC,MAAM;YACR,KAAK,UAAU,CAAC,cAAc;gBAC5B,QAAQ,GAAG,2BAA2B,CAAC;gBACvC,MAAM;YACR;gBACE,0BAA0B;gBAC1B,MAAM;SACT;QACD,GAAG,CAAC,mBAAmB,EAAE,QAAQ,CAAC,CAAC;QACnC,GAAG,CAAC,oCAAoC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACxE,GAAG,CAAC,uBAAuB,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7C,GAAG,CACD,0CAA0C,EAC1C,IAAI,CAAC,gBAAgB,CAAC,CAAC,EACvB,IAAI,CAAC,gBAAgB,CAAC,CAAC,CACxB,CAAC;QACF,GAAG,CAAC,iCAAiC,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;QAC/D,GAAG,CAAC,+BAA+B,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC;QAC3D,GAAG,CAAC,gCAAgC,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC7D,GAAG,CAAC,yBAAyB,EAAE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACxE,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QAC/D,GAAG,CACD,4BAA4B,EAC5B,IAAI,CAAC,mBAAmB,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAC5C,CAAC;QACF,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACjE,GAAG,CAAC,qBAAqB,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;QACjE,GAAG,CAAC,8BAA8B,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QACzD,GAAG,CAAC,IAAI,CAAC,CAAC;QACV,GAAG,CAAC,+CAA+C,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;QACzE,GAAG,CAAC,IAAI,CAAC,CAAC;QACV,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;YAClE,GAAG,CAAC,OAAO,CAAC,CAAC;YACb,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,CAAC,CAAC;YACvB,GAAG,CAAC,OAAO,CAAC,CAAC;SACd;QACD,GAAG,CAAC,KAAK,CAAC,CAAC;IACb,CAAC;IAIM,oCAAmB,GAA1B;QACE,IAAM,GAAG,GAAgB,MAAM,CAAC,yBAAyB,CAAC;QAC1D,GAAG,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAChC,cAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QACpD,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,EAAE,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;QAE5C,4GAA4G;QAC5G,IAAM,YAAY,GAAW,eAAM,CAAC,KAAK,CACvC,IAAI,CAAC,OAAO,CAAC,CAAC,EACd,IAAI,CAAC,OAAO,CAAC,EAAE,EACf,MAAM,CAAC,kCAAkC,CAC1C,CAAC;QAEF,KAAK,IAAI,CAAC,GAAqB,IAAI,CAAC,aAAa,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,MAAM,EAAE;YAClE,CAAC,CAAC,kBAAkB,CAAC,GAAG,EAAE,IAAI,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;SACpD;IACH,CAAC;IAEM,qCAAoB,GAA3B;QACE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACrC,cAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAChE,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;IAED,2DAA2D;IAC3D,sDAAsD;IAC/C,8BAAa,GAApB,UAAqB,KAAa;QAChC,oDAAoD;QACpD,IACE,IAAI,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa;YACxC,KAAK,CAAC,MAAM,KAAK,UAAU,CAAC,aAAa,EACzC;YACA,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC;IAC5C,CAAC;IAEM,uCAAsB,GAA7B,UAA8B,KAAa;QACzC,kCAAkC;QAClC,KAAK,IAAI,EAAE,GAAuB,IAAI,CAAC,WAAW,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,IAAI,EAAE;YACpE,IAAI,EAAE,CAAC,KAAK,KAAK,KAAK,EAAE;gBACtB,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,kBAAkB,EAAE;oBAChC,OAAO,KAAK,CAAC;iBACd;aACF;SACF;QAED,OAAO,IAAI,CAAC;IACd,CAAC;IAEM,wBAAO,GAAd,UAAe,KAAa;QAC1B,mEAAmE;QACnE,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAC5B,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACrC,IAAI,CAAC,OAAO,CAAC,CAAC,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC;QACjC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACrC,cAAK,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,OAAO,CAAC,WAAW,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QAChE,eAAM,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;IAED,2BAA2B;IACpB,kCAAiB,GAAxB;QACE,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAEM,mCAAkB,GAAzB;QACE,OAAO,IAAI,CAAC,iBAAiB,CAAC;IAChC,CAAC;IAz5BD,8DAA8D;IAC9D,kFAAkF;IAClF,wDAAwD;IACxD,yFAAyF;IACzF,wCAAwC;IACxC,qEAAqE;IACrE,sDAAsD;IACvC,sCAA+B,GAAiB,IAAI,wBAAY,EAAE,CAAC;IAsXlF,4EAA4E;IAC5E,uDAAuD;IACvD,sEAAsE;IACtE,0DAA0D;IAC1D,wCAAwC;IACzB,8BAAuB,GAAW,IAAI,eAAM,EAAE,CAAC;IA8C9D,sFAAsF;IACtF,sFAAsF;IACtF,kDAAkD;IACnC,kCAA2B,GAAW,IAAI,eAAM,EAAE,CAAC;IACnD,gCAAyB,GAAW,IAAI,eAAM,EAAE,CAAC;IACjD,+BAAwB,GAAe,IAAI,oBAAU,EAAE,CAAC;IA+ZxD,gCAAyB,GAAgB,IAAI,oBAAW,EAAE,CAAC;IAC3D,yCAAkC,GAAW,IAAI,eAAM,EAAE,CAAC;IAsE3E,aAAC;CAAA,AAjkCD,IAikCC;AAjkCY,wBAAM","sourcesContent":["/*\r\n * Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\n// DEBUG: import { b2IsValid } from \"../Common/b2Math\";\r\nimport { b2Maybe } from \"../Common/b2Settings\";\r\nimport { b2Vec2, b2Rot, b2Transform, b2Sweep, XY } from \"../Common/b2Math\";\r\nimport { b2Shape, b2MassData } from \"../Collision/Shapes/b2Shape\";\r\nimport { b2ContactEdge } from \"./Contacts/b2Contact\";\r\nimport { b2JointEdge } from \"./Joints/b2Joint\";\r\nimport { b2Fixture, b2FixtureDef, b2IFixtureDef } from \"./b2Fixture\";\r\nimport { b2World } from \"./b2World\";\r\n// #if B2_ENABLE_CONTROLLER\r\nimport { b2ControllerEdge } from \"../Controllers/b2Controller\";\r\n// #endif\r\n\r\n/// The body type.\r\n/// static: zero mass, zero velocity, may be manually moved\r\n/// kinematic: zero mass, non-zero velocity set by user, moved by solver\r\n/// dynamic: positive mass, non-zero velocity determined by forces, moved by solver\r\nexport enum b2BodyType {\r\n  b2_unknown = -1,\r\n  b2_staticBody = 0,\r\n  b2_kinematicBody = 1,\r\n  b2_dynamicBody = 2\r\n\r\n  // TODO_ERIN\r\n  // b2_bulletBody = 3\r\n}\r\n\r\nexport interface b2IBodyDef {\r\n  /// The body type: static, kinematic, or dynamic.\r\n  /// Note: if a dynamic body would have zero mass, the mass is set to one.\r\n  type?: b2BodyType;\r\n\r\n  /// The world position of the body. Avoid creating bodies at the origin\r\n  /// since this can lead to many overlapping shapes.\r\n  position?: XY;\r\n\r\n  /// The world angle of the body in radians.\r\n  angle?: number;\r\n\r\n  /// The linear velocity of the body's origin in world co-ordinates.\r\n  linearVelocity?: XY;\r\n\r\n  /// The angular velocity of the body.\r\n  angularVelocity?: number;\r\n\r\n  /// Linear damping is use to reduce the linear velocity. The damping parameter\r\n  /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n  /// time step when the damping parameter is large.\r\n  /// Units are 1/time\r\n  linearDamping?: number;\r\n\r\n  /// Angular damping is use to reduce the angular velocity. The damping parameter\r\n  /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n  /// time step when the damping parameter is large.\r\n  /// Units are 1/time\r\n  angularDamping?: number;\r\n\r\n  /// Set this flag to false if this body should never fall asleep. Note that\r\n  /// this increases CPU usage.\r\n  allowSleep?: boolean;\r\n\r\n  /// Is this body initially awake or sleeping?\r\n  awake?: boolean;\r\n\r\n  /// Should this body be prevented from rotating? Useful for characters.\r\n  fixedRotation?: boolean;\r\n\r\n  /// Is this a fast moving body that should be prevented from tunneling through\r\n  /// other moving bodies? Note that all bodies are prevented from tunneling through\r\n  /// kinematic and static bodies. This setting is only considered on dynamic bodies.\r\n  /// @warning You should use this flag sparingly since it increases processing time.\r\n  bullet?: boolean;\r\n\r\n  /// Does this body start out active?\r\n  active?: boolean;\r\n\r\n  /// Use this to store application specific body data.\r\n  userData?: any;\r\n\r\n  /// Scale the gravity applied to this body.\r\n  gravityScale?: number;\r\n}\r\n\r\n/// A body definition holds all the data needed to construct a rigid body.\r\n/// You can safely re-use body definitions. Shapes are added to a body after construction.\r\nexport class b2BodyDef implements b2IBodyDef {\r\n  /// The body type: static, kinematic, or dynamic.\r\n  /// Note: if a dynamic body would have zero mass, the mass is set to one.\r\n  public type: b2BodyType = b2BodyType.b2_staticBody;\r\n\r\n  /// The world position of the body. Avoid creating bodies at the origin\r\n  /// since this can lead to many overlapping shapes.\r\n  public readonly position: b2Vec2 = new b2Vec2(0, 0);\r\n\r\n  /// The world angle of the body in radians.\r\n  public angle: number = 0;\r\n\r\n  /// The linear velocity of the body's origin in world co-ordinates.\r\n  public readonly linearVelocity: b2Vec2 = new b2Vec2(0, 0);\r\n\r\n  /// The angular velocity of the body.\r\n  public angularVelocity: number = 0;\r\n\r\n  /// Linear damping is use to reduce the linear velocity. The damping parameter\r\n  /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n  /// time step when the damping parameter is large.\r\n  public linearDamping: number = 0;\r\n\r\n  /// Angular damping is use to reduce the angular velocity. The damping parameter\r\n  /// can be larger than 1.0f but the damping effect becomes sensitive to the\r\n  /// time step when the damping parameter is large.\r\n  public angularDamping: number = 0;\r\n\r\n  /// Set this flag to false if this body should never fall asleep. Note that\r\n  /// this increases CPU usage.\r\n  public allowSleep: boolean = true;\r\n\r\n  /// Is this body initially awake or sleeping?\r\n  public awake: boolean = true;\r\n\r\n  /// Should this body be prevented from rotating? Useful for characters.\r\n  public fixedRotation: boolean = false;\r\n\r\n  /// Is this a fast moving body that should be prevented from tunneling through\r\n  /// other moving bodies? Note that all bodies are prevented from tunneling through\r\n  /// kinematic and static bodies. This setting is only considered on dynamic bodies.\r\n  /// @warning You should use this flag sparingly since it increases processing time.\r\n  public bullet: boolean = false;\r\n\r\n  /// Does this body start out active?\r\n  public active: boolean = true;\r\n\r\n  /// Use this to store application specific body data.\r\n  public userData: any = null;\r\n\r\n  /// Scale the gravity applied to this body.\r\n  public gravityScale: number = 1;\r\n}\r\n\r\n/// A rigid body. These are created via b2World::CreateBody.\r\nexport class b2Body {\r\n  public m_type: b2BodyType = b2BodyType.b2_staticBody;\r\n\r\n  public m_islandFlag: boolean = false;\r\n  public m_awakeFlag: boolean = false;\r\n  public m_autoSleepFlag: boolean = false;\r\n  public m_bulletFlag: boolean = false;\r\n  public m_fixedRotationFlag: boolean = false;\r\n  public m_activeFlag: boolean = false;\r\n  public m_toiFlag: boolean = false;\r\n\r\n  public m_islandIndex: number = 0;\r\n\r\n  public readonly m_xf: b2Transform = new b2Transform(); // the body origin transform\r\n  // #if B2_ENABLE_PARTICLE\r\n  public readonly m_xf0: b2Transform = new b2Transform();\r\n  // #endif\r\n  public readonly m_sweep: b2Sweep = new b2Sweep(); // the swept motion for CCD\r\n\r\n  public readonly m_linearVelocity: b2Vec2 = new b2Vec2();\r\n  public m_angularVelocity: number = 0;\r\n\r\n  public readonly m_force: b2Vec2 = new b2Vec2();\r\n  public m_torque: number = 0;\r\n\r\n  public m_world: b2World;\r\n  public m_prev: b2Body | null = null;\r\n  public m_next: b2Body | null = null;\r\n\r\n  public m_fixtureList: b2Fixture | null = null;\r\n  public m_fixtureCount: number = 0;\r\n\r\n  public m_jointList: b2JointEdge | null = null;\r\n  public m_contactList: b2ContactEdge | null = null;\r\n\r\n  public m_mass: number = 1;\r\n  public m_invMass: number = 1;\r\n\r\n  // Rotational inertia about the center of mass.\r\n  public m_I: number = 0;\r\n  public m_invI: number = 0;\r\n\r\n  public m_linearDamping: number = 0;\r\n  public m_angularDamping: number = 0;\r\n  public m_gravityScale: number = 1;\r\n\r\n  public m_sleepTime: number = 0;\r\n\r\n  public m_userData: any = null;\r\n\r\n  // #if B2_ENABLE_CONTROLLER\r\n  public m_controllerList: b2ControllerEdge | null = null;\r\n  public m_controllerCount: number = 0;\r\n  // #endif\r\n\r\n  constructor(bd: b2IBodyDef, world: b2World) {\r\n    this.m_bulletFlag = b2Maybe(bd.bullet, false);\r\n    this.m_fixedRotationFlag = b2Maybe(bd.fixedRotation, false);\r\n    this.m_autoSleepFlag = b2Maybe(bd.allowSleep, true);\r\n    this.m_awakeFlag = b2Maybe(bd.awake, true);\r\n    this.m_activeFlag = b2Maybe(bd.active, true);\r\n\r\n    this.m_world = world;\r\n\r\n    this.m_xf.p.Copy(b2Maybe(bd.position, b2Vec2.ZERO));\r\n    // DEBUG: b2Assert(this.m_xf.p.IsValid());\r\n    this.m_xf.q.SetAngle(b2Maybe(bd.angle, 0));\r\n    // DEBUG: b2Assert(b2IsValid(this.m_xf.q.GetAngle()));\r\n    // #if B2_ENABLE_PARTICLE\r\n    this.m_xf0.Copy(this.m_xf);\r\n    // #endif\r\n\r\n    this.m_sweep.localCenter.SetZero();\r\n    this.m_sweep.c0.Copy(this.m_xf.p);\r\n    this.m_sweep.c.Copy(this.m_xf.p);\r\n    this.m_sweep.a0 = this.m_sweep.a = this.m_xf.q.GetAngle();\r\n    this.m_sweep.alpha0 = 0;\r\n\r\n    this.m_linearVelocity.Copy(b2Maybe(bd.linearVelocity, b2Vec2.ZERO));\r\n    // DEBUG: b2Assert(this.m_linearVelocity.IsValid());\r\n    this.m_angularVelocity = b2Maybe(bd.angularVelocity, 0);\r\n    // DEBUG: b2Assert(b2IsValid(this.m_angularVelocity));\r\n\r\n    this.m_linearDamping = b2Maybe(bd.linearDamping, 0);\r\n    this.m_angularDamping = b2Maybe(bd.angularDamping, 0);\r\n    this.m_gravityScale = b2Maybe(bd.gravityScale, 1);\r\n    // DEBUG: b2Assert(b2IsValid(this.m_gravityScale) && this.m_gravityScale >= 0);\r\n    // DEBUG: b2Assert(b2IsValid(this.m_angularDamping) && this.m_angularDamping >= 0);\r\n    // DEBUG: b2Assert(b2IsValid(this.m_linearDamping) && this.m_linearDamping >= 0);\r\n\r\n    this.m_force.SetZero();\r\n    this.m_torque = 0;\r\n\r\n    this.m_sleepTime = 0;\r\n\r\n    this.m_type = b2Maybe(bd.type, b2BodyType.b2_staticBody);\r\n\r\n    if (bd.type === b2BodyType.b2_dynamicBody) {\r\n      this.m_mass = 1;\r\n      this.m_invMass = 1;\r\n    } else {\r\n      this.m_mass = 0;\r\n      this.m_invMass = 0;\r\n    }\r\n\r\n    this.m_I = 0;\r\n    this.m_invI = 0;\r\n\r\n    this.m_userData = bd.userData;\r\n\r\n    this.m_fixtureList = null;\r\n    this.m_fixtureCount = 0;\r\n\r\n    // #if B2_ENABLE_CONTROLLER\r\n    this.m_controllerList = null;\r\n    this.m_controllerCount = 0;\r\n    // #endif\r\n  }\r\n\r\n  public CreateFixture(def: b2IFixtureDef): b2Fixture;\r\n  public CreateFixture(shape: b2Shape): b2Fixture;\r\n  public CreateFixture(shape: b2Shape, density: number): b2Fixture;\r\n  public CreateFixture(a: b2IFixtureDef | b2Shape, b: number = 0): b2Fixture {\r\n    if (a instanceof b2Shape) {\r\n      return this.CreateFixtureShapeDensity(a, b);\r\n    } else {\r\n      return this.CreateFixtureDef(a);\r\n    }\r\n  }\r\n\r\n  /// Creates a fixture and attach it to this body. Use this function if you need\r\n  /// to set some fixture parameters, like friction. Otherwise you can create the\r\n  /// fixture directly from a shape.\r\n  /// If the density is non-zero, this function automatically updates the mass of the body.\r\n  /// Contacts are not created until the next time step.\r\n  /// @param def the fixture definition.\r\n  /// @warning This function is locked during callbacks.\r\n  public CreateFixtureDef(def: b2IFixtureDef): b2Fixture {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    const fixture: b2Fixture = new b2Fixture(this, def);\r\n\r\n    if (this.m_activeFlag) {\r\n      fixture.CreateProxies();\r\n    }\r\n\r\n    fixture.m_next = this.m_fixtureList;\r\n    this.m_fixtureList = fixture;\r\n    ++this.m_fixtureCount;\r\n\r\n    // fixture.m_body = this;\r\n\r\n    // Adjust mass properties if needed.\r\n    if (fixture.m_density > 0) {\r\n      this.ResetMassData();\r\n    }\r\n\r\n    // Let the world know we have a new fixture. This will cause new contacts\r\n    // to be created at the beginning of the next time step.\r\n    this.m_world.m_newFixture = true;\r\n\r\n    return fixture;\r\n  }\r\n\r\n  /// Creates a fixture from a shape and attach it to this body.\r\n  /// This is a convenience function. Use b2FixtureDef if you need to set parameters\r\n  /// like friction, restitution, user data, or filtering.\r\n  /// If the density is non-zero, this function automatically updates the mass of the body.\r\n  /// @param shape the shape to be cloned.\r\n  /// @param density the shape density (set to zero for static bodies).\r\n  /// @warning This function is locked during callbacks.\r\n  private static CreateFixtureShapeDensity_s_def: b2FixtureDef = new b2FixtureDef();\r\n  public CreateFixtureShapeDensity(\r\n    shape: b2Shape,\r\n    density: number = 0\r\n  ): b2Fixture {\r\n    const def: b2FixtureDef = b2Body.CreateFixtureShapeDensity_s_def;\r\n    def.shape = shape;\r\n    def.density = density;\r\n    return this.CreateFixtureDef(def);\r\n  }\r\n\r\n  /// Destroy a fixture. This removes the fixture from the broad-phase and\r\n  /// destroys all contacts associated with this fixture. This will\r\n  /// automatically adjust the mass of the body if the body is dynamic and the\r\n  /// fixture has positive density.\r\n  /// All fixtures attached to a body are implicitly destroyed when the body is destroyed.\r\n  /// @param fixture the fixture to be removed.\r\n  /// @warning This function is locked during callbacks.\r\n  public DestroyFixture(fixture: b2Fixture): void {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    // DEBUG: b2Assert(fixture.m_body === this);\r\n\r\n    // Remove the fixture from this body's singly linked list.\r\n    // DEBUG: b2Assert(this.m_fixtureCount > 0);\r\n    let node: b2Fixture | null = this.m_fixtureList;\r\n    let ppF: b2Fixture | null = null;\r\n    // DEBUG: let found: boolean = false;\r\n    while (node !== null) {\r\n      if (node === fixture) {\r\n        if (ppF) {\r\n          ppF.m_next = fixture.m_next;\r\n        } else {\r\n          this.m_fixtureList = fixture.m_next;\r\n        }\r\n        // DEBUG: found = true;\r\n        break;\r\n      }\r\n\r\n      ppF = node;\r\n      node = node.m_next;\r\n    }\r\n\r\n    // You tried to remove a shape that is not attached to this body.\r\n    // DEBUG: b2Assert(found);\r\n\r\n    // Destroy any contacts associated with the fixture.\r\n    let edge: b2ContactEdge | null = this.m_contactList;\r\n    while (edge) {\r\n      const c = edge.contact;\r\n      edge = edge.next;\r\n\r\n      const fixtureA: b2Fixture = c.GetFixtureA();\r\n      const fixtureB: b2Fixture = c.GetFixtureB();\r\n\r\n      if (fixture === fixtureA || fixture === fixtureB) {\r\n        // This destroys the contact and removes it from\r\n        // this body's contact list.\r\n        this.m_world.m_contactManager.Destroy(c);\r\n      }\r\n    }\r\n\r\n    if (this.m_activeFlag) {\r\n      fixture.DestroyProxies();\r\n    }\r\n\r\n    // fixture.m_body = null;\r\n    fixture.m_next = null;\r\n    fixture.Reset();\r\n\r\n    --this.m_fixtureCount;\r\n\r\n    // Reset the mass data.\r\n    this.ResetMassData();\r\n  }\r\n\r\n  /// Set the position of the body's origin and rotation.\r\n  /// This breaks any contacts and wakes the other bodies.\r\n  /// Manipulating a body's transform may cause non-physical behavior.\r\n  /// @param position the world position of the body's local origin.\r\n  /// @param angle the world rotation in radians.\r\n  public SetTransformVec(position: XY, angle: number): void {\r\n    this.SetTransformXY(position.x, position.y, angle);\r\n  }\r\n\r\n  public SetTransformXY(x: number, y: number, angle: number): void {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    this.m_xf.q.SetAngle(angle);\r\n    this.m_xf.p.Set(x, y);\r\n    // #if B2_ENABLE_PARTICLE\r\n    this.m_xf0.Copy(this.m_xf);\r\n    // #endif\r\n\r\n    b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n    this.m_sweep.a = angle;\r\n\r\n    this.m_sweep.c0.Copy(this.m_sweep.c);\r\n    this.m_sweep.a0 = angle;\r\n\r\n    for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n      f.SynchronizeProxies(this.m_xf, this.m_xf, b2Vec2.ZERO);\r\n    }\r\n\r\n    this.m_world.m_contactManager.FindNewContacts();\r\n  }\r\n\r\n  public SetTransform(xf: b2Transform): void {\r\n    this.SetTransformVec(xf.p, xf.GetAngle());\r\n  }\r\n\r\n  public SetTransformWithAngle(xf: b2Transform, angle: number): void {\r\n    this.SetTransformVec(xf.p, angle);\r\n  }\r\n\r\n  /// Get the body transform for the body's origin.\r\n  /// @return the world transform of the body's origin.\r\n  public GetTransform(): Readonly<b2Transform> {\r\n    return this.m_xf;\r\n  }\r\n\r\n  /// Get the world body origin position.\r\n  /// @return the world position of the body's origin.\r\n  public GetPosition(): Readonly<b2Vec2> {\r\n    return this.m_xf.p;\r\n  }\r\n\r\n  public SetPosition(position: XY): void {\r\n    this.SetTransformVec(position, this.GetAngle());\r\n  }\r\n\r\n  public SetPositionXY(x: number, y: number): void {\r\n    this.SetTransformXY(x, y, this.GetAngle());\r\n  }\r\n\r\n  /// Get the angle in radians.\r\n  /// @return the current world rotation angle in radians.\r\n  public GetAngle(): number {\r\n    return this.m_sweep.a;\r\n  }\r\n\r\n  public SetAngle(angle: number): void {\r\n    this.SetTransformVec(this.GetPosition(), angle);\r\n  }\r\n\r\n  /// Get the world position of the center of mass.\r\n  public GetWorldCenter(): Readonly<b2Vec2> {\r\n    return this.m_sweep.c;\r\n  }\r\n\r\n  /// Get the local position of the center of mass.\r\n  public GetLocalCenter(): Readonly<b2Vec2> {\r\n    return this.m_sweep.localCenter;\r\n  }\r\n\r\n  /// Set the linear velocity of the center of mass.\r\n  /// @param v the new linear velocity of the center of mass.\r\n  public SetLinearVelocity(v: XY): void {\r\n    if (this.m_type === b2BodyType.b2_staticBody) {\r\n      return;\r\n    }\r\n\r\n    if (b2Vec2.DotVV(v, v) > 0) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    this.m_linearVelocity.Copy(v);\r\n  }\r\n\r\n  /// Get the linear velocity of the center of mass.\r\n  /// @return the linear velocity of the center of mass.\r\n  public GetLinearVelocity(): Readonly<b2Vec2> {\r\n    return this.m_linearVelocity;\r\n  }\r\n\r\n  /// Set the angular velocity.\r\n  /// @param omega the new angular velocity in radians/second.\r\n  public SetAngularVelocity(w: number): void {\r\n    if (this.m_type === b2BodyType.b2_staticBody) {\r\n      return;\r\n    }\r\n\r\n    if (w * w > 0) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    this.m_angularVelocity = w;\r\n  }\r\n\r\n  /// Get the angular velocity.\r\n  /// @return the angular velocity in radians/second.\r\n  public GetAngularVelocity(): number {\r\n    return this.m_angularVelocity;\r\n  }\r\n\r\n  public GetDefinition(bd: b2BodyDef): b2BodyDef {\r\n    bd.type = this.GetType();\r\n    bd.allowSleep = this.m_autoSleepFlag;\r\n    bd.angle = this.GetAngle();\r\n    bd.angularDamping = this.m_angularDamping;\r\n    bd.gravityScale = this.m_gravityScale;\r\n    bd.angularVelocity = this.m_angularVelocity;\r\n    bd.fixedRotation = this.m_fixedRotationFlag;\r\n    bd.bullet = this.m_bulletFlag;\r\n    bd.awake = this.m_awakeFlag;\r\n    bd.linearDamping = this.m_linearDamping;\r\n    bd.linearVelocity.Copy(this.GetLinearVelocity());\r\n    bd.position.Copy(this.GetPosition());\r\n    bd.userData = this.GetUserData();\r\n    return bd;\r\n  }\r\n\r\n  /// Apply a force at a world point. If the force is not\r\n  /// applied at the center of mass, it will generate a torque and\r\n  /// affect the angular velocity. This wakes up the body.\r\n  /// @param force the world force vector, usually in Newtons (N).\r\n  /// @param point the world position of the point of application.\r\n  /// @param wake also wake up the body\r\n  public ApplyForce(force: XY, point: XY, wake: boolean = true): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_force.x += force.x;\r\n      this.m_force.y += force.y;\r\n      this.m_torque +=\r\n        (point.x - this.m_sweep.c.x) * force.y -\r\n        (point.y - this.m_sweep.c.y) * force.x;\r\n    }\r\n  }\r\n\r\n  /// Apply a force to the center of mass. This wakes up the body.\r\n  /// @param force the world force vector, usually in Newtons (N).\r\n  /// @param wake also wake up the body\r\n  public ApplyForceToCenter(force: XY, wake: boolean = true): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_force.x += force.x;\r\n      this.m_force.y += force.y;\r\n    }\r\n  }\r\n\r\n  /// Apply a torque. This affects the angular velocity\r\n  /// without affecting the linear velocity of the center of mass.\r\n  /// @param torque about the z-axis (out of the screen), usually in N-m.\r\n  /// @param wake also wake up the body\r\n  public ApplyTorque(torque: number, wake: boolean = true): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_torque += torque;\r\n    }\r\n  }\r\n\r\n  /// Apply an impulse at a point. This immediately modifies the velocity.\r\n  /// It also modifies the angular velocity if the point of application\r\n  /// is not at the center of mass. This wakes up the body.\r\n  /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n  /// @param point the world position of the point of application.\r\n  /// @param wake also wake up the body\r\n  public ApplyLinearImpulse(\r\n    impulse: XY,\r\n    point: XY,\r\n    wake: boolean = true\r\n  ): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_linearVelocity.x += this.m_invMass * impulse.x;\r\n      this.m_linearVelocity.y += this.m_invMass * impulse.y;\r\n      this.m_angularVelocity +=\r\n        this.m_invI *\r\n        ((point.x - this.m_sweep.c.x) * impulse.y -\r\n          (point.y - this.m_sweep.c.y) * impulse.x);\r\n    }\r\n  }\r\n\r\n  /// Apply an impulse at the center of gravity. This immediately modifies the velocity.\r\n  /// @param impulse the world impulse vector, usually in N-seconds or kg-m/s.\r\n  /// @param wake also wake up the body\r\n  public ApplyLinearImpulseToCenter(impulse: XY, wake: boolean = true): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_linearVelocity.x += this.m_invMass * impulse.x;\r\n      this.m_linearVelocity.y += this.m_invMass * impulse.y;\r\n    }\r\n  }\r\n\r\n  /// Apply an angular impulse.\r\n  /// @param impulse the angular impulse in units of kg*m*m/s\r\n  /// @param wake also wake up the body\r\n  public ApplyAngularImpulse(impulse: number, wake: boolean = true): void {\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    if (wake && !this.m_awakeFlag) {\r\n      this.SetAwake(true);\r\n    }\r\n\r\n    // Don't accumulate a force if the body is sleeping.\r\n    if (this.m_awakeFlag) {\r\n      this.m_angularVelocity += this.m_invI * impulse;\r\n    }\r\n  }\r\n\r\n  /// Get the total mass of the body.\r\n  /// @return the mass, usually in kilograms (kg).\r\n  public GetMass(): number {\r\n    return this.m_mass;\r\n  }\r\n\r\n  /// Get the rotational inertia of the body about the local origin.\r\n  /// @return the rotational inertia, usually in kg-m^2.\r\n  public GetInertia(): number {\r\n    return (\r\n      this.m_I +\r\n      this.m_mass *\r\n        b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter)\r\n    );\r\n  }\r\n\r\n  /// Get the mass data of the body.\r\n  /// @return a struct containing the mass, inertia and center of the body.\r\n  public GetMassData(data: b2MassData): b2MassData {\r\n    data.mass = this.m_mass;\r\n    data.I =\r\n      this.m_I +\r\n      this.m_mass *\r\n        b2Vec2.DotVV(this.m_sweep.localCenter, this.m_sweep.localCenter);\r\n    data.center.Copy(this.m_sweep.localCenter);\r\n    return data;\r\n  }\r\n\r\n  /// Set the mass properties to override the mass properties of the fixtures.\r\n  /// Note that this changes the center of mass position.\r\n  /// Note that creating or destroying fixtures can also alter the mass.\r\n  /// This function has no effect if the body isn't dynamic.\r\n  /// @param massData the mass properties.\r\n  private static SetMassData_s_oldCenter: b2Vec2 = new b2Vec2();\r\n  public SetMassData(massData: b2MassData): void {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    if (this.m_type !== b2BodyType.b2_dynamicBody) {\r\n      return;\r\n    }\r\n\r\n    this.m_invMass = 0;\r\n    this.m_I = 0;\r\n    this.m_invI = 0;\r\n\r\n    this.m_mass = massData.mass;\r\n    if (this.m_mass <= 0) {\r\n      this.m_mass = 1;\r\n    }\r\n\r\n    this.m_invMass = 1 / this.m_mass;\r\n\r\n    if (massData.I > 0 && !this.m_fixedRotationFlag) {\r\n      this.m_I =\r\n        massData.I -\r\n        this.m_mass * b2Vec2.DotVV(massData.center, massData.center);\r\n      // DEBUG: b2Assert(this.m_I > 0);\r\n      this.m_invI = 1 / this.m_I;\r\n    }\r\n\r\n    // Move center of mass.\r\n    const oldCenter: b2Vec2 = b2Body.SetMassData_s_oldCenter.Copy(\r\n      this.m_sweep.c\r\n    );\r\n    this.m_sweep.localCenter.Copy(massData.center);\r\n    b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n    this.m_sweep.c0.Copy(this.m_sweep.c);\r\n\r\n    // Update center of mass velocity.\r\n    b2Vec2.AddVCrossSV(\r\n      this.m_linearVelocity,\r\n      this.m_angularVelocity,\r\n      b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0),\r\n      this.m_linearVelocity\r\n    );\r\n  }\r\n\r\n  /// This resets the mass properties to the sum of the mass properties of the fixtures.\r\n  /// This normally does not need to be called unless you called SetMassData to override\r\n  /// the mass and you later want to reset the mass.\r\n  private static ResetMassData_s_localCenter: b2Vec2 = new b2Vec2();\r\n  private static ResetMassData_s_oldCenter: b2Vec2 = new b2Vec2();\r\n  private static ResetMassData_s_massData: b2MassData = new b2MassData();\r\n  public ResetMassData(): void {\r\n    // Compute mass data from shapes. Each shape has its own density.\r\n    this.m_mass = 0;\r\n    this.m_invMass = 0;\r\n    this.m_I = 0;\r\n    this.m_invI = 0;\r\n    this.m_sweep.localCenter.SetZero();\r\n\r\n    // Static and kinematic bodies have zero mass.\r\n    if (\r\n      this.m_type === b2BodyType.b2_staticBody ||\r\n      this.m_type === b2BodyType.b2_kinematicBody\r\n    ) {\r\n      this.m_sweep.c0.Copy(this.m_xf.p);\r\n      this.m_sweep.c.Copy(this.m_xf.p);\r\n      this.m_sweep.a0 = this.m_sweep.a;\r\n      return;\r\n    }\r\n\r\n    // DEBUG: b2Assert(this.m_type === b2BodyType.b2_dynamicBody);\r\n\r\n    // Accumulate mass over all fixtures.\r\n    const localCenter: b2Vec2 = b2Body.ResetMassData_s_localCenter.SetZero();\r\n    for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n      if (f.m_density === 0) {\r\n        continue;\r\n      }\r\n\r\n      const massData: b2MassData = f.GetMassData(\r\n        b2Body.ResetMassData_s_massData\r\n      );\r\n      this.m_mass += massData.mass;\r\n      localCenter.x += massData.center.x * massData.mass;\r\n      localCenter.y += massData.center.y * massData.mass;\r\n      this.m_I += massData.I;\r\n    }\r\n\r\n    // Compute center of mass.\r\n    if (this.m_mass > 0) {\r\n      this.m_invMass = 1 / this.m_mass;\r\n      localCenter.x *= this.m_invMass;\r\n      localCenter.y *= this.m_invMass;\r\n    } else {\r\n      // Force all dynamic bodies to have a positive mass.\r\n      this.m_mass = 1;\r\n      this.m_invMass = 1;\r\n    }\r\n\r\n    if (this.m_I > 0 && !this.m_fixedRotationFlag) {\r\n      // Center the inertia about the center of mass.\r\n      this.m_I -= this.m_mass * b2Vec2.DotVV(localCenter, localCenter);\r\n      // DEBUG: b2Assert(this.m_I > 0);\r\n      this.m_invI = 1 / this.m_I;\r\n    } else {\r\n      this.m_I = 0;\r\n      this.m_invI = 0;\r\n    }\r\n\r\n    // Move center of mass.\r\n    const oldCenter: b2Vec2 = b2Body.ResetMassData_s_oldCenter.Copy(\r\n      this.m_sweep.c\r\n    );\r\n    this.m_sweep.localCenter.Copy(localCenter);\r\n    b2Transform.MulXV(this.m_xf, this.m_sweep.localCenter, this.m_sweep.c);\r\n    this.m_sweep.c0.Copy(this.m_sweep.c);\r\n\r\n    // Update center of mass velocity.\r\n    b2Vec2.AddVCrossSV(\r\n      this.m_linearVelocity,\r\n      this.m_angularVelocity,\r\n      b2Vec2.SubVV(this.m_sweep.c, oldCenter, b2Vec2.s_t0),\r\n      this.m_linearVelocity\r\n    );\r\n  }\r\n\r\n  /// Get the world coordinates of a point given the local coordinates.\r\n  /// @param localPoint a point on the body measured relative the the body's origin.\r\n  /// @return the same point expressed in world coordinates.\r\n  public GetWorldPoint<T extends XY>(localPoint: XY, out: T): T {\r\n    return b2Transform.MulXV(this.m_xf, localPoint, out);\r\n  }\r\n\r\n  /// Get the world coordinates of a vector given the local coordinates.\r\n  /// @param localVector a vector fixed in the body.\r\n  /// @return the same vector expressed in world coordinates.\r\n  public GetWorldVector<T extends XY>(localVector: XY, out: T): T {\r\n    return b2Rot.MulRV(this.m_xf.q, localVector, out);\r\n  }\r\n\r\n  /// Gets a local point relative to the body's origin given a world point.\r\n  /// @param a point in world coordinates.\r\n  /// @return the corresponding local point relative to the body's origin.\r\n  public GetLocalPoint<T extends XY>(worldPoint: XY, out: T): T {\r\n    return b2Transform.MulTXV(this.m_xf, worldPoint, out);\r\n  }\r\n\r\n  /// Gets a local vector given a world vector.\r\n  /// @param a vector in world coordinates.\r\n  /// @return the corresponding local vector.\r\n  public GetLocalVector<T extends XY>(worldVector: XY, out: T): T {\r\n    return b2Rot.MulTRV(this.m_xf.q, worldVector, out);\r\n  }\r\n\r\n  /// Get the world linear velocity of a world point attached to this body.\r\n  /// @param a point in world coordinates.\r\n  /// @return the world velocity of a point.\r\n  public GetLinearVelocityFromWorldPoint<T extends XY>(\r\n    worldPoint: XY,\r\n    out: T\r\n  ): T {\r\n    return b2Vec2.AddVCrossSV(\r\n      this.m_linearVelocity,\r\n      this.m_angularVelocity,\r\n      b2Vec2.SubVV(worldPoint, this.m_sweep.c, b2Vec2.s_t0),\r\n      out\r\n    );\r\n  }\r\n\r\n  /// Get the world velocity of a local point.\r\n  /// @param a point in local coordinates.\r\n  /// @return the world velocity of a point.\r\n  public GetLinearVelocityFromLocalPoint<T extends XY>(\r\n    localPoint: XY,\r\n    out: T\r\n  ): T {\r\n    return this.GetLinearVelocityFromWorldPoint(\r\n      this.GetWorldPoint(localPoint, out),\r\n      out\r\n    );\r\n  }\r\n\r\n  /// Get the linear damping of the body.\r\n  public GetLinearDamping(): number {\r\n    return this.m_linearDamping;\r\n  }\r\n\r\n  /// Set the linear damping of the body.\r\n  public SetLinearDamping(linearDamping: number): void {\r\n    this.m_linearDamping = linearDamping;\r\n  }\r\n\r\n  /// Get the angular damping of the body.\r\n  public GetAngularDamping(): number {\r\n    return this.m_angularDamping;\r\n  }\r\n\r\n  /// Set the angular damping of the body.\r\n  public SetAngularDamping(angularDamping: number): void {\r\n    this.m_angularDamping = angularDamping;\r\n  }\r\n\r\n  /// Get the gravity scale of the body.\r\n  public GetGravityScale(): number {\r\n    return this.m_gravityScale;\r\n  }\r\n\r\n  /// Set the gravity scale of the body.\r\n  public SetGravityScale(scale: number): void {\r\n    this.m_gravityScale = scale;\r\n  }\r\n\r\n  /// Set the type of this body. This may alter the mass and velocity.\r\n  public SetType(type: b2BodyType): void {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    if (this.m_type === type) {\r\n      return;\r\n    }\r\n\r\n    this.m_type = type;\r\n\r\n    this.ResetMassData();\r\n\r\n    if (this.m_type === b2BodyType.b2_staticBody) {\r\n      this.m_linearVelocity.SetZero();\r\n      this.m_angularVelocity = 0;\r\n      this.m_sweep.a0 = this.m_sweep.a;\r\n      this.m_sweep.c0.Copy(this.m_sweep.c);\r\n      this.SynchronizeFixtures();\r\n    }\r\n\r\n    this.SetAwake(true);\r\n\r\n    this.m_force.SetZero();\r\n    this.m_torque = 0;\r\n\r\n    // Delete the attached contacts.\r\n    let ce: b2ContactEdge | null = this.m_contactList;\r\n    while (ce) {\r\n      const ce0: b2ContactEdge = ce;\r\n      ce = ce.next;\r\n      this.m_world.m_contactManager.Destroy(ce0.contact);\r\n    }\r\n    this.m_contactList = null;\r\n\r\n    // Touch the proxies so that new contacts will be created (when appropriate)\r\n    for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n      f.TouchProxies();\r\n    }\r\n  }\r\n\r\n  /// Get the type of this body.\r\n  public GetType(): b2BodyType {\r\n    return this.m_type;\r\n  }\r\n\r\n  /// Should this body be treated like a bullet for continuous collision detection?\r\n  public SetBullet(flag: boolean): void {\r\n    this.m_bulletFlag = flag;\r\n  }\r\n\r\n  /// Is this body treated like a bullet for continuous collision detection?\r\n  public IsBullet(): boolean {\r\n    return this.m_bulletFlag;\r\n  }\r\n\r\n  /// You can disable sleeping on this body. If you disable sleeping, the\r\n  /// body will be woken.\r\n  public SetSleepingAllowed(flag: boolean): void {\r\n    this.m_autoSleepFlag = flag;\r\n    if (!flag) {\r\n      this.SetAwake(true);\r\n    }\r\n  }\r\n\r\n  /// Is this body allowed to sleep\r\n  public IsSleepingAllowed(): boolean {\r\n    return this.m_autoSleepFlag;\r\n  }\r\n\r\n  /// Set the sleep state of the body. A sleeping body has very\r\n  /// low CPU cost.\r\n  /// @param flag set to true to wake the body, false to put it to sleep.\r\n  public SetAwake(flag: boolean): void {\r\n    if (flag) {\r\n      this.m_awakeFlag = true;\r\n      this.m_sleepTime = 0;\r\n    } else {\r\n      this.m_awakeFlag = false;\r\n      this.m_sleepTime = 0;\r\n      this.m_linearVelocity.SetZero();\r\n      this.m_angularVelocity = 0;\r\n      this.m_force.SetZero();\r\n      this.m_torque = 0;\r\n    }\r\n  }\r\n\r\n  /// Get the sleeping state of this body.\r\n  /// @return true if the body is sleeping.\r\n  public IsAwake(): boolean {\r\n    return this.m_awakeFlag;\r\n  }\r\n\r\n  /// Set the active state of the body. An inactive body is not\r\n  /// simulated and cannot be collided with or woken up.\r\n  /// If you pass a flag of true, all fixtures will be added to the\r\n  /// broad-phase.\r\n  /// If you pass a flag of false, all fixtures will be removed from\r\n  /// the broad-phase and all contacts will be destroyed.\r\n  /// Fixtures and joints are otherwise unaffected. You may continue\r\n  /// to create/destroy fixtures and joints on inactive bodies.\r\n  /// Fixtures on an inactive body are implicitly inactive and will\r\n  /// not participate in collisions, ray-casts, or queries.\r\n  /// Joints connected to an inactive body are implicitly inactive.\r\n  /// An inactive body is still owned by a b2World object and remains\r\n  /// in the body list.\r\n  public SetActive(flag: boolean): void {\r\n    if (this.m_world.IsLocked()) {\r\n      throw new Error();\r\n    }\r\n\r\n    if (flag === this.IsActive()) {\r\n      return;\r\n    }\r\n\r\n    this.m_activeFlag = flag;\r\n\r\n    if (flag) {\r\n      // Create all proxies.\r\n      for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n        f.CreateProxies();\r\n      }\r\n      // Contacts are created the next time step.\r\n    } else {\r\n      // Destroy all proxies.\r\n      for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n        f.DestroyProxies();\r\n      }\r\n      // Destroy the attached contacts.\r\n      let ce: b2ContactEdge | null = this.m_contactList;\r\n      while (ce) {\r\n        const ce0: b2ContactEdge = ce;\r\n        ce = ce.next;\r\n        this.m_world.m_contactManager.Destroy(ce0.contact);\r\n      }\r\n      this.m_contactList = null;\r\n    }\r\n  }\r\n\r\n  /// Get the active state of the body.\r\n  public IsActive(): boolean {\r\n    return this.m_activeFlag;\r\n  }\r\n\r\n  /// Set this body to have fixed rotation. This causes the mass\r\n  /// to be reset.\r\n  public SetFixedRotation(flag: boolean): void {\r\n    if (this.m_fixedRotationFlag === flag) {\r\n      return;\r\n    }\r\n\r\n    this.m_fixedRotationFlag = flag;\r\n\r\n    this.m_angularVelocity = 0;\r\n\r\n    this.ResetMassData();\r\n  }\r\n\r\n  /// Does this body have fixed rotation?\r\n  public IsFixedRotation(): boolean {\r\n    return this.m_fixedRotationFlag;\r\n  }\r\n\r\n  /// Get the list of all fixtures attached to this body.\r\n  public GetFixtureList(): b2Fixture | null {\r\n    return this.m_fixtureList;\r\n  }\r\n\r\n  /// Get the list of all joints attached to this body.\r\n  public GetJointList(): b2JointEdge | null {\r\n    return this.m_jointList;\r\n  }\r\n\r\n  /// Get the list of all contacts attached to this body.\r\n  /// @warning this list changes during the time step and you may\r\n  /// miss some collisions if you don't use b2ContactListener.\r\n  public GetContactList(): b2ContactEdge | null {\r\n    return this.m_contactList;\r\n  }\r\n\r\n  /// Get the next body in the world's body list.\r\n  public GetNext(): b2Body | null {\r\n    return this.m_next;\r\n  }\r\n\r\n  /// Get the user data pointer that was provided in the body definition.\r\n  public GetUserData(): any {\r\n    return this.m_userData;\r\n  }\r\n\r\n  /// Set the user data. Use this to store your application specific data.\r\n  public SetUserData(data: any): void {\r\n    this.m_userData = data;\r\n  }\r\n\r\n  /// Get the parent world of this body.\r\n  public GetWorld(): b2World {\r\n    return this.m_world;\r\n  }\r\n\r\n  /// Dump this body to a log file\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    const bodyIndex: number = this.m_islandIndex;\r\n\r\n    log(\"{\\n\");\r\n    log(\"  const bd: b2BodyDef = new b2BodyDef();\\n\");\r\n    let type_str: string = \"\";\r\n    switch (this.m_type) {\r\n      case b2BodyType.b2_staticBody:\r\n        type_str = \"b2BodyType.b2_staticBody\";\r\n        break;\r\n      case b2BodyType.b2_kinematicBody:\r\n        type_str = \"b2BodyType.b2_kinematicBody\";\r\n        break;\r\n      case b2BodyType.b2_dynamicBody:\r\n        type_str = \"b2BodyType.b2_dynamicBody\";\r\n        break;\r\n      default:\r\n        // DEBUG: b2Assert(false);\r\n        break;\r\n    }\r\n    log(\"  bd.type = %s;\\n\", type_str);\r\n    log(\"  bd.position.Set(%.15f, %.15f);\\n\", this.m_xf.p.x, this.m_xf.p.y);\r\n    log(\"  bd.angle = %.15f;\\n\", this.m_sweep.a);\r\n    log(\r\n      \"  bd.linearVelocity.Set(%.15f, %.15f);\\n\",\r\n      this.m_linearVelocity.x,\r\n      this.m_linearVelocity.y\r\n    );\r\n    log(\"  bd.angularVelocity = %.15f;\\n\", this.m_angularVelocity);\r\n    log(\"  bd.linearDamping = %.15f;\\n\", this.m_linearDamping);\r\n    log(\"  bd.angularDamping = %.15f;\\n\", this.m_angularDamping);\r\n    log(\"  bd.allowSleep = %s;\\n\", this.m_autoSleepFlag ? \"true\" : \"false\");\r\n    log(\"  bd.awake = %s;\\n\", this.m_awakeFlag ? \"true\" : \"false\");\r\n    log(\r\n      \"  bd.fixedRotation = %s;\\n\",\r\n      this.m_fixedRotationFlag ? \"true\" : \"false\"\r\n    );\r\n    log(\"  bd.bullet = %s;\\n\", this.m_bulletFlag ? \"true\" : \"false\");\r\n    log(\"  bd.active = %s;\\n\", this.m_activeFlag ? \"true\" : \"false\");\r\n    log(\"  bd.gravityScale = %.15f;\\n\", this.m_gravityScale);\r\n    log(\"\\n\");\r\n    log(\"  bodies[%d] = this.m_world.CreateBody(bd);\\n\", this.m_islandIndex);\r\n    log(\"\\n\");\r\n    for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n      log(\"  {\\n\");\r\n      f.Dump(log, bodyIndex);\r\n      log(\"  }\\n\");\r\n    }\r\n    log(\"}\\n\");\r\n  }\r\n\r\n  private static SynchronizeFixtures_s_xf1: b2Transform = new b2Transform();\r\n  private static SynchronizeFixtures_s_displacement: b2Vec2 = new b2Vec2();\r\n  public SynchronizeFixtures(): void {\r\n    const xf1: b2Transform = b2Body.SynchronizeFixtures_s_xf1;\r\n    xf1.q.SetAngle(this.m_sweep.a0);\r\n    b2Rot.MulRV(xf1.q, this.m_sweep.localCenter, xf1.p);\r\n    b2Vec2.SubVV(this.m_sweep.c0, xf1.p, xf1.p);\r\n\r\n    // const displacement: b2Vec2 = b2Vec2.SubVV(this.m_xf.p, xf1.p, b2Body.SynchronizeFixtures_s_displacement);\r\n    const displacement: b2Vec2 = b2Vec2.SubVV(\r\n      this.m_sweep.c,\r\n      this.m_sweep.c0,\r\n      b2Body.SynchronizeFixtures_s_displacement\r\n    );\r\n\r\n    for (let f: b2Fixture | null = this.m_fixtureList; f; f = f.m_next) {\r\n      f.SynchronizeProxies(xf1, this.m_xf, displacement);\r\n    }\r\n  }\r\n\r\n  public SynchronizeTransform(): void {\r\n    this.m_xf.q.SetAngle(this.m_sweep.a);\r\n    b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n    b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n  }\r\n\r\n  // This is used to prevent connected bodies from colliding.\r\n  // It may lie, depending on the collideConnected flag.\r\n  public ShouldCollide(other: b2Body): boolean {\r\n    // At least one body should be dynamic or kinematic.\r\n    if (\r\n      this.m_type === b2BodyType.b2_staticBody &&\r\n      other.m_type === b2BodyType.b2_staticBody\r\n    ) {\r\n      return false;\r\n    }\r\n    return this.ShouldCollideConnected(other);\r\n  }\r\n\r\n  public ShouldCollideConnected(other: b2Body): boolean {\r\n    // Does a joint prevent collision?\r\n    for (let jn: b2JointEdge | null = this.m_jointList; jn; jn = jn.next) {\r\n      if (jn.other === other) {\r\n        if (!jn.joint.m_collideConnected) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  public Advance(alpha: number): void {\r\n    // Advance to the new safe time. This doesn't sync the broad-phase.\r\n    this.m_sweep.Advance(alpha);\r\n    this.m_sweep.c.Copy(this.m_sweep.c0);\r\n    this.m_sweep.a = this.m_sweep.a0;\r\n    this.m_xf.q.SetAngle(this.m_sweep.a);\r\n    b2Rot.MulRV(this.m_xf.q, this.m_sweep.localCenter, this.m_xf.p);\r\n    b2Vec2.SubVV(this.m_sweep.c, this.m_xf.p, this.m_xf.p);\r\n  }\r\n\r\n  // #if B2_ENABLE_CONTROLLER\r\n  public GetControllerList(): b2ControllerEdge | null {\r\n    return this.m_controllerList;\r\n  }\r\n\r\n  public GetControllerCount(): number {\r\n    return this.m_controllerCount;\r\n  }\r\n  // #endif\r\n}\r\n"]}},"error":null,"hash":"4c8cb1598b666dcde8ee0fe84303b2a3","cacheData":{"env":{}}}