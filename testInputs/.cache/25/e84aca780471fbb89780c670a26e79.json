{"id":"../node_modules/box2d.package.ts/Collision/b2TimeOfImpact.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2Timer","loc":{"line":23,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Timer.ts"},{"name":"./b2Distance","loc":{"line":24,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2TimeOfImpact.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Distance.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Timer_1 = require(\"../Common/b2Timer\");\r\nvar b2Distance_1 = require(\"./b2Distance\");\r\nexports.b2_toiTime = 0;\r\nexports.b2_toiMaxTime = 0;\r\nexports.b2_toiCalls = 0;\r\nexports.b2_toiIters = 0;\r\nexports.b2_toiMaxIters = 0;\r\nexports.b2_toiRootIters = 0;\r\nexports.b2_toiMaxRootIters = 0;\r\nfunction b2_toi_reset() {\r\n    exports.b2_toiTime = 0;\r\n    exports.b2_toiMaxTime = 0;\r\n    exports.b2_toiCalls = 0;\r\n    exports.b2_toiIters = 0;\r\n    exports.b2_toiMaxIters = 0;\r\n    exports.b2_toiRootIters = 0;\r\n    exports.b2_toiMaxRootIters = 0;\r\n}\r\nexports.b2_toi_reset = b2_toi_reset;\r\nvar b2TimeOfImpact_s_xfA = new b2Math_1.b2Transform();\r\nvar b2TimeOfImpact_s_xfB = new b2Math_1.b2Transform();\r\nvar b2TimeOfImpact_s_pointA = new b2Math_1.b2Vec2();\r\nvar b2TimeOfImpact_s_pointB = new b2Math_1.b2Vec2();\r\nvar b2TimeOfImpact_s_normal = new b2Math_1.b2Vec2();\r\nvar b2TimeOfImpact_s_axisA = new b2Math_1.b2Vec2();\r\nvar b2TimeOfImpact_s_axisB = new b2Math_1.b2Vec2();\r\n/// Input parameters for b2TimeOfImpact\r\nvar b2TOIInput = /** @class */ (function () {\r\n    function b2TOIInput() {\r\n        this.proxyA = new b2Distance_1.b2DistanceProxy();\r\n        this.proxyB = new b2Distance_1.b2DistanceProxy();\r\n        this.sweepA = new b2Math_1.b2Sweep();\r\n        this.sweepB = new b2Math_1.b2Sweep();\r\n        this.tMax = 0; // defines sweep interval [0, tMax]\r\n    }\r\n    return b2TOIInput;\r\n}());\r\nexports.b2TOIInput = b2TOIInput;\r\n/// Output parameters for b2TimeOfImpact.\r\nvar b2TOIOutputState;\r\n(function (b2TOIOutputState) {\r\n    b2TOIOutputState[b2TOIOutputState[\"e_unknown\"] = 0] = \"e_unknown\";\r\n    b2TOIOutputState[b2TOIOutputState[\"e_failed\"] = 1] = \"e_failed\";\r\n    b2TOIOutputState[b2TOIOutputState[\"e_overlapped\"] = 2] = \"e_overlapped\";\r\n    b2TOIOutputState[b2TOIOutputState[\"e_touching\"] = 3] = \"e_touching\";\r\n    b2TOIOutputState[b2TOIOutputState[\"e_separated\"] = 4] = \"e_separated\";\r\n})(b2TOIOutputState = exports.b2TOIOutputState || (exports.b2TOIOutputState = {}));\r\nvar b2TOIOutput = /** @class */ (function () {\r\n    function b2TOIOutput() {\r\n        this.state = b2TOIOutputState.e_unknown;\r\n        this.t = 0;\r\n    }\r\n    return b2TOIOutput;\r\n}());\r\nexports.b2TOIOutput = b2TOIOutput;\r\nvar b2SeparationFunctionType;\r\n(function (b2SeparationFunctionType) {\r\n    b2SeparationFunctionType[b2SeparationFunctionType[\"e_unknown\"] = -1] = \"e_unknown\";\r\n    b2SeparationFunctionType[b2SeparationFunctionType[\"e_points\"] = 0] = \"e_points\";\r\n    b2SeparationFunctionType[b2SeparationFunctionType[\"e_faceA\"] = 1] = \"e_faceA\";\r\n    b2SeparationFunctionType[b2SeparationFunctionType[\"e_faceB\"] = 2] = \"e_faceB\";\r\n})(b2SeparationFunctionType = exports.b2SeparationFunctionType || (exports.b2SeparationFunctionType = {}));\r\nvar b2SeparationFunction = /** @class */ (function () {\r\n    function b2SeparationFunction() {\r\n        this.m_sweepA = new b2Math_1.b2Sweep();\r\n        this.m_sweepB = new b2Math_1.b2Sweep();\r\n        this.m_type = b2SeparationFunctionType.e_unknown;\r\n        this.m_localPoint = new b2Math_1.b2Vec2();\r\n        this.m_axis = new b2Math_1.b2Vec2();\r\n    }\r\n    b2SeparationFunction.prototype.Initialize = function (cache, proxyA, sweepA, proxyB, sweepB, t1) {\r\n        this.m_proxyA = proxyA;\r\n        this.m_proxyB = proxyB;\r\n        var count = cache.count;\r\n        // DEBUG: b2Assert(0 < count && count < 3);\r\n        this.m_sweepA.Copy(sweepA);\r\n        this.m_sweepB.Copy(sweepB);\r\n        var xfA = b2TimeOfImpact_s_xfA;\r\n        var xfB = b2TimeOfImpact_s_xfB;\r\n        this.m_sweepA.GetTransform(xfA, t1);\r\n        this.m_sweepB.GetTransform(xfB, t1);\r\n        if (count === 1) {\r\n            this.m_type = b2SeparationFunctionType.e_points;\r\n            var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n            var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n            var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n            var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n            b2Math_1.b2Vec2.SubVV(pointB, pointA, this.m_axis);\r\n            var s = this.m_axis.Normalize();\r\n            // #if B2_ENABLE_PARTICLE\r\n            this.m_localPoint.SetZero();\r\n            // #endif\r\n            return s;\r\n        }\r\n        else if (cache.indexA[0] === cache.indexA[1]) {\r\n            // Two points on B and one on A.\r\n            this.m_type = b2SeparationFunctionType.e_faceB;\r\n            var localPointB1 = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n            var localPointB2 = this.m_proxyB.GetVertex(cache.indexB[1]);\r\n            b2Math_1.b2Vec2.CrossVOne(b2Math_1.b2Vec2.SubVV(localPointB2, localPointB1, b2Math_1.b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n            var normal = b2Math_1.b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n            b2Math_1.b2Vec2.MidVV(localPointB1, localPointB2, this.m_localPoint);\r\n            var pointB = b2Math_1.b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n            var localPointA = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n            var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n            var s = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointA, pointB, b2Math_1.b2Vec2.s_t0), normal);\r\n            if (s < 0) {\r\n                this.m_axis.SelfNeg();\r\n                s = -s;\r\n            }\r\n            return s;\r\n        }\r\n        else {\r\n            // Two points on A and one or two points on B.\r\n            this.m_type = b2SeparationFunctionType.e_faceA;\r\n            var localPointA1 = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n            var localPointA2 = this.m_proxyA.GetVertex(cache.indexA[1]);\r\n            b2Math_1.b2Vec2.CrossVOne(b2Math_1.b2Vec2.SubVV(localPointA2, localPointA1, b2Math_1.b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n            var normal = b2Math_1.b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n            b2Math_1.b2Vec2.MidVV(localPointA1, localPointA2, this.m_localPoint);\r\n            var pointA = b2Math_1.b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n            var localPointB = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n            var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n            var s = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), normal);\r\n            if (s < 0) {\r\n                this.m_axis.SelfNeg();\r\n                s = -s;\r\n            }\r\n            return s;\r\n        }\r\n    };\r\n    b2SeparationFunction.prototype.FindMinSeparation = function (indexA, indexB, t) {\r\n        var xfA = b2TimeOfImpact_s_xfA;\r\n        var xfB = b2TimeOfImpact_s_xfB;\r\n        this.m_sweepA.GetTransform(xfA, t);\r\n        this.m_sweepB.GetTransform(xfB, t);\r\n        switch (this.m_type) {\r\n            case b2SeparationFunctionType.e_points: {\r\n                var axisA = b2Math_1.b2Rot.MulTRV(xfA.q, this.m_axis, b2TimeOfImpact_s_axisA);\r\n                var axisB = b2Math_1.b2Rot.MulTRV(xfB.q, b2Math_1.b2Vec2.NegV(this.m_axis, b2Math_1.b2Vec2.s_t0), b2TimeOfImpact_s_axisB);\r\n                indexA[0] = this.m_proxyA.GetSupport(axisA);\r\n                indexB[0] = this.m_proxyB.GetSupport(axisB);\r\n                var localPointA = this.m_proxyA.GetVertex(indexA[0]);\r\n                var localPointB = this.m_proxyB.GetVertex(indexB[0]);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), this.m_axis);\r\n                return separation;\r\n            }\r\n            case b2SeparationFunctionType.e_faceA: {\r\n                var normal = b2Math_1.b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n                var axisB = b2Math_1.b2Rot.MulTRV(xfB.q, b2Math_1.b2Vec2.NegV(normal, b2Math_1.b2Vec2.s_t0), b2TimeOfImpact_s_axisB);\r\n                indexA[0] = -1;\r\n                indexB[0] = this.m_proxyB.GetSupport(axisB);\r\n                var localPointB = this.m_proxyB.GetVertex(indexB[0]);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), normal);\r\n                return separation;\r\n            }\r\n            case b2SeparationFunctionType.e_faceB: {\r\n                var normal = b2Math_1.b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n                var axisA = b2Math_1.b2Rot.MulTRV(xfA.q, b2Math_1.b2Vec2.NegV(normal, b2Math_1.b2Vec2.s_t0), b2TimeOfImpact_s_axisA);\r\n                indexB[0] = -1;\r\n                indexA[0] = this.m_proxyA.GetSupport(axisA);\r\n                var localPointA = this.m_proxyA.GetVertex(indexA[0]);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointA, pointB, b2Math_1.b2Vec2.s_t0), normal);\r\n                return separation;\r\n            }\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                indexA[0] = -1;\r\n                indexB[0] = -1;\r\n                return 0;\r\n        }\r\n    };\r\n    b2SeparationFunction.prototype.Evaluate = function (indexA, indexB, t) {\r\n        var xfA = b2TimeOfImpact_s_xfA;\r\n        var xfB = b2TimeOfImpact_s_xfB;\r\n        this.m_sweepA.GetTransform(xfA, t);\r\n        this.m_sweepB.GetTransform(xfB, t);\r\n        switch (this.m_type) {\r\n            case b2SeparationFunctionType.e_points: {\r\n                var localPointA = this.m_proxyA.GetVertex(indexA);\r\n                var localPointB = this.m_proxyB.GetVertex(indexB);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), this.m_axis);\r\n                return separation;\r\n            }\r\n            case b2SeparationFunctionType.e_faceA: {\r\n                var normal = b2Math_1.b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n                var localPointB = this.m_proxyB.GetVertex(indexB);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), normal);\r\n                return separation;\r\n            }\r\n            case b2SeparationFunctionType.e_faceB: {\r\n                var normal = b2Math_1.b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n                var pointB = b2Math_1.b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n                var localPointA = this.m_proxyA.GetVertex(indexA);\r\n                var pointA = b2Math_1.b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n                var separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointA, pointB, b2Math_1.b2Vec2.s_t0), normal);\r\n                return separation;\r\n            }\r\n            default:\r\n                // DEBUG: b2Assert(false);\r\n                return 0;\r\n        }\r\n    };\r\n    return b2SeparationFunction;\r\n}());\r\nexports.b2SeparationFunction = b2SeparationFunction;\r\nvar b2TimeOfImpact_s_timer = new b2Timer_1.b2Timer();\r\nvar b2TimeOfImpact_s_cache = new b2Distance_1.b2SimplexCache();\r\nvar b2TimeOfImpact_s_distanceInput = new b2Distance_1.b2DistanceInput();\r\nvar b2TimeOfImpact_s_distanceOutput = new b2Distance_1.b2DistanceOutput();\r\nvar b2TimeOfImpact_s_fcn = new b2SeparationFunction();\r\nvar b2TimeOfImpact_s_indexA = [0];\r\nvar b2TimeOfImpact_s_indexB = [0];\r\nvar b2TimeOfImpact_s_sweepA = new b2Math_1.b2Sweep();\r\nvar b2TimeOfImpact_s_sweepB = new b2Math_1.b2Sweep();\r\nfunction b2TimeOfImpact(output, input) {\r\n    var timer = b2TimeOfImpact_s_timer.Reset();\r\n    ++exports.b2_toiCalls;\r\n    output.state = b2TOIOutputState.e_unknown;\r\n    output.t = input.tMax;\r\n    var proxyA = input.proxyA;\r\n    var proxyB = input.proxyB;\r\n    var maxVertices = b2Math_1.b2Max(b2Settings_1.b2_maxPolygonVertices, b2Math_1.b2Max(proxyA.m_count, proxyB.m_count));\r\n    var sweepA = b2TimeOfImpact_s_sweepA.Copy(input.sweepA);\r\n    var sweepB = b2TimeOfImpact_s_sweepB.Copy(input.sweepB);\r\n    // Large rotations can make the root finder fail, so we normalize the\r\n    // sweep angles.\r\n    sweepA.Normalize();\r\n    sweepB.Normalize();\r\n    var tMax = input.tMax;\r\n    var totalRadius = proxyA.m_radius + proxyB.m_radius;\r\n    var target = b2Math_1.b2Max(b2Settings_1.b2_linearSlop, totalRadius - 3 * b2Settings_1.b2_linearSlop);\r\n    var tolerance = 0.25 * b2Settings_1.b2_linearSlop;\r\n    // DEBUG: b2Assert(target > tolerance);\r\n    var t1 = 0;\r\n    var k_maxIterations = 20; // TODO_ERIN b2Settings\r\n    var iter = 0;\r\n    // Prepare input for distance query.\r\n    var cache = b2TimeOfImpact_s_cache;\r\n    cache.count = 0;\r\n    var distanceInput = b2TimeOfImpact_s_distanceInput;\r\n    distanceInput.proxyA.Copy(input.proxyA);\r\n    distanceInput.proxyB.Copy(input.proxyB);\r\n    distanceInput.useRadii = false;\r\n    // The outer loop progressively attempts to compute new separating axes.\r\n    // This loop terminates when an axis is repeated (no progress is made).\r\n    for (;;) {\r\n        var xfA = b2TimeOfImpact_s_xfA;\r\n        var xfB = b2TimeOfImpact_s_xfB;\r\n        sweepA.GetTransform(xfA, t1);\r\n        sweepB.GetTransform(xfB, t1);\r\n        // Get the distance between shapes. We can also use the results\r\n        // to get a separating axis.\r\n        distanceInput.transformA.Copy(xfA);\r\n        distanceInput.transformB.Copy(xfB);\r\n        var distanceOutput = b2TimeOfImpact_s_distanceOutput;\r\n        b2Distance_1.b2Distance(distanceOutput, cache, distanceInput);\r\n        // If the shapes are overlapped, we give up on continuous collision.\r\n        if (distanceOutput.distance <= 0) {\r\n            // Failure!\r\n            output.state = b2TOIOutputState.e_overlapped;\r\n            output.t = 0;\r\n            break;\r\n        }\r\n        if (distanceOutput.distance < target + tolerance) {\r\n            // Victory!\r\n            output.state = b2TOIOutputState.e_touching;\r\n            output.t = t1;\r\n            break;\r\n        }\r\n        // Initialize the separating axis.\r\n        var fcn = b2TimeOfImpact_s_fcn;\r\n        fcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\r\n        /*\r\n        #if 0\r\n            // Dump the curve seen by the root finder {\r\n              const int32 N = 100;\r\n              float32 dx = 1.0f / N;\r\n              float32 xs[N+1];\r\n              float32 fs[N+1];\r\n        \r\n              float32 x = 0.0f;\r\n        \r\n              for (int32 i = 0; i <= N; ++i) {\r\n                sweepA.GetTransform(&xfA, x);\r\n                sweepB.GetTransform(&xfB, x);\r\n                float32 f = fcn.Evaluate(xfA, xfB) - target;\r\n        \r\n                printf(\"%g %g\\n\", x, f);\r\n        \r\n                xs[i] = x;\r\n                fs[i] = f;\r\n        \r\n                x += dx;\r\n              }\r\n            }\r\n        #endif\r\n        */\r\n        // Compute the TOI on the separating axis. We do this by successively\r\n        // resolving the deepest point. This loop is bounded by the number of vertices.\r\n        var done = false;\r\n        var t2 = tMax;\r\n        var pushBackIter = 0;\r\n        for (;;) {\r\n            // Find the deepest point at t2. Store the witness point indices.\r\n            var indexA = b2TimeOfImpact_s_indexA;\r\n            var indexB = b2TimeOfImpact_s_indexB;\r\n            var s2 = fcn.FindMinSeparation(indexA, indexB, t2);\r\n            // Is the final configuration separated?\r\n            if (s2 > (target + tolerance)) {\r\n                // Victory!\r\n                output.state = b2TOIOutputState.e_separated;\r\n                output.t = tMax;\r\n                done = true;\r\n                break;\r\n            }\r\n            // Has the separation reached tolerance?\r\n            if (s2 > (target - tolerance)) {\r\n                // Advance the sweeps\r\n                t1 = t2;\r\n                break;\r\n            }\r\n            // Compute the initial separation of the witness points.\r\n            var s1 = fcn.Evaluate(indexA[0], indexB[0], t1);\r\n            // Check for initial overlap. This might happen if the root finder\r\n            // runs out of iterations.\r\n            if (s1 < (target - tolerance)) {\r\n                output.state = b2TOIOutputState.e_failed;\r\n                output.t = t1;\r\n                done = true;\r\n                break;\r\n            }\r\n            // Check for touching\r\n            if (s1 <= (target + tolerance)) {\r\n                // Victory! t1 should hold the TOI (could be 0.0).\r\n                output.state = b2TOIOutputState.e_touching;\r\n                output.t = t1;\r\n                done = true;\r\n                break;\r\n            }\r\n            // Compute 1D root of: f(x) - target = 0\r\n            var rootIterCount = 0;\r\n            var a1 = t1;\r\n            var a2 = t2;\r\n            for (;;) {\r\n                // Use a mix of the secant rule and bisection.\r\n                var t = 0;\r\n                if (rootIterCount & 1) {\r\n                    // Secant rule to improve convergence.\r\n                    t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\r\n                }\r\n                else {\r\n                    // Bisection to guarantee progress.\r\n                    t = 0.5 * (a1 + a2);\r\n                }\r\n                ++rootIterCount;\r\n                ++exports.b2_toiRootIters;\r\n                var s = fcn.Evaluate(indexA[0], indexB[0], t);\r\n                if (b2Math_1.b2Abs(s - target) < tolerance) {\r\n                    // t2 holds a tentative value for t1\r\n                    t2 = t;\r\n                    break;\r\n                }\r\n                // Ensure we continue to bracket the root.\r\n                if (s > target) {\r\n                    a1 = t;\r\n                    s1 = s;\r\n                }\r\n                else {\r\n                    a2 = t;\r\n                    s2 = s;\r\n                }\r\n                if (rootIterCount === 50) {\r\n                    break;\r\n                }\r\n            }\r\n            exports.b2_toiMaxRootIters = b2Math_1.b2Max(exports.b2_toiMaxRootIters, rootIterCount);\r\n            ++pushBackIter;\r\n            if (pushBackIter === maxVertices) {\r\n                break;\r\n            }\r\n        }\r\n        ++iter;\r\n        ++exports.b2_toiIters;\r\n        if (done) {\r\n            break;\r\n        }\r\n        if (iter === k_maxIterations) {\r\n            // Root finder got stuck. Semi-victory.\r\n            output.state = b2TOIOutputState.e_failed;\r\n            output.t = t1;\r\n            break;\r\n        }\r\n    }\r\n    exports.b2_toiMaxIters = b2Math_1.b2Max(exports.b2_toiMaxIters, iter);\r\n    var time = timer.GetMilliseconds();\r\n    exports.b2_toiMaxTime = b2Math_1.b2Max(exports.b2_toiMaxTime, time);\r\n    exports.b2_toiTime += time;\r\n}\r\nexports.b2TimeOfImpact = b2TimeOfImpact;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2TimeOfImpact.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2TimeOfImpact.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_linearSlop, b2_maxPolygonVertices } from \"../Common/b2Settings\";\r\nimport { b2Abs, b2Max, b2Vec2, b2Rot, b2Transform, b2Sweep } from \"../Common/b2Math\";\r\nimport { b2Timer } from \"../Common/b2Timer\";\r\nimport { b2Distance, b2DistanceInput, b2DistanceOutput, b2DistanceProxy, b2SimplexCache } from \"./b2Distance\";\r\n\r\nexport let b2_toiTime: number = 0;\r\nexport let b2_toiMaxTime: number = 0;\r\nexport let b2_toiCalls: number = 0;\r\nexport let b2_toiIters: number = 0;\r\nexport let b2_toiMaxIters: number = 0;\r\nexport let b2_toiRootIters: number = 0;\r\nexport let b2_toiMaxRootIters: number = 0;\r\nexport function b2_toi_reset(): void {\r\n  b2_toiTime = 0;\r\n  b2_toiMaxTime = 0;\r\n  b2_toiCalls = 0;\r\n  b2_toiIters = 0;\r\n  b2_toiMaxIters = 0;\r\n  b2_toiRootIters = 0;\r\n  b2_toiMaxRootIters = 0;\r\n}\r\n\r\nconst b2TimeOfImpact_s_xfA: b2Transform = new b2Transform();\r\nconst b2TimeOfImpact_s_xfB: b2Transform = new b2Transform();\r\nconst b2TimeOfImpact_s_pointA: b2Vec2 = new b2Vec2();\r\nconst b2TimeOfImpact_s_pointB: b2Vec2 = new b2Vec2();\r\nconst b2TimeOfImpact_s_normal: b2Vec2 = new b2Vec2();\r\nconst b2TimeOfImpact_s_axisA: b2Vec2 = new b2Vec2();\r\nconst b2TimeOfImpact_s_axisB: b2Vec2 = new b2Vec2();\r\n\r\n/// Input parameters for b2TimeOfImpact\r\nexport class b2TOIInput {\r\n  public readonly proxyA: b2DistanceProxy = new b2DistanceProxy();\r\n  public readonly proxyB: b2DistanceProxy = new b2DistanceProxy();\r\n  public readonly sweepA: b2Sweep = new b2Sweep();\r\n  public readonly sweepB: b2Sweep = new b2Sweep();\r\n  public tMax: number = 0; // defines sweep interval [0, tMax]\r\n}\r\n\r\n/// Output parameters for b2TimeOfImpact.\r\nexport enum b2TOIOutputState {\r\n  e_unknown = 0,\r\n  e_failed = 1,\r\n  e_overlapped = 2,\r\n  e_touching = 3,\r\n  e_separated = 4,\r\n}\r\n\r\nexport class b2TOIOutput {\r\n  public state = b2TOIOutputState.e_unknown;\r\n  public t: number = 0;\r\n}\r\n\r\nexport enum b2SeparationFunctionType {\r\n  e_unknown = -1,\r\n  e_points = 0,\r\n  e_faceA = 1,\r\n  e_faceB = 2,\r\n}\r\n\r\nexport class b2SeparationFunction {\r\n  public m_proxyA!: b2DistanceProxy;\r\n  public m_proxyB!: b2DistanceProxy;\r\n  public readonly m_sweepA: b2Sweep = new b2Sweep();\r\n  public readonly m_sweepB: b2Sweep = new b2Sweep();\r\n  public m_type: b2SeparationFunctionType = b2SeparationFunctionType.e_unknown;\r\n  public readonly m_localPoint: b2Vec2 = new b2Vec2();\r\n  public readonly m_axis: b2Vec2 = new b2Vec2();\r\n\r\n  public Initialize(cache: b2SimplexCache, proxyA: b2DistanceProxy, sweepA: b2Sweep, proxyB: b2DistanceProxy, sweepB: b2Sweep, t1: number): number {\r\n    this.m_proxyA = proxyA;\r\n    this.m_proxyB = proxyB;\r\n    const count: number = cache.count;\r\n    // DEBUG: b2Assert(0 < count && count < 3);\r\n\r\n    this.m_sweepA.Copy(sweepA);\r\n    this.m_sweepB.Copy(sweepB);\r\n\r\n    const xfA: b2Transform = b2TimeOfImpact_s_xfA;\r\n    const xfB: b2Transform = b2TimeOfImpact_s_xfB;\r\n    this.m_sweepA.GetTransform(xfA, t1);\r\n    this.m_sweepB.GetTransform(xfB, t1);\r\n\r\n    if (count === 1) {\r\n      this.m_type = b2SeparationFunctionType.e_points;\r\n      const localPointA: b2Vec2 = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n      const localPointB: b2Vec2 = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n      const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n      const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n      b2Vec2.SubVV(pointB, pointA, this.m_axis);\r\n      const s: number = this.m_axis.Normalize();\r\n      // #if B2_ENABLE_PARTICLE\r\n      this.m_localPoint.SetZero();\r\n      // #endif\r\n      return s;\r\n    } else if (cache.indexA[0] === cache.indexA[1]) {\r\n      // Two points on B and one on A.\r\n      this.m_type = b2SeparationFunctionType.e_faceB;\r\n      const localPointB1: b2Vec2 = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n      const localPointB2: b2Vec2 = this.m_proxyB.GetVertex(cache.indexB[1]);\r\n\r\n      b2Vec2.CrossVOne(b2Vec2.SubVV(localPointB2, localPointB1, b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n      const normal: b2Vec2 = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n\r\n      b2Vec2.MidVV(localPointB1, localPointB2, this.m_localPoint);\r\n      const pointB: b2Vec2 = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n\r\n      const localPointA: b2Vec2 = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n      const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n\r\n      let s: number = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);\r\n      if (s < 0) {\r\n        this.m_axis.SelfNeg();\r\n        s = -s;\r\n      }\r\n      return s;\r\n    } else {\r\n      // Two points on A and one or two points on B.\r\n      this.m_type = b2SeparationFunctionType.e_faceA;\r\n      const localPointA1: b2Vec2 = this.m_proxyA.GetVertex(cache.indexA[0]);\r\n      const localPointA2: b2Vec2 = this.m_proxyA.GetVertex(cache.indexA[1]);\r\n\r\n      b2Vec2.CrossVOne(b2Vec2.SubVV(localPointA2, localPointA1, b2Vec2.s_t0), this.m_axis).SelfNormalize();\r\n      const normal: b2Vec2 = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n\r\n      b2Vec2.MidVV(localPointA1, localPointA2, this.m_localPoint);\r\n      const pointA: b2Vec2 = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n\r\n      const localPointB: b2Vec2 = this.m_proxyB.GetVertex(cache.indexB[0]);\r\n      const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n\r\n      let s: number = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);\r\n      if (s < 0) {\r\n        this.m_axis.SelfNeg();\r\n        s = -s;\r\n      }\r\n      return s;\r\n    }\r\n  }\r\n\r\n  public FindMinSeparation(indexA: [number], indexB: [number], t: number): number {\r\n    const xfA: b2Transform = b2TimeOfImpact_s_xfA;\r\n    const xfB: b2Transform = b2TimeOfImpact_s_xfB;\r\n    this.m_sweepA.GetTransform(xfA, t);\r\n    this.m_sweepB.GetTransform(xfB, t);\r\n\r\n    switch (this.m_type) {\r\n    case b2SeparationFunctionType.e_points: {\r\n        const axisA: b2Vec2 = b2Rot.MulTRV(xfA.q, this.m_axis, b2TimeOfImpact_s_axisA);\r\n        const axisB: b2Vec2 = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(this.m_axis, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);\r\n\r\n        indexA[0] = this.m_proxyA.GetSupport(axisA);\r\n        indexB[0] = this.m_proxyB.GetSupport(axisB);\r\n\r\n        const localPointA: b2Vec2 = this.m_proxyA.GetVertex(indexA[0]);\r\n        const localPointB: b2Vec2 = this.m_proxyB.GetVertex(indexB[0]);\r\n\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);\r\n        return separation;\r\n      }\r\n\r\n    case b2SeparationFunctionType.e_faceA: {\r\n        const normal: b2Vec2 = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n\r\n        const axisB: b2Vec2 = b2Rot.MulTRV(xfB.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisB);\r\n\r\n        indexA[0] = -1;\r\n        indexB[0] = this.m_proxyB.GetSupport(axisB);\r\n\r\n        const localPointB: b2Vec2 = this.m_proxyB.GetVertex(indexB[0]);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);\r\n        return separation;\r\n      }\r\n\r\n    case b2SeparationFunctionType.e_faceB: {\r\n        const normal: b2Vec2 = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n\r\n        const axisA: b2Vec2 = b2Rot.MulTRV(xfA.q, b2Vec2.NegV(normal, b2Vec2.s_t0), b2TimeOfImpact_s_axisA);\r\n\r\n        indexB[0] = -1;\r\n        indexA[0] = this.m_proxyA.GetSupport(axisA);\r\n\r\n        const localPointA: b2Vec2 = this.m_proxyA.GetVertex(indexA[0]);\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);\r\n        return separation;\r\n      }\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      indexA[0] = -1;\r\n      indexB[0] = -1;\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  public Evaluate(indexA: number, indexB: number, t: number): number {\r\n    const xfA: b2Transform = b2TimeOfImpact_s_xfA;\r\n    const xfB: b2Transform = b2TimeOfImpact_s_xfB;\r\n    this.m_sweepA.GetTransform(xfA, t);\r\n    this.m_sweepB.GetTransform(xfB, t);\r\n\r\n    switch (this.m_type) {\r\n    case b2SeparationFunctionType.e_points: {\r\n        const localPointA: b2Vec2 = this.m_proxyA.GetVertex(indexA);\r\n        const localPointB: b2Vec2 = this.m_proxyB.GetVertex(indexB);\r\n\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.m_axis);\r\n\r\n        return separation;\r\n      }\r\n\r\n    case b2SeparationFunctionType.e_faceA: {\r\n        const normal: b2Vec2 = b2Rot.MulRV(xfA.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, this.m_localPoint, b2TimeOfImpact_s_pointA);\r\n\r\n        const localPointB: b2Vec2 = this.m_proxyB.GetVertex(indexB);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, localPointB, b2TimeOfImpact_s_pointB);\r\n\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), normal);\r\n        return separation;\r\n      }\r\n\r\n    case b2SeparationFunctionType.e_faceB: {\r\n        const normal: b2Vec2 = b2Rot.MulRV(xfB.q, this.m_axis, b2TimeOfImpact_s_normal);\r\n        const pointB: b2Vec2 = b2Transform.MulXV(xfB, this.m_localPoint, b2TimeOfImpact_s_pointB);\r\n\r\n        const localPointA: b2Vec2 = this.m_proxyA.GetVertex(indexA);\r\n        const pointA: b2Vec2 = b2Transform.MulXV(xfA, localPointA, b2TimeOfImpact_s_pointA);\r\n\r\n        const separation: number = b2Vec2.DotVV(b2Vec2.SubVV(pointA, pointB, b2Vec2.s_t0), normal);\r\n        return separation;\r\n      }\r\n\r\n    default:\r\n      // DEBUG: b2Assert(false);\r\n      return 0;\r\n    }\r\n  }\r\n}\r\n\r\nconst b2TimeOfImpact_s_timer: b2Timer = new b2Timer();\r\nconst b2TimeOfImpact_s_cache: b2SimplexCache = new b2SimplexCache();\r\nconst b2TimeOfImpact_s_distanceInput: b2DistanceInput = new b2DistanceInput();\r\nconst b2TimeOfImpact_s_distanceOutput: b2DistanceOutput = new b2DistanceOutput();\r\nconst b2TimeOfImpact_s_fcn: b2SeparationFunction = new b2SeparationFunction();\r\nconst b2TimeOfImpact_s_indexA: [number] = [ 0 ];\r\nconst b2TimeOfImpact_s_indexB: [number] = [ 0 ];\r\nconst b2TimeOfImpact_s_sweepA: b2Sweep = new b2Sweep();\r\nconst b2TimeOfImpact_s_sweepB: b2Sweep = new b2Sweep();\r\nexport function b2TimeOfImpact(output: b2TOIOutput, input: b2TOIInput): void {\r\n  const timer: b2Timer = b2TimeOfImpact_s_timer.Reset();\r\n\r\n  ++b2_toiCalls;\r\n\r\n  output.state = b2TOIOutputState.e_unknown;\r\n  output.t = input.tMax;\r\n\r\n  const proxyA: b2DistanceProxy = input.proxyA;\r\n  const proxyB: b2DistanceProxy = input.proxyB;\r\n  const maxVertices: number = b2Max(b2_maxPolygonVertices, b2Max(proxyA.m_count, proxyB.m_count));\r\n\r\n  const sweepA: b2Sweep = b2TimeOfImpact_s_sweepA.Copy(input.sweepA);\r\n  const sweepB: b2Sweep = b2TimeOfImpact_s_sweepB.Copy(input.sweepB);\r\n\r\n  // Large rotations can make the root finder fail, so we normalize the\r\n  // sweep angles.\r\n  sweepA.Normalize();\r\n  sweepB.Normalize();\r\n\r\n  const tMax: number = input.tMax;\r\n\r\n  const totalRadius: number = proxyA.m_radius + proxyB.m_radius;\r\n  const target: number = b2Max(b2_linearSlop, totalRadius - 3 * b2_linearSlop);\r\n  const tolerance: number = 0.25 * b2_linearSlop;\r\n  // DEBUG: b2Assert(target > tolerance);\r\n\r\n  let t1: number = 0;\r\n  const k_maxIterations: number = 20; // TODO_ERIN b2Settings\r\n  let iter: number = 0;\r\n\r\n  // Prepare input for distance query.\r\n  const cache: b2SimplexCache = b2TimeOfImpact_s_cache;\r\n  cache.count = 0;\r\n  const distanceInput: b2DistanceInput = b2TimeOfImpact_s_distanceInput;\r\n  distanceInput.proxyA.Copy(input.proxyA);\r\n  distanceInput.proxyB.Copy(input.proxyB);\r\n  distanceInput.useRadii = false;\r\n\r\n  // The outer loop progressively attempts to compute new separating axes.\r\n  // This loop terminates when an axis is repeated (no progress is made).\r\n  for (; ; ) {\r\n    const xfA: b2Transform = b2TimeOfImpact_s_xfA;\r\n    const xfB: b2Transform = b2TimeOfImpact_s_xfB;\r\n    sweepA.GetTransform(xfA, t1);\r\n    sweepB.GetTransform(xfB, t1);\r\n\r\n    // Get the distance between shapes. We can also use the results\r\n    // to get a separating axis.\r\n    distanceInput.transformA.Copy(xfA);\r\n    distanceInput.transformB.Copy(xfB);\r\n    const distanceOutput: b2DistanceOutput = b2TimeOfImpact_s_distanceOutput;\r\n    b2Distance(distanceOutput, cache, distanceInput);\r\n\r\n    // If the shapes are overlapped, we give up on continuous collision.\r\n    if (distanceOutput.distance <= 0) {\r\n      // Failure!\r\n      output.state = b2TOIOutputState.e_overlapped;\r\n      output.t = 0;\r\n      break;\r\n    }\r\n\r\n    if (distanceOutput.distance < target + tolerance) {\r\n      // Victory!\r\n      output.state = b2TOIOutputState.e_touching;\r\n      output.t = t1;\r\n      break;\r\n    }\r\n\r\n    // Initialize the separating axis.\r\n    const fcn: b2SeparationFunction = b2TimeOfImpact_s_fcn;\r\n    fcn.Initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\r\n/*\r\n#if 0\r\n    // Dump the curve seen by the root finder {\r\n      const int32 N = 100;\r\n      float32 dx = 1.0f / N;\r\n      float32 xs[N+1];\r\n      float32 fs[N+1];\r\n\r\n      float32 x = 0.0f;\r\n\r\n      for (int32 i = 0; i <= N; ++i) {\r\n        sweepA.GetTransform(&xfA, x);\r\n        sweepB.GetTransform(&xfB, x);\r\n        float32 f = fcn.Evaluate(xfA, xfB) - target;\r\n\r\n        printf(\"%g %g\\n\", x, f);\r\n\r\n        xs[i] = x;\r\n        fs[i] = f;\r\n\r\n        x += dx;\r\n      }\r\n    }\r\n#endif\r\n*/\r\n\r\n    // Compute the TOI on the separating axis. We do this by successively\r\n    // resolving the deepest point. This loop is bounded by the number of vertices.\r\n    let done: boolean = false;\r\n    let t2: number = tMax;\r\n    let pushBackIter: number = 0;\r\n    for (; ; ) {\r\n      // Find the deepest point at t2. Store the witness point indices.\r\n      const indexA: [number] = b2TimeOfImpact_s_indexA;\r\n      const indexB: [number] = b2TimeOfImpact_s_indexB;\r\n      let s2: number = fcn.FindMinSeparation(indexA, indexB, t2);\r\n\r\n      // Is the final configuration separated?\r\n      if (s2 > (target + tolerance)) {\r\n        // Victory!\r\n        output.state = b2TOIOutputState.e_separated;\r\n        output.t = tMax;\r\n        done = true;\r\n        break;\r\n      }\r\n\r\n      // Has the separation reached tolerance?\r\n      if (s2 > (target - tolerance)) {\r\n        // Advance the sweeps\r\n        t1 = t2;\r\n        break;\r\n      }\r\n\r\n      // Compute the initial separation of the witness points.\r\n      let s1: number = fcn.Evaluate(indexA[0], indexB[0], t1);\r\n\r\n      // Check for initial overlap. This might happen if the root finder\r\n      // runs out of iterations.\r\n      if (s1 < (target - tolerance)) {\r\n        output.state = b2TOIOutputState.e_failed;\r\n        output.t = t1;\r\n        done = true;\r\n        break;\r\n      }\r\n\r\n      // Check for touching\r\n      if (s1 <= (target + tolerance)) {\r\n        // Victory! t1 should hold the TOI (could be 0.0).\r\n        output.state = b2TOIOutputState.e_touching;\r\n        output.t = t1;\r\n        done = true;\r\n        break;\r\n      }\r\n\r\n      // Compute 1D root of: f(x) - target = 0\r\n      let rootIterCount: number = 0;\r\n      let a1: number = t1;\r\n      let a2: number = t2;\r\n      for (; ; ) {\r\n        // Use a mix of the secant rule and bisection.\r\n        let t: number = 0;\r\n        if (rootIterCount & 1) {\r\n          // Secant rule to improve convergence.\r\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\r\n        } else {\r\n          // Bisection to guarantee progress.\r\n          t = 0.5 * (a1 + a2);\r\n        }\r\n\r\n        ++rootIterCount;\r\n        ++b2_toiRootIters;\r\n\r\n        const s: number = fcn.Evaluate(indexA[0], indexB[0], t);\r\n\r\n        if (b2Abs(s - target) < tolerance) {\r\n          // t2 holds a tentative value for t1\r\n          t2 = t;\r\n          break;\r\n        }\r\n\r\n        // Ensure we continue to bracket the root.\r\n        if (s > target) {\r\n          a1 = t;\r\n          s1 = s;\r\n        } else {\r\n          a2 = t;\r\n          s2 = s;\r\n        }\r\n\r\n        if (rootIterCount === 50) {\r\n          break;\r\n        }\r\n      }\r\n\r\n      b2_toiMaxRootIters = b2Max(b2_toiMaxRootIters, rootIterCount);\r\n\r\n      ++pushBackIter;\r\n\r\n      if (pushBackIter === maxVertices) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    ++iter;\r\n    ++b2_toiIters;\r\n\r\n    if (done) {\r\n      break;\r\n    }\r\n\r\n    if (iter === k_maxIterations) {\r\n      // Root finder got stuck. Semi-victory.\r\n      output.state = b2TOIOutputState.e_failed;\r\n      output.t = t1;\r\n      break;\r\n    }\r\n  }\r\n\r\n  b2_toiMaxIters = b2Max(b2_toiMaxIters, iter);\r\n\r\n  const time: number = timer.GetMilliseconds();\r\n  b2_toiMaxTime = b2Max(b2_toiMaxTime, time);\r\n  b2_toiTime += time;\r\n}\r\n"]}},"error":null,"hash":"df961c20f0564d1969d276aa7dc54a38","cacheData":{"env":{}}}