{"id":"../node_modules/box2d.package.ts/Dynamics/Joints/b2RevoluteJoint.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":30,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2RevoluteJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":31,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2RevoluteJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Joint","loc":{"line":32,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2RevoluteJoint.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Joints\\b2Joint.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Joint_1 = require(\"./b2Joint\");\r\n/// Revolute joint definition. This requires defining an\r\n/// anchor point where the bodies are joined. The definition\r\n/// uses local anchor points so that the initial configuration\r\n/// can violate the constraint slightly. You also need to\r\n/// specify the initial relative angle for joint limits. This\r\n/// helps when saving and loading a game.\r\n/// The local anchor points are measured from the body's origin\r\n/// rather than the center of mass because:\r\n/// 1. you might not know where the center of mass will be.\r\n/// 2. if you add/remove shapes from a body and recompute the mass,\r\n///    the joints will be broken.\r\nvar b2RevoluteJointDef = /** @class */ (function (_super) {\r\n    __extends(b2RevoluteJointDef, _super);\r\n    function b2RevoluteJointDef() {\r\n        var _this = _super.call(this, b2Joint_1.b2JointType.e_revoluteJoint) || this;\r\n        _this.localAnchorA = new b2Math_1.b2Vec2(0, 0);\r\n        _this.localAnchorB = new b2Math_1.b2Vec2(0, 0);\r\n        _this.referenceAngle = 0;\r\n        _this.enableLimit = false;\r\n        _this.lowerAngle = 0;\r\n        _this.upperAngle = 0;\r\n        _this.enableMotor = false;\r\n        _this.motorSpeed = 0;\r\n        _this.maxMotorTorque = 0;\r\n        return _this;\r\n    }\r\n    b2RevoluteJointDef.prototype.Initialize = function (bA, bB, anchor) {\r\n        this.bodyA = bA;\r\n        this.bodyB = bB;\r\n        this.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n        this.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n        this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();\r\n    };\r\n    return b2RevoluteJointDef;\r\n}(b2Joint_1.b2JointDef));\r\nexports.b2RevoluteJointDef = b2RevoluteJointDef;\r\nvar b2RevoluteJoint = /** @class */ (function (_super) {\r\n    __extends(b2RevoluteJoint, _super);\r\n    function b2RevoluteJoint(def) {\r\n        var _this = _super.call(this, def) || this;\r\n        // Solver shared\r\n        _this.m_localAnchorA = new b2Math_1.b2Vec2();\r\n        _this.m_localAnchorB = new b2Math_1.b2Vec2();\r\n        _this.m_impulse = new b2Math_1.b2Vec3();\r\n        _this.m_motorImpulse = 0;\r\n        _this.m_enableMotor = false;\r\n        _this.m_maxMotorTorque = 0;\r\n        _this.m_motorSpeed = 0;\r\n        _this.m_enableLimit = false;\r\n        _this.m_referenceAngle = 0;\r\n        _this.m_lowerAngle = 0;\r\n        _this.m_upperAngle = 0;\r\n        // Solver temp\r\n        _this.m_indexA = 0;\r\n        _this.m_indexB = 0;\r\n        _this.m_rA = new b2Math_1.b2Vec2();\r\n        _this.m_rB = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterA = new b2Math_1.b2Vec2();\r\n        _this.m_localCenterB = new b2Math_1.b2Vec2();\r\n        _this.m_invMassA = 0;\r\n        _this.m_invMassB = 0;\r\n        _this.m_invIA = 0;\r\n        _this.m_invIB = 0;\r\n        _this.m_mass = new b2Math_1.b2Mat33(); // effective mass for point-to-point constraint.\r\n        _this.m_motorMass = 0; // effective mass for motor/limit angular constraint.\r\n        _this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n        _this.m_qA = new b2Math_1.b2Rot();\r\n        _this.m_qB = new b2Math_1.b2Rot();\r\n        _this.m_lalcA = new b2Math_1.b2Vec2();\r\n        _this.m_lalcB = new b2Math_1.b2Vec2();\r\n        _this.m_K = new b2Math_1.b2Mat22();\r\n        _this.m_localAnchorA.Copy(b2Settings_1.b2Maybe(def.localAnchorA, b2Math_1.b2Vec2.ZERO));\r\n        _this.m_localAnchorB.Copy(b2Settings_1.b2Maybe(def.localAnchorB, b2Math_1.b2Vec2.ZERO));\r\n        _this.m_referenceAngle = b2Settings_1.b2Maybe(def.referenceAngle, 0);\r\n        _this.m_impulse.SetZero();\r\n        _this.m_motorImpulse = 0;\r\n        _this.m_lowerAngle = b2Settings_1.b2Maybe(def.lowerAngle, 0);\r\n        _this.m_upperAngle = b2Settings_1.b2Maybe(def.upperAngle, 0);\r\n        _this.m_maxMotorTorque = b2Settings_1.b2Maybe(def.maxMotorTorque, 0);\r\n        _this.m_motorSpeed = b2Settings_1.b2Maybe(def.motorSpeed, 0);\r\n        _this.m_enableLimit = b2Settings_1.b2Maybe(def.enableLimit, false);\r\n        _this.m_enableMotor = b2Settings_1.b2Maybe(def.enableMotor, false);\r\n        _this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n        return _this;\r\n    }\r\n    b2RevoluteJoint.prototype.InitVelocityConstraints = function (data) {\r\n        this.m_indexA = this.m_bodyA.m_islandIndex;\r\n        this.m_indexB = this.m_bodyB.m_islandIndex;\r\n        this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n        this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n        this.m_invMassA = this.m_bodyA.m_invMass;\r\n        this.m_invMassB = this.m_bodyB.m_invMass;\r\n        this.m_invIA = this.m_bodyA.m_invI;\r\n        this.m_invIB = this.m_bodyB.m_invI;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        // b2Rot qA(aA), qB(aB);\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n        b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n        // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n        b2Math_1.b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n        b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n        // J = [-I -r1_skew I r2_skew]\r\n        //     [ 0       -1 0       1]\r\n        // r_skew = [-ry; rx]\r\n        // Matlab\r\n        // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n        //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n        //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        var fixedRotation = (iA + iB === 0);\r\n        this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\r\n        this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\r\n        this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\r\n        this.m_mass.ex.y = this.m_mass.ey.x;\r\n        this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\r\n        this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\r\n        this.m_mass.ex.z = this.m_mass.ez.x;\r\n        this.m_mass.ey.z = this.m_mass.ez.y;\r\n        this.m_mass.ez.z = iA + iB;\r\n        this.m_motorMass = iA + iB;\r\n        if (this.m_motorMass > 0) {\r\n            this.m_motorMass = 1 / this.m_motorMass;\r\n        }\r\n        if (!this.m_enableMotor || fixedRotation) {\r\n            this.m_motorImpulse = 0;\r\n        }\r\n        if (this.m_enableLimit && !fixedRotation) {\r\n            var jointAngle = aB - aA - this.m_referenceAngle;\r\n            if (b2Math_1.b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2Settings_1.b2_angularSlop) {\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_equalLimits;\r\n            }\r\n            else if (jointAngle <= this.m_lowerAngle) {\r\n                if (this.m_limitState !== b2Joint_1.b2LimitState.e_atLowerLimit) {\r\n                    this.m_impulse.z = 0;\r\n                }\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_atLowerLimit;\r\n            }\r\n            else if (jointAngle >= this.m_upperAngle) {\r\n                if (this.m_limitState !== b2Joint_1.b2LimitState.e_atUpperLimit) {\r\n                    this.m_impulse.z = 0;\r\n                }\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_atUpperLimit;\r\n            }\r\n            else {\r\n                this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n                this.m_impulse.z = 0;\r\n            }\r\n        }\r\n        else {\r\n            this.m_limitState = b2Joint_1.b2LimitState.e_inactiveLimit;\r\n        }\r\n        if (data.step.warmStarting) {\r\n            // Scale impulses to support a variable time step.\r\n            this.m_impulse.SelfMul(data.step.dtRatio);\r\n            this.m_motorImpulse *= data.step.dtRatio;\r\n            // b2Vec2 P(m_impulse.x, m_impulse.y);\r\n            var P = b2RevoluteJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * (b2Math_1.b2Vec2.CrossVV(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * (b2Math_1.b2Vec2.CrossVV(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\r\n        }\r\n        else {\r\n            this.m_impulse.SetZero();\r\n            this.m_motorImpulse = 0;\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2RevoluteJoint.prototype.SolveVelocityConstraints = function (data) {\r\n        var vA = data.velocities[this.m_indexA].v;\r\n        var wA = data.velocities[this.m_indexA].w;\r\n        var vB = data.velocities[this.m_indexB].v;\r\n        var wB = data.velocities[this.m_indexB].w;\r\n        var mA = this.m_invMassA, mB = this.m_invMassB;\r\n        var iA = this.m_invIA, iB = this.m_invIB;\r\n        var fixedRotation = (iA + iB === 0);\r\n        // Solve motor constraint.\r\n        if (this.m_enableMotor && this.m_limitState !== b2Joint_1.b2LimitState.e_equalLimits && !fixedRotation) {\r\n            var Cdot = wB - wA - this.m_motorSpeed;\r\n            var impulse = -this.m_motorMass * Cdot;\r\n            var oldImpulse = this.m_motorImpulse;\r\n            var maxImpulse = data.step.dt * this.m_maxMotorTorque;\r\n            this.m_motorImpulse = b2Math_1.b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n            impulse = this.m_motorImpulse - oldImpulse;\r\n            wA -= iA * impulse;\r\n            wB += iB * impulse;\r\n        }\r\n        // Solve limit constraint.\r\n        if (this.m_enableLimit && this.m_limitState !== b2Joint_1.b2LimitState.e_inactiveLimit && !fixedRotation) {\r\n            // b2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n            var Cdot1 = b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Math_1.b2Vec2.s_t1), b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1);\r\n            var Cdot2 = wB - wA;\r\n            // b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n            // b2Vec3 impulse = -this.m_mass.Solve33(Cdot);\r\n            var impulse_v3 = this.m_mass.Solve33(Cdot1.x, Cdot1.y, Cdot2, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3).SelfNeg();\r\n            if (this.m_limitState === b2Joint_1.b2LimitState.e_equalLimits) {\r\n                this.m_impulse.SelfAdd(impulse_v3);\r\n            }\r\n            else if (this.m_limitState === b2Joint_1.b2LimitState.e_atLowerLimit) {\r\n                var newImpulse = this.m_impulse.z + impulse_v3.z;\r\n                if (newImpulse < 0) {\r\n                    // b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n                    var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n                    var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n                    var reduced_v2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);\r\n                    impulse_v3.x = reduced_v2.x;\r\n                    impulse_v3.y = reduced_v2.y;\r\n                    impulse_v3.z = -this.m_impulse.z;\r\n                    this.m_impulse.x += reduced_v2.x;\r\n                    this.m_impulse.y += reduced_v2.y;\r\n                    this.m_impulse.z = 0;\r\n                }\r\n                else {\r\n                    this.m_impulse.SelfAdd(impulse_v3);\r\n                }\r\n            }\r\n            else if (this.m_limitState === b2Joint_1.b2LimitState.e_atUpperLimit) {\r\n                var newImpulse = this.m_impulse.z + impulse_v3.z;\r\n                if (newImpulse > 0) {\r\n                    // b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n                    var rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n                    var rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n                    var reduced_v2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);\r\n                    impulse_v3.x = reduced_v2.x;\r\n                    impulse_v3.y = reduced_v2.y;\r\n                    impulse_v3.z = -this.m_impulse.z;\r\n                    this.m_impulse.x += reduced_v2.x;\r\n                    this.m_impulse.y += reduced_v2.y;\r\n                    this.m_impulse.z = 0;\r\n                }\r\n                else {\r\n                    this.m_impulse.SelfAdd(impulse_v3);\r\n                }\r\n            }\r\n            // b2Vec2 P(impulse.x, impulse.y);\r\n            var P = b2RevoluteJoint.SolveVelocityConstraints_s_P.Set(impulse_v3.x, impulse_v3.y);\r\n            // vA -= mA * P;\r\n            vA.SelfMulSub(mA, P);\r\n            wA -= iA * (b2Math_1.b2Vec2.CrossVV(this.m_rA, P) + impulse_v3.z);\r\n            // vB += mB * P;\r\n            vB.SelfMulAdd(mB, P);\r\n            wB += iB * (b2Math_1.b2Vec2.CrossVV(this.m_rB, P) + impulse_v3.z);\r\n        }\r\n        else {\r\n            // Solve point-to-point constraint\r\n            // b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n            var Cdot_v2 = b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Math_1.b2Vec2.s_t1), b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2);\r\n            // b2Vec2 impulse = m_mass.Solve22(-Cdot);\r\n            var impulse_v2 = this.m_mass.Solve22(-Cdot_v2.x, -Cdot_v2.y, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2);\r\n            this.m_impulse.x += impulse_v2.x;\r\n            this.m_impulse.y += impulse_v2.y;\r\n            // vA -= mA * impulse;\r\n            vA.SelfMulSub(mA, impulse_v2);\r\n            wA -= iA * b2Math_1.b2Vec2.CrossVV(this.m_rA, impulse_v2);\r\n            // vB += mB * impulse;\r\n            vB.SelfMulAdd(mB, impulse_v2);\r\n            wB += iB * b2Math_1.b2Vec2.CrossVV(this.m_rB, impulse_v2);\r\n        }\r\n        // data.velocities[this.m_indexA].v = vA;\r\n        data.velocities[this.m_indexA].w = wA;\r\n        // data.velocities[this.m_indexB].v = vB;\r\n        data.velocities[this.m_indexB].w = wB;\r\n    };\r\n    b2RevoluteJoint.prototype.SolvePositionConstraints = function (data) {\r\n        var cA = data.positions[this.m_indexA].c;\r\n        var aA = data.positions[this.m_indexA].a;\r\n        var cB = data.positions[this.m_indexB].c;\r\n        var aB = data.positions[this.m_indexB].a;\r\n        // b2Rot qA(aA), qB(aB);\r\n        var qA = this.m_qA.SetAngle(aA), qB = this.m_qB.SetAngle(aB);\r\n        var angularError = 0;\r\n        var positionError = 0;\r\n        var fixedRotation = (this.m_invIA + this.m_invIB === 0);\r\n        // Solve angular limit constraint.\r\n        if (this.m_enableLimit && this.m_limitState !== b2Joint_1.b2LimitState.e_inactiveLimit && !fixedRotation) {\r\n            var angle = aB - aA - this.m_referenceAngle;\r\n            var limitImpulse = 0;\r\n            if (this.m_limitState === b2Joint_1.b2LimitState.e_equalLimits) {\r\n                // Prevent large angular corrections\r\n                var C = b2Math_1.b2Clamp(angle - this.m_lowerAngle, -b2Settings_1.b2_maxAngularCorrection, b2Settings_1.b2_maxAngularCorrection);\r\n                limitImpulse = -this.m_motorMass * C;\r\n                angularError = b2Math_1.b2Abs(C);\r\n            }\r\n            else if (this.m_limitState === b2Joint_1.b2LimitState.e_atLowerLimit) {\r\n                var C = angle - this.m_lowerAngle;\r\n                angularError = -C;\r\n                // Prevent large angular corrections and allow some slop.\r\n                C = b2Math_1.b2Clamp(C + b2Settings_1.b2_angularSlop, -b2Settings_1.b2_maxAngularCorrection, 0);\r\n                limitImpulse = -this.m_motorMass * C;\r\n            }\r\n            else if (this.m_limitState === b2Joint_1.b2LimitState.e_atUpperLimit) {\r\n                var C = angle - this.m_upperAngle;\r\n                angularError = C;\r\n                // Prevent large angular corrections and allow some slop.\r\n                C = b2Math_1.b2Clamp(C - b2Settings_1.b2_angularSlop, 0, b2Settings_1.b2_maxAngularCorrection);\r\n                limitImpulse = -this.m_motorMass * C;\r\n            }\r\n            aA -= this.m_invIA * limitImpulse;\r\n            aB += this.m_invIB * limitImpulse;\r\n        }\r\n        // Solve point-to-point constraint.\r\n        {\r\n            qA.SetAngle(aA);\r\n            qB.SetAngle(aB);\r\n            // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n            b2Math_1.b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n            var rA = b2Math_1.b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n            // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n            b2Math_1.b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n            var rB = b2Math_1.b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n            // b2Vec2 C = cB + rB - cA - rA;\r\n            var C_v2 = b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVV(cB, rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVV(cA, rA, b2Math_1.b2Vec2.s_t1), b2RevoluteJoint.SolvePositionConstraints_s_C_v2);\r\n            // positionError = C.Length();\r\n            positionError = C_v2.Length();\r\n            var mA = this.m_invMassA, mB = this.m_invMassB;\r\n            var iA = this.m_invIA, iB = this.m_invIB;\r\n            var K = this.m_K;\r\n            K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n            K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n            K.ey.x = K.ex.y;\r\n            K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n            // b2Vec2 impulse = -K.Solve(C);\r\n            var impulse = K.Solve(C_v2.x, C_v2.y, b2RevoluteJoint.SolvePositionConstraints_s_impulse).SelfNeg();\r\n            // cA -= mA * impulse;\r\n            cA.SelfMulSub(mA, impulse);\r\n            aA -= iA * b2Math_1.b2Vec2.CrossVV(rA, impulse);\r\n            // cB += mB * impulse;\r\n            cB.SelfMulAdd(mB, impulse);\r\n            aB += iB * b2Math_1.b2Vec2.CrossVV(rB, impulse);\r\n        }\r\n        // data.positions[this.m_indexA].c = cA;\r\n        data.positions[this.m_indexA].a = aA;\r\n        // data.positions[this.m_indexB].c = cB;\r\n        data.positions[this.m_indexB].a = aB;\r\n        return positionError <= b2Settings_1.b2_linearSlop && angularError <= b2Settings_1.b2_angularSlop;\r\n    };\r\n    b2RevoluteJoint.prototype.GetAnchorA = function (out) {\r\n        return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n    };\r\n    b2RevoluteJoint.prototype.GetAnchorB = function (out) {\r\n        return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n    };\r\n    b2RevoluteJoint.prototype.GetReactionForce = function (inv_dt, out) {\r\n        // b2Vec2 P(this.m_impulse.x, this.m_impulse.y);\r\n        // return inv_dt * P;\r\n        out.x = inv_dt * this.m_impulse.x;\r\n        out.y = inv_dt * this.m_impulse.y;\r\n        return out;\r\n    };\r\n    b2RevoluteJoint.prototype.GetReactionTorque = function (inv_dt) {\r\n        return inv_dt * this.m_impulse.z;\r\n    };\r\n    b2RevoluteJoint.prototype.GetLocalAnchorA = function () { return this.m_localAnchorA; };\r\n    b2RevoluteJoint.prototype.GetLocalAnchorB = function () { return this.m_localAnchorB; };\r\n    b2RevoluteJoint.prototype.GetReferenceAngle = function () { return this.m_referenceAngle; };\r\n    b2RevoluteJoint.prototype.GetJointAngle = function () {\r\n        // b2Body* bA = this.m_bodyA;\r\n        // b2Body* bB = this.m_bodyB;\r\n        // return bB->this.m_sweep.a - bA->this.m_sweep.a - this.m_referenceAngle;\r\n        return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;\r\n    };\r\n    b2RevoluteJoint.prototype.GetJointSpeed = function () {\r\n        // b2Body* bA = this.m_bodyA;\r\n        // b2Body* bB = this.m_bodyB;\r\n        // return bB->this.m_angularVelocity - bA->this.m_angularVelocity;\r\n        return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;\r\n    };\r\n    b2RevoluteJoint.prototype.IsMotorEnabled = function () {\r\n        return this.m_enableMotor;\r\n    };\r\n    b2RevoluteJoint.prototype.EnableMotor = function (flag) {\r\n        if (flag !== this.m_enableMotor) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_enableMotor = flag;\r\n        }\r\n    };\r\n    b2RevoluteJoint.prototype.GetMotorTorque = function (inv_dt) {\r\n        return inv_dt * this.m_motorImpulse;\r\n    };\r\n    b2RevoluteJoint.prototype.GetMotorSpeed = function () {\r\n        return this.m_motorSpeed;\r\n    };\r\n    b2RevoluteJoint.prototype.SetMaxMotorTorque = function (torque) {\r\n        if (torque !== this.m_maxMotorTorque) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_maxMotorTorque = torque;\r\n        }\r\n    };\r\n    b2RevoluteJoint.prototype.GetMaxMotorTorque = function () { return this.m_maxMotorTorque; };\r\n    b2RevoluteJoint.prototype.IsLimitEnabled = function () {\r\n        return this.m_enableLimit;\r\n    };\r\n    b2RevoluteJoint.prototype.EnableLimit = function (flag) {\r\n        if (flag !== this.m_enableLimit) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_enableLimit = flag;\r\n            this.m_impulse.z = 0;\r\n        }\r\n    };\r\n    b2RevoluteJoint.prototype.GetLowerLimit = function () {\r\n        return this.m_lowerAngle;\r\n    };\r\n    b2RevoluteJoint.prototype.GetUpperLimit = function () {\r\n        return this.m_upperAngle;\r\n    };\r\n    b2RevoluteJoint.prototype.SetLimits = function (lower, upper) {\r\n        if (lower !== this.m_lowerAngle || upper !== this.m_upperAngle) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_impulse.z = 0;\r\n            this.m_lowerAngle = lower;\r\n            this.m_upperAngle = upper;\r\n        }\r\n    };\r\n    b2RevoluteJoint.prototype.SetMotorSpeed = function (speed) {\r\n        if (speed !== this.m_motorSpeed) {\r\n            this.m_bodyA.SetAwake(true);\r\n            this.m_bodyB.SetAwake(true);\r\n            this.m_motorSpeed = speed;\r\n        }\r\n    };\r\n    b2RevoluteJoint.prototype.Dump = function (log) {\r\n        var indexA = this.m_bodyA.m_islandIndex;\r\n        var indexB = this.m_bodyB.m_islandIndex;\r\n        log(\"  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\\n\");\r\n        log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n        log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n        log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n        log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n        log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n        log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.lowerAngle = %.15f;\\n\", this.m_lowerAngle);\r\n        log(\"  jd.upperAngle = %.15f;\\n\", this.m_upperAngle);\r\n        log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor) ? (\"true\") : (\"false\"));\r\n        log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n        log(\"  jd.maxMotorTorque = %.15f;\\n\", this.m_maxMotorTorque);\r\n        log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n    };\r\n    b2RevoluteJoint.InitVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2 = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1 = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3 = new b2Math_1.b2Vec3();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2 = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2 = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolvePositionConstraints_s_C_v2 = new b2Math_1.b2Vec2();\r\n    b2RevoluteJoint.SolvePositionConstraints_s_impulse = new b2Math_1.b2Vec2();\r\n    return b2RevoluteJoint;\r\n}(b2Joint_1.b2Joint));\r\nexports.b2RevoluteJoint = b2RevoluteJoint;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2RevoluteJoint.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Joints/b2RevoluteJoint.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2011 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\nimport { b2_linearSlop, b2_angularSlop, b2_maxAngularCorrection, b2Maybe } from \"../../Common/b2Settings\";\r\nimport { b2Abs, b2Clamp, b2Vec2, b2Mat22, b2Vec3, b2Mat33, b2Rot, XY } from \"../../Common/b2Math\";\r\nimport { b2Body } from \"../b2Body\";\r\nimport { b2Joint, b2JointDef, b2JointType, b2LimitState, b2IJointDef } from \"./b2Joint\";\r\nimport { b2SolverData } from \"../b2TimeStep\";\r\n\r\nexport interface b2IRevoluteJointDef extends b2IJointDef {\r\n  localAnchorA?: XY;\r\n\r\n  localAnchorB?: XY;\r\n\r\n  referenceAngle?: number;\r\n\r\n  enableLimit?: boolean;\r\n\r\n  lowerAngle?: number;\r\n\r\n  upperAngle?: number;\r\n\r\n  enableMotor?: boolean;\r\n\r\n  motorSpeed?: number;\r\n\r\n  maxMotorTorque?: number;\r\n}\r\n\r\n/// Revolute joint definition. This requires defining an\r\n/// anchor point where the bodies are joined. The definition\r\n/// uses local anchor points so that the initial configuration\r\n/// can violate the constraint slightly. You also need to\r\n/// specify the initial relative angle for joint limits. This\r\n/// helps when saving and loading a game.\r\n/// The local anchor points are measured from the body's origin\r\n/// rather than the center of mass because:\r\n/// 1. you might not know where the center of mass will be.\r\n/// 2. if you add/remove shapes from a body and recompute the mass,\r\n///    the joints will be broken.\r\nexport class b2RevoluteJointDef extends b2JointDef implements b2IRevoluteJointDef {\r\n  public readonly localAnchorA: b2Vec2 = new b2Vec2(0, 0);\r\n\r\n  public readonly localAnchorB: b2Vec2 = new b2Vec2(0, 0);\r\n\r\n  public referenceAngle: number = 0;\r\n\r\n  public enableLimit = false;\r\n\r\n  public lowerAngle: number = 0;\r\n\r\n  public upperAngle: number = 0;\r\n\r\n  public enableMotor = false;\r\n\r\n  public motorSpeed: number = 0;\r\n\r\n  public maxMotorTorque: number = 0;\r\n\r\n  constructor() {\r\n    super(b2JointType.e_revoluteJoint);\r\n  }\r\n\r\n  public Initialize(bA: b2Body, bB: b2Body, anchor: XY): void {\r\n    this.bodyA = bA;\r\n    this.bodyB = bB;\r\n    this.bodyA.GetLocalPoint(anchor, this.localAnchorA);\r\n    this.bodyB.GetLocalPoint(anchor, this.localAnchorB);\r\n    this.referenceAngle = this.bodyB.GetAngle() - this.bodyA.GetAngle();\r\n  }\r\n}\r\n\r\nexport class b2RevoluteJoint extends b2Joint {\r\n  // Solver shared\r\n  public readonly m_localAnchorA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localAnchorB: b2Vec2 = new b2Vec2();\r\n  public readonly m_impulse: b2Vec3 = new b2Vec3();\r\n  public m_motorImpulse: number = 0;\r\n\r\n  public m_enableMotor: boolean = false;\r\n  public m_maxMotorTorque: number = 0;\r\n  public m_motorSpeed: number = 0;\r\n\r\n  public m_enableLimit: boolean = false;\r\n  public m_referenceAngle: number = 0;\r\n  public m_lowerAngle: number = 0;\r\n  public m_upperAngle: number = 0;\r\n\r\n  // Solver temp\r\n  public m_indexA: number = 0;\r\n  public m_indexB: number = 0;\r\n  public readonly m_rA: b2Vec2 = new b2Vec2();\r\n  public readonly m_rB: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterA: b2Vec2 = new b2Vec2();\r\n  public readonly m_localCenterB: b2Vec2 = new b2Vec2();\r\n  public m_invMassA: number = 0;\r\n  public m_invMassB: number = 0;\r\n  public m_invIA: number = 0;\r\n  public m_invIB: number = 0;\r\n  public readonly m_mass: b2Mat33 = new b2Mat33(); // effective mass for point-to-point constraint.\r\n  public m_motorMass: number = 0; // effective mass for motor/limit angular constraint.\r\n  public m_limitState: b2LimitState = b2LimitState.e_inactiveLimit;\r\n\r\n  public readonly m_qA: b2Rot = new b2Rot();\r\n  public readonly m_qB: b2Rot = new b2Rot();\r\n  public readonly m_lalcA: b2Vec2 = new b2Vec2();\r\n  public readonly m_lalcB: b2Vec2 = new b2Vec2();\r\n  public readonly m_K: b2Mat22 = new b2Mat22();\r\n\r\n  constructor(def: b2IRevoluteJointDef) {\r\n    super(def);\r\n\r\n    this.m_localAnchorA.Copy(b2Maybe(def.localAnchorA, b2Vec2.ZERO));\r\n    this.m_localAnchorB.Copy(b2Maybe(def.localAnchorB, b2Vec2.ZERO));\r\n    this.m_referenceAngle = b2Maybe(def.referenceAngle, 0);\r\n\r\n    this.m_impulse.SetZero();\r\n    this.m_motorImpulse = 0;\r\n\r\n    this.m_lowerAngle = b2Maybe(def.lowerAngle, 0);\r\n    this.m_upperAngle = b2Maybe(def.upperAngle, 0);\r\n    this.m_maxMotorTorque = b2Maybe(def.maxMotorTorque, 0);\r\n    this.m_motorSpeed = b2Maybe(def.motorSpeed, 0);\r\n    this.m_enableLimit = b2Maybe(def.enableLimit, false);\r\n    this.m_enableMotor = b2Maybe(def.enableMotor, false);\r\n    this.m_limitState = b2LimitState.e_inactiveLimit;\r\n  }\r\n\r\n  private static InitVelocityConstraints_s_P = new b2Vec2();\r\n  public InitVelocityConstraints(data: b2SolverData): void {\r\n    this.m_indexA = this.m_bodyA.m_islandIndex;\r\n    this.m_indexB = this.m_bodyB.m_islandIndex;\r\n    this.m_localCenterA.Copy(this.m_bodyA.m_sweep.localCenter);\r\n    this.m_localCenterB.Copy(this.m_bodyB.m_sweep.localCenter);\r\n    this.m_invMassA = this.m_bodyA.m_invMass;\r\n    this.m_invMassB = this.m_bodyB.m_invMass;\r\n    this.m_invIA = this.m_bodyA.m_invI;\r\n    this.m_invIB = this.m_bodyB.m_invI;\r\n\r\n    const aA: number = data.positions[this.m_indexA].a;\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n\r\n    const aB: number = data.positions[this.m_indexB].a;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    // b2Rot qA(aA), qB(aB);\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    // m_rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n    b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n    b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n    // m_rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n    b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n    b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n    // J = [-I -r1_skew I r2_skew]\r\n    //     [ 0       -1 0       1]\r\n    // r_skew = [-ry; rx]\r\n\r\n    // Matlab\r\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB,  -r1y*iA*r1x-r2y*iB*r2x,          -r1y*iA-r2y*iB]\r\n    //     [  -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB,           r1x*iA+r2x*iB]\r\n    //     [          -r1y*iA-r2y*iB,           r1x*iA+r2x*iB,                   iA+iB]\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    const fixedRotation: boolean = (iA + iB === 0);\r\n\r\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\r\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\r\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\r\n    this.m_mass.ex.y = this.m_mass.ey.x;\r\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\r\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\r\n    this.m_mass.ex.z = this.m_mass.ez.x;\r\n    this.m_mass.ey.z = this.m_mass.ez.y;\r\n    this.m_mass.ez.z = iA + iB;\r\n\r\n    this.m_motorMass = iA + iB;\r\n    if (this.m_motorMass > 0) {\r\n      this.m_motorMass = 1 / this.m_motorMass;\r\n    }\r\n\r\n    if (!this.m_enableMotor || fixedRotation) {\r\n      this.m_motorImpulse = 0;\r\n    }\r\n\r\n    if (this.m_enableLimit && !fixedRotation) {\r\n      const jointAngle: number = aB - aA - this.m_referenceAngle;\r\n      if (b2Abs(this.m_upperAngle - this.m_lowerAngle) < 2 * b2_angularSlop) {\r\n        this.m_limitState = b2LimitState.e_equalLimits;\r\n      } else if (jointAngle <= this.m_lowerAngle) {\r\n        if (this.m_limitState !== b2LimitState.e_atLowerLimit) {\r\n          this.m_impulse.z = 0;\r\n        }\r\n        this.m_limitState = b2LimitState.e_atLowerLimit;\r\n      } else if (jointAngle >= this.m_upperAngle) {\r\n        if (this.m_limitState !== b2LimitState.e_atUpperLimit) {\r\n          this.m_impulse.z = 0;\r\n        }\r\n        this.m_limitState = b2LimitState.e_atUpperLimit;\r\n      } else {\r\n        this.m_limitState = b2LimitState.e_inactiveLimit;\r\n        this.m_impulse.z = 0;\r\n      }\r\n    } else {\r\n      this.m_limitState = b2LimitState.e_inactiveLimit;\r\n    }\r\n\r\n    if (data.step.warmStarting) {\r\n      // Scale impulses to support a variable time step.\r\n      this.m_impulse.SelfMul(data.step.dtRatio);\r\n      this.m_motorImpulse *= data.step.dtRatio;\r\n\r\n      // b2Vec2 P(m_impulse.x, m_impulse.y);\r\n      const P: b2Vec2 = b2RevoluteJoint.InitVelocityConstraints_s_P.Set(this.m_impulse.x, this.m_impulse.y);\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\r\n    } else {\r\n      this.m_impulse.SetZero();\r\n      this.m_motorImpulse = 0;\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolveVelocityConstraints_s_P: b2Vec2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_Cdot_v2: b2Vec2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_Cdot1: b2Vec2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_impulse_v3: b2Vec3 = new b2Vec3();\r\n  private static SolveVelocityConstraints_s_reduced_v2: b2Vec2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_impulse_v2: b2Vec2 = new b2Vec2();\r\n  public SolveVelocityConstraints(data: b2SolverData): void {\r\n    const vA: b2Vec2 = data.velocities[this.m_indexA].v;\r\n    let wA: number = data.velocities[this.m_indexA].w;\r\n    const vB: b2Vec2 = data.velocities[this.m_indexB].v;\r\n    let wB: number = data.velocities[this.m_indexB].w;\r\n\r\n    const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n    const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n    const fixedRotation: boolean = (iA + iB === 0);\r\n\r\n    // Solve motor constraint.\r\n    if (this.m_enableMotor && this.m_limitState !== b2LimitState.e_equalLimits && !fixedRotation) {\r\n      const Cdot: number = wB - wA - this.m_motorSpeed;\r\n      let impulse: number = -this.m_motorMass * Cdot;\r\n      const oldImpulse: number = this.m_motorImpulse;\r\n      const maxImpulse: number = data.step.dt * this.m_maxMotorTorque;\r\n      this.m_motorImpulse = b2Clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\r\n      impulse = this.m_motorImpulse - oldImpulse;\r\n\r\n      wA -= iA * impulse;\r\n      wB += iB * impulse;\r\n    }\r\n\r\n    // Solve limit constraint.\r\n    if (this.m_enableLimit && this.m_limitState !== b2LimitState.e_inactiveLimit && !fixedRotation) {\r\n      // b2Vec2 Cdot1 = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n      const Cdot1: b2Vec2 = b2Vec2.SubVV(\r\n        b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0),\r\n        b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1),\r\n        b2RevoluteJoint.SolveVelocityConstraints_s_Cdot1);\r\n      const Cdot2: number = wB - wA;\r\n      // b2Vec3 Cdot(Cdot1.x, Cdot1.y, Cdot2);\r\n\r\n      // b2Vec3 impulse = -this.m_mass.Solve33(Cdot);\r\n      const impulse_v3: b2Vec3 = this.m_mass.Solve33(Cdot1.x, Cdot1.y, Cdot2, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v3).SelfNeg();\r\n\r\n      if (this.m_limitState === b2LimitState.e_equalLimits) {\r\n        this.m_impulse.SelfAdd(impulse_v3);\r\n      } else if (this.m_limitState === b2LimitState.e_atLowerLimit) {\r\n        const newImpulse: number = this.m_impulse.z + impulse_v3.z;\r\n        if (newImpulse < 0) {\r\n          // b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n          const rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n          const rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n          const reduced_v2: b2Vec2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);\r\n          impulse_v3.x = reduced_v2.x;\r\n          impulse_v3.y = reduced_v2.y;\r\n          impulse_v3.z = -this.m_impulse.z;\r\n          this.m_impulse.x += reduced_v2.x;\r\n          this.m_impulse.y += reduced_v2.y;\r\n          this.m_impulse.z = 0;\r\n        } else {\r\n          this.m_impulse.SelfAdd(impulse_v3);\r\n        }\r\n      } else if (this.m_limitState === b2LimitState.e_atUpperLimit) {\r\n        const newImpulse: number = this.m_impulse.z + impulse_v3.z;\r\n        if (newImpulse > 0) {\r\n          // b2Vec2 rhs = -Cdot1 + m_impulse.z * b2Vec2(m_mass.ez.x, m_mass.ez.y);\r\n          const rhs_x = -Cdot1.x + this.m_impulse.z * this.m_mass.ez.x;\r\n          const rhs_y = -Cdot1.y + this.m_impulse.z * this.m_mass.ez.y;\r\n          const reduced_v2: b2Vec2 = this.m_mass.Solve22(rhs_x, rhs_y, b2RevoluteJoint.SolveVelocityConstraints_s_reduced_v2);\r\n          impulse_v3.x = reduced_v2.x;\r\n          impulse_v3.y = reduced_v2.y;\r\n          impulse_v3.z = -this.m_impulse.z;\r\n          this.m_impulse.x += reduced_v2.x;\r\n          this.m_impulse.y += reduced_v2.y;\r\n          this.m_impulse.z = 0;\r\n        } else {\r\n          this.m_impulse.SelfAdd(impulse_v3);\r\n        }\r\n      }\r\n\r\n      // b2Vec2 P(impulse.x, impulse.y);\r\n      const P: b2Vec2 = b2RevoluteJoint.SolveVelocityConstraints_s_P.Set(impulse_v3.x, impulse_v3.y);\r\n\r\n      // vA -= mA * P;\r\n      vA.SelfMulSub(mA, P);\r\n      wA -= iA * (b2Vec2.CrossVV(this.m_rA, P) + impulse_v3.z);\r\n\r\n      // vB += mB * P;\r\n      vB.SelfMulAdd(mB, P);\r\n      wB += iB * (b2Vec2.CrossVV(this.m_rB, P) + impulse_v3.z);\r\n    } else {\r\n      // Solve point-to-point constraint\r\n      // b2Vec2 Cdot = vB + b2Cross(wB, m_rB) - vA - b2Cross(wA, m_rA);\r\n      const Cdot_v2: b2Vec2 = b2Vec2.SubVV(\r\n        b2Vec2.AddVCrossSV(vB, wB, this.m_rB, b2Vec2.s_t0),\r\n        b2Vec2.AddVCrossSV(vA, wA, this.m_rA, b2Vec2.s_t1),\r\n        b2RevoluteJoint.SolveVelocityConstraints_s_Cdot_v2);\r\n      // b2Vec2 impulse = m_mass.Solve22(-Cdot);\r\n      const impulse_v2: b2Vec2 = this.m_mass.Solve22(-Cdot_v2.x, -Cdot_v2.y, b2RevoluteJoint.SolveVelocityConstraints_s_impulse_v2);\r\n\r\n      this.m_impulse.x += impulse_v2.x;\r\n      this.m_impulse.y += impulse_v2.y;\r\n\r\n      // vA -= mA * impulse;\r\n      vA.SelfMulSub(mA, impulse_v2);\r\n      wA -= iA * b2Vec2.CrossVV(this.m_rA, impulse_v2);\r\n\r\n      // vB += mB * impulse;\r\n      vB.SelfMulAdd(mB, impulse_v2);\r\n      wB += iB * b2Vec2.CrossVV(this.m_rB, impulse_v2);\r\n    }\r\n\r\n    // data.velocities[this.m_indexA].v = vA;\r\n    data.velocities[this.m_indexA].w = wA;\r\n    // data.velocities[this.m_indexB].v = vB;\r\n    data.velocities[this.m_indexB].w = wB;\r\n  }\r\n\r\n  private static SolvePositionConstraints_s_C_v2 = new b2Vec2();\r\n  private static SolvePositionConstraints_s_impulse = new b2Vec2();\r\n  public SolvePositionConstraints(data: b2SolverData): boolean {\r\n    const cA: b2Vec2 = data.positions[this.m_indexA].c;\r\n    let aA: number = data.positions[this.m_indexA].a;\r\n    const cB: b2Vec2 = data.positions[this.m_indexB].c;\r\n    let aB: number = data.positions[this.m_indexB].a;\r\n\r\n    // b2Rot qA(aA), qB(aB);\r\n    const qA: b2Rot = this.m_qA.SetAngle(aA), qB: b2Rot = this.m_qB.SetAngle(aB);\r\n\r\n    let angularError: number = 0;\r\n    let positionError: number = 0;\r\n\r\n    const fixedRotation: boolean = (this.m_invIA + this.m_invIB === 0);\r\n\r\n    // Solve angular limit constraint.\r\n    if (this.m_enableLimit && this.m_limitState !== b2LimitState.e_inactiveLimit && !fixedRotation) {\r\n      const angle: number = aB - aA - this.m_referenceAngle;\r\n      let limitImpulse: number = 0;\r\n\r\n      if (this.m_limitState === b2LimitState.e_equalLimits) {\r\n        // Prevent large angular corrections\r\n        const C: number = b2Clamp(angle - this.m_lowerAngle, -b2_maxAngularCorrection, b2_maxAngularCorrection);\r\n        limitImpulse = -this.m_motorMass * C;\r\n        angularError = b2Abs(C);\r\n      } else if (this.m_limitState === b2LimitState.e_atLowerLimit) {\r\n        let C: number = angle - this.m_lowerAngle;\r\n        angularError = -C;\r\n\r\n        // Prevent large angular corrections and allow some slop.\r\n        C = b2Clamp(C + b2_angularSlop, -b2_maxAngularCorrection, 0);\r\n        limitImpulse = -this.m_motorMass * C;\r\n      } else if (this.m_limitState === b2LimitState.e_atUpperLimit) {\r\n        let C: number = angle - this.m_upperAngle;\r\n        angularError = C;\r\n\r\n        // Prevent large angular corrections and allow some slop.\r\n        C = b2Clamp(C - b2_angularSlop, 0, b2_maxAngularCorrection);\r\n        limitImpulse = -this.m_motorMass * C;\r\n      }\r\n\r\n      aA -= this.m_invIA * limitImpulse;\r\n      aB += this.m_invIB * limitImpulse;\r\n    }\r\n\r\n    // Solve point-to-point constraint.\r\n    {\r\n      qA.SetAngle(aA);\r\n      qB.SetAngle(aB);\r\n      // b2Vec2 rA = b2Mul(qA, m_localAnchorA - m_localCenterA);\r\n      b2Vec2.SubVV(this.m_localAnchorA, this.m_localCenterA, this.m_lalcA);\r\n      const rA: b2Vec2 = b2Rot.MulRV(qA, this.m_lalcA, this.m_rA);\r\n      // b2Vec2 rB = b2Mul(qB, m_localAnchorB - m_localCenterB);\r\n      b2Vec2.SubVV(this.m_localAnchorB, this.m_localCenterB, this.m_lalcB);\r\n      const rB: b2Vec2 = b2Rot.MulRV(qB, this.m_lalcB, this.m_rB);\r\n\r\n      // b2Vec2 C = cB + rB - cA - rA;\r\n      const C_v2 =\r\n        b2Vec2.SubVV(\r\n          b2Vec2.AddVV(cB, rB, b2Vec2.s_t0),\r\n          b2Vec2.AddVV(cA, rA, b2Vec2.s_t1),\r\n          b2RevoluteJoint.SolvePositionConstraints_s_C_v2);\r\n      // positionError = C.Length();\r\n      positionError = C_v2.Length();\r\n\r\n      const mA: number = this.m_invMassA, mB: number = this.m_invMassB;\r\n      const iA: number = this.m_invIA, iB: number = this.m_invIB;\r\n\r\n      const K: b2Mat22 = this.m_K;\r\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\r\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\r\n      K.ey.x = K.ex.y;\r\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\r\n\r\n      // b2Vec2 impulse = -K.Solve(C);\r\n      const impulse: b2Vec2 = K.Solve(C_v2.x, C_v2.y, b2RevoluteJoint.SolvePositionConstraints_s_impulse).SelfNeg();\r\n\r\n      // cA -= mA * impulse;\r\n      cA.SelfMulSub(mA, impulse);\r\n      aA -= iA * b2Vec2.CrossVV(rA, impulse);\r\n\r\n      // cB += mB * impulse;\r\n      cB.SelfMulAdd(mB, impulse);\r\n      aB += iB * b2Vec2.CrossVV(rB, impulse);\r\n    }\r\n\r\n    // data.positions[this.m_indexA].c = cA;\r\n    data.positions[this.m_indexA].a = aA;\r\n    // data.positions[this.m_indexB].c = cB;\r\n    data.positions[this.m_indexB].a = aB;\r\n\r\n    return positionError <= b2_linearSlop && angularError <= b2_angularSlop;\r\n  }\r\n\r\n  public GetAnchorA<T extends XY>(out: T): T {\r\n    return this.m_bodyA.GetWorldPoint(this.m_localAnchorA, out);\r\n  }\r\n\r\n  public GetAnchorB<T extends XY>(out: T): T {\r\n    return this.m_bodyB.GetWorldPoint(this.m_localAnchorB, out);\r\n  }\r\n\r\n  public GetReactionForce<T extends XY>(inv_dt: number, out: T): T {\r\n    // b2Vec2 P(this.m_impulse.x, this.m_impulse.y);\r\n    // return inv_dt * P;\r\n    out.x = inv_dt * this.m_impulse.x;\r\n    out.y = inv_dt * this.m_impulse.y;\r\n    return out;\r\n  }\r\n\r\n  public GetReactionTorque(inv_dt: number): number {\r\n    return inv_dt * this.m_impulse.z;\r\n  }\r\n\r\n  public GetLocalAnchorA(): Readonly<b2Vec2> { return this.m_localAnchorA; }\r\n\r\n  public GetLocalAnchorB(): Readonly<b2Vec2> { return this.m_localAnchorB; }\r\n\r\n  public GetReferenceAngle(): number { return this.m_referenceAngle; }\r\n\r\n  public GetJointAngle(): number {\r\n    // b2Body* bA = this.m_bodyA;\r\n    // b2Body* bB = this.m_bodyB;\r\n    // return bB->this.m_sweep.a - bA->this.m_sweep.a - this.m_referenceAngle;\r\n    return this.m_bodyB.m_sweep.a - this.m_bodyA.m_sweep.a - this.m_referenceAngle;\r\n  }\r\n\r\n  public GetJointSpeed(): number {\r\n    // b2Body* bA = this.m_bodyA;\r\n    // b2Body* bB = this.m_bodyB;\r\n    // return bB->this.m_angularVelocity - bA->this.m_angularVelocity;\r\n    return this.m_bodyB.m_angularVelocity - this.m_bodyA.m_angularVelocity;\r\n  }\r\n\r\n  public IsMotorEnabled(): boolean {\r\n    return this.m_enableMotor;\r\n  }\r\n\r\n  public EnableMotor(flag: boolean): void {\r\n    if (flag !== this.m_enableMotor) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_enableMotor = flag;\r\n    }\r\n  }\r\n\r\n  public GetMotorTorque(inv_dt: number): number {\r\n    return inv_dt * this.m_motorImpulse;\r\n  }\r\n\r\n  public GetMotorSpeed(): number {\r\n    return this.m_motorSpeed;\r\n  }\r\n\r\n  public SetMaxMotorTorque(torque: number): void {\r\n    if (torque !== this.m_maxMotorTorque) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_maxMotorTorque = torque;\r\n    }\r\n  }\r\n\r\n  public GetMaxMotorTorque(): number { return this.m_maxMotorTorque; }\r\n\r\n  public IsLimitEnabled(): boolean {\r\n    return this.m_enableLimit;\r\n  }\r\n\r\n  public EnableLimit(flag: boolean): void {\r\n    if (flag !== this.m_enableLimit) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_enableLimit = flag;\r\n      this.m_impulse.z = 0;\r\n    }\r\n  }\r\n\r\n  public GetLowerLimit(): number {\r\n    return this.m_lowerAngle;\r\n  }\r\n\r\n  public GetUpperLimit(): number {\r\n    return this.m_upperAngle;\r\n  }\r\n\r\n  public SetLimits(lower: number, upper: number): void {\r\n\r\n    if (lower !== this.m_lowerAngle || upper !== this.m_upperAngle) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_impulse.z = 0;\r\n      this.m_lowerAngle = lower;\r\n      this.m_upperAngle = upper;\r\n    }\r\n  }\r\n\r\n  public SetMotorSpeed(speed: number): void {\r\n    if (speed !== this.m_motorSpeed) {\r\n      this.m_bodyA.SetAwake(true);\r\n      this.m_bodyB.SetAwake(true);\r\n      this.m_motorSpeed = speed;\r\n    }\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void) {\r\n    const indexA = this.m_bodyA.m_islandIndex;\r\n    const indexB = this.m_bodyB.m_islandIndex;\r\n\r\n    log(\"  const jd: b2RevoluteJointDef = new b2RevoluteJointDef();\\n\");\r\n    log(\"  jd.bodyA = bodies[%d];\\n\", indexA);\r\n    log(\"  jd.bodyB = bodies[%d];\\n\", indexB);\r\n    log(\"  jd.collideConnected = %s;\\n\", (this.m_collideConnected) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.localAnchorA.Set(%.15f, %.15f);\\n\", this.m_localAnchorA.x, this.m_localAnchorA.y);\r\n    log(\"  jd.localAnchorB.Set(%.15f, %.15f);\\n\", this.m_localAnchorB.x, this.m_localAnchorB.y);\r\n    log(\"  jd.referenceAngle = %.15f;\\n\", this.m_referenceAngle);\r\n    log(\"  jd.enableLimit = %s;\\n\", (this.m_enableLimit) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.lowerAngle = %.15f;\\n\", this.m_lowerAngle);\r\n    log(\"  jd.upperAngle = %.15f;\\n\", this.m_upperAngle);\r\n    log(\"  jd.enableMotor = %s;\\n\", (this.m_enableMotor) ? (\"true\") : (\"false\"));\r\n    log(\"  jd.motorSpeed = %.15f;\\n\", this.m_motorSpeed);\r\n    log(\"  jd.maxMotorTorque = %.15f;\\n\", this.m_maxMotorTorque);\r\n    log(\"  joints[%d] = this.m_world.CreateJoint(jd);\\n\", this.m_index);\r\n  }\r\n}\r\n"]}},"error":null,"hash":"65d0d80b1e1fe001311c0b69637e5740","cacheData":{"env":{}}}