{"id":"../node_modules/box2d.package.ts/Collision/Shapes/b2CircleShape.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":31,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2CircleShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":32,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2CircleShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"./b2Shape","loc":{"line":33,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2CircleShape.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\Shapes\\b2Shape.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Shape_1 = require(\"./b2Shape\");\r\n/// A circle shape.\r\nvar b2CircleShape = /** @class */ (function (_super) {\r\n    __extends(b2CircleShape, _super);\r\n    function b2CircleShape(radius) {\r\n        if (radius === void 0) { radius = 0; }\r\n        var _this = _super.call(this, b2Shape_1.b2ShapeType.e_circleShape, radius) || this;\r\n        _this.m_p = new b2Math_1.b2Vec2();\r\n        return _this;\r\n    }\r\n    b2CircleShape.prototype.Set = function (position, radius) {\r\n        if (radius === void 0) { radius = this.m_radius; }\r\n        this.m_p.Copy(position);\r\n        this.m_radius = radius;\r\n        return this;\r\n    };\r\n    /// Implement b2Shape.\r\n    b2CircleShape.prototype.Clone = function () {\r\n        return new b2CircleShape().Copy(this);\r\n    };\r\n    b2CircleShape.prototype.Copy = function (other) {\r\n        _super.prototype.Copy.call(this, other);\r\n        // DEBUG: b2Assert(other instanceof b2CircleShape);\r\n        this.m_p.Copy(other.m_p);\r\n        return this;\r\n    };\r\n    /// @see b2Shape::GetChildCount\r\n    b2CircleShape.prototype.GetChildCount = function () {\r\n        return 1;\r\n    };\r\n    b2CircleShape.prototype.TestPoint = function (transform, p) {\r\n        var center = b2Math_1.b2Transform.MulXV(transform, this.m_p, b2CircleShape.TestPoint_s_center);\r\n        var d = b2Math_1.b2Vec2.SubVV(p, center, b2CircleShape.TestPoint_s_d);\r\n        return b2Math_1.b2Vec2.DotVV(d, d) <= b2Math_1.b2Sq(this.m_radius);\r\n    };\r\n    b2CircleShape.prototype.ComputeDistance = function (xf, p, normal, childIndex) {\r\n        var center = b2Math_1.b2Transform.MulXV(xf, this.m_p, b2CircleShape.ComputeDistance_s_center);\r\n        b2Math_1.b2Vec2.SubVV(p, center, normal);\r\n        return normal.Normalize() - this.m_radius;\r\n    };\r\n    b2CircleShape.prototype.RayCast = function (output, input, transform, childIndex) {\r\n        var position = b2Math_1.b2Transform.MulXV(transform, this.m_p, b2CircleShape.RayCast_s_position);\r\n        var s = b2Math_1.b2Vec2.SubVV(input.p1, position, b2CircleShape.RayCast_s_s);\r\n        var b = b2Math_1.b2Vec2.DotVV(s, s) - b2Math_1.b2Sq(this.m_radius);\r\n        // Solve quadratic equation.\r\n        var r = b2Math_1.b2Vec2.SubVV(input.p2, input.p1, b2CircleShape.RayCast_s_r);\r\n        var c = b2Math_1.b2Vec2.DotVV(s, r);\r\n        var rr = b2Math_1.b2Vec2.DotVV(r, r);\r\n        var sigma = c * c - rr * b;\r\n        // Check for negative discriminant and short segment.\r\n        if (sigma < 0 || rr < b2Settings_1.b2_epsilon) {\r\n            return false;\r\n        }\r\n        // Find the point of intersection of the line with the circle.\r\n        var a = (-(c + b2Math_1.b2Sqrt(sigma)));\r\n        // Is the intersection point on the segment?\r\n        if (0 <= a && a <= input.maxFraction * rr) {\r\n            a /= rr;\r\n            output.fraction = a;\r\n            b2Math_1.b2Vec2.AddVMulSV(s, a, r, output.normal).SelfNormalize();\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    b2CircleShape.prototype.ComputeAABB = function (aabb, transform, childIndex) {\r\n        var p = b2Math_1.b2Transform.MulXV(transform, this.m_p, b2CircleShape.ComputeAABB_s_p);\r\n        aabb.lowerBound.Set(p.x - this.m_radius, p.y - this.m_radius);\r\n        aabb.upperBound.Set(p.x + this.m_radius, p.y + this.m_radius);\r\n    };\r\n    /// @see b2Shape::ComputeMass\r\n    b2CircleShape.prototype.ComputeMass = function (massData, density) {\r\n        var radius_sq = b2Math_1.b2Sq(this.m_radius);\r\n        massData.mass = density * b2Settings_1.b2_pi * radius_sq;\r\n        massData.center.Copy(this.m_p);\r\n        // inertia about the local origin\r\n        massData.I = massData.mass * (0.5 * radius_sq + b2Math_1.b2Vec2.DotVV(this.m_p, this.m_p));\r\n    };\r\n    b2CircleShape.prototype.SetupDistanceProxy = function (proxy, index) {\r\n        proxy.m_vertices = proxy.m_buffer;\r\n        proxy.m_vertices[0].Copy(this.m_p);\r\n        proxy.m_count = 1;\r\n        proxy.m_radius = this.m_radius;\r\n    };\r\n    b2CircleShape.prototype.ComputeSubmergedArea = function (normal, offset, xf, c) {\r\n        var p = b2Math_1.b2Transform.MulXV(xf, this.m_p, new b2Math_1.b2Vec2());\r\n        var l = (-(b2Math_1.b2Vec2.DotVV(normal, p) - offset));\r\n        if (l < (-this.m_radius) + b2Settings_1.b2_epsilon) {\r\n            // Completely dry\r\n            return 0;\r\n        }\r\n        if (l > this.m_radius) {\r\n            // Completely wet\r\n            c.Copy(p);\r\n            return b2Settings_1.b2_pi * this.m_radius * this.m_radius;\r\n        }\r\n        // Magic\r\n        var r2 = this.m_radius * this.m_radius;\r\n        var l2 = l * l;\r\n        var area = r2 * (b2Math_1.b2Asin(l / this.m_radius) + b2Settings_1.b2_pi / 2) + l * b2Math_1.b2Sqrt(r2 - l2);\r\n        var com = (-2 / 3 * b2Math_1.b2Pow(r2 - l2, 1.5) / area);\r\n        c.x = p.x + normal.x * com;\r\n        c.y = p.y + normal.y * com;\r\n        return area;\r\n    };\r\n    b2CircleShape.prototype.Dump = function (log) {\r\n        log(\"    const shape: b2CircleShape = new b2CircleShape();\\n\");\r\n        log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n        log(\"    shape.m_p.Set(%.15f, %.15f);\\n\", this.m_p.x, this.m_p.y);\r\n    };\r\n    /// Implement b2Shape.\r\n    b2CircleShape.TestPoint_s_center = new b2Math_1.b2Vec2();\r\n    b2CircleShape.TestPoint_s_d = new b2Math_1.b2Vec2();\r\n    // #if B2_ENABLE_PARTICLE\r\n    /// @see b2Shape::ComputeDistance\r\n    b2CircleShape.ComputeDistance_s_center = new b2Math_1.b2Vec2();\r\n    // #endif\r\n    /// Implement b2Shape.\r\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\r\n    // From Section 3.1.2\r\n    // x = s + a * r\r\n    // norm(x) = radius\r\n    b2CircleShape.RayCast_s_position = new b2Math_1.b2Vec2();\r\n    b2CircleShape.RayCast_s_s = new b2Math_1.b2Vec2();\r\n    b2CircleShape.RayCast_s_r = new b2Math_1.b2Vec2();\r\n    /// @see b2Shape::ComputeAABB\r\n    b2CircleShape.ComputeAABB_s_p = new b2Math_1.b2Vec2();\r\n    return b2CircleShape;\r\n}(b2Shape_1.b2Shape));\r\nexports.b2CircleShape = b2CircleShape;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2CircleShape.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/Shapes/b2CircleShape.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nimport { b2_pi, b2_epsilon } from \"../../Common/b2Settings\";\r\nimport { b2Sq, b2Sqrt, b2Asin, b2Pow, b2Vec2, b2Transform, XY } from \"../../Common/b2Math\";\r\nimport { b2AABB, b2RayCastInput, b2RayCastOutput } from \"../b2Collision\";\r\nimport { b2DistanceProxy } from \"../b2Distance\";\r\nimport { b2MassData } from \"./b2Shape\";\r\nimport { b2Shape, b2ShapeType } from \"./b2Shape\";\r\n\r\n/// A circle shape.\r\nexport class b2CircleShape extends b2Shape {\r\n  public readonly m_p: b2Vec2 = new b2Vec2();\r\n\r\n  constructor(radius: number = 0) {\r\n    super(b2ShapeType.e_circleShape, radius);\r\n  }\r\n\r\n  public Set(position: XY, radius: number = this.m_radius): this {\r\n    this.m_p.Copy(position);\r\n    this.m_radius = radius;\r\n    return this;\r\n  }\r\n\r\n  /// Implement b2Shape.\r\n  public Clone(): b2CircleShape {\r\n    return new b2CircleShape().Copy(this);\r\n  }\r\n\r\n  public Copy(other: b2CircleShape): b2CircleShape {\r\n    super.Copy(other);\r\n\r\n    // DEBUG: b2Assert(other instanceof b2CircleShape);\r\n\r\n    this.m_p.Copy(other.m_p);\r\n    return this;\r\n  }\r\n\r\n  /// @see b2Shape::GetChildCount\r\n  public GetChildCount(): number {\r\n    return 1;\r\n  }\r\n\r\n  /// Implement b2Shape.\r\n  private static TestPoint_s_center = new b2Vec2();\r\n  private static TestPoint_s_d = new b2Vec2();\r\n  public TestPoint(transform: b2Transform, p: XY): boolean {\r\n    const center: b2Vec2 = b2Transform.MulXV(transform, this.m_p, b2CircleShape.TestPoint_s_center);\r\n    const d: b2Vec2 = b2Vec2.SubVV(p, center, b2CircleShape.TestPoint_s_d);\r\n    return b2Vec2.DotVV(d, d) <= b2Sq(this.m_radius);\r\n  }\r\n\r\n  // #if B2_ENABLE_PARTICLE\r\n  /// @see b2Shape::ComputeDistance\r\n  private static ComputeDistance_s_center = new b2Vec2();\r\n  public ComputeDistance(xf: b2Transform, p: b2Vec2, normal: b2Vec2, childIndex: number): number {\r\n    const center = b2Transform.MulXV(xf, this.m_p, b2CircleShape.ComputeDistance_s_center);\r\n    b2Vec2.SubVV(p, center, normal);\r\n    return normal.Normalize() - this.m_radius;\r\n  }\r\n  // #endif\r\n\r\n  /// Implement b2Shape.\r\n  // Collision Detection in Interactive 3D Environments by Gino van den Bergen\r\n  // From Section 3.1.2\r\n  // x = s + a * r\r\n  // norm(x) = radius\r\n  private static RayCast_s_position = new b2Vec2();\r\n  private static RayCast_s_s = new b2Vec2();\r\n  private static RayCast_s_r = new b2Vec2();\r\n  public RayCast(output: b2RayCastOutput, input: b2RayCastInput, transform: b2Transform, childIndex: number): boolean {\r\n    const position: b2Vec2 = b2Transform.MulXV(transform, this.m_p, b2CircleShape.RayCast_s_position);\r\n    const s: b2Vec2 = b2Vec2.SubVV(input.p1, position, b2CircleShape.RayCast_s_s);\r\n    const b: number = b2Vec2.DotVV(s, s) - b2Sq(this.m_radius);\r\n\r\n    // Solve quadratic equation.\r\n    const r: b2Vec2 = b2Vec2.SubVV(input.p2, input.p1, b2CircleShape.RayCast_s_r);\r\n    const c: number = b2Vec2.DotVV(s, r);\r\n    const rr: number = b2Vec2.DotVV(r, r);\r\n    const sigma = c * c - rr * b;\r\n\r\n    // Check for negative discriminant and short segment.\r\n    if (sigma < 0 || rr < b2_epsilon) {\r\n      return false;\r\n    }\r\n\r\n    // Find the point of intersection of the line with the circle.\r\n    let a: number = (-(c + b2Sqrt(sigma)));\r\n\r\n    // Is the intersection point on the segment?\r\n    if (0 <= a && a <= input.maxFraction * rr) {\r\n      a /= rr;\r\n      output.fraction = a;\r\n      b2Vec2.AddVMulSV(s, a, r, output.normal).SelfNormalize();\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /// @see b2Shape::ComputeAABB\r\n  private static ComputeAABB_s_p = new b2Vec2();\r\n  public ComputeAABB(aabb: b2AABB, transform: b2Transform, childIndex: number): void {\r\n    const p: b2Vec2 = b2Transform.MulXV(transform, this.m_p, b2CircleShape.ComputeAABB_s_p);\r\n    aabb.lowerBound.Set(p.x - this.m_radius, p.y - this.m_radius);\r\n    aabb.upperBound.Set(p.x + this.m_radius, p.y + this.m_radius);\r\n  }\r\n\r\n  /// @see b2Shape::ComputeMass\r\n  public ComputeMass(massData: b2MassData, density: number): void {\r\n    const radius_sq: number = b2Sq(this.m_radius);\r\n    massData.mass = density * b2_pi * radius_sq;\r\n    massData.center.Copy(this.m_p);\r\n\r\n    // inertia about the local origin\r\n    massData.I = massData.mass * (0.5 * radius_sq + b2Vec2.DotVV(this.m_p, this.m_p));\r\n  }\r\n\r\n  public SetupDistanceProxy(proxy: b2DistanceProxy, index: number): void {\r\n    proxy.m_vertices = proxy.m_buffer;\r\n    proxy.m_vertices[0].Copy(this.m_p);\r\n    proxy.m_count = 1;\r\n    proxy.m_radius = this.m_radius;\r\n  }\r\n\r\n  public ComputeSubmergedArea(normal: b2Vec2, offset: number, xf: b2Transform, c: b2Vec2): number {\r\n    const p: b2Vec2 = b2Transform.MulXV(xf, this.m_p, new b2Vec2());\r\n    const l: number = (-(b2Vec2.DotVV(normal, p) - offset));\r\n\r\n    if (l < (-this.m_radius) + b2_epsilon) {\r\n      // Completely dry\r\n      return 0;\r\n    }\r\n    if (l > this.m_radius) {\r\n      // Completely wet\r\n      c.Copy(p);\r\n      return b2_pi * this.m_radius * this.m_radius;\r\n    }\r\n\r\n    // Magic\r\n    const r2: number = this.m_radius * this.m_radius;\r\n    const l2: number = l * l;\r\n    const area: number = r2 * (b2Asin(l / this.m_radius) + b2_pi / 2) + l * b2Sqrt(r2 - l2);\r\n    const com: number = (-2 / 3 * b2Pow(r2 - l2, 1.5) / area);\r\n\r\n    c.x = p.x + normal.x * com;\r\n    c.y = p.y + normal.y * com;\r\n\r\n    return area;\r\n  }\r\n\r\n  public Dump(log: (format: string, ...args: any[]) => void): void {\r\n    log(\"    const shape: b2CircleShape = new b2CircleShape();\\n\");\r\n    log(\"    shape.m_radius = %.15f;\\n\", this.m_radius);\r\n    log(\"    shape.m_p.Set(%.15f, %.15f);\\n\", this.m_p.x, this.m_p.y);\r\n  }\r\n}\r\n"]}},"error":null,"hash":"bd14e41ac9f1dbb67f26b0053a4d654c","cacheData":{"env":{}}}