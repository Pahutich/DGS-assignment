{"id":"../node_modules/box2d.package.ts/Controllers/b2BuoyancyController.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"./b2Controller","loc":{"line":31,"column":29},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Controllers\\b2BuoyancyController.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Controllers\\b2Controller.ts"},{"name":"../Common/b2Math","loc":{"line":32,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Controllers\\b2BuoyancyController.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2Settings","loc":{"line":33,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Controllers\\b2BuoyancyController.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Draw","loc":{"line":34,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Controllers\\b2BuoyancyController.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Draw.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\nvar __extends = (this && this.__extends) || (function () {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nexports.__esModule = true;\r\n// #if B2_ENABLE_CONTROLLER\r\nvar b2Controller_1 = require(\"./b2Controller\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Draw_1 = require(\"../Common/b2Draw\");\r\n/**\r\n * Calculates buoyancy forces for fluids in the form of a half\r\n * plane.\r\n */\r\nvar b2BuoyancyController = /** @class */ (function (_super) {\r\n    __extends(b2BuoyancyController, _super);\r\n    function b2BuoyancyController() {\r\n        var _this = _super !== null && _super.apply(this, arguments) || this;\r\n        /**\r\n         * The outer surface normal\r\n         */\r\n        _this.normal = new b2Math_1.b2Vec2(0, 1);\r\n        /**\r\n         * The height of the fluid surface along the normal\r\n         */\r\n        _this.offset = 0;\r\n        /**\r\n         * The fluid density\r\n         */\r\n        _this.density = 0;\r\n        /**\r\n         * Fluid velocity, for drag calculations\r\n         */\r\n        _this.velocity = new b2Math_1.b2Vec2(0, 0);\r\n        /**\r\n         * Linear drag co-efficient\r\n         */\r\n        _this.linearDrag = 0;\r\n        /**\r\n         * Angular drag co-efficient\r\n         */\r\n        _this.angularDrag = 0;\r\n        /**\r\n         * If false, bodies are assumed to be uniformly dense, otherwise\r\n         * use the shapes densities\r\n         */\r\n        _this.useDensity = false; //False by default to prevent a gotcha\r\n        /**\r\n         * If true, gravity is taken from the world instead of the\r\n         */\r\n        _this.useWorldGravity = true;\r\n        /**\r\n         * Gravity vector, if the world's gravity is not used\r\n         */\r\n        _this.gravity = new b2Math_1.b2Vec2(0, 0);\r\n        return _this;\r\n    }\r\n    b2BuoyancyController.prototype.Step = function (step) {\r\n        if (!this.m_bodyList) {\r\n            return;\r\n        }\r\n        if (this.useWorldGravity) {\r\n            this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());\r\n        }\r\n        for (var i = this.m_bodyList; i; i = i.nextBody) {\r\n            var body = i.body;\r\n            if (!body.IsAwake()) {\r\n                //Buoyancy force is just a function of position,\r\n                //so unlike most forces, it is safe to ignore sleeping bodes\r\n                continue;\r\n            }\r\n            var areac = new b2Math_1.b2Vec2();\r\n            var massc = new b2Math_1.b2Vec2();\r\n            var area = 0;\r\n            var mass = 0;\r\n            for (var fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next) {\r\n                var sc = new b2Math_1.b2Vec2();\r\n                var sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);\r\n                area += sarea;\r\n                areac.x += sarea * sc.x;\r\n                areac.y += sarea * sc.y;\r\n                var shapeDensity = 0;\r\n                if (this.useDensity) {\r\n                    //TODO: Expose density publicly\r\n                    shapeDensity = fixture.GetDensity();\r\n                }\r\n                else {\r\n                    shapeDensity = 1;\r\n                }\r\n                mass += sarea * shapeDensity;\r\n                massc.x += sarea * sc.x * shapeDensity;\r\n                massc.y += sarea * sc.y * shapeDensity;\r\n            }\r\n            areac.x /= area;\r\n            areac.y /= area;\r\n            //    b2Vec2 localCentroid = b2MulT(body->GetXForm(),areac);\r\n            massc.x /= mass;\r\n            massc.y /= mass;\r\n            if (area < b2Settings_1.b2_epsilon) {\r\n                continue;\r\n            }\r\n            //Buoyancy\r\n            var buoyancyForce = this.gravity.Clone().SelfNeg();\r\n            buoyancyForce.SelfMul(this.density * area);\r\n            body.ApplyForce(buoyancyForce, massc);\r\n            //Linear drag\r\n            var dragForce = body.GetLinearVelocityFromWorldPoint(areac, new b2Math_1.b2Vec2());\r\n            dragForce.SelfSub(this.velocity);\r\n            dragForce.SelfMul((-this.linearDrag * area));\r\n            body.ApplyForce(dragForce, areac);\r\n            //Angular drag\r\n            //TODO: Something that makes more physical sense?\r\n            body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));\r\n        }\r\n    };\r\n    b2BuoyancyController.prototype.Draw = function (debugDraw) {\r\n        var r = 100;\r\n        var p1 = new b2Math_1.b2Vec2();\r\n        var p2 = new b2Math_1.b2Vec2();\r\n        p1.x = this.normal.x * this.offset + this.normal.y * r;\r\n        p1.y = this.normal.y * this.offset - this.normal.x * r;\r\n        p2.x = this.normal.x * this.offset - this.normal.y * r;\r\n        p2.y = this.normal.y * this.offset + this.normal.x * r;\r\n        var color = new b2Draw_1.b2Color(0, 0, 0.8);\r\n        debugDraw.DrawSegment(p1, p2, color);\r\n    };\r\n    return b2BuoyancyController;\r\n}(b2Controller_1.b2Controller));\r\nexports.b2BuoyancyController = b2BuoyancyController;\r\n// #endif\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2BuoyancyController.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Controllers/b2BuoyancyController.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n *\r\n * This software is provided 'as-is', without any express or implied\r\n * warranty.  In no event will the authors be held liable for any damages\r\n * arising from the use of this software.\r\n * Permission is granted to anyone to use this software for any purpose,\r\n * including commercial applications, and to alter it and redistribute it\r\n * freely, subject to the following restrictions:\r\n * 1. The origin of this software must not be misrepresented; you must not\r\n * claim that you wrote the original software. If you use this software\r\n * in a product, an acknowledgment in the product documentation would be\r\n * appreciated but is not required.\r\n * 2. Altered source versions must be plainly marked as such, and must not be\r\n * misrepresented as being the original software.\r\n * 3. This notice may not be removed or altered from any source distribution.\r\n */\r\n\r\n// #if B2_ENABLE_CONTROLLER\r\n\r\nimport { b2Controller, b2ControllerEdge } from \"./b2Controller\";\r\nimport { b2Vec2 } from \"../Common/b2Math\";\r\nimport { b2TimeStep } from \"../Dynamics/b2TimeStep\";\r\nimport { b2_epsilon } from \"../Common/b2Settings\";\r\nimport { b2Draw, b2Color } from \"../Common/b2Draw\";\r\n\r\n/**\r\n * Calculates buoyancy forces for fluids in the form of a half\r\n * plane.\r\n */\r\nexport class b2BuoyancyController extends b2Controller {\r\n  /**\r\n   * The outer surface normal\r\n   */\r\n  public readonly normal = new b2Vec2(0, 1);\r\n  /**\r\n   * The height of the fluid surface along the normal\r\n   */\r\n  public offset = 0;\r\n  /**\r\n   * The fluid density\r\n   */\r\n  public density = 0;\r\n  /**\r\n   * Fluid velocity, for drag calculations\r\n   */\r\n  public readonly velocity = new b2Vec2(0, 0);\r\n  /**\r\n   * Linear drag co-efficient\r\n   */\r\n  public linearDrag = 0;\r\n  /**\r\n   * Angular drag co-efficient\r\n   */\r\n  public angularDrag = 0;\r\n  /**\r\n   * If false, bodies are assumed to be uniformly dense, otherwise\r\n   * use the shapes densities\r\n   */\r\n  public useDensity = false; //False by default to prevent a gotcha\r\n  /**\r\n   * If true, gravity is taken from the world instead of the\r\n   */\r\n  public useWorldGravity = true;\r\n  /**\r\n   * Gravity vector, if the world's gravity is not used\r\n   */\r\n  public readonly gravity = new b2Vec2(0, 0);\r\n\r\n  public Step(step: b2TimeStep) {\r\n    if (!this.m_bodyList) {\r\n      return;\r\n    }\r\n    if (this.useWorldGravity) {\r\n      this.gravity.Copy(this.m_bodyList.body.GetWorld().GetGravity());\r\n    }\r\n    for (let i: b2ControllerEdge | null = this.m_bodyList; i; i = i.nextBody) {\r\n      const body = i.body;\r\n      if (!body.IsAwake()) {\r\n        //Buoyancy force is just a function of position,\r\n        //so unlike most forces, it is safe to ignore sleeping bodes\r\n        continue;\r\n      }\r\n      const areac = new b2Vec2();\r\n      const massc = new b2Vec2();\r\n      let area = 0;\r\n      let mass = 0;\r\n      for (let fixture = body.GetFixtureList(); fixture; fixture = fixture.m_next) {\r\n        const sc = new b2Vec2();\r\n        const sarea = fixture.GetShape().ComputeSubmergedArea(this.normal, this.offset, body.GetTransform(), sc);\r\n        area += sarea;\r\n        areac.x += sarea * sc.x;\r\n        areac.y += sarea * sc.y;\r\n        let shapeDensity = 0;\r\n        if (this.useDensity) {\r\n          //TODO: Expose density publicly\r\n          shapeDensity = fixture.GetDensity();\r\n        } else {\r\n          shapeDensity = 1;\r\n        }\r\n        mass += sarea * shapeDensity;\r\n        massc.x += sarea * sc.x * shapeDensity;\r\n        massc.y += sarea * sc.y * shapeDensity;\r\n      }\r\n      areac.x /= area;\r\n      areac.y /= area;\r\n      //    b2Vec2 localCentroid = b2MulT(body->GetXForm(),areac);\r\n      massc.x /= mass;\r\n      massc.y /= mass;\r\n      if (area < b2_epsilon) {\r\n        continue;\r\n      }\r\n      //Buoyancy\r\n      const buoyancyForce = this.gravity.Clone().SelfNeg();\r\n      buoyancyForce.SelfMul(this.density * area);\r\n      body.ApplyForce(buoyancyForce, massc);\r\n      //Linear drag\r\n      const dragForce = body.GetLinearVelocityFromWorldPoint(areac, new b2Vec2());\r\n      dragForce.SelfSub(this.velocity);\r\n      dragForce.SelfMul((-this.linearDrag * area));\r\n      body.ApplyForce(dragForce, areac);\r\n      //Angular drag\r\n      //TODO: Something that makes more physical sense?\r\n      body.ApplyTorque((-body.GetInertia() / body.GetMass() * area * body.GetAngularVelocity() * this.angularDrag));\r\n    }\r\n  }\r\n\r\n  public Draw(debugDraw: b2Draw) {\r\n    const r = 100;\r\n    const p1 = new b2Vec2();\r\n    const p2 = new b2Vec2();\r\n    p1.x = this.normal.x * this.offset + this.normal.y * r;\r\n    p1.y = this.normal.y * this.offset - this.normal.x * r;\r\n    p2.x = this.normal.x * this.offset - this.normal.y * r;\r\n    p2.y = this.normal.y * this.offset + this.normal.x * r;\r\n\r\n    const color = new b2Color(0, 0, 0.8);\r\n\r\n    debugDraw.DrawSegment(p1, p2, color);\r\n  }\r\n}\r\n\r\n// #endif\r\n"]}},"error":null,"hash":"8613421074d5582bb3554ddd0e64dec9","cacheData":{"env":{}}}