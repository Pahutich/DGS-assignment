{"id":"../node_modules/box2d.package.ts/Collision/b2DynamicTree.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2DynamicTree.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2DynamicTree.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2GrowableStack","loc":{"line":23,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2DynamicTree.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2GrowableStack.ts"},{"name":"./b2Collision","loc":{"line":24,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2DynamicTree.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2GrowableStack_1 = require(\"../Common/b2GrowableStack\");\r\nvar b2Collision_1 = require(\"./b2Collision\");\r\nfunction verify(value) {\r\n    if (value === null) {\r\n        throw new Error();\r\n    }\r\n    return value;\r\n}\r\n/// A node in the dynamic tree. The client does not interact with this directly.\r\nvar b2TreeNode = /** @class */ (function () {\r\n    function b2TreeNode(id) {\r\n        if (id === void 0) { id = 0; }\r\n        this.m_id = 0;\r\n        this.aabb = new b2Collision_1.b2AABB();\r\n        this._userData = null;\r\n        this.parent = null; // or next\r\n        this.child1 = null;\r\n        this.child2 = null;\r\n        this.height = 0; // leaf = 0, free node = -1\r\n        this.m_id = id;\r\n    }\r\n    Object.defineProperty(b2TreeNode.prototype, \"userData\", {\r\n        get: function () {\r\n            if (this._userData === null) {\r\n                throw new Error();\r\n            }\r\n            return this._userData;\r\n        },\r\n        set: function (value) {\r\n            if (this._userData !== null) {\r\n                throw new Error();\r\n            }\r\n            this._userData = value;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    b2TreeNode.prototype.Reset = function () {\r\n        this._userData = null;\r\n    };\r\n    b2TreeNode.prototype.IsLeaf = function () {\r\n        return this.child1 === null;\r\n    };\r\n    return b2TreeNode;\r\n}());\r\nexports.b2TreeNode = b2TreeNode;\r\nvar b2DynamicTree = /** @class */ (function () {\r\n    function b2DynamicTree() {\r\n        this.m_root = null;\r\n        // b2TreeNode* public m_nodes;\r\n        // int32 public m_nodeCount;\r\n        // int32 public m_nodeCapacity;\r\n        this.m_freeList = null;\r\n        this.m_path = 0;\r\n        this.m_insertionCount = 0;\r\n        this.m_stack = new b2GrowableStack_1.b2GrowableStack(256);\r\n    }\r\n    // public GetUserData(node: b2TreeNode<T>): T {\r\n    //   // DEBUG: b2Assert(node !== null);\r\n    //   return node.userData;\r\n    // }\r\n    // public GetFatAABB(node: b2TreeNode<T>): b2AABB {\r\n    //   // DEBUG: b2Assert(node !== null);\r\n    //   return node.aabb;\r\n    // }\r\n    b2DynamicTree.prototype.Query = function (aabb, callback) {\r\n        var stack = this.m_stack.Reset();\r\n        stack.Push(this.m_root);\r\n        while (stack.GetCount() > 0) {\r\n            var node = stack.Pop();\r\n            if (node === null) {\r\n                continue;\r\n            }\r\n            if (node.aabb.TestOverlap(aabb)) {\r\n                if (node.IsLeaf()) {\r\n                    var proceed = callback(node);\r\n                    if (!proceed) {\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    stack.Push(node.child1);\r\n                    stack.Push(node.child2);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2DynamicTree.prototype.QueryPoint = function (point, callback) {\r\n        var stack = this.m_stack.Reset();\r\n        stack.Push(this.m_root);\r\n        while (stack.GetCount() > 0) {\r\n            var node = stack.Pop();\r\n            if (node === null) {\r\n                continue;\r\n            }\r\n            if (node.aabb.TestContain(point)) {\r\n                if (node.IsLeaf()) {\r\n                    var proceed = callback(node);\r\n                    if (!proceed) {\r\n                        return;\r\n                    }\r\n                }\r\n                else {\r\n                    stack.Push(node.child1);\r\n                    stack.Push(node.child2);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2DynamicTree.prototype.RayCast = function (input, callback) {\r\n        var p1 = input.p1;\r\n        var p2 = input.p2;\r\n        var r = b2Math_1.b2Vec2.SubVV(p2, p1, b2DynamicTree.s_r);\r\n        // DEBUG: b2Assert(r.LengthSquared() > 0);\r\n        r.Normalize();\r\n        // v is perpendicular to the segment.\r\n        var v = b2Math_1.b2Vec2.CrossOneV(r, b2DynamicTree.s_v);\r\n        var abs_v = b2Math_1.b2Vec2.AbsV(v, b2DynamicTree.s_abs_v);\r\n        // Separating axis for segment (Gino, p80).\r\n        // |dot(v, p1 - c)| > dot(|v|, h)\r\n        var maxFraction = input.maxFraction;\r\n        // Build a bounding box for the segment.\r\n        var segmentAABB = b2DynamicTree.s_segmentAABB;\r\n        var t_x = p1.x + maxFraction * (p2.x - p1.x);\r\n        var t_y = p1.y + maxFraction * (p2.y - p1.y);\r\n        segmentAABB.lowerBound.x = b2Math_1.b2Min(p1.x, t_x);\r\n        segmentAABB.lowerBound.y = b2Math_1.b2Min(p1.y, t_y);\r\n        segmentAABB.upperBound.x = b2Math_1.b2Max(p1.x, t_x);\r\n        segmentAABB.upperBound.y = b2Math_1.b2Max(p1.y, t_y);\r\n        var stack = this.m_stack.Reset();\r\n        stack.Push(this.m_root);\r\n        while (stack.GetCount() > 0) {\r\n            var node = stack.Pop();\r\n            if (node === null) {\r\n                continue;\r\n            }\r\n            if (!b2Collision_1.b2TestOverlapAABB(node.aabb, segmentAABB)) {\r\n                continue;\r\n            }\r\n            // Separating axis for segment (Gino, p80).\r\n            // |dot(v, p1 - c)| > dot(|v|, h)\r\n            var c = node.aabb.GetCenter();\r\n            var h = node.aabb.GetExtents();\r\n            var separation = b2Math_1.b2Abs(b2Math_1.b2Vec2.DotVV(v, b2Math_1.b2Vec2.SubVV(p1, c, b2Math_1.b2Vec2.s_t0))) - b2Math_1.b2Vec2.DotVV(abs_v, h);\r\n            if (separation > 0) {\r\n                continue;\r\n            }\r\n            if (node.IsLeaf()) {\r\n                var subInput = b2DynamicTree.s_subInput;\r\n                subInput.p1.Copy(input.p1);\r\n                subInput.p2.Copy(input.p2);\r\n                subInput.maxFraction = maxFraction;\r\n                var value = callback(subInput, node);\r\n                if (value === 0) {\r\n                    // The client has terminated the ray cast.\r\n                    return;\r\n                }\r\n                if (value > 0) {\r\n                    // Update segment bounding box.\r\n                    maxFraction = value;\r\n                    t_x = p1.x + maxFraction * (p2.x - p1.x);\r\n                    t_y = p1.y + maxFraction * (p2.y - p1.y);\r\n                    segmentAABB.lowerBound.x = b2Math_1.b2Min(p1.x, t_x);\r\n                    segmentAABB.lowerBound.y = b2Math_1.b2Min(p1.y, t_y);\r\n                    segmentAABB.upperBound.x = b2Math_1.b2Max(p1.x, t_x);\r\n                    segmentAABB.upperBound.y = b2Math_1.b2Max(p1.y, t_y);\r\n                }\r\n            }\r\n            else {\r\n                stack.Push(node.child1);\r\n                stack.Push(node.child2);\r\n            }\r\n        }\r\n    };\r\n    b2DynamicTree.prototype.AllocateNode = function () {\r\n        // Expand the node pool as needed.\r\n        if (this.m_freeList !== null) {\r\n            var node = this.m_freeList;\r\n            this.m_freeList = node.parent; // this.m_freeList = node.next;\r\n            node.parent = null;\r\n            node.child1 = null;\r\n            node.child2 = null;\r\n            node.height = 0;\r\n            return node;\r\n        }\r\n        return new b2TreeNode(b2DynamicTree.s_node_id++);\r\n    };\r\n    b2DynamicTree.prototype.FreeNode = function (node) {\r\n        node.parent = this.m_freeList; // node.next = this.m_freeList;\r\n        node.child1 = null;\r\n        node.child2 = null;\r\n        node.height = -1;\r\n        node.Reset();\r\n        this.m_freeList = node;\r\n    };\r\n    b2DynamicTree.prototype.CreateProxy = function (aabb, userData) {\r\n        var node = this.AllocateNode();\r\n        // Fatten the aabb.\r\n        var r_x = b2Settings_1.b2_aabbExtension;\r\n        var r_y = b2Settings_1.b2_aabbExtension;\r\n        node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n        node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n        node.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n        node.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n        node.userData = userData;\r\n        node.height = 0;\r\n        this.InsertLeaf(node);\r\n        return node;\r\n    };\r\n    b2DynamicTree.prototype.DestroyProxy = function (node) {\r\n        // DEBUG: b2Assert(node.IsLeaf());\r\n        this.RemoveLeaf(node);\r\n        this.FreeNode(node);\r\n    };\r\n    b2DynamicTree.prototype.MoveProxy = function (node, aabb, displacement) {\r\n        // DEBUG: b2Assert(node.IsLeaf());\r\n        if (node.aabb.Contains(aabb)) {\r\n            return false;\r\n        }\r\n        this.RemoveLeaf(node);\r\n        // Extend AABB.\r\n        var r_x = b2Settings_1.b2_aabbExtension;\r\n        var r_y = b2Settings_1.b2_aabbExtension;\r\n        node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n        node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n        node.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n        node.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n        // Predict AABB displacement.\r\n        var d_x = b2Settings_1.b2_aabbMultiplier * displacement.x;\r\n        var d_y = b2Settings_1.b2_aabbMultiplier * displacement.y;\r\n        if (d_x < 0.0) {\r\n            node.aabb.lowerBound.x += d_x;\r\n        }\r\n        else {\r\n            node.aabb.upperBound.x += d_x;\r\n        }\r\n        if (d_y < 0.0) {\r\n            node.aabb.lowerBound.y += d_y;\r\n        }\r\n        else {\r\n            node.aabb.upperBound.y += d_y;\r\n        }\r\n        this.InsertLeaf(node);\r\n        return true;\r\n    };\r\n    b2DynamicTree.prototype.InsertLeaf = function (leaf) {\r\n        ++this.m_insertionCount;\r\n        if (this.m_root === null) {\r\n            this.m_root = leaf;\r\n            this.m_root.parent = null;\r\n            return;\r\n        }\r\n        // Find the best sibling for this node\r\n        var leafAABB = leaf.aabb;\r\n        var sibling = this.m_root;\r\n        while (!sibling.IsLeaf()) {\r\n            var child1 = verify(sibling.child1);\r\n            var child2 = verify(sibling.child2);\r\n            var area = sibling.aabb.GetPerimeter();\r\n            var combinedAABB = b2DynamicTree.s_combinedAABB;\r\n            combinedAABB.Combine2(sibling.aabb, leafAABB);\r\n            var combinedArea = combinedAABB.GetPerimeter();\r\n            // Cost of creating a new parent for this node and the new leaf\r\n            var cost = 2 * combinedArea;\r\n            // Minimum cost of pushing the leaf further down the tree\r\n            var inheritanceCost = 2 * (combinedArea - area);\r\n            // Cost of descending into child1\r\n            var cost1 = void 0;\r\n            var aabb = b2DynamicTree.s_aabb;\r\n            var oldArea = void 0;\r\n            var newArea = void 0;\r\n            if (child1.IsLeaf()) {\r\n                aabb.Combine2(leafAABB, child1.aabb);\r\n                cost1 = aabb.GetPerimeter() + inheritanceCost;\r\n            }\r\n            else {\r\n                aabb.Combine2(leafAABB, child1.aabb);\r\n                oldArea = child1.aabb.GetPerimeter();\r\n                newArea = aabb.GetPerimeter();\r\n                cost1 = (newArea - oldArea) + inheritanceCost;\r\n            }\r\n            // Cost of descending into child2\r\n            var cost2 = void 0;\r\n            if (child2.IsLeaf()) {\r\n                aabb.Combine2(leafAABB, child2.aabb);\r\n                cost2 = aabb.GetPerimeter() + inheritanceCost;\r\n            }\r\n            else {\r\n                aabb.Combine2(leafAABB, child2.aabb);\r\n                oldArea = child2.aabb.GetPerimeter();\r\n                newArea = aabb.GetPerimeter();\r\n                cost2 = newArea - oldArea + inheritanceCost;\r\n            }\r\n            // Descend according to the minimum cost.\r\n            if (cost < cost1 && cost < cost2) {\r\n                break;\r\n            }\r\n            // Descend\r\n            if (cost1 < cost2) {\r\n                sibling = child1;\r\n            }\r\n            else {\r\n                sibling = child2;\r\n            }\r\n        }\r\n        // Create a parent for the siblings.\r\n        var oldParent = sibling.parent;\r\n        var newParent = this.AllocateNode();\r\n        newParent.parent = oldParent;\r\n        newParent.aabb.Combine2(leafAABB, sibling.aabb);\r\n        newParent.height = sibling.height + 1;\r\n        if (oldParent !== null) {\r\n            // The sibling was not the root.\r\n            if (oldParent.child1 === sibling) {\r\n                oldParent.child1 = newParent;\r\n            }\r\n            else {\r\n                oldParent.child2 = newParent;\r\n            }\r\n            newParent.child1 = sibling;\r\n            newParent.child2 = leaf;\r\n            sibling.parent = newParent;\r\n            leaf.parent = newParent;\r\n        }\r\n        else {\r\n            // The sibling was the root.\r\n            newParent.child1 = sibling;\r\n            newParent.child2 = leaf;\r\n            sibling.parent = newParent;\r\n            leaf.parent = newParent;\r\n            this.m_root = newParent;\r\n        }\r\n        // Walk back up the tree fixing heights and AABBs\r\n        var node = leaf.parent;\r\n        while (node !== null) {\r\n            node = this.Balance(node);\r\n            var child1 = verify(node.child1);\r\n            var child2 = verify(node.child2);\r\n            node.height = 1 + b2Math_1.b2Max(child1.height, child2.height);\r\n            node.aabb.Combine2(child1.aabb, child2.aabb);\r\n            node = node.parent;\r\n        }\r\n        // this.Validate();\r\n    };\r\n    b2DynamicTree.prototype.RemoveLeaf = function (leaf) {\r\n        if (leaf === this.m_root) {\r\n            this.m_root = null;\r\n            return;\r\n        }\r\n        var parent = verify(leaf.parent);\r\n        var grandParent = parent && parent.parent;\r\n        var sibling = verify(parent.child1 === leaf ? parent.child2 : parent.child1);\r\n        if (grandParent !== null) {\r\n            // Destroy parent and connect sibling to grandParent.\r\n            if (grandParent.child1 === parent) {\r\n                grandParent.child1 = sibling;\r\n            }\r\n            else {\r\n                grandParent.child2 = sibling;\r\n            }\r\n            sibling.parent = grandParent;\r\n            this.FreeNode(parent);\r\n            // Adjust ancestor bounds.\r\n            var index = grandParent;\r\n            while (index !== null) {\r\n                index = this.Balance(index);\r\n                var child1 = verify(index.child1);\r\n                var child2 = verify(index.child2);\r\n                index.aabb.Combine2(child1.aabb, child2.aabb);\r\n                index.height = 1 + b2Math_1.b2Max(child1.height, child2.height);\r\n                index = index.parent;\r\n            }\r\n        }\r\n        else {\r\n            this.m_root = sibling;\r\n            sibling.parent = null;\r\n            this.FreeNode(parent);\r\n        }\r\n        // this.Validate();\r\n    };\r\n    b2DynamicTree.prototype.Balance = function (A) {\r\n        // DEBUG: b2Assert(A !== null);\r\n        if (A.IsLeaf() || A.height < 2) {\r\n            return A;\r\n        }\r\n        var B = verify(A.child1);\r\n        var C = verify(A.child2);\r\n        var balance = C.height - B.height;\r\n        // Rotate C up\r\n        if (balance > 1) {\r\n            var F = verify(C.child1);\r\n            var G = verify(C.child2);\r\n            // Swap A and C\r\n            C.child1 = A;\r\n            C.parent = A.parent;\r\n            A.parent = C;\r\n            // A's old parent should point to C\r\n            if (C.parent !== null) {\r\n                if (C.parent.child1 === A) {\r\n                    C.parent.child1 = C;\r\n                }\r\n                else {\r\n                    // DEBUG: b2Assert(C.parent.child2 === A);\r\n                    C.parent.child2 = C;\r\n                }\r\n            }\r\n            else {\r\n                this.m_root = C;\r\n            }\r\n            // Rotate\r\n            if (F.height > G.height) {\r\n                C.child2 = F;\r\n                A.child2 = G;\r\n                G.parent = A;\r\n                A.aabb.Combine2(B.aabb, G.aabb);\r\n                C.aabb.Combine2(A.aabb, F.aabb);\r\n                A.height = 1 + b2Math_1.b2Max(B.height, G.height);\r\n                C.height = 1 + b2Math_1.b2Max(A.height, F.height);\r\n            }\r\n            else {\r\n                C.child2 = G;\r\n                A.child2 = F;\r\n                F.parent = A;\r\n                A.aabb.Combine2(B.aabb, F.aabb);\r\n                C.aabb.Combine2(A.aabb, G.aabb);\r\n                A.height = 1 + b2Math_1.b2Max(B.height, F.height);\r\n                C.height = 1 + b2Math_1.b2Max(A.height, G.height);\r\n            }\r\n            return C;\r\n        }\r\n        // Rotate B up\r\n        if (balance < -1) {\r\n            var D = verify(B.child1);\r\n            var E = verify(B.child2);\r\n            // Swap A and B\r\n            B.child1 = A;\r\n            B.parent = A.parent;\r\n            A.parent = B;\r\n            // A's old parent should point to B\r\n            if (B.parent !== null) {\r\n                if (B.parent.child1 === A) {\r\n                    B.parent.child1 = B;\r\n                }\r\n                else {\r\n                    // DEBUG: b2Assert(B.parent.child2 === A);\r\n                    B.parent.child2 = B;\r\n                }\r\n            }\r\n            else {\r\n                this.m_root = B;\r\n            }\r\n            // Rotate\r\n            if (D.height > E.height) {\r\n                B.child2 = D;\r\n                A.child1 = E;\r\n                E.parent = A;\r\n                A.aabb.Combine2(C.aabb, E.aabb);\r\n                B.aabb.Combine2(A.aabb, D.aabb);\r\n                A.height = 1 + b2Math_1.b2Max(C.height, E.height);\r\n                B.height = 1 + b2Math_1.b2Max(A.height, D.height);\r\n            }\r\n            else {\r\n                B.child2 = E;\r\n                A.child1 = D;\r\n                D.parent = A;\r\n                A.aabb.Combine2(C.aabb, D.aabb);\r\n                B.aabb.Combine2(A.aabb, E.aabb);\r\n                A.height = 1 + b2Math_1.b2Max(C.height, D.height);\r\n                B.height = 1 + b2Math_1.b2Max(A.height, E.height);\r\n            }\r\n            return B;\r\n        }\r\n        return A;\r\n    };\r\n    b2DynamicTree.prototype.GetHeight = function () {\r\n        if (this.m_root === null) {\r\n            return 0;\r\n        }\r\n        return this.m_root.height;\r\n    };\r\n    b2DynamicTree.GetAreaNode = function (node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        if (node.IsLeaf()) {\r\n            return 0;\r\n        }\r\n        var area = node.aabb.GetPerimeter();\r\n        area += b2DynamicTree.GetAreaNode(node.child1);\r\n        area += b2DynamicTree.GetAreaNode(node.child2);\r\n        return area;\r\n    };\r\n    b2DynamicTree.prototype.GetAreaRatio = function () {\r\n        if (this.m_root === null) {\r\n            return 0;\r\n        }\r\n        var root = this.m_root;\r\n        var rootArea = root.aabb.GetPerimeter();\r\n        var totalArea = b2DynamicTree.GetAreaNode(this.m_root);\r\n        /*\r\n        float32 totalArea = 0.0;\r\n        for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n          const b2TreeNode<T>* node = m_nodes + i;\r\n          if (node.height < 0) {\r\n            // Free node in pool\r\n            continue;\r\n          }\r\n    \r\n          totalArea += node.aabb.GetPerimeter();\r\n        }\r\n        */\r\n        return totalArea / rootArea;\r\n    };\r\n    b2DynamicTree.ComputeHeightNode = function (node) {\r\n        if (node === null) {\r\n            return 0;\r\n        }\r\n        if (node.IsLeaf()) {\r\n            return 0;\r\n        }\r\n        var height1 = b2DynamicTree.ComputeHeightNode(node.child1);\r\n        var height2 = b2DynamicTree.ComputeHeightNode(node.child2);\r\n        return 1 + b2Math_1.b2Max(height1, height2);\r\n    };\r\n    b2DynamicTree.prototype.ComputeHeight = function () {\r\n        var height = b2DynamicTree.ComputeHeightNode(this.m_root);\r\n        return height;\r\n    };\r\n    b2DynamicTree.prototype.ValidateStructure = function (node) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        if (node === this.m_root) {\r\n            // DEBUG: b2Assert(node.parent === null);\r\n        }\r\n        if (node.IsLeaf()) {\r\n            // DEBUG: b2Assert(node.child1 === null);\r\n            // DEBUG: b2Assert(node.child2 === null);\r\n            // DEBUG: b2Assert(node.height === 0);\r\n            return;\r\n        }\r\n        var child1 = verify(node.child1);\r\n        var child2 = verify(node.child2);\r\n        // DEBUG: b2Assert(child1.parent === index);\r\n        // DEBUG: b2Assert(child2.parent === index);\r\n        this.ValidateStructure(child1);\r\n        this.ValidateStructure(child2);\r\n    };\r\n    b2DynamicTree.prototype.ValidateMetrics = function (node) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        if (node.IsLeaf()) {\r\n            // DEBUG: b2Assert(node.child1 === null);\r\n            // DEBUG: b2Assert(node.child2 === null);\r\n            // DEBUG: b2Assert(node.height === 0);\r\n            return;\r\n        }\r\n        var child1 = verify(node.child1);\r\n        var child2 = verify(node.child2);\r\n        // DEBUG: const height1: number = child1.height;\r\n        // DEBUG: const height2: number = child2.height;\r\n        // DEBUG: const height: number = 1 + b2Max(height1, height2);\r\n        // DEBUG: b2Assert(node.height === height);\r\n        var aabb = b2DynamicTree.s_aabb;\r\n        aabb.Combine2(child1.aabb, child2.aabb);\r\n        // DEBUG: b2Assert(aabb.lowerBound === node.aabb.lowerBound);\r\n        // DEBUG: b2Assert(aabb.upperBound === node.aabb.upperBound);\r\n        this.ValidateMetrics(child1);\r\n        this.ValidateMetrics(child2);\r\n    };\r\n    b2DynamicTree.prototype.Validate = function () {\r\n        // DEBUG: this.ValidateStructure(this.m_root);\r\n        // DEBUG: this.ValidateMetrics(this.m_root);\r\n        // let freeCount: number = 0;\r\n        // let freeIndex: b2TreeNode<T> | null = this.m_freeList;\r\n        // while (freeIndex !== null) {\r\n        //   freeIndex = freeIndex.parent; // freeIndex = freeIndex.next;\r\n        //   ++freeCount;\r\n        // }\r\n        // DEBUG: b2Assert(this.GetHeight() === this.ComputeHeight());\r\n        // b2Assert(this.m_nodeCount + freeCount === this.m_nodeCapacity);\r\n    };\r\n    b2DynamicTree.GetMaxBalanceNode = function (node, maxBalance) {\r\n        if (node === null) {\r\n            return maxBalance;\r\n        }\r\n        if (node.height <= 1) {\r\n            return maxBalance;\r\n        }\r\n        // DEBUG: b2Assert(!node.IsLeaf());\r\n        var child1 = verify(node.child1);\r\n        var child2 = verify(node.child2);\r\n        var balance = b2Math_1.b2Abs(child2.height - child1.height);\r\n        return b2Math_1.b2Max(maxBalance, balance);\r\n    };\r\n    b2DynamicTree.prototype.GetMaxBalance = function () {\r\n        var maxBalance = b2DynamicTree.GetMaxBalanceNode(this.m_root, 0);\r\n        /*\r\n        int32 maxBalance = 0;\r\n        for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n          const b2TreeNode<T>* node = m_nodes + i;\r\n          if (node.height <= 1) {\r\n            continue;\r\n          }\r\n    \r\n          b2Assert(!node.IsLeaf());\r\n    \r\n          int32 child1 = node.child1;\r\n          int32 child2 = node.child2;\r\n          int32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].height);\r\n          maxBalance = b2Max(maxBalance, balance);\r\n        }\r\n        */\r\n        return maxBalance;\r\n    };\r\n    b2DynamicTree.prototype.RebuildBottomUp = function () {\r\n        /*\r\n        int32* nodes = (int32*)b2Alloc(m_nodeCount * sizeof(int32));\r\n        int32 count = 0;\r\n    \r\n        // Build array of leaves. Free the rest.\r\n        for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n          if (m_nodes[i].height < 0) {\r\n            // free node in pool\r\n            continue;\r\n          }\r\n    \r\n          if (m_nodes[i].IsLeaf()) {\r\n            m_nodes[i].parent = b2_nullNode;\r\n            nodes[count] = i;\r\n            ++count;\r\n          } else {\r\n            FreeNode(i);\r\n          }\r\n        }\r\n    \r\n        while (count > 1) {\r\n          float32 minCost = b2_maxFloat;\r\n          int32 iMin = -1, jMin = -1;\r\n          for (int32 i = 0; i < count; ++i) {\r\n            b2AABB aabbi = m_nodes[nodes[i]].aabb;\r\n    \r\n            for (int32 j = i + 1; j < count; ++j) {\r\n              b2AABB aabbj = m_nodes[nodes[j]].aabb;\r\n              b2AABB b;\r\n              b.Combine(aabbi, aabbj);\r\n              float32 cost = b.GetPerimeter();\r\n              if (cost < minCost) {\r\n                iMin = i;\r\n                jMin = j;\r\n                minCost = cost;\r\n              }\r\n            }\r\n          }\r\n    \r\n          int32 index1 = nodes[iMin];\r\n          int32 index2 = nodes[jMin];\r\n          b2TreeNode<T>* child1 = m_nodes + index1;\r\n          b2TreeNode<T>* child2 = m_nodes + index2;\r\n    \r\n          int32 parentIndex = AllocateNode();\r\n          b2TreeNode<T>* parent = m_nodes + parentIndex;\r\n          parent.child1 = index1;\r\n          parent.child2 = index2;\r\n          parent.height = 1 + b2Max(child1.height, child2.height);\r\n          parent.aabb.Combine(child1.aabb, child2.aabb);\r\n          parent.parent = b2_nullNode;\r\n    \r\n          child1.parent = parentIndex;\r\n          child2.parent = parentIndex;\r\n    \r\n          nodes[jMin] = nodes[count-1];\r\n          nodes[iMin] = parentIndex;\r\n          --count;\r\n        }\r\n    \r\n        m_root = nodes[0];\r\n        b2Free(nodes);\r\n        */\r\n        this.Validate();\r\n    };\r\n    b2DynamicTree.ShiftOriginNode = function (node, newOrigin) {\r\n        if (node === null) {\r\n            return;\r\n        }\r\n        if (node.height <= 1) {\r\n            return;\r\n        }\r\n        // DEBUG: b2Assert(!node.IsLeaf());\r\n        var child1 = node.child1;\r\n        var child2 = node.child2;\r\n        b2DynamicTree.ShiftOriginNode(child1, newOrigin);\r\n        b2DynamicTree.ShiftOriginNode(child2, newOrigin);\r\n        node.aabb.lowerBound.SelfSub(newOrigin);\r\n        node.aabb.upperBound.SelfSub(newOrigin);\r\n    };\r\n    b2DynamicTree.prototype.ShiftOrigin = function (newOrigin) {\r\n        b2DynamicTree.ShiftOriginNode(this.m_root, newOrigin);\r\n        /*\r\n        // Build array of leaves. Free the rest.\r\n        for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n          m_nodes[i].aabb.lowerBound -= newOrigin;\r\n          m_nodes[i].aabb.upperBound -= newOrigin;\r\n        }\r\n        */\r\n    };\r\n    b2DynamicTree.s_r = new b2Math_1.b2Vec2();\r\n    b2DynamicTree.s_v = new b2Math_1.b2Vec2();\r\n    b2DynamicTree.s_abs_v = new b2Math_1.b2Vec2();\r\n    b2DynamicTree.s_segmentAABB = new b2Collision_1.b2AABB();\r\n    b2DynamicTree.s_subInput = new b2Collision_1.b2RayCastInput();\r\n    b2DynamicTree.s_combinedAABB = new b2Collision_1.b2AABB();\r\n    b2DynamicTree.s_aabb = new b2Collision_1.b2AABB();\r\n    b2DynamicTree.s_node_id = 0;\r\n    return b2DynamicTree;\r\n}());\r\nexports.b2DynamicTree = b2DynamicTree;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2DynamicTree.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Collision/b2DynamicTree.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_aabbExtension, b2_aabbMultiplier } from \"../Common/b2Settings\";\r\nimport { b2Abs, b2Min, b2Max, b2Vec2, XY } from \"../Common/b2Math\";\r\nimport { b2GrowableStack } from \"../Common/b2GrowableStack\";\r\nimport { b2AABB, b2RayCastInput, b2TestOverlapAABB } from \"./b2Collision\";\r\n\r\nfunction verify<T>(value: T | null): T {\r\n  if (value === null) { throw new Error(); }\r\n  return value;\r\n}\r\n\r\n/// A node in the dynamic tree. The client does not interact with this directly.\r\nexport class b2TreeNode<T> {\r\n  public readonly m_id: number = 0;\r\n  public readonly aabb: b2AABB = new b2AABB();\r\n  private _userData: T | null = null;\r\n  public get userData(): T {\r\n    if (this._userData === null) { throw new Error(); }\r\n    return this._userData;\r\n  }\r\n  public set userData(value: T) {\r\n    if (this._userData !== null) { throw new Error(); }\r\n    this._userData = value;\r\n  }\r\n  public parent: b2TreeNode<T> | null = null; // or next\r\n  public child1: b2TreeNode<T> | null = null;\r\n  public child2: b2TreeNode<T> | null = null;\r\n  public height: number = 0; // leaf = 0, free node = -1\r\n\r\n  constructor(id: number = 0) {\r\n    this.m_id = id;\r\n  }\r\n\r\n  public Reset(): void {\r\n    this._userData = null;\r\n  }\r\n\r\n  public IsLeaf(): boolean {\r\n    return this.child1 === null;\r\n  }\r\n}\r\n\r\nexport class b2DynamicTree<T> {\r\n  public m_root: b2TreeNode<T> | null = null;\r\n\r\n  // b2TreeNode* public m_nodes;\r\n  // int32 public m_nodeCount;\r\n  // int32 public m_nodeCapacity;\r\n\r\n  public m_freeList: b2TreeNode<T> | null = null;\r\n\r\n  public m_path: number = 0;\r\n\r\n  public m_insertionCount: number = 0;\r\n\r\n  public readonly m_stack = new b2GrowableStack<b2TreeNode<T> | null>(256);\r\n  public static readonly s_r = new b2Vec2();\r\n  public static readonly s_v = new b2Vec2();\r\n  public static readonly s_abs_v = new b2Vec2();\r\n  public static readonly s_segmentAABB = new b2AABB();\r\n  public static readonly s_subInput = new b2RayCastInput();\r\n  public static readonly s_combinedAABB = new b2AABB();\r\n  public static readonly s_aabb = new b2AABB();\r\n\r\n  // public GetUserData(node: b2TreeNode<T>): T {\r\n  //   // DEBUG: b2Assert(node !== null);\r\n  //   return node.userData;\r\n  // }\r\n\r\n  // public GetFatAABB(node: b2TreeNode<T>): b2AABB {\r\n  //   // DEBUG: b2Assert(node !== null);\r\n  //   return node.aabb;\r\n  // }\r\n\r\n  public Query(aabb: b2AABB, callback: (node: b2TreeNode<T>) => boolean): void {\r\n    const stack: b2GrowableStack<b2TreeNode<T> | null> = this.m_stack.Reset();\r\n    stack.Push(this.m_root);\r\n\r\n    while (stack.GetCount() > 0) {\r\n      const node: b2TreeNode<T> | null = stack.Pop();\r\n      if (node === null) {\r\n        continue;\r\n      }\r\n\r\n      if (node.aabb.TestOverlap(aabb)) {\r\n        if (node.IsLeaf()) {\r\n          const proceed: boolean = callback(node);\r\n          if (!proceed) {\r\n            return;\r\n          }\r\n        } else {\r\n          stack.Push(node.child1);\r\n          stack.Push(node.child2);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public QueryPoint(point: XY, callback: (node: b2TreeNode<T>) => boolean): void {\r\n    const stack: b2GrowableStack<b2TreeNode<T> | null> = this.m_stack.Reset();\r\n    stack.Push(this.m_root);\r\n\r\n    while (stack.GetCount() > 0) {\r\n      const node: b2TreeNode<T> | null = stack.Pop();\r\n      if (node === null) {\r\n        continue;\r\n      }\r\n\r\n      if (node.aabb.TestContain(point)) {\r\n        if (node.IsLeaf()) {\r\n          const proceed: boolean = callback(node);\r\n          if (!proceed) {\r\n            return;\r\n          }\r\n        } else {\r\n          stack.Push(node.child1);\r\n          stack.Push(node.child2);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public RayCast(input: b2RayCastInput, callback: (input: b2RayCastInput, node: b2TreeNode<T>) => number): void {\r\n    const p1: b2Vec2 = input.p1;\r\n    const p2: b2Vec2 = input.p2;\r\n    const r: b2Vec2 = b2Vec2.SubVV(p2, p1, b2DynamicTree.s_r);\r\n    // DEBUG: b2Assert(r.LengthSquared() > 0);\r\n    r.Normalize();\r\n\r\n    // v is perpendicular to the segment.\r\n    const v: b2Vec2 = b2Vec2.CrossOneV(r, b2DynamicTree.s_v);\r\n    const abs_v: b2Vec2 = b2Vec2.AbsV(v, b2DynamicTree.s_abs_v);\r\n\r\n    // Separating axis for segment (Gino, p80).\r\n    // |dot(v, p1 - c)| > dot(|v|, h)\r\n\r\n    let maxFraction: number = input.maxFraction;\r\n\r\n    // Build a bounding box for the segment.\r\n    const segmentAABB: b2AABB = b2DynamicTree.s_segmentAABB;\r\n    let t_x: number = p1.x + maxFraction * (p2.x - p1.x);\r\n    let t_y: number = p1.y + maxFraction * (p2.y - p1.y);\r\n    segmentAABB.lowerBound.x = b2Min(p1.x, t_x);\r\n    segmentAABB.lowerBound.y = b2Min(p1.y, t_y);\r\n    segmentAABB.upperBound.x = b2Max(p1.x, t_x);\r\n    segmentAABB.upperBound.y = b2Max(p1.y, t_y);\r\n\r\n    const stack: b2GrowableStack<b2TreeNode<T> | null> = this.m_stack.Reset();\r\n    stack.Push(this.m_root);\r\n\r\n    while (stack.GetCount() > 0) {\r\n      const node: b2TreeNode<T> | null = stack.Pop();\r\n      if (node === null) {\r\n        continue;\r\n      }\r\n\r\n      if (!b2TestOverlapAABB(node.aabb, segmentAABB)) {\r\n        continue;\r\n      }\r\n\r\n      // Separating axis for segment (Gino, p80).\r\n      // |dot(v, p1 - c)| > dot(|v|, h)\r\n      const c: b2Vec2 = node.aabb.GetCenter();\r\n      const h: b2Vec2 = node.aabb.GetExtents();\r\n      const separation: number = b2Abs(b2Vec2.DotVV(v, b2Vec2.SubVV(p1, c, b2Vec2.s_t0))) - b2Vec2.DotVV(abs_v, h);\r\n      if (separation > 0) {\r\n        continue;\r\n      }\r\n\r\n      if (node.IsLeaf()) {\r\n        const subInput: b2RayCastInput = b2DynamicTree.s_subInput;\r\n        subInput.p1.Copy(input.p1);\r\n        subInput.p2.Copy(input.p2);\r\n        subInput.maxFraction = maxFraction;\r\n\r\n        const value: number = callback(subInput, node);\r\n\r\n        if (value === 0) {\r\n          // The client has terminated the ray cast.\r\n          return;\r\n        }\r\n\r\n        if (value > 0) {\r\n          // Update segment bounding box.\r\n          maxFraction = value;\r\n          t_x = p1.x + maxFraction * (p2.x - p1.x);\r\n          t_y = p1.y + maxFraction * (p2.y - p1.y);\r\n          segmentAABB.lowerBound.x = b2Min(p1.x, t_x);\r\n          segmentAABB.lowerBound.y = b2Min(p1.y, t_y);\r\n          segmentAABB.upperBound.x = b2Max(p1.x, t_x);\r\n          segmentAABB.upperBound.y = b2Max(p1.y, t_y);\r\n        }\r\n      } else {\r\n        stack.Push(node.child1);\r\n        stack.Push(node.child2);\r\n      }\r\n    }\r\n  }\r\n\r\n  public static s_node_id: number = 0;\r\n\r\n  public AllocateNode(): b2TreeNode<T> {\r\n    // Expand the node pool as needed.\r\n    if (this.m_freeList !== null) {\r\n      const node: b2TreeNode<T> = this.m_freeList;\r\n      this.m_freeList = node.parent; // this.m_freeList = node.next;\r\n      node.parent = null;\r\n      node.child1 = null;\r\n      node.child2 = null;\r\n      node.height = 0;\r\n      return node;\r\n    }\r\n\r\n    return new b2TreeNode<T>(b2DynamicTree.s_node_id++);\r\n  }\r\n\r\n  public FreeNode(node: b2TreeNode<T>): void {\r\n    node.parent = this.m_freeList; // node.next = this.m_freeList;\r\n    node.child1 = null;\r\n    node.child2 = null;\r\n    node.height = -1;\r\n    node.Reset();\r\n    this.m_freeList = node;\r\n  }\r\n\r\n  public CreateProxy(aabb: b2AABB, userData: T): b2TreeNode<T> {\r\n    const node: b2TreeNode<T> = this.AllocateNode();\r\n\r\n    // Fatten the aabb.\r\n    const r_x: number = b2_aabbExtension;\r\n    const r_y: number = b2_aabbExtension;\r\n    node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n    node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n    node.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n    node.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n    node.userData = userData;\r\n    node.height = 0;\r\n\r\n    this.InsertLeaf(node);\r\n\r\n    return node;\r\n  }\r\n\r\n  public DestroyProxy(node: b2TreeNode<T>): void {\r\n    // DEBUG: b2Assert(node.IsLeaf());\r\n\r\n    this.RemoveLeaf(node);\r\n    this.FreeNode(node);\r\n  }\r\n\r\n  public MoveProxy(node: b2TreeNode<T>, aabb: b2AABB, displacement: b2Vec2): boolean {\r\n    // DEBUG: b2Assert(node.IsLeaf());\r\n\r\n    if (node.aabb.Contains(aabb)) {\r\n      return false;\r\n    }\r\n\r\n    this.RemoveLeaf(node);\r\n\r\n    // Extend AABB.\r\n    const r_x: number = b2_aabbExtension;\r\n    const r_y: number = b2_aabbExtension;\r\n    node.aabb.lowerBound.x = aabb.lowerBound.x - r_x;\r\n    node.aabb.lowerBound.y = aabb.lowerBound.y - r_y;\r\n    node.aabb.upperBound.x = aabb.upperBound.x + r_x;\r\n    node.aabb.upperBound.y = aabb.upperBound.y + r_y;\r\n\r\n    // Predict AABB displacement.\r\n    const d_x: number = b2_aabbMultiplier * displacement.x;\r\n    const d_y: number = b2_aabbMultiplier * displacement.y;\r\n\r\n    if (d_x < 0.0) {\r\n    \tnode.aabb.lowerBound.x += d_x;\r\n    } else {\r\n    \tnode.aabb.upperBound.x += d_x;\r\n    }\r\n\r\n    if (d_y < 0.0) {\r\n    \tnode.aabb.lowerBound.y += d_y;\r\n    } else {\r\n    \tnode.aabb.upperBound.y += d_y;\r\n    }\r\n\r\n    this.InsertLeaf(node);\r\n    return true;\r\n  }\r\n\r\n  public InsertLeaf(leaf: b2TreeNode<T>): void {\r\n    ++this.m_insertionCount;\r\n\r\n    if (this.m_root === null) {\r\n      this.m_root = leaf;\r\n      this.m_root.parent = null;\r\n      return;\r\n    }\r\n\r\n    // Find the best sibling for this node\r\n    const leafAABB: b2AABB = leaf.aabb;\r\n    let sibling: b2TreeNode<T> = this.m_root;\r\n    while (!sibling.IsLeaf()) {\r\n      const child1: b2TreeNode<T> = verify(sibling.child1);\r\n      const child2: b2TreeNode<T> = verify(sibling.child2);\r\n\r\n      const area: number = sibling.aabb.GetPerimeter();\r\n\r\n      const combinedAABB: b2AABB = b2DynamicTree.s_combinedAABB;\r\n      combinedAABB.Combine2(sibling.aabb, leafAABB);\r\n      const combinedArea: number = combinedAABB.GetPerimeter();\r\n\r\n      // Cost of creating a new parent for this node and the new leaf\r\n      const cost: number = 2 * combinedArea;\r\n\r\n      // Minimum cost of pushing the leaf further down the tree\r\n      const inheritanceCost: number = 2 * (combinedArea - area);\r\n\r\n      // Cost of descending into child1\r\n      let cost1: number;\r\n      const aabb: b2AABB = b2DynamicTree.s_aabb;\r\n      let oldArea: number;\r\n      let newArea: number;\r\n      if (child1.IsLeaf()) {\r\n        aabb.Combine2(leafAABB, child1.aabb);\r\n        cost1 = aabb.GetPerimeter() + inheritanceCost;\r\n      } else {\r\n        aabb.Combine2(leafAABB, child1.aabb);\r\n        oldArea = child1.aabb.GetPerimeter();\r\n        newArea = aabb.GetPerimeter();\r\n        cost1 = (newArea - oldArea) + inheritanceCost;\r\n      }\r\n\r\n      // Cost of descending into child2\r\n      let cost2: number;\r\n      if (child2.IsLeaf()) {\r\n        aabb.Combine2(leafAABB, child2.aabb);\r\n        cost2 = aabb.GetPerimeter() + inheritanceCost;\r\n      } else {\r\n        aabb.Combine2(leafAABB, child2.aabb);\r\n        oldArea = child2.aabb.GetPerimeter();\r\n        newArea = aabb.GetPerimeter();\r\n        cost2 = newArea - oldArea + inheritanceCost;\r\n      }\r\n\r\n      // Descend according to the minimum cost.\r\n      if (cost < cost1 && cost < cost2) {\r\n        break;\r\n      }\r\n\r\n      // Descend\r\n      if (cost1 < cost2) {\r\n        sibling = child1;\r\n      } else {\r\n        sibling = child2;\r\n      }\r\n    }\r\n\r\n    // Create a parent for the siblings.\r\n    const oldParent: b2TreeNode<T> | null = sibling.parent;\r\n    const newParent: b2TreeNode<T> = this.AllocateNode();\r\n    newParent.parent = oldParent;\r\n    newParent.aabb.Combine2(leafAABB, sibling.aabb);\r\n    newParent.height = sibling.height + 1;\r\n\r\n    if (oldParent !== null) {\r\n      // The sibling was not the root.\r\n      if (oldParent.child1 === sibling) {\r\n        oldParent.child1 = newParent;\r\n      } else {\r\n        oldParent.child2 = newParent;\r\n      }\r\n\r\n      newParent.child1 = sibling;\r\n      newParent.child2 = leaf;\r\n      sibling.parent = newParent;\r\n      leaf.parent = newParent;\r\n    } else {\r\n      // The sibling was the root.\r\n      newParent.child1 = sibling;\r\n      newParent.child2 = leaf;\r\n      sibling.parent = newParent;\r\n      leaf.parent = newParent;\r\n      this.m_root = newParent;\r\n    }\r\n\r\n    // Walk back up the tree fixing heights and AABBs\r\n    let node: b2TreeNode<T> | null = leaf.parent;\r\n    while (node !== null) {\r\n      node = this.Balance(node);\r\n\r\n      const child1: b2TreeNode<T> = verify(node.child1);\r\n      const child2: b2TreeNode<T> = verify(node.child2);\r\n\r\n      node.height = 1 + b2Max(child1.height, child2.height);\r\n      node.aabb.Combine2(child1.aabb, child2.aabb);\r\n\r\n      node = node.parent;\r\n    }\r\n\r\n    // this.Validate();\r\n  }\r\n\r\n  public RemoveLeaf(leaf: b2TreeNode<T>): void {\r\n    if (leaf === this.m_root) {\r\n      this.m_root = null;\r\n      return;\r\n    }\r\n\r\n    const parent: b2TreeNode<T> = verify(leaf.parent);\r\n    const grandParent: b2TreeNode<T> | null = parent && parent.parent;\r\n    const sibling: b2TreeNode<T> = verify(parent.child1 === leaf ? parent.child2 : parent.child1);\r\n\r\n    if (grandParent !== null) {\r\n      // Destroy parent and connect sibling to grandParent.\r\n      if (grandParent.child1 === parent) {\r\n        grandParent.child1 = sibling;\r\n      } else {\r\n        grandParent.child2 = sibling;\r\n      }\r\n      sibling.parent = grandParent;\r\n      this.FreeNode(parent);\r\n\r\n      // Adjust ancestor bounds.\r\n      let index: b2TreeNode<T> | null = grandParent;\r\n      while (index !== null) {\r\n        index = this.Balance(index);\r\n\r\n        const child1: b2TreeNode<T> = verify(index.child1);\r\n        const child2: b2TreeNode<T> = verify(index.child2);\r\n\r\n        index.aabb.Combine2(child1.aabb, child2.aabb);\r\n        index.height = 1 + b2Max(child1.height, child2.height);\r\n\r\n        index = index.parent;\r\n      }\r\n    } else {\r\n      this.m_root = sibling;\r\n      sibling.parent = null;\r\n      this.FreeNode(parent);\r\n    }\r\n\r\n    // this.Validate();\r\n  }\r\n\r\n  public Balance(A: b2TreeNode<T>): b2TreeNode<T> {\r\n    // DEBUG: b2Assert(A !== null);\r\n\r\n    if (A.IsLeaf() || A.height < 2) {\r\n      return A;\r\n    }\r\n\r\n    const B: b2TreeNode<T> = verify(A.child1);\r\n    const C: b2TreeNode<T> = verify(A.child2);\r\n\r\n    const balance: number = C.height - B.height;\r\n\r\n    // Rotate C up\r\n    if (balance > 1) {\r\n      const F: b2TreeNode<T> = verify(C.child1);\r\n      const G: b2TreeNode<T> = verify(C.child2);\r\n\r\n      // Swap A and C\r\n      C.child1 = A;\r\n      C.parent = A.parent;\r\n      A.parent = C;\r\n\r\n      // A's old parent should point to C\r\n      if (C.parent !== null) {\r\n        if (C.parent.child1 === A) {\r\n          C.parent.child1 = C;\r\n        } else {\r\n          // DEBUG: b2Assert(C.parent.child2 === A);\r\n          C.parent.child2 = C;\r\n        }\r\n      } else {\r\n        this.m_root = C;\r\n      }\r\n\r\n      // Rotate\r\n      if (F.height > G.height) {\r\n        C.child2 = F;\r\n        A.child2 = G;\r\n        G.parent = A;\r\n        A.aabb.Combine2(B.aabb, G.aabb);\r\n        C.aabb.Combine2(A.aabb, F.aabb);\r\n\r\n        A.height = 1 + b2Max(B.height, G.height);\r\n        C.height = 1 + b2Max(A.height, F.height);\r\n      } else {\r\n        C.child2 = G;\r\n        A.child2 = F;\r\n        F.parent = A;\r\n        A.aabb.Combine2(B.aabb, F.aabb);\r\n        C.aabb.Combine2(A.aabb, G.aabb);\r\n\r\n        A.height = 1 + b2Max(B.height, F.height);\r\n        C.height = 1 + b2Max(A.height, G.height);\r\n      }\r\n\r\n      return C;\r\n    }\r\n\r\n    // Rotate B up\r\n    if (balance < -1) {\r\n      const D: b2TreeNode<T> = verify(B.child1);\r\n      const E: b2TreeNode<T> = verify(B.child2);\r\n\r\n      // Swap A and B\r\n      B.child1 = A;\r\n      B.parent = A.parent;\r\n      A.parent = B;\r\n\r\n      // A's old parent should point to B\r\n      if (B.parent !== null) {\r\n        if (B.parent.child1 === A) {\r\n          B.parent.child1 = B;\r\n        } else {\r\n          // DEBUG: b2Assert(B.parent.child2 === A);\r\n          B.parent.child2 = B;\r\n        }\r\n      } else {\r\n        this.m_root = B;\r\n      }\r\n\r\n      // Rotate\r\n      if (D.height > E.height) {\r\n        B.child2 = D;\r\n        A.child1 = E;\r\n        E.parent = A;\r\n        A.aabb.Combine2(C.aabb, E.aabb);\r\n        B.aabb.Combine2(A.aabb, D.aabb);\r\n\r\n        A.height = 1 + b2Max(C.height, E.height);\r\n        B.height = 1 + b2Max(A.height, D.height);\r\n      } else {\r\n        B.child2 = E;\r\n        A.child1 = D;\r\n        D.parent = A;\r\n        A.aabb.Combine2(C.aabb, D.aabb);\r\n        B.aabb.Combine2(A.aabb, E.aabb);\r\n\r\n        A.height = 1 + b2Max(C.height, D.height);\r\n        B.height = 1 + b2Max(A.height, E.height);\r\n      }\r\n\r\n      return B;\r\n    }\r\n\r\n    return A;\r\n  }\r\n\r\n  public GetHeight(): number {\r\n    if (this.m_root === null) {\r\n      return 0;\r\n    }\r\n\r\n    return this.m_root.height;\r\n  }\r\n\r\n  private static GetAreaNode<T>(node: b2TreeNode<T> | null): number {\r\n    if (node === null) {\r\n      return 0;\r\n    }\r\n\r\n    if (node.IsLeaf()) {\r\n      return 0;\r\n    }\r\n\r\n    let area: number = node.aabb.GetPerimeter();\r\n    area += b2DynamicTree.GetAreaNode(node.child1);\r\n    area += b2DynamicTree.GetAreaNode(node.child2);\r\n    return area;\r\n  }\r\n\r\n  public GetAreaRatio(): number {\r\n    if (this.m_root === null) {\r\n      return 0;\r\n    }\r\n\r\n    const root: b2TreeNode<T> = this.m_root;\r\n    const rootArea: number = root.aabb.GetPerimeter();\r\n\r\n    const totalArea: number = b2DynamicTree.GetAreaNode(this.m_root);\r\n\r\n    /*\r\n    float32 totalArea = 0.0;\r\n    for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n      const b2TreeNode<T>* node = m_nodes + i;\r\n      if (node.height < 0) {\r\n        // Free node in pool\r\n        continue;\r\n      }\r\n\r\n      totalArea += node.aabb.GetPerimeter();\r\n    }\r\n    */\r\n\r\n    return totalArea / rootArea;\r\n  }\r\n\r\n  public static ComputeHeightNode<T>(node: b2TreeNode<T> | null): number {\r\n    if (node === null) {\r\n      return 0;\r\n    }\r\n\r\n    if (node.IsLeaf()) {\r\n      return 0;\r\n    }\r\n\r\n    const height1: number = b2DynamicTree.ComputeHeightNode(node.child1);\r\n    const height2: number = b2DynamicTree.ComputeHeightNode(node.child2);\r\n    return 1 + b2Max(height1, height2);\r\n  }\r\n\r\n  public ComputeHeight(): number {\r\n    const height: number = b2DynamicTree.ComputeHeightNode(this.m_root);\r\n    return height;\r\n  }\r\n\r\n  public ValidateStructure(node: b2TreeNode<T> | null): void {\r\n    if (node === null) {\r\n      return;\r\n    }\r\n\r\n    if (node === this.m_root) {\r\n      // DEBUG: b2Assert(node.parent === null);\r\n    }\r\n\r\n    if (node.IsLeaf()) {\r\n      // DEBUG: b2Assert(node.child1 === null);\r\n      // DEBUG: b2Assert(node.child2 === null);\r\n      // DEBUG: b2Assert(node.height === 0);\r\n      return;\r\n    }\r\n\r\n    const child1: b2TreeNode<T> = verify(node.child1);\r\n    const child2: b2TreeNode<T> = verify(node.child2);\r\n\r\n    // DEBUG: b2Assert(child1.parent === index);\r\n    // DEBUG: b2Assert(child2.parent === index);\r\n\r\n    this.ValidateStructure(child1);\r\n    this.ValidateStructure(child2);\r\n  }\r\n\r\n  public ValidateMetrics(node: b2TreeNode<T> | null): void {\r\n    if (node === null) {\r\n      return;\r\n    }\r\n\r\n    if (node.IsLeaf()) {\r\n      // DEBUG: b2Assert(node.child1 === null);\r\n      // DEBUG: b2Assert(node.child2 === null);\r\n      // DEBUG: b2Assert(node.height === 0);\r\n      return;\r\n    }\r\n\r\n    const child1: b2TreeNode<T> = verify(node.child1);\r\n    const child2: b2TreeNode<T> = verify(node.child2);\r\n\r\n    // DEBUG: const height1: number = child1.height;\r\n    // DEBUG: const height2: number = child2.height;\r\n    // DEBUG: const height: number = 1 + b2Max(height1, height2);\r\n    // DEBUG: b2Assert(node.height === height);\r\n\r\n    const aabb: b2AABB = b2DynamicTree.s_aabb;\r\n    aabb.Combine2(child1.aabb, child2.aabb);\r\n\r\n    // DEBUG: b2Assert(aabb.lowerBound === node.aabb.lowerBound);\r\n    // DEBUG: b2Assert(aabb.upperBound === node.aabb.upperBound);\r\n\r\n    this.ValidateMetrics(child1);\r\n    this.ValidateMetrics(child2);\r\n  }\r\n\r\n  public Validate(): void {\r\n    // DEBUG: this.ValidateStructure(this.m_root);\r\n    // DEBUG: this.ValidateMetrics(this.m_root);\r\n\r\n    // let freeCount: number = 0;\r\n    // let freeIndex: b2TreeNode<T> | null = this.m_freeList;\r\n    // while (freeIndex !== null) {\r\n    //   freeIndex = freeIndex.parent; // freeIndex = freeIndex.next;\r\n    //   ++freeCount;\r\n    // }\r\n\r\n    // DEBUG: b2Assert(this.GetHeight() === this.ComputeHeight());\r\n\r\n    // b2Assert(this.m_nodeCount + freeCount === this.m_nodeCapacity);\r\n  }\r\n\r\n  private static GetMaxBalanceNode<T>(node: b2TreeNode<T> | null, maxBalance: number): number {\r\n    if (node === null) {\r\n      return maxBalance;\r\n    }\r\n\r\n    if (node.height <= 1) {\r\n      return maxBalance;\r\n    }\r\n\r\n    // DEBUG: b2Assert(!node.IsLeaf());\r\n\r\n    const child1: b2TreeNode<T> = verify(node.child1);\r\n    const child2: b2TreeNode<T> = verify(node.child2);\r\n    const balance: number = b2Abs(child2.height - child1.height);\r\n    return b2Max(maxBalance, balance);\r\n  }\r\n\r\n  public GetMaxBalance(): number {\r\n    const maxBalance: number = b2DynamicTree.GetMaxBalanceNode(this.m_root, 0);\r\n\r\n    /*\r\n    int32 maxBalance = 0;\r\n    for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n      const b2TreeNode<T>* node = m_nodes + i;\r\n      if (node.height <= 1) {\r\n        continue;\r\n      }\r\n\r\n      b2Assert(!node.IsLeaf());\r\n\r\n      int32 child1 = node.child1;\r\n      int32 child2 = node.child2;\r\n      int32 balance = b2Abs(m_nodes[child2].height - m_nodes[child1].height);\r\n      maxBalance = b2Max(maxBalance, balance);\r\n    }\r\n    */\r\n\r\n    return maxBalance;\r\n  }\r\n\r\n  public RebuildBottomUp(): void {\r\n    /*\r\n    int32* nodes = (int32*)b2Alloc(m_nodeCount * sizeof(int32));\r\n    int32 count = 0;\r\n\r\n    // Build array of leaves. Free the rest.\r\n    for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n      if (m_nodes[i].height < 0) {\r\n        // free node in pool\r\n        continue;\r\n      }\r\n\r\n      if (m_nodes[i].IsLeaf()) {\r\n        m_nodes[i].parent = b2_nullNode;\r\n        nodes[count] = i;\r\n        ++count;\r\n      } else {\r\n        FreeNode(i);\r\n      }\r\n    }\r\n\r\n    while (count > 1) {\r\n      float32 minCost = b2_maxFloat;\r\n      int32 iMin = -1, jMin = -1;\r\n      for (int32 i = 0; i < count; ++i) {\r\n        b2AABB aabbi = m_nodes[nodes[i]].aabb;\r\n\r\n        for (int32 j = i + 1; j < count; ++j) {\r\n          b2AABB aabbj = m_nodes[nodes[j]].aabb;\r\n          b2AABB b;\r\n          b.Combine(aabbi, aabbj);\r\n          float32 cost = b.GetPerimeter();\r\n          if (cost < minCost) {\r\n            iMin = i;\r\n            jMin = j;\r\n            minCost = cost;\r\n          }\r\n        }\r\n      }\r\n\r\n      int32 index1 = nodes[iMin];\r\n      int32 index2 = nodes[jMin];\r\n      b2TreeNode<T>* child1 = m_nodes + index1;\r\n      b2TreeNode<T>* child2 = m_nodes + index2;\r\n\r\n      int32 parentIndex = AllocateNode();\r\n      b2TreeNode<T>* parent = m_nodes + parentIndex;\r\n      parent.child1 = index1;\r\n      parent.child2 = index2;\r\n      parent.height = 1 + b2Max(child1.height, child2.height);\r\n      parent.aabb.Combine(child1.aabb, child2.aabb);\r\n      parent.parent = b2_nullNode;\r\n\r\n      child1.parent = parentIndex;\r\n      child2.parent = parentIndex;\r\n\r\n      nodes[jMin] = nodes[count-1];\r\n      nodes[iMin] = parentIndex;\r\n      --count;\r\n    }\r\n\r\n    m_root = nodes[0];\r\n    b2Free(nodes);\r\n    */\r\n\r\n    this.Validate();\r\n  }\r\n\r\n  private static ShiftOriginNode<T>(node: b2TreeNode<T> | null, newOrigin: XY): void {\r\n    if (node === null) {\r\n      return;\r\n    }\r\n\r\n    if (node.height <= 1) {\r\n      return;\r\n    }\r\n\r\n    // DEBUG: b2Assert(!node.IsLeaf());\r\n\r\n    const child1: b2TreeNode<T> | null = node.child1;\r\n    const child2: b2TreeNode<T> | null = node.child2;\r\n    b2DynamicTree.ShiftOriginNode(child1, newOrigin);\r\n    b2DynamicTree.ShiftOriginNode(child2, newOrigin);\r\n\r\n    node.aabb.lowerBound.SelfSub(newOrigin);\r\n    node.aabb.upperBound.SelfSub(newOrigin);\r\n  }\r\n\r\n  public ShiftOrigin(newOrigin: XY): void {\r\n\r\n    b2DynamicTree.ShiftOriginNode(this.m_root, newOrigin);\r\n\r\n    /*\r\n    // Build array of leaves. Free the rest.\r\n    for (int32 i = 0; i < m_nodeCapacity; ++i) {\r\n      m_nodes[i].aabb.lowerBound -= newOrigin;\r\n      m_nodes[i].aabb.upperBound -= newOrigin;\r\n    }\r\n    */\r\n  }\r\n}\r\n"]}},"error":null,"hash":"c9b7b34469e4ab33e6b35ffb21f30e96","cacheData":{"env":{}}}