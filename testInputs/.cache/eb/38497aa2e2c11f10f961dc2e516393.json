{"id":"../node_modules/box2d.package.ts/Dynamics/b2Island.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../Common/b2Settings","loc":{"line":24,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../Common/b2Math","loc":{"line":25,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../Common/b2Timer","loc":{"line":26,"column":24},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Timer.ts"},{"name":"./Contacts/b2ContactSolver","loc":{"line":27,"column":32},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactSolver.ts"},{"name":"./b2Body","loc":{"line":28,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Body.ts"},{"name":"./b2TimeStep","loc":{"line":29,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2TimeStep.ts"},{"name":"./b2WorldCallbacks","loc":{"line":30,"column":33},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2Island.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2WorldCallbacks.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../Common/b2Settings\");\r\nvar b2Settings_2 = require(\"../Common/b2Settings\");\r\nvar b2Settings_3 = require(\"../Common/b2Settings\");\r\nvar b2Settings_4 = require(\"../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../Common/b2Math\");\r\nvar b2Timer_1 = require(\"../Common/b2Timer\");\r\nvar b2ContactSolver_1 = require(\"./Contacts/b2ContactSolver\");\r\nvar b2Body_1 = require(\"./b2Body\");\r\nvar b2TimeStep_1 = require(\"./b2TimeStep\");\r\nvar b2WorldCallbacks_1 = require(\"./b2WorldCallbacks\");\r\n/*\r\nPosition Correction Notes\r\n=========================\r\nI tried the several algorithms for position correction of the 2D revolute joint.\r\nI looked at these systems:\r\n- simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.\r\n- suspension bridge with 30 1m long planks of length 1m.\r\n- multi-link chain with 30 1m long links.\r\n\r\nHere are the algorithms:\r\n\r\nBaumgarte - A fraction of the position error is added to the velocity error. There is no\r\nseparate position solver.\r\n\r\nPseudo Velocities - After the velocity solver and position integration,\r\nthe position error, Jacobian, and effective mass are recomputed. Then\r\nthe velocity constraints are solved with pseudo velocities and a fraction\r\nof the position error is added to the pseudo velocity error. The pseudo\r\nvelocities are initialized to zero and there is no warm-starting. After\r\nthe position solver, the pseudo velocities are added to the positions.\r\nThis is also called the First Order World method or the Position LCP method.\r\n\r\nModified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the\r\nposition error is re-computed for each constraint and the positions are updated\r\nafter the constraint is solved. The radius vectors (aka Jacobians) are\r\nre-computed too (otherwise the algorithm has horrible instability). The pseudo\r\nvelocity states are not needed because they are effectively zero at the beginning\r\nof each iteration. Since we have the current position error, we allow the\r\niterations to terminate early if the error becomes smaller than b2_linearSlop.\r\n\r\nFull NGS or just NGS - Like Modified NGS except the effective mass are re-computed\r\neach time a constraint is solved.\r\n\r\nHere are the results:\r\nBaumgarte - this is the cheapest algorithm but it has some stability problems,\r\nespecially with the bridge. The chain links separate easily close to the root\r\nand they jitter as they struggle to pull together. This is one of the most common\r\nmethods in the field. The big drawback is that the position correction artificially\r\naffects the momentum, thus leading to instabilities and false bounce. I used a\r\nbias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller\r\nfactor makes joints and contacts more spongy.\r\n\r\nPseudo Velocities - the is more stable than the Baumgarte method. The bridge is\r\nstable. However, joints still separate with large angular velocities. Drag the\r\nsimple pendulum in a circle quickly and the joint will separate. The chain separates\r\neasily and does not recover. I used a bias factor of 0.2. A larger value lead to\r\nthe bridge collapsing when a heavy cube drops on it.\r\n\r\nModified NGS - this algorithm is better in some ways than Baumgarte and Pseudo\r\nVelocities, but in other ways it is worse. The bridge and chain are much more\r\nstable, but the simple pendulum goes unstable at high angular velocities.\r\n\r\nFull NGS - stable in all tests. The joints display good stiffness. The bridge\r\nstill sags, but this is better than infinite forces.\r\n\r\nRecommendations\r\nPseudo Velocities are not really worthwhile because the bridge and chain cannot\r\nrecover from joint separation. In other cases the benefit over Baumgarte is small.\r\n\r\nModified NGS is not a robust method for the revolute joint due to the violent\r\ninstability seen in the simple pendulum. Perhaps it is viable with other constraint\r\ntypes, especially scalar constraints where the effective mass is a scalar.\r\n\r\nThis leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities\r\nand is very fast. I don't think we can escape Baumgarte, especially in highly\r\ndemanding cases where high constraint fidelity is not needed.\r\n\r\nFull NGS is robust and easy on the eyes. I recommend this as an option for\r\nhigher fidelity simulation and certainly for suspension bridges and long chains.\r\nFull NGS might be a good choice for ragdolls, especially motorized ragdolls where\r\njoint separation can be problematic. The number of NGS iterations can be reduced\r\nfor better performance without harming robustness much.\r\n\r\nEach joint in a can be handled differently in the position solver. So I recommend\r\na system where the user can select the algorithm on a per joint basis. I would\r\nprobably default to the slower Full NGS and let the user select the faster\r\nBaumgarte method in performance critical scenarios.\r\n*/\r\n/*\r\nCache Performance\r\n\r\nThe Box2D solvers are dominated by cache misses. Data structures are designed\r\nto increase the number of cache hits. Much of misses are due to random access\r\nto body data. The constraint structures are iterated over linearly, which leads\r\nto few cache misses.\r\n\r\nThe bodies are not accessed during iteration. Instead read only data, such as\r\nthe mass values are stored with the constraints. The mutable data are the constraint\r\nimpulses and the bodies velocities/positions. The impulses are held inside the\r\nconstraint structures. The body velocities/positions are held in compact, temporary\r\narrays to increase the number of cache hits. Linear and angular velocity are\r\nstored in a single array since multiple arrays lead to multiple misses.\r\n*/\r\n/*\r\n2D Rotation\r\n\r\nR = [cos(theta) -sin(theta)]\r\n    [sin(theta) cos(theta) ]\r\n\r\nthetaDot = omega\r\n\r\nLet q1 = cos(theta), q2 = sin(theta).\r\nR = [q1 -q2]\r\n    [q2  q1]\r\n\r\nq1Dot = -thetaDot * q2\r\nq2Dot = thetaDot * q1\r\n\r\nq1_new = q1_old - dt * w * q2\r\nq2_new = q2_old + dt * w * q1\r\nthen normalize.\r\n\r\nThis might be faster than computing sin+cos.\r\nHowever, we can compute sin+cos of the same angle fast.\r\n*/\r\nvar b2Island = /** @class */ (function () {\r\n    function b2Island() {\r\n        this.m_bodies = [ /*1024*/]; // TODO: b2Settings\r\n        this.m_contacts = [ /*1024*/]; // TODO: b2Settings\r\n        this.m_joints = [ /*1024*/]; // TODO: b2Settings\r\n        this.m_positions = b2TimeStep_1.b2Position.MakeArray(1024); // TODO: b2Settings\r\n        this.m_velocities = b2TimeStep_1.b2Velocity.MakeArray(1024); // TODO: b2Settings\r\n        this.m_bodyCount = 0;\r\n        this.m_jointCount = 0;\r\n        this.m_contactCount = 0;\r\n        this.m_bodyCapacity = 0;\r\n        this.m_contactCapacity = 0;\r\n        this.m_jointCapacity = 0;\r\n    }\r\n    b2Island.prototype.Initialize = function (bodyCapacity, contactCapacity, jointCapacity, listener) {\r\n        this.m_bodyCapacity = bodyCapacity;\r\n        this.m_contactCapacity = contactCapacity;\r\n        this.m_jointCapacity = jointCapacity;\r\n        this.m_bodyCount = 0;\r\n        this.m_contactCount = 0;\r\n        this.m_jointCount = 0;\r\n        this.m_listener = listener;\r\n        // TODO:\r\n        // while (this.m_bodies.length < bodyCapacity) {\r\n        //   this.m_bodies[this.m_bodies.length] = null;\r\n        // }\r\n        // TODO:\r\n        // while (this.m_contacts.length < contactCapacity) {\r\n        //   this.m_contacts[this.m_contacts.length] = null;\r\n        // }\r\n        // TODO:\r\n        // while (this.m_joints.length < jointCapacity) {\r\n        //   this.m_joints[this.m_joints.length] = null;\r\n        // }\r\n        // TODO:\r\n        if (this.m_positions.length < bodyCapacity) {\r\n            var new_length = b2Math_1.b2Max(this.m_positions.length * 2, bodyCapacity);\r\n            while (this.m_positions.length < new_length) {\r\n                this.m_positions[this.m_positions.length] = new b2TimeStep_1.b2Position();\r\n            }\r\n        }\r\n        // TODO:\r\n        if (this.m_velocities.length < bodyCapacity) {\r\n            var new_length = b2Math_1.b2Max(this.m_velocities.length * 2, bodyCapacity);\r\n            while (this.m_velocities.length < new_length) {\r\n                this.m_velocities[this.m_velocities.length] = new b2TimeStep_1.b2Velocity();\r\n            }\r\n        }\r\n    };\r\n    b2Island.prototype.Clear = function () {\r\n        this.m_bodyCount = 0;\r\n        this.m_contactCount = 0;\r\n        this.m_jointCount = 0;\r\n    };\r\n    b2Island.prototype.AddBody = function (body) {\r\n        // DEBUG: b2Assert(this.m_bodyCount < this.m_bodyCapacity);\r\n        body.m_islandIndex = this.m_bodyCount;\r\n        this.m_bodies[this.m_bodyCount++] = body;\r\n    };\r\n    b2Island.prototype.AddContact = function (contact) {\r\n        // DEBUG: b2Assert(this.m_contactCount < this.m_contactCapacity);\r\n        this.m_contacts[this.m_contactCount++] = contact;\r\n    };\r\n    b2Island.prototype.AddJoint = function (joint) {\r\n        // DEBUG: b2Assert(this.m_jointCount < this.m_jointCapacity);\r\n        this.m_joints[this.m_jointCount++] = joint;\r\n    };\r\n    b2Island.prototype.Solve = function (profile, step, gravity, allowSleep) {\r\n        var timer = b2Island.s_timer.Reset();\r\n        var h = step.dt;\r\n        // Integrate velocities and apply damping. Initialize the body state.\r\n        for (var i = 0; i < this.m_bodyCount; ++i) {\r\n            var b = this.m_bodies[i];\r\n            // const c: b2Vec2 =\r\n            this.m_positions[i].c.Copy(b.m_sweep.c);\r\n            var a = b.m_sweep.a;\r\n            var v = this.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n            var w = b.m_angularVelocity;\r\n            // Store positions for continuous collision.\r\n            b.m_sweep.c0.Copy(b.m_sweep.c);\r\n            b.m_sweep.a0 = b.m_sweep.a;\r\n            if (b.m_type === b2Body_1.b2BodyType.b2_dynamicBody) {\r\n                // Integrate velocities.\r\n                v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);\r\n                v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);\r\n                w += h * b.m_invI * b.m_torque;\r\n                // Apply damping.\r\n                // ODE: dv/dt + c * v = 0\r\n                // Solution: v(t) = v0 * exp(-c * t)\r\n                // Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\r\n                // v2 = exp(-c * dt) * v1\r\n                // Pade approximation:\r\n                // v2 = v1 * 1 / (1 + c * dt)\r\n                v.SelfMul(1.0 / (1.0 + h * b.m_linearDamping));\r\n                w *= 1.0 / (1.0 + h * b.m_angularDamping);\r\n            }\r\n            // this.m_positions[i].c = c;\r\n            this.m_positions[i].a = a;\r\n            // this.m_velocities[i].v = v;\r\n            this.m_velocities[i].w = w;\r\n        }\r\n        timer.Reset();\r\n        // Solver data\r\n        var solverData = b2Island.s_solverData;\r\n        solverData.step.Copy(step);\r\n        solverData.positions = this.m_positions;\r\n        solverData.velocities = this.m_velocities;\r\n        // Initialize velocity constraints.\r\n        var contactSolverDef = b2Island.s_contactSolverDef;\r\n        contactSolverDef.step.Copy(step);\r\n        contactSolverDef.contacts = this.m_contacts;\r\n        contactSolverDef.count = this.m_contactCount;\r\n        contactSolverDef.positions = this.m_positions;\r\n        contactSolverDef.velocities = this.m_velocities;\r\n        var contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n        contactSolver.InitializeVelocityConstraints();\r\n        if (step.warmStarting) {\r\n            contactSolver.WarmStart();\r\n        }\r\n        for (var i = 0; i < this.m_jointCount; ++i) {\r\n            this.m_joints[i].InitVelocityConstraints(solverData);\r\n        }\r\n        profile.solveInit = timer.GetMilliseconds();\r\n        // Solve velocity constraints.\r\n        timer.Reset();\r\n        for (var i = 0; i < step.velocityIterations; ++i) {\r\n            for (var j = 0; j < this.m_jointCount; ++j) {\r\n                this.m_joints[j].SolveVelocityConstraints(solverData);\r\n            }\r\n            contactSolver.SolveVelocityConstraints();\r\n        }\r\n        // Store impulses for warm starting\r\n        contactSolver.StoreImpulses();\r\n        profile.solveVelocity = timer.GetMilliseconds();\r\n        // Integrate positions.\r\n        for (var i = 0; i < this.m_bodyCount; ++i) {\r\n            var c = this.m_positions[i].c;\r\n            var a = this.m_positions[i].a;\r\n            var v = this.m_velocities[i].v;\r\n            var w = this.m_velocities[i].w;\r\n            // Check for large velocities\r\n            var translation = b2Math_1.b2Vec2.MulSV(h, v, b2Island.s_translation);\r\n            if (b2Math_1.b2Vec2.DotVV(translation, translation) > b2Settings_2.b2_maxTranslationSquared) {\r\n                var ratio = b2Settings_2.b2_maxTranslation / translation.Length();\r\n                v.SelfMul(ratio);\r\n            }\r\n            var rotation = h * w;\r\n            if (rotation * rotation > b2Settings_3.b2_maxRotationSquared) {\r\n                var ratio = b2Settings_3.b2_maxRotation / b2Math_1.b2Abs(rotation);\r\n                w *= ratio;\r\n            }\r\n            // Integrate\r\n            c.x += h * v.x;\r\n            c.y += h * v.y;\r\n            a += h * w;\r\n            // this.m_positions[i].c = c;\r\n            this.m_positions[i].a = a;\r\n            // this.m_velocities[i].v = v;\r\n            this.m_velocities[i].w = w;\r\n        }\r\n        // Solve position constraints\r\n        timer.Reset();\r\n        var positionSolved = false;\r\n        for (var i = 0; i < step.positionIterations; ++i) {\r\n            var contactsOkay = contactSolver.SolvePositionConstraints();\r\n            var jointsOkay = true;\r\n            for (var j = 0; j < this.m_jointCount; ++j) {\r\n                var jointOkay = this.m_joints[j].SolvePositionConstraints(solverData);\r\n                jointsOkay = jointsOkay && jointOkay;\r\n            }\r\n            if (contactsOkay && jointsOkay) {\r\n                // Exit early if the position errors are small.\r\n                positionSolved = true;\r\n                break;\r\n            }\r\n        }\r\n        // Copy state buffers back to the bodies\r\n        for (var i = 0; i < this.m_bodyCount; ++i) {\r\n            var body = this.m_bodies[i];\r\n            body.m_sweep.c.Copy(this.m_positions[i].c);\r\n            body.m_sweep.a = this.m_positions[i].a;\r\n            body.m_linearVelocity.Copy(this.m_velocities[i].v);\r\n            body.m_angularVelocity = this.m_velocities[i].w;\r\n            body.SynchronizeTransform();\r\n        }\r\n        profile.solvePosition = timer.GetMilliseconds();\r\n        this.Report(contactSolver.m_velocityConstraints);\r\n        if (allowSleep) {\r\n            var minSleepTime = b2Settings_1.b2_maxFloat;\r\n            var linTolSqr = b2Settings_4.b2_linearSleepTolerance * b2Settings_4.b2_linearSleepTolerance;\r\n            var angTolSqr = b2Settings_4.b2_angularSleepTolerance * b2Settings_4.b2_angularSleepTolerance;\r\n            for (var i = 0; i < this.m_bodyCount; ++i) {\r\n                var b = this.m_bodies[i];\r\n                if (b.GetType() === b2Body_1.b2BodyType.b2_staticBody) {\r\n                    continue;\r\n                }\r\n                if (!b.m_autoSleepFlag ||\r\n                    b.m_angularVelocity * b.m_angularVelocity > angTolSqr ||\r\n                    b2Math_1.b2Vec2.DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {\r\n                    b.m_sleepTime = 0;\r\n                    minSleepTime = 0;\r\n                }\r\n                else {\r\n                    b.m_sleepTime += h;\r\n                    minSleepTime = b2Math_1.b2Min(minSleepTime, b.m_sleepTime);\r\n                }\r\n            }\r\n            if (minSleepTime >= b2Settings_1.b2_timeToSleep && positionSolved) {\r\n                for (var i = 0; i < this.m_bodyCount; ++i) {\r\n                    var b = this.m_bodies[i];\r\n                    b.SetAwake(false);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2Island.prototype.SolveTOI = function (subStep, toiIndexA, toiIndexB) {\r\n        // DEBUG: b2Assert(toiIndexA < this.m_bodyCount);\r\n        // DEBUG: b2Assert(toiIndexB < this.m_bodyCount);\r\n        // Initialize the body state.\r\n        for (var i = 0; i < this.m_bodyCount; ++i) {\r\n            var b = this.m_bodies[i];\r\n            this.m_positions[i].c.Copy(b.m_sweep.c);\r\n            this.m_positions[i].a = b.m_sweep.a;\r\n            this.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n            this.m_velocities[i].w = b.m_angularVelocity;\r\n        }\r\n        var contactSolverDef = b2Island.s_contactSolverDef;\r\n        contactSolverDef.contacts = this.m_contacts;\r\n        contactSolverDef.count = this.m_contactCount;\r\n        contactSolverDef.step.Copy(subStep);\r\n        contactSolverDef.positions = this.m_positions;\r\n        contactSolverDef.velocities = this.m_velocities;\r\n        var contactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n        // Solve position constraints.\r\n        for (var i = 0; i < subStep.positionIterations; ++i) {\r\n            var contactsOkay = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);\r\n            if (contactsOkay) {\r\n                break;\r\n            }\r\n        }\r\n        /*\r\n        #if 0\r\n          // Is the new position really safe?\r\n          for (int32 i = 0; i < this.m_contactCount; ++i) {\r\n            b2Contact* c = this.m_contacts[i];\r\n            b2Fixture* fA = c.GetFixtureA();\r\n            b2Fixture* fB = c.GetFixtureB();\r\n      \r\n            b2Body* bA = fA.GetBody();\r\n            b2Body* bB = fB.GetBody();\r\n      \r\n            int32 indexA = c.GetChildIndexA();\r\n            int32 indexB = c.GetChildIndexB();\r\n      \r\n            b2DistanceInput input;\r\n            input.proxyA.Set(fA.GetShape(), indexA);\r\n            input.proxyB.Set(fB.GetShape(), indexB);\r\n            input.transformA = bA.GetTransform();\r\n            input.transformB = bB.GetTransform();\r\n            input.useRadii = false;\r\n      \r\n            b2DistanceOutput output;\r\n            b2SimplexCache cache;\r\n            cache.count = 0;\r\n            b2Distance(&output, &cache, &input);\r\n      \r\n            if (output.distance === 0 || cache.count === 3) {\r\n              cache.count += 0;\r\n            }\r\n          }\r\n        #endif\r\n        */\r\n        // Leap of faith to new safe state.\r\n        this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);\r\n        this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;\r\n        this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);\r\n        this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;\r\n        // No warm starting is needed for TOI events because warm\r\n        // starting impulses were applied in the discrete solver.\r\n        contactSolver.InitializeVelocityConstraints();\r\n        // Solve velocity constraints.\r\n        for (var i = 0; i < subStep.velocityIterations; ++i) {\r\n            contactSolver.SolveVelocityConstraints();\r\n        }\r\n        // Don't store the TOI contact forces for warm starting\r\n        // because they can be quite large.\r\n        var h = subStep.dt;\r\n        // Integrate positions\r\n        for (var i = 0; i < this.m_bodyCount; ++i) {\r\n            var c = this.m_positions[i].c;\r\n            var a = this.m_positions[i].a;\r\n            var v = this.m_velocities[i].v;\r\n            var w = this.m_velocities[i].w;\r\n            // Check for large velocities\r\n            var translation = b2Math_1.b2Vec2.MulSV(h, v, b2Island.s_translation);\r\n            if (b2Math_1.b2Vec2.DotVV(translation, translation) > b2Settings_2.b2_maxTranslationSquared) {\r\n                var ratio = b2Settings_2.b2_maxTranslation / translation.Length();\r\n                v.SelfMul(ratio);\r\n            }\r\n            var rotation = h * w;\r\n            if (rotation * rotation > b2Settings_3.b2_maxRotationSquared) {\r\n                var ratio = b2Settings_3.b2_maxRotation / b2Math_1.b2Abs(rotation);\r\n                w *= ratio;\r\n            }\r\n            // Integrate\r\n            c.SelfMulAdd(h, v);\r\n            a += h * w;\r\n            // this.m_positions[i].c = c;\r\n            this.m_positions[i].a = a;\r\n            // this.m_velocities[i].v = v;\r\n            this.m_velocities[i].w = w;\r\n            // Sync bodies\r\n            var body = this.m_bodies[i];\r\n            body.m_sweep.c.Copy(c);\r\n            body.m_sweep.a = a;\r\n            body.m_linearVelocity.Copy(v);\r\n            body.m_angularVelocity = w;\r\n            body.SynchronizeTransform();\r\n        }\r\n        this.Report(contactSolver.m_velocityConstraints);\r\n    };\r\n    b2Island.prototype.Report = function (constraints) {\r\n        if (this.m_listener === null) {\r\n            return;\r\n        }\r\n        for (var i = 0; i < this.m_contactCount; ++i) {\r\n            var c = this.m_contacts[i];\r\n            if (!c) {\r\n                continue;\r\n            }\r\n            var vc = constraints[i];\r\n            var impulse = b2Island.s_impulse;\r\n            impulse.count = vc.pointCount;\r\n            for (var j = 0; j < vc.pointCount; ++j) {\r\n                impulse.normalImpulses[j] = vc.points[j].normalImpulse;\r\n                impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;\r\n            }\r\n            this.m_listener.PostSolve(c, impulse);\r\n        }\r\n    };\r\n    b2Island.s_timer = new b2Timer_1.b2Timer();\r\n    b2Island.s_solverData = new b2TimeStep_1.b2SolverData();\r\n    b2Island.s_contactSolverDef = new b2ContactSolver_1.b2ContactSolverDef();\r\n    b2Island.s_contactSolver = new b2ContactSolver_1.b2ContactSolver();\r\n    b2Island.s_translation = new b2Math_1.b2Vec2();\r\n    b2Island.s_impulse = new b2WorldCallbacks_1.b2ContactImpulse();\r\n    return b2Island;\r\n}());\r\nexports.b2Island = b2Island;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2Island.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/b2Island.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../Common/b2Settings\";\r\nimport { b2_maxFloat, b2_timeToSleep } from \"../Common/b2Settings\";\r\nimport { b2_maxTranslation, b2_maxTranslationSquared } from \"../Common/b2Settings\";\r\nimport { b2_maxRotation, b2_maxRotationSquared } from \"../Common/b2Settings\";\r\nimport { b2_linearSleepTolerance, b2_angularSleepTolerance } from \"../Common/b2Settings\";\r\nimport { b2Abs, b2Min, b2Max, b2Vec2 } from \"../Common/b2Math\";\r\nimport { b2Timer } from \"../Common/b2Timer\";\r\nimport { b2Contact } from \"./Contacts/b2Contact\";\r\nimport { b2ContactSolver, b2ContactSolverDef } from \"./Contacts/b2ContactSolver\";\r\nimport { b2ContactVelocityConstraint } from \"./Contacts/b2ContactSolver\";\r\nimport { b2Joint } from \"./Joints/b2Joint\";\r\nimport { b2Body, b2BodyType } from \"./b2Body\";\r\nimport { b2TimeStep, b2Profile, b2SolverData, b2Position, b2Velocity } from \"./b2TimeStep\";\r\nimport { b2ContactImpulse, b2ContactListener } from \"./b2WorldCallbacks\";\r\n\r\n/*\r\nPosition Correction Notes\r\n=========================\r\nI tried the several algorithms for position correction of the 2D revolute joint.\r\nI looked at these systems:\r\n- simple pendulum (1m diameter sphere on massless 5m stick) with initial angular velocity of 100 rad/s.\r\n- suspension bridge with 30 1m long planks of length 1m.\r\n- multi-link chain with 30 1m long links.\r\n\r\nHere are the algorithms:\r\n\r\nBaumgarte - A fraction of the position error is added to the velocity error. There is no\r\nseparate position solver.\r\n\r\nPseudo Velocities - After the velocity solver and position integration,\r\nthe position error, Jacobian, and effective mass are recomputed. Then\r\nthe velocity constraints are solved with pseudo velocities and a fraction\r\nof the position error is added to the pseudo velocity error. The pseudo\r\nvelocities are initialized to zero and there is no warm-starting. After\r\nthe position solver, the pseudo velocities are added to the positions.\r\nThis is also called the First Order World method or the Position LCP method.\r\n\r\nModified Nonlinear Gauss-Seidel (NGS) - Like Pseudo Velocities except the\r\nposition error is re-computed for each constraint and the positions are updated\r\nafter the constraint is solved. The radius vectors (aka Jacobians) are\r\nre-computed too (otherwise the algorithm has horrible instability). The pseudo\r\nvelocity states are not needed because they are effectively zero at the beginning\r\nof each iteration. Since we have the current position error, we allow the\r\niterations to terminate early if the error becomes smaller than b2_linearSlop.\r\n\r\nFull NGS or just NGS - Like Modified NGS except the effective mass are re-computed\r\neach time a constraint is solved.\r\n\r\nHere are the results:\r\nBaumgarte - this is the cheapest algorithm but it has some stability problems,\r\nespecially with the bridge. The chain links separate easily close to the root\r\nand they jitter as they struggle to pull together. This is one of the most common\r\nmethods in the field. The big drawback is that the position correction artificially\r\naffects the momentum, thus leading to instabilities and false bounce. I used a\r\nbias factor of 0.2. A larger bias factor makes the bridge less stable, a smaller\r\nfactor makes joints and contacts more spongy.\r\n\r\nPseudo Velocities - the is more stable than the Baumgarte method. The bridge is\r\nstable. However, joints still separate with large angular velocities. Drag the\r\nsimple pendulum in a circle quickly and the joint will separate. The chain separates\r\neasily and does not recover. I used a bias factor of 0.2. A larger value lead to\r\nthe bridge collapsing when a heavy cube drops on it.\r\n\r\nModified NGS - this algorithm is better in some ways than Baumgarte and Pseudo\r\nVelocities, but in other ways it is worse. The bridge and chain are much more\r\nstable, but the simple pendulum goes unstable at high angular velocities.\r\n\r\nFull NGS - stable in all tests. The joints display good stiffness. The bridge\r\nstill sags, but this is better than infinite forces.\r\n\r\nRecommendations\r\nPseudo Velocities are not really worthwhile because the bridge and chain cannot\r\nrecover from joint separation. In other cases the benefit over Baumgarte is small.\r\n\r\nModified NGS is not a robust method for the revolute joint due to the violent\r\ninstability seen in the simple pendulum. Perhaps it is viable with other constraint\r\ntypes, especially scalar constraints where the effective mass is a scalar.\r\n\r\nThis leaves Baumgarte and Full NGS. Baumgarte has small, but manageable instabilities\r\nand is very fast. I don't think we can escape Baumgarte, especially in highly\r\ndemanding cases where high constraint fidelity is not needed.\r\n\r\nFull NGS is robust and easy on the eyes. I recommend this as an option for\r\nhigher fidelity simulation and certainly for suspension bridges and long chains.\r\nFull NGS might be a good choice for ragdolls, especially motorized ragdolls where\r\njoint separation can be problematic. The number of NGS iterations can be reduced\r\nfor better performance without harming robustness much.\r\n\r\nEach joint in a can be handled differently in the position solver. So I recommend\r\na system where the user can select the algorithm on a per joint basis. I would\r\nprobably default to the slower Full NGS and let the user select the faster\r\nBaumgarte method in performance critical scenarios.\r\n*/\r\n\r\n/*\r\nCache Performance\r\n\r\nThe Box2D solvers are dominated by cache misses. Data structures are designed\r\nto increase the number of cache hits. Much of misses are due to random access\r\nto body data. The constraint structures are iterated over linearly, which leads\r\nto few cache misses.\r\n\r\nThe bodies are not accessed during iteration. Instead read only data, such as\r\nthe mass values are stored with the constraints. The mutable data are the constraint\r\nimpulses and the bodies velocities/positions. The impulses are held inside the\r\nconstraint structures. The body velocities/positions are held in compact, temporary\r\narrays to increase the number of cache hits. Linear and angular velocity are\r\nstored in a single array since multiple arrays lead to multiple misses.\r\n*/\r\n\r\n/*\r\n2D Rotation\r\n\r\nR = [cos(theta) -sin(theta)]\r\n    [sin(theta) cos(theta) ]\r\n\r\nthetaDot = omega\r\n\r\nLet q1 = cos(theta), q2 = sin(theta).\r\nR = [q1 -q2]\r\n    [q2  q1]\r\n\r\nq1Dot = -thetaDot * q2\r\nq2Dot = thetaDot * q1\r\n\r\nq1_new = q1_old - dt * w * q2\r\nq2_new = q2_old + dt * w * q1\r\nthen normalize.\r\n\r\nThis might be faster than computing sin+cos.\r\nHowever, we can compute sin+cos of the same angle fast.\r\n*/\r\n\r\nexport class b2Island {\r\n  public m_listener!: b2ContactListener;\r\n\r\n  public readonly m_bodies: b2Body[] = [/*1024*/]; // TODO: b2Settings\r\n  public readonly m_contacts: b2Contact[] = [/*1024*/]; // TODO: b2Settings\r\n  public readonly m_joints: b2Joint[] = [/*1024*/]; // TODO: b2Settings\r\n\r\n  public readonly m_positions: b2Position[] = b2Position.MakeArray(1024); // TODO: b2Settings\r\n  public readonly m_velocities: b2Velocity[] = b2Velocity.MakeArray(1024); // TODO: b2Settings\r\n\r\n  public m_bodyCount: number = 0;\r\n  public m_jointCount: number = 0;\r\n  public m_contactCount: number = 0;\r\n\r\n  public m_bodyCapacity: number = 0;\r\n  public m_contactCapacity: number = 0;\r\n  public m_jointCapacity: number = 0;\r\n\r\n  public Initialize(bodyCapacity: number, contactCapacity: number, jointCapacity: number, listener: b2ContactListener): void {\r\n    this.m_bodyCapacity = bodyCapacity;\r\n    this.m_contactCapacity = contactCapacity;\r\n    this.m_jointCapacity = jointCapacity;\r\n    this.m_bodyCount = 0;\r\n    this.m_contactCount = 0;\r\n    this.m_jointCount = 0;\r\n\r\n    this.m_listener = listener;\r\n\r\n    // TODO:\r\n    // while (this.m_bodies.length < bodyCapacity) {\r\n    //   this.m_bodies[this.m_bodies.length] = null;\r\n    // }\r\n    // TODO:\r\n    // while (this.m_contacts.length < contactCapacity) {\r\n    //   this.m_contacts[this.m_contacts.length] = null;\r\n    // }\r\n    // TODO:\r\n    // while (this.m_joints.length < jointCapacity) {\r\n    //   this.m_joints[this.m_joints.length] = null;\r\n    // }\r\n\r\n    // TODO:\r\n    if (this.m_positions.length < bodyCapacity) {\r\n      const new_length = b2Max(this.m_positions.length * 2, bodyCapacity);\r\n      while (this.m_positions.length < new_length) {\r\n        this.m_positions[this.m_positions.length] = new b2Position();\r\n      }\r\n    }\r\n    // TODO:\r\n    if (this.m_velocities.length < bodyCapacity) {\r\n      const new_length = b2Max(this.m_velocities.length * 2, bodyCapacity);\r\n      while (this.m_velocities.length < new_length) {\r\n        this.m_velocities[this.m_velocities.length] = new b2Velocity();\r\n      }\r\n    }\r\n  }\r\n\r\n  public Clear(): void {\r\n    this.m_bodyCount = 0;\r\n    this.m_contactCount = 0;\r\n    this.m_jointCount = 0;\r\n  }\r\n\r\n  public AddBody(body: b2Body): void {\r\n    // DEBUG: b2Assert(this.m_bodyCount < this.m_bodyCapacity);\r\n    body.m_islandIndex = this.m_bodyCount;\r\n    this.m_bodies[this.m_bodyCount++] = body;\r\n  }\r\n\r\n  public AddContact(contact: b2Contact): void {\r\n    // DEBUG: b2Assert(this.m_contactCount < this.m_contactCapacity);\r\n    this.m_contacts[this.m_contactCount++] = contact;\r\n  }\r\n\r\n  public AddJoint(joint: b2Joint): void {\r\n    // DEBUG: b2Assert(this.m_jointCount < this.m_jointCapacity);\r\n    this.m_joints[this.m_jointCount++] = joint;\r\n  }\r\n\r\n  private static s_timer = new b2Timer();\r\n  private static s_solverData = new b2SolverData();\r\n  private static s_contactSolverDef = new b2ContactSolverDef();\r\n  private static s_contactSolver = new b2ContactSolver();\r\n  private static s_translation = new b2Vec2();\r\n  public Solve(profile: b2Profile, step: b2TimeStep, gravity: b2Vec2, allowSleep: boolean): void {\r\n    const timer: b2Timer = b2Island.s_timer.Reset();\r\n\r\n    const h: number = step.dt;\r\n\r\n    // Integrate velocities and apply damping. Initialize the body state.\r\n    for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n      const b: b2Body = this.m_bodies[i];\r\n\r\n      // const c: b2Vec2 =\r\n      this.m_positions[i].c.Copy(b.m_sweep.c);\r\n      const a: number = b.m_sweep.a;\r\n      const v: b2Vec2 = this.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n      let w: number = b.m_angularVelocity;\r\n\r\n      // Store positions for continuous collision.\r\n      b.m_sweep.c0.Copy(b.m_sweep.c);\r\n      b.m_sweep.a0 = b.m_sweep.a;\r\n\r\n      if (b.m_type === b2BodyType.b2_dynamicBody) {\r\n        // Integrate velocities.\r\n        v.x += h * (b.m_gravityScale * gravity.x + b.m_invMass * b.m_force.x);\r\n        v.y += h * (b.m_gravityScale * gravity.y + b.m_invMass * b.m_force.y);\r\n        w += h * b.m_invI * b.m_torque;\r\n\r\n        // Apply damping.\r\n        // ODE: dv/dt + c * v = 0\r\n        // Solution: v(t) = v0 * exp(-c * t)\r\n        // Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\r\n        // v2 = exp(-c * dt) * v1\r\n        // Pade approximation:\r\n        // v2 = v1 * 1 / (1 + c * dt)\r\n        v.SelfMul(1.0 / (1.0 + h * b.m_linearDamping));\r\n        w *= 1.0 / (1.0 + h * b.m_angularDamping);\r\n      }\r\n\r\n      // this.m_positions[i].c = c;\r\n      this.m_positions[i].a = a;\r\n      // this.m_velocities[i].v = v;\r\n      this.m_velocities[i].w = w;\r\n    }\r\n\r\n    timer.Reset();\r\n\r\n    // Solver data\r\n    const solverData: b2SolverData = b2Island.s_solverData;\r\n    solverData.step.Copy(step);\r\n    solverData.positions = this.m_positions;\r\n    solverData.velocities = this.m_velocities;\r\n\r\n    // Initialize velocity constraints.\r\n    const contactSolverDef: b2ContactSolverDef = b2Island.s_contactSolverDef;\r\n    contactSolverDef.step.Copy(step);\r\n    contactSolverDef.contacts = this.m_contacts;\r\n    contactSolverDef.count = this.m_contactCount;\r\n    contactSolverDef.positions = this.m_positions;\r\n    contactSolverDef.velocities = this.m_velocities;\r\n\r\n    const contactSolver: b2ContactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n    contactSolver.InitializeVelocityConstraints();\r\n\r\n    if (step.warmStarting) {\r\n      contactSolver.WarmStart();\r\n    }\r\n\r\n    for (let i: number = 0; i < this.m_jointCount; ++i) {\r\n      this.m_joints[i].InitVelocityConstraints(solverData);\r\n    }\r\n\r\n    profile.solveInit = timer.GetMilliseconds();\r\n\r\n    // Solve velocity constraints.\r\n    timer.Reset();\r\n    for (let i: number = 0; i < step.velocityIterations; ++i) {\r\n      for (let j: number = 0; j < this.m_jointCount; ++j) {\r\n        this.m_joints[j].SolveVelocityConstraints(solverData);\r\n      }\r\n\r\n      contactSolver.SolveVelocityConstraints();\r\n    }\r\n\r\n    // Store impulses for warm starting\r\n    contactSolver.StoreImpulses();\r\n    profile.solveVelocity = timer.GetMilliseconds();\r\n\r\n    // Integrate positions.\r\n    for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n      const c: b2Vec2 = this.m_positions[i].c;\r\n      let a: number = this.m_positions[i].a;\r\n      const v: b2Vec2 = this.m_velocities[i].v;\r\n      let w: number = this.m_velocities[i].w;\r\n\r\n      // Check for large velocities\r\n      const translation: b2Vec2 = b2Vec2.MulSV(h, v, b2Island.s_translation);\r\n      if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {\r\n        const ratio: number = b2_maxTranslation / translation.Length();\r\n        v.SelfMul(ratio);\r\n      }\r\n\r\n      const rotation: number = h * w;\r\n      if (rotation * rotation > b2_maxRotationSquared) {\r\n        const ratio: number = b2_maxRotation / b2Abs(rotation);\r\n        w *= ratio;\r\n      }\r\n\r\n      // Integrate\r\n      c.x += h * v.x;\r\n      c.y += h * v.y;\r\n      a += h * w;\r\n\r\n      // this.m_positions[i].c = c;\r\n      this.m_positions[i].a = a;\r\n      // this.m_velocities[i].v = v;\r\n      this.m_velocities[i].w = w;\r\n    }\r\n\r\n    // Solve position constraints\r\n    timer.Reset();\r\n    let positionSolved: boolean = false;\r\n    for (let i: number = 0; i < step.positionIterations; ++i) {\r\n      const contactsOkay: boolean = contactSolver.SolvePositionConstraints();\r\n\r\n      let jointsOkay: boolean = true;\r\n      for (let j: number = 0; j < this.m_jointCount; ++j) {\r\n        const jointOkay: boolean = this.m_joints[j].SolvePositionConstraints(solverData);\r\n        jointsOkay = jointsOkay && jointOkay;\r\n      }\r\n\r\n      if (contactsOkay && jointsOkay) {\r\n        // Exit early if the position errors are small.\r\n        positionSolved = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Copy state buffers back to the bodies\r\n    for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n      const body: b2Body = this.m_bodies[i];\r\n      body.m_sweep.c.Copy(this.m_positions[i].c);\r\n      body.m_sweep.a = this.m_positions[i].a;\r\n      body.m_linearVelocity.Copy(this.m_velocities[i].v);\r\n      body.m_angularVelocity = this.m_velocities[i].w;\r\n      body.SynchronizeTransform();\r\n    }\r\n\r\n    profile.solvePosition = timer.GetMilliseconds();\r\n\r\n    this.Report(contactSolver.m_velocityConstraints);\r\n\r\n    if (allowSleep) {\r\n      let minSleepTime: number = b2_maxFloat;\r\n\r\n      const linTolSqr: number = b2_linearSleepTolerance * b2_linearSleepTolerance;\r\n      const angTolSqr: number = b2_angularSleepTolerance * b2_angularSleepTolerance;\r\n\r\n      for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n        const b: b2Body = this.m_bodies[i];\r\n        if (b.GetType() === b2BodyType.b2_staticBody) {\r\n          continue;\r\n        }\r\n\r\n        if (!b.m_autoSleepFlag ||\r\n          b.m_angularVelocity * b.m_angularVelocity > angTolSqr ||\r\n          b2Vec2.DotVV(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr) {\r\n          b.m_sleepTime = 0;\r\n          minSleepTime = 0;\r\n        } else {\r\n          b.m_sleepTime += h;\r\n          minSleepTime = b2Min(minSleepTime, b.m_sleepTime);\r\n        }\r\n      }\r\n\r\n      if (minSleepTime >= b2_timeToSleep && positionSolved) {\r\n        for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n          const b: b2Body = this.m_bodies[i];\r\n          b.SetAwake(false);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public SolveTOI(subStep: b2TimeStep, toiIndexA: number, toiIndexB: number): void {\r\n    // DEBUG: b2Assert(toiIndexA < this.m_bodyCount);\r\n    // DEBUG: b2Assert(toiIndexB < this.m_bodyCount);\r\n\r\n    // Initialize the body state.\r\n    for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n      const b: b2Body = this.m_bodies[i];\r\n      this.m_positions[i].c.Copy(b.m_sweep.c);\r\n      this.m_positions[i].a = b.m_sweep.a;\r\n      this.m_velocities[i].v.Copy(b.m_linearVelocity);\r\n      this.m_velocities[i].w = b.m_angularVelocity;\r\n    }\r\n\r\n    const contactSolverDef: b2ContactSolverDef = b2Island.s_contactSolverDef;\r\n    contactSolverDef.contacts = this.m_contacts;\r\n    contactSolverDef.count = this.m_contactCount;\r\n    contactSolverDef.step.Copy(subStep);\r\n    contactSolverDef.positions = this.m_positions;\r\n    contactSolverDef.velocities = this.m_velocities;\r\n    const contactSolver: b2ContactSolver = b2Island.s_contactSolver.Initialize(contactSolverDef);\r\n\r\n    // Solve position constraints.\r\n    for (let i: number = 0; i < subStep.positionIterations; ++i) {\r\n      const contactsOkay: boolean = contactSolver.SolveTOIPositionConstraints(toiIndexA, toiIndexB);\r\n      if (contactsOkay) {\r\n        break;\r\n      }\r\n    }\r\n\r\n  /*\r\n  #if 0\r\n    // Is the new position really safe?\r\n    for (int32 i = 0; i < this.m_contactCount; ++i) {\r\n      b2Contact* c = this.m_contacts[i];\r\n      b2Fixture* fA = c.GetFixtureA();\r\n      b2Fixture* fB = c.GetFixtureB();\r\n\r\n      b2Body* bA = fA.GetBody();\r\n      b2Body* bB = fB.GetBody();\r\n\r\n      int32 indexA = c.GetChildIndexA();\r\n      int32 indexB = c.GetChildIndexB();\r\n\r\n      b2DistanceInput input;\r\n      input.proxyA.Set(fA.GetShape(), indexA);\r\n      input.proxyB.Set(fB.GetShape(), indexB);\r\n      input.transformA = bA.GetTransform();\r\n      input.transformB = bB.GetTransform();\r\n      input.useRadii = false;\r\n\r\n      b2DistanceOutput output;\r\n      b2SimplexCache cache;\r\n      cache.count = 0;\r\n      b2Distance(&output, &cache, &input);\r\n\r\n      if (output.distance === 0 || cache.count === 3) {\r\n        cache.count += 0;\r\n      }\r\n    }\r\n  #endif\r\n  */\r\n\r\n    // Leap of faith to new safe state.\r\n    this.m_bodies[toiIndexA].m_sweep.c0.Copy(this.m_positions[toiIndexA].c);\r\n    this.m_bodies[toiIndexA].m_sweep.a0 = this.m_positions[toiIndexA].a;\r\n    this.m_bodies[toiIndexB].m_sweep.c0.Copy(this.m_positions[toiIndexB].c);\r\n    this.m_bodies[toiIndexB].m_sweep.a0 = this.m_positions[toiIndexB].a;\r\n\r\n    // No warm starting is needed for TOI events because warm\r\n    // starting impulses were applied in the discrete solver.\r\n    contactSolver.InitializeVelocityConstraints();\r\n\r\n    // Solve velocity constraints.\r\n    for (let i: number = 0; i < subStep.velocityIterations; ++i) {\r\n      contactSolver.SolveVelocityConstraints();\r\n    }\r\n\r\n    // Don't store the TOI contact forces for warm starting\r\n    // because they can be quite large.\r\n\r\n    const h: number = subStep.dt;\r\n\r\n    // Integrate positions\r\n    for (let i: number = 0; i < this.m_bodyCount; ++i) {\r\n      const c: b2Vec2 = this.m_positions[i].c;\r\n      let a: number = this.m_positions[i].a;\r\n      const v: b2Vec2 = this.m_velocities[i].v;\r\n      let w: number = this.m_velocities[i].w;\r\n\r\n      // Check for large velocities\r\n      const translation: b2Vec2 = b2Vec2.MulSV(h, v, b2Island.s_translation);\r\n      if (b2Vec2.DotVV(translation, translation) > b2_maxTranslationSquared) {\r\n        const ratio: number = b2_maxTranslation / translation.Length();\r\n        v.SelfMul(ratio);\r\n      }\r\n\r\n      const rotation: number = h * w;\r\n      if (rotation * rotation > b2_maxRotationSquared) {\r\n        const ratio: number = b2_maxRotation / b2Abs(rotation);\r\n        w *= ratio;\r\n      }\r\n\r\n      // Integrate\r\n      c.SelfMulAdd(h, v);\r\n      a += h * w;\r\n\r\n      // this.m_positions[i].c = c;\r\n      this.m_positions[i].a = a;\r\n      // this.m_velocities[i].v = v;\r\n      this.m_velocities[i].w = w;\r\n\r\n      // Sync bodies\r\n      const body: b2Body = this.m_bodies[i];\r\n      body.m_sweep.c.Copy(c);\r\n      body.m_sweep.a = a;\r\n      body.m_linearVelocity.Copy(v);\r\n      body.m_angularVelocity = w;\r\n      body.SynchronizeTransform();\r\n    }\r\n\r\n    this.Report(contactSolver.m_velocityConstraints);\r\n  }\r\n\r\n  private static s_impulse = new b2ContactImpulse();\r\n  public Report(constraints: b2ContactVelocityConstraint[]): void {\r\n    if (this.m_listener === null) {\r\n      return;\r\n    }\r\n\r\n    for (let i: number = 0; i < this.m_contactCount; ++i) {\r\n      const c: b2Contact = this.m_contacts[i];\r\n\r\n      if (!c) { continue; }\r\n\r\n      const vc: b2ContactVelocityConstraint = constraints[i];\r\n\r\n      const impulse: b2ContactImpulse = b2Island.s_impulse;\r\n      impulse.count = vc.pointCount;\r\n      for (let j: number = 0; j < vc.pointCount; ++j) {\r\n        impulse.normalImpulses[j] = vc.points[j].normalImpulse;\r\n        impulse.tangentImpulses[j] = vc.points[j].tangentImpulse;\r\n      }\r\n\r\n      this.m_listener.PostSolve(c, impulse);\r\n    }\r\n  }\r\n}\r\n"]}},"error":null,"hash":"a5af501ef371896a2591f49956161bd0","cacheData":{"env":{}}}