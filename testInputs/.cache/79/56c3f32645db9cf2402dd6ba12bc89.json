{"id":"../node_modules/box2d.package.ts/Dynamics/Contacts/b2ContactSolver.ts","dependencies":[{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\package.json","includedInParent":true,"mtime":1586335198964},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\.babelrc","includedInParent":true,"mtime":1586259187841},{"name":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\package.json","includedInParent":true,"mtime":1586252018883},{"name":"../../Common/b2Settings","loc":{"line":21,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactSolver.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Settings.ts"},{"name":"../../Common/b2Math","loc":{"line":22,"column":23},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactSolver.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Common\\b2Math.ts"},{"name":"../../Collision/b2Collision","loc":{"line":24,"column":28},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactSolver.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Collision\\b2Collision.ts"},{"name":"../b2TimeStep","loc":{"line":25,"column":27},"parent":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\Contacts\\b2ContactSolver.ts","resolved":"C:\\Users\\ricardo\\Desktop\\testInputs\\node_modules\\box2d.package.ts\\Dynamics\\b2TimeStep.ts"}],"generated":{"js":"\"use strict\";\r\n/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\nexports.__esModule = true;\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nvar b2Settings_1 = require(\"../../Common/b2Settings\");\r\nvar b2Math_1 = require(\"../../Common/b2Math\");\r\nvar b2Collision_1 = require(\"../../Collision/b2Collision\");\r\nvar b2Collision_2 = require(\"../../Collision/b2Collision\");\r\nvar b2TimeStep_1 = require(\"../b2TimeStep\");\r\n// Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.\r\n// #define B2_DEBUG_SOLVER 0\r\nexports.g_blockSolve = false;\r\nvar b2VelocityConstraintPoint = /** @class */ (function () {\r\n    function b2VelocityConstraintPoint() {\r\n        this.rA = new b2Math_1.b2Vec2();\r\n        this.rB = new b2Math_1.b2Vec2();\r\n        this.normalImpulse = 0;\r\n        this.tangentImpulse = 0;\r\n        this.normalMass = 0;\r\n        this.tangentMass = 0;\r\n        this.velocityBias = 0;\r\n    }\r\n    b2VelocityConstraintPoint.MakeArray = function (length) {\r\n        return b2Settings_1.b2MakeArray(length, function (i) { return new b2VelocityConstraintPoint(); });\r\n    };\r\n    return b2VelocityConstraintPoint;\r\n}());\r\nexports.b2VelocityConstraintPoint = b2VelocityConstraintPoint;\r\nvar b2ContactVelocityConstraint = /** @class */ (function () {\r\n    function b2ContactVelocityConstraint() {\r\n        this.points = b2VelocityConstraintPoint.MakeArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.tangent = new b2Math_1.b2Vec2();\r\n        this.normalMass = new b2Math_1.b2Mat22();\r\n        this.K = new b2Math_1.b2Mat22();\r\n        this.indexA = 0;\r\n        this.indexB = 0;\r\n        this.invMassA = 0;\r\n        this.invMassB = 0;\r\n        this.invIA = 0;\r\n        this.invIB = 0;\r\n        this.friction = 0;\r\n        this.restitution = 0;\r\n        this.tangentSpeed = 0;\r\n        this.pointCount = 0;\r\n        this.contactIndex = 0;\r\n    }\r\n    b2ContactVelocityConstraint.MakeArray = function (length) {\r\n        return b2Settings_1.b2MakeArray(length, function (i) { return new b2ContactVelocityConstraint(); });\r\n    };\r\n    return b2ContactVelocityConstraint;\r\n}());\r\nexports.b2ContactVelocityConstraint = b2ContactVelocityConstraint;\r\nvar b2ContactPositionConstraint = /** @class */ (function () {\r\n    function b2ContactPositionConstraint() {\r\n        this.localPoints = b2Math_1.b2Vec2.MakeArray(b2Settings_1.b2_maxManifoldPoints);\r\n        this.localNormal = new b2Math_1.b2Vec2();\r\n        this.localPoint = new b2Math_1.b2Vec2();\r\n        this.indexA = 0;\r\n        this.indexB = 0;\r\n        this.invMassA = 0;\r\n        this.invMassB = 0;\r\n        this.localCenterA = new b2Math_1.b2Vec2();\r\n        this.localCenterB = new b2Math_1.b2Vec2();\r\n        this.invIA = 0;\r\n        this.invIB = 0;\r\n        this.type = b2Collision_2.b2ManifoldType.e_unknown;\r\n        this.radiusA = 0;\r\n        this.radiusB = 0;\r\n        this.pointCount = 0;\r\n    }\r\n    b2ContactPositionConstraint.MakeArray = function (length) {\r\n        return b2Settings_1.b2MakeArray(length, function (i) { return new b2ContactPositionConstraint(); });\r\n    };\r\n    return b2ContactPositionConstraint;\r\n}());\r\nexports.b2ContactPositionConstraint = b2ContactPositionConstraint;\r\nvar b2ContactSolverDef = /** @class */ (function () {\r\n    function b2ContactSolverDef() {\r\n        this.step = new b2TimeStep_1.b2TimeStep();\r\n        this.count = 0;\r\n    }\r\n    return b2ContactSolverDef;\r\n}());\r\nexports.b2ContactSolverDef = b2ContactSolverDef;\r\nvar b2PositionSolverManifold = /** @class */ (function () {\r\n    function b2PositionSolverManifold() {\r\n        this.normal = new b2Math_1.b2Vec2();\r\n        this.point = new b2Math_1.b2Vec2();\r\n        this.separation = 0;\r\n    }\r\n    b2PositionSolverManifold.prototype.Initialize = function (pc, xfA, xfB, index) {\r\n        var pointA = b2PositionSolverManifold.Initialize_s_pointA;\r\n        var pointB = b2PositionSolverManifold.Initialize_s_pointB;\r\n        var planePoint = b2PositionSolverManifold.Initialize_s_planePoint;\r\n        var clipPoint = b2PositionSolverManifold.Initialize_s_clipPoint;\r\n        // DEBUG: b2Assert(pc.pointCount > 0);\r\n        switch (pc.type) {\r\n            case b2Collision_2.b2ManifoldType.e_circles: {\r\n                // b2Vec2 pointA = b2Mul(xfA, pc->localPoint);\r\n                b2Math_1.b2Transform.MulXV(xfA, pc.localPoint, pointA);\r\n                // b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);\r\n                b2Math_1.b2Transform.MulXV(xfB, pc.localPoints[0], pointB);\r\n                // normal = pointB - pointA;\r\n                // normal.Normalize();\r\n                b2Math_1.b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n                // point = 0.5f * (pointA + pointB);\r\n                b2Math_1.b2Vec2.MidVV(pointA, pointB, this.point);\r\n                // separation = b2Dot(pointB - pointA, normal) - pc->radius;\r\n                this.separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(pointB, pointA, b2Math_1.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n                break;\r\n            }\r\n            case b2Collision_2.b2ManifoldType.e_faceA: {\r\n                // normal = b2Mul(xfA.q, pc->localNormal);\r\n                b2Math_1.b2Rot.MulRV(xfA.q, pc.localNormal, this.normal);\r\n                // b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);\r\n                b2Math_1.b2Transform.MulXV(xfA, pc.localPoint, planePoint);\r\n                // b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);\r\n                b2Math_1.b2Transform.MulXV(xfB, pc.localPoints[index], clipPoint);\r\n                // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n                this.separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(clipPoint, planePoint, b2Math_1.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n                // point = clipPoint;\r\n                this.point.Copy(clipPoint);\r\n                break;\r\n            }\r\n            case b2Collision_2.b2ManifoldType.e_faceB: {\r\n                // normal = b2Mul(xfB.q, pc->localNormal);\r\n                b2Math_1.b2Rot.MulRV(xfB.q, pc.localNormal, this.normal);\r\n                // b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);\r\n                b2Math_1.b2Transform.MulXV(xfB, pc.localPoint, planePoint);\r\n                // b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);\r\n                b2Math_1.b2Transform.MulXV(xfA, pc.localPoints[index], clipPoint);\r\n                // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n                this.separation = b2Math_1.b2Vec2.DotVV(b2Math_1.b2Vec2.SubVV(clipPoint, planePoint, b2Math_1.b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n                // point = clipPoint;\r\n                this.point.Copy(clipPoint);\r\n                // Ensure normal points from A to B\r\n                // normal = -normal;\r\n                this.normal.SelfNeg();\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    b2PositionSolverManifold.Initialize_s_pointA = new b2Math_1.b2Vec2();\r\n    b2PositionSolverManifold.Initialize_s_pointB = new b2Math_1.b2Vec2();\r\n    b2PositionSolverManifold.Initialize_s_planePoint = new b2Math_1.b2Vec2();\r\n    b2PositionSolverManifold.Initialize_s_clipPoint = new b2Math_1.b2Vec2();\r\n    return b2PositionSolverManifold;\r\n}());\r\nexports.b2PositionSolverManifold = b2PositionSolverManifold;\r\nvar b2ContactSolver = /** @class */ (function () {\r\n    function b2ContactSolver() {\r\n        this.m_step = new b2TimeStep_1.b2TimeStep();\r\n        this.m_positionConstraints = b2ContactPositionConstraint.MakeArray(1024); // TODO: b2Settings\r\n        this.m_velocityConstraints = b2ContactVelocityConstraint.MakeArray(1024); // TODO: b2Settings\r\n        this.m_count = 0;\r\n    }\r\n    b2ContactSolver.prototype.Initialize = function (def) {\r\n        this.m_step.Copy(def.step);\r\n        this.m_count = def.count;\r\n        // TODO:\r\n        if (this.m_positionConstraints.length < this.m_count) {\r\n            var new_length = b2Math_1.b2Max(this.m_positionConstraints.length * 2, this.m_count);\r\n            while (this.m_positionConstraints.length < new_length) {\r\n                this.m_positionConstraints[this.m_positionConstraints.length] = new b2ContactPositionConstraint();\r\n            }\r\n        }\r\n        // TODO:\r\n        if (this.m_velocityConstraints.length < this.m_count) {\r\n            var new_length = b2Math_1.b2Max(this.m_velocityConstraints.length * 2, this.m_count);\r\n            while (this.m_velocityConstraints.length < new_length) {\r\n                this.m_velocityConstraints[this.m_velocityConstraints.length] = new b2ContactVelocityConstraint();\r\n            }\r\n        }\r\n        this.m_positions = def.positions;\r\n        this.m_velocities = def.velocities;\r\n        this.m_contacts = def.contacts;\r\n        // Initialize position independent portions of the constraints.\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var contact = this.m_contacts[i];\r\n            var fixtureA = contact.m_fixtureA;\r\n            var fixtureB = contact.m_fixtureB;\r\n            var shapeA = fixtureA.GetShape();\r\n            var shapeB = fixtureB.GetShape();\r\n            var radiusA = shapeA.m_radius;\r\n            var radiusB = shapeB.m_radius;\r\n            var bodyA = fixtureA.GetBody();\r\n            var bodyB = fixtureB.GetBody();\r\n            var manifold = contact.GetManifold();\r\n            var pointCount = manifold.pointCount;\r\n            // DEBUG: b2Assert(pointCount > 0);\r\n            var vc = this.m_velocityConstraints[i];\r\n            vc.friction = contact.m_friction;\r\n            vc.restitution = contact.m_restitution;\r\n            vc.tangentSpeed = contact.m_tangentSpeed;\r\n            vc.indexA = bodyA.m_islandIndex;\r\n            vc.indexB = bodyB.m_islandIndex;\r\n            vc.invMassA = bodyA.m_invMass;\r\n            vc.invMassB = bodyB.m_invMass;\r\n            vc.invIA = bodyA.m_invI;\r\n            vc.invIB = bodyB.m_invI;\r\n            vc.contactIndex = i;\r\n            vc.pointCount = pointCount;\r\n            vc.K.SetZero();\r\n            vc.normalMass.SetZero();\r\n            var pc = this.m_positionConstraints[i];\r\n            pc.indexA = bodyA.m_islandIndex;\r\n            pc.indexB = bodyB.m_islandIndex;\r\n            pc.invMassA = bodyA.m_invMass;\r\n            pc.invMassB = bodyB.m_invMass;\r\n            pc.localCenterA.Copy(bodyA.m_sweep.localCenter);\r\n            pc.localCenterB.Copy(bodyB.m_sweep.localCenter);\r\n            pc.invIA = bodyA.m_invI;\r\n            pc.invIB = bodyB.m_invI;\r\n            pc.localNormal.Copy(manifold.localNormal);\r\n            pc.localPoint.Copy(manifold.localPoint);\r\n            pc.pointCount = pointCount;\r\n            pc.radiusA = radiusA;\r\n            pc.radiusB = radiusB;\r\n            pc.type = manifold.type;\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                var cp = manifold.points[j];\r\n                var vcp = vc.points[j];\r\n                if (this.m_step.warmStarting) {\r\n                    vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;\r\n                    vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;\r\n                }\r\n                else {\r\n                    vcp.normalImpulse = 0;\r\n                    vcp.tangentImpulse = 0;\r\n                }\r\n                vcp.rA.SetZero();\r\n                vcp.rB.SetZero();\r\n                vcp.normalMass = 0;\r\n                vcp.tangentMass = 0;\r\n                vcp.velocityBias = 0;\r\n                pc.localPoints[j].Copy(cp.localPoint);\r\n            }\r\n        }\r\n        return this;\r\n    };\r\n    b2ContactSolver.prototype.InitializeVelocityConstraints = function () {\r\n        var xfA = b2ContactSolver.InitializeVelocityConstraints_s_xfA;\r\n        var xfB = b2ContactSolver.InitializeVelocityConstraints_s_xfB;\r\n        var worldManifold = b2ContactSolver.InitializeVelocityConstraints_s_worldManifold;\r\n        var k_maxConditionNumber = 1000;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var vc = this.m_velocityConstraints[i];\r\n            var pc = this.m_positionConstraints[i];\r\n            var radiusA = pc.radiusA;\r\n            var radiusB = pc.radiusB;\r\n            var manifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n            var indexA = vc.indexA;\r\n            var indexB = vc.indexB;\r\n            var mA = vc.invMassA;\r\n            var mB = vc.invMassB;\r\n            var iA = vc.invIA;\r\n            var iB = vc.invIB;\r\n            var localCenterA = pc.localCenterA;\r\n            var localCenterB = pc.localCenterB;\r\n            var cA = this.m_positions[indexA].c;\r\n            var aA = this.m_positions[indexA].a;\r\n            var vA = this.m_velocities[indexA].v;\r\n            var wA = this.m_velocities[indexA].w;\r\n            var cB = this.m_positions[indexB].c;\r\n            var aB = this.m_positions[indexB].a;\r\n            var vB = this.m_velocities[indexB].v;\r\n            var wB = this.m_velocities[indexB].w;\r\n            // DEBUG: b2Assert(manifold.pointCount > 0);\r\n            xfA.q.SetAngle(aA);\r\n            xfB.q.SetAngle(aB);\r\n            b2Math_1.b2Vec2.SubVV(cA, b2Math_1.b2Rot.MulRV(xfA.q, localCenterA, b2Math_1.b2Vec2.s_t0), xfA.p);\r\n            b2Math_1.b2Vec2.SubVV(cB, b2Math_1.b2Rot.MulRV(xfB.q, localCenterB, b2Math_1.b2Vec2.s_t0), xfB.p);\r\n            worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);\r\n            vc.normal.Copy(worldManifold.normal);\r\n            b2Math_1.b2Vec2.CrossVOne(vc.normal, vc.tangent); // compute from normal\r\n            var pointCount = vc.pointCount;\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                var vcp = vc.points[j];\r\n                // vcp->rA = worldManifold.points[j] - cA;\r\n                b2Math_1.b2Vec2.SubVV(worldManifold.points[j], cA, vcp.rA);\r\n                // vcp->rB = worldManifold.points[j] - cB;\r\n                b2Math_1.b2Vec2.SubVV(worldManifold.points[j], cB, vcp.rB);\r\n                var rnA = b2Math_1.b2Vec2.CrossVV(vcp.rA, vc.normal);\r\n                var rnB = b2Math_1.b2Vec2.CrossVV(vcp.rB, vc.normal);\r\n                var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n                vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;\r\n                // b2Vec2 tangent = b2Cross(vc->normal, 1.0f);\r\n                var tangent = vc.tangent; // precomputed from normal\r\n                var rtA = b2Math_1.b2Vec2.CrossVV(vcp.rA, tangent);\r\n                var rtB = b2Math_1.b2Vec2.CrossVV(vcp.rB, tangent);\r\n                var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\r\n                vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;\r\n                // Setup a velocity bias for restitution.\r\n                vcp.velocityBias = 0;\r\n                // float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));\r\n                var vRel = b2Math_1.b2Vec2.DotVV(vc.normal, b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Math_1.b2Vec2.s_t1), b2Math_1.b2Vec2.s_t0));\r\n                if (vRel < (-b2Settings_1.b2_velocityThreshold)) {\r\n                    vcp.velocityBias += (-vc.restitution * vRel);\r\n                }\r\n            }\r\n            // If we have two points, then prepare the block solver.\r\n            if (vc.pointCount === 2 && exports.g_blockSolve) {\r\n                var vcp1 = vc.points[0];\r\n                var vcp2 = vc.points[1];\r\n                var rn1A = b2Math_1.b2Vec2.CrossVV(vcp1.rA, vc.normal);\r\n                var rn1B = b2Math_1.b2Vec2.CrossVV(vcp1.rB, vc.normal);\r\n                var rn2A = b2Math_1.b2Vec2.CrossVV(vcp2.rA, vc.normal);\r\n                var rn2B = b2Math_1.b2Vec2.CrossVV(vcp2.rB, vc.normal);\r\n                var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\r\n                var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\r\n                var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\r\n                // Ensure a reasonable condition number.\r\n                // float32 k_maxConditionNumber = 1000.0f;\r\n                if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\r\n                    // K is safe to invert.\r\n                    vc.K.ex.Set(k11, k12);\r\n                    vc.K.ey.Set(k12, k22);\r\n                    vc.K.GetInverse(vc.normalMass);\r\n                }\r\n                else {\r\n                    // The constraints are redundant, just use one.\r\n                    // TODO_ERIN use deepest?\r\n                    vc.pointCount = 1;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    b2ContactSolver.prototype.WarmStart = function () {\r\n        var P = b2ContactSolver.WarmStart_s_P;\r\n        // Warm start.\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var vc = this.m_velocityConstraints[i];\r\n            var indexA = vc.indexA;\r\n            var indexB = vc.indexB;\r\n            var mA = vc.invMassA;\r\n            var iA = vc.invIA;\r\n            var mB = vc.invMassB;\r\n            var iB = vc.invIB;\r\n            var pointCount = vc.pointCount;\r\n            var vA = this.m_velocities[indexA].v;\r\n            var wA = this.m_velocities[indexA].w;\r\n            var vB = this.m_velocities[indexB].v;\r\n            var wB = this.m_velocities[indexB].w;\r\n            var normal = vc.normal;\r\n            // b2Vec2 tangent = b2Cross(normal, 1.0f);\r\n            var tangent = vc.tangent; // precomputed from normal\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                var vcp = vc.points[j];\r\n                // b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;\r\n                b2Math_1.b2Vec2.AddVV(b2Math_1.b2Vec2.MulSV(vcp.normalImpulse, normal, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.MulSV(vcp.tangentImpulse, tangent, b2Math_1.b2Vec2.s_t1), P);\r\n                // wA -= iA * b2Cross(vcp->rA, P);\r\n                wA -= iA * b2Math_1.b2Vec2.CrossVV(vcp.rA, P);\r\n                // vA -= mA * P;\r\n                vA.SelfMulSub(mA, P);\r\n                // wB += iB * b2Cross(vcp->rB, P);\r\n                wB += iB * b2Math_1.b2Vec2.CrossVV(vcp.rB, P);\r\n                // vB += mB * P;\r\n                vB.SelfMulAdd(mB, P);\r\n            }\r\n            // this.m_velocities[indexA].v = vA;\r\n            this.m_velocities[indexA].w = wA;\r\n            // this.m_velocities[indexB].v = vB;\r\n            this.m_velocities[indexB].w = wB;\r\n        }\r\n    };\r\n    b2ContactSolver.prototype.SolveVelocityConstraints = function () {\r\n        var dv = b2ContactSolver.SolveVelocityConstraints_s_dv;\r\n        var dv1 = b2ContactSolver.SolveVelocityConstraints_s_dv1;\r\n        var dv2 = b2ContactSolver.SolveVelocityConstraints_s_dv2;\r\n        var P = b2ContactSolver.SolveVelocityConstraints_s_P;\r\n        var a = b2ContactSolver.SolveVelocityConstraints_s_a;\r\n        var b = b2ContactSolver.SolveVelocityConstraints_s_b;\r\n        var x = b2ContactSolver.SolveVelocityConstraints_s_x;\r\n        var d = b2ContactSolver.SolveVelocityConstraints_s_d;\r\n        var P1 = b2ContactSolver.SolveVelocityConstraints_s_P1;\r\n        var P2 = b2ContactSolver.SolveVelocityConstraints_s_P2;\r\n        var P1P2 = b2ContactSolver.SolveVelocityConstraints_s_P1P2;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var vc = this.m_velocityConstraints[i];\r\n            var indexA = vc.indexA;\r\n            var indexB = vc.indexB;\r\n            var mA = vc.invMassA;\r\n            var iA = vc.invIA;\r\n            var mB = vc.invMassB;\r\n            var iB = vc.invIB;\r\n            var pointCount = vc.pointCount;\r\n            var vA = this.m_velocities[indexA].v;\r\n            var wA = this.m_velocities[indexA].w;\r\n            var vB = this.m_velocities[indexB].v;\r\n            var wB = this.m_velocities[indexB].w;\r\n            // b2Vec2 normal = vc->normal;\r\n            var normal = vc.normal;\r\n            // b2Vec2 tangent = b2Cross(normal, 1.0f);\r\n            var tangent = vc.tangent; // precomputed from normal\r\n            var friction = vc.friction;\r\n            // DEBUG: b2Assert(pointCount === 1 || pointCount === 2);\r\n            // Solve tangent constraints first because non-penetration is more important\r\n            // than friction.\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                var vcp = vc.points[j];\r\n                // Relative velocity at contact\r\n                // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n                b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Math_1.b2Vec2.s_t1), dv);\r\n                // Compute tangent force\r\n                // float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;\r\n                var vt = b2Math_1.b2Vec2.DotVV(dv, tangent) - vc.tangentSpeed;\r\n                var lambda = vcp.tangentMass * (-vt);\r\n                // b2Clamp the accumulated force\r\n                var maxFriction = friction * vcp.normalImpulse;\r\n                var newImpulse = b2Math_1.b2Clamp(vcp.tangentImpulse + lambda, (-maxFriction), maxFriction);\r\n                lambda = newImpulse - vcp.tangentImpulse;\r\n                vcp.tangentImpulse = newImpulse;\r\n                // Apply contact impulse\r\n                // b2Vec2 P = lambda * tangent;\r\n                b2Math_1.b2Vec2.MulSV(lambda, tangent, P);\r\n                // vA -= mA * P;\r\n                vA.SelfMulSub(mA, P);\r\n                // wA -= iA * b2Cross(vcp->rA, P);\r\n                wA -= iA * b2Math_1.b2Vec2.CrossVV(vcp.rA, P);\r\n                // vB += mB * P;\r\n                vB.SelfMulAdd(mB, P);\r\n                // wB += iB * b2Cross(vcp->rB, P);\r\n                wB += iB * b2Math_1.b2Vec2.CrossVV(vcp.rB, P);\r\n            }\r\n            // Solve normal constraints\r\n            if (vc.pointCount === 1 || exports.g_blockSolve === false) {\r\n                for (var j = 0; j < pointCount; ++j) {\r\n                    var vcp = vc.points[j];\r\n                    // Relative velocity at contact\r\n                    // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n                    b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Math_1.b2Vec2.s_t1), dv);\r\n                    // Compute normal impulse\r\n                    // float32 vn = b2Dot(dv, normal);\r\n                    var vn = b2Math_1.b2Vec2.DotVV(dv, normal);\r\n                    var lambda = (-vcp.normalMass * (vn - vcp.velocityBias));\r\n                    // b2Clamp the accumulated impulse\r\n                    // float32 newImpulse = b2Max(vcp->normalImpulse + lambda, 0.0f);\r\n                    var newImpulse = b2Math_1.b2Max(vcp.normalImpulse + lambda, 0);\r\n                    lambda = newImpulse - vcp.normalImpulse;\r\n                    vcp.normalImpulse = newImpulse;\r\n                    // Apply contact impulse\r\n                    // b2Vec2 P = lambda * normal;\r\n                    b2Math_1.b2Vec2.MulSV(lambda, normal, P);\r\n                    // vA -= mA * P;\r\n                    vA.SelfMulSub(mA, P);\r\n                    // wA -= iA * b2Cross(vcp->rA, P);\r\n                    wA -= iA * b2Math_1.b2Vec2.CrossVV(vcp.rA, P);\r\n                    // vB += mB * P;\r\n                    vB.SelfMulAdd(mB, P);\r\n                    // wB += iB * b2Cross(vcp->rB, P);\r\n                    wB += iB * b2Math_1.b2Vec2.CrossVV(vcp.rB, P);\r\n                }\r\n            }\r\n            else {\r\n                // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).\r\n                // Build the mini LCP for this contact patch\r\n                //\r\n                // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\r\n                //\r\n                // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\r\n                // b = vn0 - velocityBias\r\n                //\r\n                // The system is solved using the \"Total enumeration method\" (s. Murty). The complementary constraint vn_i * x_i\r\n                // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases\r\n                // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be tested. The first valid\r\n                // solution that satisfies the problem is chosen.\r\n                //\r\n                // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires\r\n                // that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).\r\n                //\r\n                // Substitute:\r\n                //\r\n                // x = a + d\r\n                //\r\n                // a := old total impulse\r\n                // x := new total impulse\r\n                // d := incremental impulse\r\n                //\r\n                // For the current iteration we extend the formula for the incremental impulse\r\n                // to compute the new total impulse:\r\n                //\r\n                // vn = A * d + b\r\n                //    = A * (x - a) + b\r\n                //    = A * x + b - A * a\r\n                //    = A * x + b'\r\n                // b' = b - A * a;\r\n                var cp1 = vc.points[0];\r\n                var cp2 = vc.points[1];\r\n                // b2Vec2 a(cp1->normalImpulse, cp2->normalImpulse);\r\n                a.Set(cp1.normalImpulse, cp2.normalImpulse);\r\n                // DEBUG: b2Assert(a.x >= 0 && a.y >= 0);\r\n                // Relative velocity at contact\r\n                // b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n                b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, cp1.rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, cp1.rA, b2Math_1.b2Vec2.s_t1), dv1);\r\n                // b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n                b2Math_1.b2Vec2.SubVV(b2Math_1.b2Vec2.AddVCrossSV(vB, wB, cp2.rB, b2Math_1.b2Vec2.s_t0), b2Math_1.b2Vec2.AddVCrossSV(vA, wA, cp2.rA, b2Math_1.b2Vec2.s_t1), dv2);\r\n                // Compute normal velocity\r\n                // float32 vn1 = b2Dot(dv1, normal);\r\n                var vn1 = b2Math_1.b2Vec2.DotVV(dv1, normal);\r\n                // float32 vn2 = b2Dot(dv2, normal);\r\n                var vn2 = b2Math_1.b2Vec2.DotVV(dv2, normal);\r\n                // b2Vec2 b;\r\n                b.x = vn1 - cp1.velocityBias;\r\n                b.y = vn2 - cp2.velocityBias;\r\n                // Compute b'\r\n                // b -= b2Mul(vc->K, a);\r\n                b.SelfSub(b2Math_1.b2Mat22.MulMV(vc.K, a, b2Math_1.b2Vec2.s_t0));\r\n                /*\r\n                #if B2_DEBUG_SOLVER === 1\r\n                const k_errorTol: number = 0.001;\r\n                #endif\r\n                */\r\n                for (;;) {\r\n                    //\r\n                    // Case 1: vn = 0\r\n                    //\r\n                    // 0 = A * x + b'\r\n                    //\r\n                    // Solve for x:\r\n                    //\r\n                    // x = - inv(A) * b'\r\n                    //\r\n                    // b2Vec2 x = - b2Mul(vc->normalMass, b);\r\n                    b2Math_1.b2Mat22.MulMV(vc.normalMass, b, x).SelfNeg();\r\n                    if (x.x >= 0 && x.y >= 0) {\r\n                        // Get the incremental impulse\r\n                        // b2Vec2 d = x - a;\r\n                        b2Math_1.b2Vec2.SubVV(x, a, d);\r\n                        // Apply incremental impulse\r\n                        // b2Vec2 P1 = d.x * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.x, normal, P1);\r\n                        // b2Vec2 P2 = d.y * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.y, normal, P2);\r\n                        b2Math_1.b2Vec2.AddVV(P1, P2, P1P2);\r\n                        // vA -= mA * (P1 + P2);\r\n                        vA.SelfMulSub(mA, P1P2);\r\n                        // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n                        wA -= iA * (b2Math_1.b2Vec2.CrossVV(cp1.rA, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rA, P2));\r\n                        // vB += mB * (P1 + P2);\r\n                        vB.SelfMulAdd(mB, P1P2);\r\n                        // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n                        wB += iB * (b2Math_1.b2Vec2.CrossVV(cp1.rB, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rB, P2));\r\n                        // Accumulate\r\n                        cp1.normalImpulse = x.x;\r\n                        cp2.normalImpulse = x.y;\r\n                        /*\r\n                        #if B2_DEBUG_SOLVER === 1\r\n                        // Postconditions\r\n                        dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n                        dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n            \r\n                        // Compute normal velocity\r\n                        vn1 = b2Dot(dv1, normal);\r\n                        vn2 = b2Dot(dv2, normal);\r\n            \r\n                        b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);\r\n                        b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);\r\n                        #endif\r\n                        */\r\n                        break;\r\n                    }\r\n                    //\r\n                    // Case 2: vn1 = 0 and x2 = 0\r\n                    //\r\n                    //   0 = a11 * x1 + a12 * 0 + b1'\r\n                    // vn2 = a21 * x1 + a22 * 0 + b2'\r\n                    //\r\n                    x.x = (-cp1.normalMass * b.x);\r\n                    x.y = 0;\r\n                    vn1 = 0;\r\n                    vn2 = vc.K.ex.y * x.x + b.y;\r\n                    if (x.x >= 0 && vn2 >= 0) {\r\n                        // Get the incremental impulse\r\n                        // b2Vec2 d = x - a;\r\n                        b2Math_1.b2Vec2.SubVV(x, a, d);\r\n                        // Apply incremental impulse\r\n                        // b2Vec2 P1 = d.x * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.x, normal, P1);\r\n                        // b2Vec2 P2 = d.y * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.y, normal, P2);\r\n                        b2Math_1.b2Vec2.AddVV(P1, P2, P1P2);\r\n                        // vA -= mA * (P1 + P2);\r\n                        vA.SelfMulSub(mA, P1P2);\r\n                        // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n                        wA -= iA * (b2Math_1.b2Vec2.CrossVV(cp1.rA, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rA, P2));\r\n                        // vB += mB * (P1 + P2);\r\n                        vB.SelfMulAdd(mB, P1P2);\r\n                        // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n                        wB += iB * (b2Math_1.b2Vec2.CrossVV(cp1.rB, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rB, P2));\r\n                        // Accumulate\r\n                        cp1.normalImpulse = x.x;\r\n                        cp2.normalImpulse = x.y;\r\n                        /*\r\n                        #if B2_DEBUG_SOLVER === 1\r\n                        // Postconditions\r\n                        dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n            \r\n                        // Compute normal velocity\r\n                        vn1 = b2Dot(dv1, normal);\r\n            \r\n                        b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);\r\n                        #endif\r\n                        */\r\n                        break;\r\n                    }\r\n                    //\r\n                    // Case 3: vn2 = 0 and x1 = 0\r\n                    //\r\n                    // vn1 = a11 * 0 + a12 * x2 + b1'\r\n                    //   0 = a21 * 0 + a22 * x2 + b2'\r\n                    //\r\n                    x.x = 0;\r\n                    x.y = (-cp2.normalMass * b.y);\r\n                    vn1 = vc.K.ey.x * x.y + b.x;\r\n                    vn2 = 0;\r\n                    if (x.y >= 0 && vn1 >= 0) {\r\n                        // Resubstitute for the incremental impulse\r\n                        // b2Vec2 d = x - a;\r\n                        b2Math_1.b2Vec2.SubVV(x, a, d);\r\n                        // Apply incremental impulse\r\n                        // b2Vec2 P1 = d.x * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.x, normal, P1);\r\n                        // b2Vec2 P2 = d.y * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.y, normal, P2);\r\n                        b2Math_1.b2Vec2.AddVV(P1, P2, P1P2);\r\n                        // vA -= mA * (P1 + P2);\r\n                        vA.SelfMulSub(mA, P1P2);\r\n                        // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n                        wA -= iA * (b2Math_1.b2Vec2.CrossVV(cp1.rA, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rA, P2));\r\n                        // vB += mB * (P1 + P2);\r\n                        vB.SelfMulAdd(mB, P1P2);\r\n                        // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n                        wB += iB * (b2Math_1.b2Vec2.CrossVV(cp1.rB, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rB, P2));\r\n                        // Accumulate\r\n                        cp1.normalImpulse = x.x;\r\n                        cp2.normalImpulse = x.y;\r\n                        /*\r\n                        #if B2_DEBUG_SOLVER === 1\r\n                        // Postconditions\r\n                        dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n            \r\n                        // Compute normal velocity\r\n                        vn2 = b2Dot(dv2, normal);\r\n            \r\n                        b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);\r\n                        #endif\r\n                        */\r\n                        break;\r\n                    }\r\n                    //\r\n                    // Case 4: x1 = 0 and x2 = 0\r\n                    //\r\n                    // vn1 = b1\r\n                    // vn2 = b2;\r\n                    x.x = 0;\r\n                    x.y = 0;\r\n                    vn1 = b.x;\r\n                    vn2 = b.y;\r\n                    if (vn1 >= 0 && vn2 >= 0) {\r\n                        // Resubstitute for the incremental impulse\r\n                        // b2Vec2 d = x - a;\r\n                        b2Math_1.b2Vec2.SubVV(x, a, d);\r\n                        // Apply incremental impulse\r\n                        // b2Vec2 P1 = d.x * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.x, normal, P1);\r\n                        // b2Vec2 P2 = d.y * normal;\r\n                        b2Math_1.b2Vec2.MulSV(d.y, normal, P2);\r\n                        b2Math_1.b2Vec2.AddVV(P1, P2, P1P2);\r\n                        // vA -= mA * (P1 + P2);\r\n                        vA.SelfMulSub(mA, P1P2);\r\n                        // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n                        wA -= iA * (b2Math_1.b2Vec2.CrossVV(cp1.rA, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rA, P2));\r\n                        // vB += mB * (P1 + P2);\r\n                        vB.SelfMulAdd(mB, P1P2);\r\n                        // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n                        wB += iB * (b2Math_1.b2Vec2.CrossVV(cp1.rB, P1) + b2Math_1.b2Vec2.CrossVV(cp2.rB, P2));\r\n                        // Accumulate\r\n                        cp1.normalImpulse = x.x;\r\n                        cp2.normalImpulse = x.y;\r\n                        break;\r\n                    }\r\n                    // No solution, give up. This is hit sometimes, but it doesn't seem to matter.\r\n                    break;\r\n                }\r\n            }\r\n            // this.m_velocities[indexA].v = vA;\r\n            this.m_velocities[indexA].w = wA;\r\n            // this.m_velocities[indexB].v = vB;\r\n            this.m_velocities[indexB].w = wB;\r\n        }\r\n    };\r\n    b2ContactSolver.prototype.StoreImpulses = function () {\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var vc = this.m_velocityConstraints[i];\r\n            var manifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n            for (var j = 0; j < vc.pointCount; ++j) {\r\n                manifold.points[j].normalImpulse = vc.points[j].normalImpulse;\r\n                manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;\r\n            }\r\n        }\r\n    };\r\n    b2ContactSolver.prototype.SolvePositionConstraints = function () {\r\n        var xfA = b2ContactSolver.SolvePositionConstraints_s_xfA;\r\n        var xfB = b2ContactSolver.SolvePositionConstraints_s_xfB;\r\n        var psm = b2ContactSolver.SolvePositionConstraints_s_psm;\r\n        var rA = b2ContactSolver.SolvePositionConstraints_s_rA;\r\n        var rB = b2ContactSolver.SolvePositionConstraints_s_rB;\r\n        var P = b2ContactSolver.SolvePositionConstraints_s_P;\r\n        var minSeparation = 0;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var pc = this.m_positionConstraints[i];\r\n            var indexA = pc.indexA;\r\n            var indexB = pc.indexB;\r\n            var localCenterA = pc.localCenterA;\r\n            var mA = pc.invMassA;\r\n            var iA = pc.invIA;\r\n            var localCenterB = pc.localCenterB;\r\n            var mB = pc.invMassB;\r\n            var iB = pc.invIB;\r\n            var pointCount = pc.pointCount;\r\n            var cA = this.m_positions[indexA].c;\r\n            var aA = this.m_positions[indexA].a;\r\n            var cB = this.m_positions[indexB].c;\r\n            var aB = this.m_positions[indexB].a;\r\n            // Solve normal constraints\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                xfA.q.SetAngle(aA);\r\n                xfB.q.SetAngle(aB);\r\n                b2Math_1.b2Vec2.SubVV(cA, b2Math_1.b2Rot.MulRV(xfA.q, localCenterA, b2Math_1.b2Vec2.s_t0), xfA.p);\r\n                b2Math_1.b2Vec2.SubVV(cB, b2Math_1.b2Rot.MulRV(xfB.q, localCenterB, b2Math_1.b2Vec2.s_t0), xfB.p);\r\n                psm.Initialize(pc, xfA, xfB, j);\r\n                var normal = psm.normal;\r\n                var point = psm.point;\r\n                var separation = psm.separation;\r\n                // b2Vec2 rA = point - cA;\r\n                b2Math_1.b2Vec2.SubVV(point, cA, rA);\r\n                // b2Vec2 rB = point - cB;\r\n                b2Math_1.b2Vec2.SubVV(point, cB, rB);\r\n                // Track max constraint error.\r\n                minSeparation = b2Math_1.b2Min(minSeparation, separation);\r\n                // Prevent large corrections and allow slop.\r\n                var C = b2Math_1.b2Clamp(b2Settings_1.b2_baumgarte * (separation + b2Settings_1.b2_linearSlop), (-b2Settings_1.b2_maxLinearCorrection), 0);\r\n                // Compute the effective mass.\r\n                // float32 rnA = b2Cross(rA, normal);\r\n                var rnA = b2Math_1.b2Vec2.CrossVV(rA, normal);\r\n                // float32 rnB = b2Cross(rB, normal);\r\n                var rnB = b2Math_1.b2Vec2.CrossVV(rB, normal);\r\n                // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n                // Compute normal impulse\r\n                var impulse = K > 0 ? -C / K : 0;\r\n                // b2Vec2 P = impulse * normal;\r\n                b2Math_1.b2Vec2.MulSV(impulse, normal, P);\r\n                // cA -= mA * P;\r\n                cA.SelfMulSub(mA, P);\r\n                // aA -= iA * b2Cross(rA, P);\r\n                aA -= iA * b2Math_1.b2Vec2.CrossVV(rA, P);\r\n                // cB += mB * P;\r\n                cB.SelfMulAdd(mB, P);\r\n                // aB += iB * b2Cross(rB, P);\r\n                aB += iB * b2Math_1.b2Vec2.CrossVV(rB, P);\r\n            }\r\n            // this.m_positions[indexA].c = cA;\r\n            this.m_positions[indexA].a = aA;\r\n            // this.m_positions[indexB].c = cB;\r\n            this.m_positions[indexB].a = aB;\r\n        }\r\n        // We can't expect minSpeparation >= -b2_linearSlop because we don't\r\n        // push the separation above -b2_linearSlop.\r\n        return minSeparation > (-3 * b2Settings_1.b2_linearSlop);\r\n    };\r\n    b2ContactSolver.prototype.SolveTOIPositionConstraints = function (toiIndexA, toiIndexB) {\r\n        var xfA = b2ContactSolver.SolveTOIPositionConstraints_s_xfA;\r\n        var xfB = b2ContactSolver.SolveTOIPositionConstraints_s_xfB;\r\n        var psm = b2ContactSolver.SolveTOIPositionConstraints_s_psm;\r\n        var rA = b2ContactSolver.SolveTOIPositionConstraints_s_rA;\r\n        var rB = b2ContactSolver.SolveTOIPositionConstraints_s_rB;\r\n        var P = b2ContactSolver.SolveTOIPositionConstraints_s_P;\r\n        var minSeparation = 0;\r\n        for (var i = 0; i < this.m_count; ++i) {\r\n            var pc = this.m_positionConstraints[i];\r\n            var indexA = pc.indexA;\r\n            var indexB = pc.indexB;\r\n            var localCenterA = pc.localCenterA;\r\n            var localCenterB = pc.localCenterB;\r\n            var pointCount = pc.pointCount;\r\n            var mA = 0;\r\n            var iA = 0;\r\n            if (indexA === toiIndexA || indexA === toiIndexB) {\r\n                mA = pc.invMassA;\r\n                iA = pc.invIA;\r\n            }\r\n            var mB = 0;\r\n            var iB = 0;\r\n            if (indexB === toiIndexA || indexB === toiIndexB) {\r\n                mB = pc.invMassB;\r\n                iB = pc.invIB;\r\n            }\r\n            var cA = this.m_positions[indexA].c;\r\n            var aA = this.m_positions[indexA].a;\r\n            var cB = this.m_positions[indexB].c;\r\n            var aB = this.m_positions[indexB].a;\r\n            // Solve normal constraints\r\n            for (var j = 0; j < pointCount; ++j) {\r\n                xfA.q.SetAngle(aA);\r\n                xfB.q.SetAngle(aB);\r\n                b2Math_1.b2Vec2.SubVV(cA, b2Math_1.b2Rot.MulRV(xfA.q, localCenterA, b2Math_1.b2Vec2.s_t0), xfA.p);\r\n                b2Math_1.b2Vec2.SubVV(cB, b2Math_1.b2Rot.MulRV(xfB.q, localCenterB, b2Math_1.b2Vec2.s_t0), xfB.p);\r\n                psm.Initialize(pc, xfA, xfB, j);\r\n                var normal = psm.normal;\r\n                var point = psm.point;\r\n                var separation = psm.separation;\r\n                // b2Vec2 rA = point - cA;\r\n                b2Math_1.b2Vec2.SubVV(point, cA, rA);\r\n                // b2Vec2 rB = point - cB;\r\n                b2Math_1.b2Vec2.SubVV(point, cB, rB);\r\n                // Track max constraint error.\r\n                minSeparation = b2Math_1.b2Min(minSeparation, separation);\r\n                // Prevent large corrections and allow slop.\r\n                var C = b2Math_1.b2Clamp(b2Settings_1.b2_toiBaumgarte * (separation + b2Settings_1.b2_linearSlop), (-b2Settings_1.b2_maxLinearCorrection), 0);\r\n                // Compute the effective mass.\r\n                // float32 rnA = b2Cross(rA, normal);\r\n                var rnA = b2Math_1.b2Vec2.CrossVV(rA, normal);\r\n                // float32 rnB = b2Cross(rB, normal);\r\n                var rnB = b2Math_1.b2Vec2.CrossVV(rB, normal);\r\n                // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n                var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n                // Compute normal impulse\r\n                var impulse = K > 0 ? -C / K : 0;\r\n                // b2Vec2 P = impulse * normal;\r\n                b2Math_1.b2Vec2.MulSV(impulse, normal, P);\r\n                // cA -= mA * P;\r\n                cA.SelfMulSub(mA, P);\r\n                // aA -= iA * b2Cross(rA, P);\r\n                aA -= iA * b2Math_1.b2Vec2.CrossVV(rA, P);\r\n                // cB += mB * P;\r\n                cB.SelfMulAdd(mB, P);\r\n                // aB += iB * b2Cross(rB, P);\r\n                aB += iB * b2Math_1.b2Vec2.CrossVV(rB, P);\r\n            }\r\n            // this.m_positions[indexA].c = cA;\r\n            this.m_positions[indexA].a = aA;\r\n            // this.m_positions[indexB].c = cB;\r\n            this.m_positions[indexB].a = aB;\r\n        }\r\n        // We can't expect minSpeparation >= -b2_linearSlop because we don't\r\n        // push the separation above -b2_linearSlop.\r\n        return minSeparation >= -1.5 * b2Settings_1.b2_linearSlop;\r\n    };\r\n    b2ContactSolver.InitializeVelocityConstraints_s_xfA = new b2Math_1.b2Transform();\r\n    b2ContactSolver.InitializeVelocityConstraints_s_xfB = new b2Math_1.b2Transform();\r\n    b2ContactSolver.InitializeVelocityConstraints_s_worldManifold = new b2Collision_1.b2WorldManifold();\r\n    b2ContactSolver.WarmStart_s_P = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_dv = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_dv1 = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_dv2 = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_a = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_b = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_x = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_d = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_P1 = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_P2 = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveVelocityConstraints_s_P1P2 = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolvePositionConstraints_s_xfA = new b2Math_1.b2Transform();\r\n    b2ContactSolver.SolvePositionConstraints_s_xfB = new b2Math_1.b2Transform();\r\n    b2ContactSolver.SolvePositionConstraints_s_psm = new b2PositionSolverManifold();\r\n    b2ContactSolver.SolvePositionConstraints_s_rA = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolvePositionConstraints_s_rB = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolvePositionConstraints_s_P = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_xfA = new b2Math_1.b2Transform();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_xfB = new b2Math_1.b2Transform();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_psm = new b2PositionSolverManifold();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_rA = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_rB = new b2Math_1.b2Vec2();\r\n    b2ContactSolver.SolveTOIPositionConstraints_s_P = new b2Math_1.b2Vec2();\r\n    return b2ContactSolver;\r\n}());\r\nexports.b2ContactSolver = b2ContactSolver;\r\n"},"sourceMaps":{"js":{"version":3,"file":"b2ContactSolver.js","sourceRoot":"","sources":["../node_modules/box2d.package.ts/Dynamics/Contacts/b2ContactSolver.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n* Copyright (c) 2006-2009 Erin Catto http://www.box2d.org\r\n*\r\n* This software is provided 'as-is', without any express or implied\r\n* warranty.  In no event will the authors be held liable for any damages\r\n* arising from the use of this software.\r\n* Permission is granted to anyone to use this software for any purpose,\r\n* including commercial applications, and to alter it and redistribute it\r\n* freely, subject to the following restrictions:\r\n* 1. The origin of this software must not be misrepresented; you must not\r\n* claim that you wrote the original software. If you use this software\r\n* in a product, an acknowledgment in the product documentation would be\r\n* appreciated but is not required.\r\n* 2. Altered source versions must be plainly marked as such, and must not be\r\n* misrepresented as being the original software.\r\n* 3. This notice may not be removed or altered from any source distribution.\r\n*/\r\n\r\n// DEBUG: import { b2Assert } from \"../../Common/b2Settings\";\r\nimport { b2_linearSlop, b2_maxManifoldPoints, b2_velocityThreshold, b2_maxLinearCorrection, b2_baumgarte, b2_toiBaumgarte, b2MakeArray } from \"../../Common/b2Settings\";\r\nimport { b2Min, b2Max, b2Clamp, b2Vec2, b2Mat22, b2Rot, b2Transform } from \"../../Common/b2Math\";\r\nimport { b2Manifold } from \"../../Collision/b2Collision\";\r\nimport { b2ManifoldPoint } from \"../../Collision/b2Collision\";\r\nimport { b2WorldManifold } from \"../../Collision/b2Collision\";\r\nimport { b2ManifoldType } from \"../../Collision/b2Collision\";\r\nimport { b2Shape } from \"../../Collision/Shapes/b2Shape\";\r\nimport { b2Contact } from \"./b2Contact\";\r\nimport { b2Body } from \"../b2Body\";\r\nimport { b2Fixture } from \"../b2Fixture\";\r\nimport { b2TimeStep, b2Position, b2Velocity } from \"../b2TimeStep\";\r\n\r\n// Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.\r\n// #define B2_DEBUG_SOLVER 0\r\n\r\nexport let g_blockSolve: boolean = false;\r\n\r\nexport class b2VelocityConstraintPoint {\r\n  public readonly rA: b2Vec2 = new b2Vec2();\r\n  public readonly rB: b2Vec2 = new b2Vec2();\r\n  public normalImpulse: number = 0;\r\n  public tangentImpulse: number = 0;\r\n  public normalMass: number = 0;\r\n  public tangentMass: number = 0;\r\n  public velocityBias: number = 0;\r\n\r\n  public static MakeArray(length: number): b2VelocityConstraintPoint[] {\r\n    return b2MakeArray(length, (i: number) => new b2VelocityConstraintPoint());\r\n  }\r\n}\r\n\r\nexport class b2ContactVelocityConstraint {\r\n  public readonly points: b2VelocityConstraintPoint[] = b2VelocityConstraintPoint.MakeArray(b2_maxManifoldPoints);\r\n  public readonly normal: b2Vec2 = new b2Vec2();\r\n  public readonly tangent: b2Vec2 = new b2Vec2();\r\n  public readonly normalMass: b2Mat22 = new b2Mat22();\r\n  public readonly K: b2Mat22 = new b2Mat22();\r\n  public indexA: number = 0;\r\n  public indexB: number = 0;\r\n  public invMassA: number = 0;\r\n  public invMassB: number = 0;\r\n  public invIA: number = 0;\r\n  public invIB: number = 0;\r\n  public friction: number = 0;\r\n  public restitution: number = 0;\r\n  public tangentSpeed: number = 0;\r\n  public pointCount: number = 0;\r\n  public contactIndex: number = 0;\r\n\r\n  public static MakeArray(length: number): b2ContactVelocityConstraint[] {\r\n    return b2MakeArray(length, (i: number) => new b2ContactVelocityConstraint());\r\n  }\r\n}\r\n\r\nexport class b2ContactPositionConstraint {\r\n  public readonly localPoints: b2Vec2[] = b2Vec2.MakeArray(b2_maxManifoldPoints);\r\n  public readonly localNormal: b2Vec2 = new b2Vec2();\r\n  public readonly localPoint: b2Vec2 = new b2Vec2();\r\n  public indexA: number = 0;\r\n  public indexB: number = 0;\r\n  public invMassA: number = 0;\r\n  public invMassB: number = 0;\r\n  public readonly localCenterA: b2Vec2 = new b2Vec2();\r\n  public readonly localCenterB: b2Vec2 = new b2Vec2();\r\n  public invIA: number = 0;\r\n  public invIB: number = 0;\r\n  public type: b2ManifoldType = b2ManifoldType.e_unknown;\r\n  public radiusA: number = 0;\r\n  public radiusB: number = 0;\r\n  public pointCount: number = 0;\r\n\r\n  public static MakeArray(length: number): b2ContactPositionConstraint[] {\r\n    return b2MakeArray(length, (i: number) => new b2ContactPositionConstraint());\r\n  }\r\n}\r\n\r\nexport class b2ContactSolverDef {\r\n  public readonly step: b2TimeStep = new b2TimeStep();\r\n  public contacts!: b2Contact[];\r\n  public count: number = 0;\r\n  public positions!: b2Position[];\r\n  public velocities!: b2Velocity[];\r\n}\r\n\r\nexport class b2PositionSolverManifold {\r\n  public readonly normal: b2Vec2 = new b2Vec2();\r\n  public readonly point: b2Vec2 = new b2Vec2();\r\n  public separation: number = 0;\r\n\r\n  private static Initialize_s_pointA = new b2Vec2();\r\n  private static Initialize_s_pointB = new b2Vec2();\r\n  private static Initialize_s_planePoint = new b2Vec2();\r\n  private static Initialize_s_clipPoint = new b2Vec2();\r\n  public Initialize(pc: b2ContactPositionConstraint, xfA: b2Transform, xfB: b2Transform, index: number): void {\r\n    const pointA: b2Vec2 = b2PositionSolverManifold.Initialize_s_pointA;\r\n    const pointB: b2Vec2 = b2PositionSolverManifold.Initialize_s_pointB;\r\n    const planePoint: b2Vec2 = b2PositionSolverManifold.Initialize_s_planePoint;\r\n    const clipPoint: b2Vec2 = b2PositionSolverManifold.Initialize_s_clipPoint;\r\n\r\n    // DEBUG: b2Assert(pc.pointCount > 0);\r\n\r\n    switch (pc.type) {\r\n    case b2ManifoldType.e_circles: {\r\n        // b2Vec2 pointA = b2Mul(xfA, pc->localPoint);\r\n        b2Transform.MulXV(xfA, pc.localPoint, pointA);\r\n        // b2Vec2 pointB = b2Mul(xfB, pc->localPoints[0]);\r\n        b2Transform.MulXV(xfB, pc.localPoints[0], pointB);\r\n        // normal = pointB - pointA;\r\n        // normal.Normalize();\r\n        b2Vec2.SubVV(pointB, pointA, this.normal).SelfNormalize();\r\n        // point = 0.5f * (pointA + pointB);\r\n        b2Vec2.MidVV(pointA, pointB, this.point);\r\n        // separation = b2Dot(pointB - pointA, normal) - pc->radius;\r\n        this.separation = b2Vec2.DotVV(b2Vec2.SubVV(pointB, pointA, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n        break;\r\n      }\r\n\r\n    case b2ManifoldType.e_faceA: {\r\n        // normal = b2Mul(xfA.q, pc->localNormal);\r\n        b2Rot.MulRV(xfA.q, pc.localNormal, this.normal);\r\n        // b2Vec2 planePoint = b2Mul(xfA, pc->localPoint);\r\n        b2Transform.MulXV(xfA, pc.localPoint, planePoint);\r\n\r\n        // b2Vec2 clipPoint = b2Mul(xfB, pc->localPoints[index]);\r\n        b2Transform.MulXV(xfB, pc.localPoints[index], clipPoint);\r\n        // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n        this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n        // point = clipPoint;\r\n        this.point.Copy(clipPoint);\r\n        break;\r\n      }\r\n\r\n    case b2ManifoldType.e_faceB: {\r\n        // normal = b2Mul(xfB.q, pc->localNormal);\r\n        b2Rot.MulRV(xfB.q, pc.localNormal, this.normal);\r\n        // b2Vec2 planePoint = b2Mul(xfB, pc->localPoint);\r\n        b2Transform.MulXV(xfB, pc.localPoint, planePoint);\r\n\r\n        // b2Vec2 clipPoint = b2Mul(xfA, pc->localPoints[index]);\r\n        b2Transform.MulXV(xfA, pc.localPoints[index], clipPoint);\r\n        // separation = b2Dot(clipPoint - planePoint, normal) - pc->radius;\r\n        this.separation = b2Vec2.DotVV(b2Vec2.SubVV(clipPoint, planePoint, b2Vec2.s_t0), this.normal) - pc.radiusA - pc.radiusB;\r\n        // point = clipPoint;\r\n        this.point.Copy(clipPoint);\r\n\r\n        // Ensure normal points from A to B\r\n        // normal = -normal;\r\n        this.normal.SelfNeg();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport class b2ContactSolver {\r\n  public readonly m_step: b2TimeStep = new b2TimeStep();\r\n  public m_positions!: b2Position[];\r\n  public m_velocities!: b2Velocity[];\r\n  public readonly m_positionConstraints: b2ContactPositionConstraint[] = b2ContactPositionConstraint.MakeArray(1024); // TODO: b2Settings\r\n  public readonly m_velocityConstraints: b2ContactVelocityConstraint[] = b2ContactVelocityConstraint.MakeArray(1024); // TODO: b2Settings\r\n  public m_contacts!: b2Contact[];\r\n  public m_count: number = 0;\r\n\r\n  public Initialize(def: b2ContactSolverDef): b2ContactSolver {\r\n    this.m_step.Copy(def.step);\r\n    this.m_count = def.count;\r\n    // TODO:\r\n    if (this.m_positionConstraints.length < this.m_count) {\r\n      const new_length: number = b2Max(this.m_positionConstraints.length * 2, this.m_count);\r\n      while (this.m_positionConstraints.length < new_length) {\r\n        this.m_positionConstraints[this.m_positionConstraints.length] = new b2ContactPositionConstraint();\r\n      }\r\n    }\r\n    // TODO:\r\n    if (this.m_velocityConstraints.length < this.m_count) {\r\n      const new_length: number = b2Max(this.m_velocityConstraints.length * 2, this.m_count);\r\n      while (this.m_velocityConstraints.length < new_length) {\r\n        this.m_velocityConstraints[this.m_velocityConstraints.length] = new b2ContactVelocityConstraint();\r\n      }\r\n    }\r\n    this.m_positions = def.positions;\r\n    this.m_velocities = def.velocities;\r\n    this.m_contacts = def.contacts;\r\n\r\n    // Initialize position independent portions of the constraints.\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const contact: b2Contact = this.m_contacts[i];\r\n\r\n      const fixtureA: b2Fixture = contact.m_fixtureA;\r\n      const fixtureB: b2Fixture = contact.m_fixtureB;\r\n      const shapeA: b2Shape = fixtureA.GetShape();\r\n      const shapeB: b2Shape = fixtureB.GetShape();\r\n      const radiusA: number = shapeA.m_radius;\r\n      const radiusB: number = shapeB.m_radius;\r\n      const bodyA: b2Body = fixtureA.GetBody();\r\n      const bodyB: b2Body = fixtureB.GetBody();\r\n      const manifold: b2Manifold = contact.GetManifold();\r\n\r\n      const pointCount: number = manifold.pointCount;\r\n      // DEBUG: b2Assert(pointCount > 0);\r\n\r\n      const vc: b2ContactVelocityConstraint = this.m_velocityConstraints[i];\r\n      vc.friction = contact.m_friction;\r\n      vc.restitution = contact.m_restitution;\r\n      vc.tangentSpeed = contact.m_tangentSpeed;\r\n      vc.indexA = bodyA.m_islandIndex;\r\n      vc.indexB = bodyB.m_islandIndex;\r\n      vc.invMassA = bodyA.m_invMass;\r\n      vc.invMassB = bodyB.m_invMass;\r\n      vc.invIA = bodyA.m_invI;\r\n      vc.invIB = bodyB.m_invI;\r\n      vc.contactIndex = i;\r\n      vc.pointCount = pointCount;\r\n      vc.K.SetZero();\r\n      vc.normalMass.SetZero();\r\n\r\n      const pc: b2ContactPositionConstraint = this.m_positionConstraints[i];\r\n      pc.indexA = bodyA.m_islandIndex;\r\n      pc.indexB = bodyB.m_islandIndex;\r\n      pc.invMassA = bodyA.m_invMass;\r\n      pc.invMassB = bodyB.m_invMass;\r\n      pc.localCenterA.Copy(bodyA.m_sweep.localCenter);\r\n      pc.localCenterB.Copy(bodyB.m_sweep.localCenter);\r\n      pc.invIA = bodyA.m_invI;\r\n      pc.invIB = bodyB.m_invI;\r\n      pc.localNormal.Copy(manifold.localNormal);\r\n      pc.localPoint.Copy(manifold.localPoint);\r\n      pc.pointCount = pointCount;\r\n      pc.radiusA = radiusA;\r\n      pc.radiusB = radiusB;\r\n      pc.type = manifold.type;\r\n\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        const cp: b2ManifoldPoint = manifold.points[j];\r\n        const vcp: b2VelocityConstraintPoint = vc.points[j];\r\n\r\n        if (this.m_step.warmStarting) {\r\n          vcp.normalImpulse = this.m_step.dtRatio * cp.normalImpulse;\r\n          vcp.tangentImpulse = this.m_step.dtRatio * cp.tangentImpulse;\r\n        } else {\r\n          vcp.normalImpulse = 0;\r\n          vcp.tangentImpulse = 0;\r\n        }\r\n\r\n        vcp.rA.SetZero();\r\n        vcp.rB.SetZero();\r\n        vcp.normalMass = 0;\r\n        vcp.tangentMass = 0;\r\n        vcp.velocityBias = 0;\r\n\r\n        pc.localPoints[j].Copy(cp.localPoint);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  private static InitializeVelocityConstraints_s_xfA = new b2Transform();\r\n  private static InitializeVelocityConstraints_s_xfB = new b2Transform();\r\n  private static InitializeVelocityConstraints_s_worldManifold = new b2WorldManifold();\r\n  public InitializeVelocityConstraints(): void {\r\n    const xfA: b2Transform = b2ContactSolver.InitializeVelocityConstraints_s_xfA;\r\n    const xfB: b2Transform = b2ContactSolver.InitializeVelocityConstraints_s_xfB;\r\n    const worldManifold: b2WorldManifold = b2ContactSolver.InitializeVelocityConstraints_s_worldManifold;\r\n\r\n    const k_maxConditionNumber: number = 1000;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const vc: b2ContactVelocityConstraint = this.m_velocityConstraints[i];\r\n      const pc: b2ContactPositionConstraint = this.m_positionConstraints[i];\r\n\r\n      const radiusA: number = pc.radiusA;\r\n      const radiusB: number = pc.radiusB;\r\n      const manifold: b2Manifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n\r\n      const indexA: number = vc.indexA;\r\n      const indexB: number = vc.indexB;\r\n\r\n      const mA: number = vc.invMassA;\r\n      const mB: number = vc.invMassB;\r\n      const iA: number = vc.invIA;\r\n      const iB: number = vc.invIB;\r\n      const localCenterA: b2Vec2 = pc.localCenterA;\r\n      const localCenterB: b2Vec2 = pc.localCenterB;\r\n\r\n      const cA: b2Vec2 = this.m_positions[indexA].c;\r\n      const aA: number = this.m_positions[indexA].a;\r\n      const vA: b2Vec2 = this.m_velocities[indexA].v;\r\n      const wA: number = this.m_velocities[indexA].w;\r\n\r\n      const cB: b2Vec2 = this.m_positions[indexB].c;\r\n      const aB: number = this.m_positions[indexB].a;\r\n      const vB: b2Vec2 = this.m_velocities[indexB].v;\r\n      const wB: number = this.m_velocities[indexB].w;\r\n\r\n      // DEBUG: b2Assert(manifold.pointCount > 0);\r\n\r\n      xfA.q.SetAngle(aA);\r\n      xfB.q.SetAngle(aB);\r\n      b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);\r\n      b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);\r\n\r\n      worldManifold.Initialize(manifold, xfA, radiusA, xfB, radiusB);\r\n\r\n      vc.normal.Copy(worldManifold.normal);\r\n      b2Vec2.CrossVOne(vc.normal, vc.tangent); // compute from normal\r\n\r\n      const pointCount: number = vc.pointCount;\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        const vcp: b2VelocityConstraintPoint = vc.points[j];\r\n\r\n        // vcp->rA = worldManifold.points[j] - cA;\r\n        b2Vec2.SubVV(worldManifold.points[j], cA, vcp.rA);\r\n        // vcp->rB = worldManifold.points[j] - cB;\r\n        b2Vec2.SubVV(worldManifold.points[j], cB, vcp.rB);\r\n\r\n        const rnA: number = b2Vec2.CrossVV(vcp.rA, vc.normal);\r\n        const rnB: number = b2Vec2.CrossVV(vcp.rB, vc.normal);\r\n\r\n        const kNormal: number = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n        vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;\r\n\r\n        // b2Vec2 tangent = b2Cross(vc->normal, 1.0f);\r\n        const tangent: b2Vec2 = vc.tangent; // precomputed from normal\r\n\r\n        const rtA: number = b2Vec2.CrossVV(vcp.rA, tangent);\r\n        const rtB: number = b2Vec2.CrossVV(vcp.rB, tangent);\r\n\r\n        const kTangent: number = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\r\n\r\n        vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;\r\n\r\n        // Setup a velocity bias for restitution.\r\n        vcp.velocityBias = 0;\r\n        // float32 vRel = b2Dot(vc->normal, vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA));\r\n        const vRel: number = b2Vec2.DotVV(\r\n          vc.normal,\r\n          b2Vec2.SubVV(\r\n            b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0),\r\n            b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1),\r\n            b2Vec2.s_t0));\r\n        if (vRel < (-b2_velocityThreshold)) {\r\n          vcp.velocityBias += (-vc.restitution * vRel);\r\n        }\r\n      }\r\n\r\n      // If we have two points, then prepare the block solver.\r\n      if (vc.pointCount === 2 && g_blockSolve) {\r\n        const vcp1: b2VelocityConstraintPoint = vc.points[0];\r\n        const vcp2: b2VelocityConstraintPoint = vc.points[1];\r\n\r\n        const rn1A: number = b2Vec2.CrossVV(vcp1.rA, vc.normal);\r\n        const rn1B: number = b2Vec2.CrossVV(vcp1.rB, vc.normal);\r\n        const rn2A: number = b2Vec2.CrossVV(vcp2.rA, vc.normal);\r\n        const rn2B: number = b2Vec2.CrossVV(vcp2.rB, vc.normal);\r\n\r\n        const k11: number = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\r\n        const k22: number = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\r\n        const k12: number = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\r\n\r\n        // Ensure a reasonable condition number.\r\n        // float32 k_maxConditionNumber = 1000.0f;\r\n        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\r\n          // K is safe to invert.\r\n          vc.K.ex.Set(k11, k12);\r\n          vc.K.ey.Set(k12, k22);\r\n          vc.K.GetInverse(vc.normalMass);\r\n        } else {\r\n          // The constraints are redundant, just use one.\r\n          // TODO_ERIN use deepest?\r\n          vc.pointCount = 1;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private static WarmStart_s_P = new b2Vec2();\r\n  public WarmStart(): void {\r\n    const P: b2Vec2 = b2ContactSolver.WarmStart_s_P;\r\n\r\n    // Warm start.\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const vc: b2ContactVelocityConstraint = this.m_velocityConstraints[i];\r\n\r\n      const indexA: number = vc.indexA;\r\n      const indexB: number = vc.indexB;\r\n      const mA: number = vc.invMassA;\r\n      const iA: number = vc.invIA;\r\n      const mB: number = vc.invMassB;\r\n      const iB: number = vc.invIB;\r\n      const pointCount: number = vc.pointCount;\r\n\r\n      const vA: b2Vec2 = this.m_velocities[indexA].v;\r\n      let wA: number = this.m_velocities[indexA].w;\r\n      const vB: b2Vec2 = this.m_velocities[indexB].v;\r\n      let wB: number = this.m_velocities[indexB].w;\r\n\r\n      const normal: b2Vec2 = vc.normal;\r\n      // b2Vec2 tangent = b2Cross(normal, 1.0f);\r\n      const tangent: b2Vec2 = vc.tangent; // precomputed from normal\r\n\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        const vcp: b2VelocityConstraintPoint = vc.points[j];\r\n        // b2Vec2 P = vcp->normalImpulse * normal + vcp->tangentImpulse * tangent;\r\n        b2Vec2.AddVV(\r\n          b2Vec2.MulSV(vcp.normalImpulse, normal, b2Vec2.s_t0),\r\n          b2Vec2.MulSV(vcp.tangentImpulse, tangent, b2Vec2.s_t1),\r\n          P);\r\n        // wA -= iA * b2Cross(vcp->rA, P);\r\n        wA -= iA * b2Vec2.CrossVV(vcp.rA, P);\r\n        // vA -= mA * P;\r\n        vA.SelfMulSub(mA, P);\r\n        // wB += iB * b2Cross(vcp->rB, P);\r\n        wB += iB * b2Vec2.CrossVV(vcp.rB, P);\r\n        // vB += mB * P;\r\n        vB.SelfMulAdd(mB, P);\r\n      }\r\n\r\n      // this.m_velocities[indexA].v = vA;\r\n      this.m_velocities[indexA].w = wA;\r\n      // this.m_velocities[indexB].v = vB;\r\n      this.m_velocities[indexB].w = wB;\r\n    }\r\n  }\r\n\r\n  private static SolveVelocityConstraints_s_dv = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_dv1 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_dv2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_P = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_a = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_b = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_x = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_d = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_P1 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_P2 = new b2Vec2();\r\n  private static SolveVelocityConstraints_s_P1P2 = new b2Vec2();\r\n  public SolveVelocityConstraints(): void {\r\n    const dv: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_dv;\r\n    const dv1: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_dv1;\r\n    const dv2: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_dv2;\r\n    const P: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_P;\r\n    const a: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_a;\r\n    const b: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_b;\r\n    const x: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_x;\r\n    const d: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_d;\r\n    const P1: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_P1;\r\n    const P2: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_P2;\r\n    const P1P2: b2Vec2 = b2ContactSolver.SolveVelocityConstraints_s_P1P2;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const vc: b2ContactVelocityConstraint = this.m_velocityConstraints[i];\r\n\r\n      const indexA: number = vc.indexA;\r\n      const indexB: number = vc.indexB;\r\n      const mA: number = vc.invMassA;\r\n      const iA: number = vc.invIA;\r\n      const mB: number = vc.invMassB;\r\n      const iB: number = vc.invIB;\r\n      const pointCount: number = vc.pointCount;\r\n\r\n      const vA: b2Vec2 = this.m_velocities[indexA].v;\r\n      let wA: number = this.m_velocities[indexA].w;\r\n      const vB: b2Vec2 = this.m_velocities[indexB].v;\r\n      let wB: number = this.m_velocities[indexB].w;\r\n\r\n      // b2Vec2 normal = vc->normal;\r\n      const normal: b2Vec2 = vc.normal;\r\n      // b2Vec2 tangent = b2Cross(normal, 1.0f);\r\n      const tangent: b2Vec2 = vc.tangent; // precomputed from normal\r\n      const friction: number = vc.friction;\r\n\r\n      // DEBUG: b2Assert(pointCount === 1 || pointCount === 2);\r\n\r\n      // Solve tangent constraints first because non-penetration is more important\r\n      // than friction.\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        const vcp: b2VelocityConstraintPoint = vc.points[j];\r\n\r\n        // Relative velocity at contact\r\n        // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n        b2Vec2.SubVV(\r\n          b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0),\r\n          b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1),\r\n          dv);\r\n\r\n        // Compute tangent force\r\n        // float32 vt = b2Dot(dv, tangent) - vc->tangentSpeed;\r\n        const vt: number = b2Vec2.DotVV(dv, tangent) - vc.tangentSpeed;\r\n        let lambda: number = vcp.tangentMass * (-vt);\r\n\r\n        // b2Clamp the accumulated force\r\n        const maxFriction: number = friction * vcp.normalImpulse;\r\n        const newImpulse: number = b2Clamp(vcp.tangentImpulse + lambda, (-maxFriction), maxFriction);\r\n        lambda = newImpulse - vcp.tangentImpulse;\r\n        vcp.tangentImpulse = newImpulse;\r\n\r\n        // Apply contact impulse\r\n        // b2Vec2 P = lambda * tangent;\r\n        b2Vec2.MulSV(lambda, tangent, P);\r\n\r\n        // vA -= mA * P;\r\n        vA.SelfMulSub(mA, P);\r\n        // wA -= iA * b2Cross(vcp->rA, P);\r\n        wA -= iA * b2Vec2.CrossVV(vcp.rA, P);\r\n\r\n        // vB += mB * P;\r\n        vB.SelfMulAdd(mB, P);\r\n        // wB += iB * b2Cross(vcp->rB, P);\r\n        wB += iB * b2Vec2.CrossVV(vcp.rB, P);\r\n      }\r\n\r\n      // Solve normal constraints\r\n      if (vc.pointCount === 1 || g_blockSolve === false) {\r\n        for (let j = 0; j < pointCount; ++j) {\r\n          const vcp: b2VelocityConstraintPoint = vc.points[j];\r\n\r\n          // Relative velocity at contact\r\n          // b2Vec2 dv = vB + b2Cross(wB, vcp->rB) - vA - b2Cross(wA, vcp->rA);\r\n          b2Vec2.SubVV(\r\n            b2Vec2.AddVCrossSV(vB, wB, vcp.rB, b2Vec2.s_t0),\r\n            b2Vec2.AddVCrossSV(vA, wA, vcp.rA, b2Vec2.s_t1),\r\n            dv);\r\n\r\n          // Compute normal impulse\r\n          // float32 vn = b2Dot(dv, normal);\r\n          const vn: number = b2Vec2.DotVV(dv, normal);\r\n          let lambda: number = (-vcp.normalMass * (vn - vcp.velocityBias));\r\n\r\n          // b2Clamp the accumulated impulse\r\n          // float32 newImpulse = b2Max(vcp->normalImpulse + lambda, 0.0f);\r\n          const newImpulse: number = b2Max(vcp.normalImpulse + lambda, 0);\r\n          lambda = newImpulse - vcp.normalImpulse;\r\n          vcp.normalImpulse = newImpulse;\r\n\r\n          // Apply contact impulse\r\n          // b2Vec2 P = lambda * normal;\r\n          b2Vec2.MulSV(lambda, normal, P);\r\n          // vA -= mA * P;\r\n          vA.SelfMulSub(mA, P);\r\n          // wA -= iA * b2Cross(vcp->rA, P);\r\n          wA -= iA * b2Vec2.CrossVV(vcp.rA, P);\r\n\r\n          // vB += mB * P;\r\n          vB.SelfMulAdd(mB, P);\r\n          // wB += iB * b2Cross(vcp->rB, P);\r\n          wB += iB * b2Vec2.CrossVV(vcp.rB, P);\r\n        }\r\n      } else {\r\n        // Block solver developed in collaboration with Dirk Gregorius (back in 01/07 on Box2D_Lite).\r\n        // Build the mini LCP for this contact patch\r\n        //\r\n        // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\r\n        //\r\n        // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\r\n        // b = vn0 - velocityBias\r\n        //\r\n        // The system is solved using the \"Total enumeration method\" (s. Murty). The complementary constraint vn_i * x_i\r\n        // implies that we must have in any solution either vn_i = 0 or x_i = 0. So for the 2D contact problem the cases\r\n        // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and vn1 = 0 need to be tested. The first valid\r\n        // solution that satisfies the problem is chosen.\r\n        //\r\n        // In order to account of the accumulated impulse 'a' (because of the iterative nature of the solver which only requires\r\n        // that the accumulated impulse is clamped and not the incremental impulse) we change the impulse variable (x_i).\r\n        //\r\n        // Substitute:\r\n        //\r\n        // x = a + d\r\n        //\r\n        // a := old total impulse\r\n        // x := new total impulse\r\n        // d := incremental impulse\r\n        //\r\n        // For the current iteration we extend the formula for the incremental impulse\r\n        // to compute the new total impulse:\r\n        //\r\n        // vn = A * d + b\r\n        //    = A * (x - a) + b\r\n        //    = A * x + b - A * a\r\n        //    = A * x + b'\r\n        // b' = b - A * a;\r\n\r\n        const cp1: b2VelocityConstraintPoint = vc.points[0];\r\n        const cp2: b2VelocityConstraintPoint = vc.points[1];\r\n\r\n        // b2Vec2 a(cp1->normalImpulse, cp2->normalImpulse);\r\n        a.Set(cp1.normalImpulse, cp2.normalImpulse);\r\n        // DEBUG: b2Assert(a.x >= 0 && a.y >= 0);\r\n\r\n        // Relative velocity at contact\r\n        // b2Vec2 dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n        b2Vec2.SubVV(\r\n          b2Vec2.AddVCrossSV(vB, wB, cp1.rB, b2Vec2.s_t0),\r\n          b2Vec2.AddVCrossSV(vA, wA, cp1.rA, b2Vec2.s_t1),\r\n          dv1);\r\n        // b2Vec2 dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n        b2Vec2.SubVV(\r\n          b2Vec2.AddVCrossSV(vB, wB, cp2.rB, b2Vec2.s_t0),\r\n          b2Vec2.AddVCrossSV(vA, wA, cp2.rA, b2Vec2.s_t1),\r\n          dv2);\r\n\r\n        // Compute normal velocity\r\n        // float32 vn1 = b2Dot(dv1, normal);\r\n        let vn1: number = b2Vec2.DotVV(dv1, normal);\r\n        // float32 vn2 = b2Dot(dv2, normal);\r\n        let vn2: number = b2Vec2.DotVV(dv2, normal);\r\n\r\n        // b2Vec2 b;\r\n        b.x = vn1 - cp1.velocityBias;\r\n        b.y = vn2 - cp2.velocityBias;\r\n\r\n        // Compute b'\r\n        // b -= b2Mul(vc->K, a);\r\n        b.SelfSub(b2Mat22.MulMV(vc.K, a, b2Vec2.s_t0));\r\n\r\n        /*\r\n        #if B2_DEBUG_SOLVER === 1\r\n        const k_errorTol: number = 0.001;\r\n        #endif\r\n        */\r\n\r\n        for (; ; ) {\r\n          //\r\n          // Case 1: vn = 0\r\n          //\r\n          // 0 = A * x + b'\r\n          //\r\n          // Solve for x:\r\n          //\r\n          // x = - inv(A) * b'\r\n          //\r\n          // b2Vec2 x = - b2Mul(vc->normalMass, b);\r\n          b2Mat22.MulMV(vc.normalMass, b, x).SelfNeg();\r\n\r\n          if (x.x >= 0 && x.y >= 0) {\r\n            // Get the incremental impulse\r\n            // b2Vec2 d = x - a;\r\n            b2Vec2.SubVV(x, a, d);\r\n\r\n            // Apply incremental impulse\r\n            // b2Vec2 P1 = d.x * normal;\r\n            b2Vec2.MulSV(d.x, normal, P1);\r\n            // b2Vec2 P2 = d.y * normal;\r\n            b2Vec2.MulSV(d.y, normal, P2);\r\n            b2Vec2.AddVV(P1, P2, P1P2);\r\n            // vA -= mA * (P1 + P2);\r\n            vA.SelfMulSub(mA, P1P2);\r\n            // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n            wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));\r\n\r\n            // vB += mB * (P1 + P2);\r\n            vB.SelfMulAdd(mB, P1P2);\r\n            // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n            wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));\r\n\r\n            // Accumulate\r\n            cp1.normalImpulse = x.x;\r\n            cp2.normalImpulse = x.y;\r\n\r\n            /*\r\n            #if B2_DEBUG_SOLVER === 1\r\n            // Postconditions\r\n            dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n            dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n\r\n            // Compute normal velocity\r\n            vn1 = b2Dot(dv1, normal);\r\n            vn2 = b2Dot(dv2, normal);\r\n\r\n            b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);\r\n            b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);\r\n            #endif\r\n            */\r\n            break;\r\n          }\r\n\r\n          //\r\n          // Case 2: vn1 = 0 and x2 = 0\r\n          //\r\n          //   0 = a11 * x1 + a12 * 0 + b1'\r\n          // vn2 = a21 * x1 + a22 * 0 + b2'\r\n          //\r\n          x.x = (-cp1.normalMass * b.x);\r\n          x.y = 0;\r\n          vn1 = 0;\r\n          vn2 = vc.K.ex.y * x.x + b.y;\r\n\r\n          if (x.x >= 0 && vn2 >= 0) {\r\n            // Get the incremental impulse\r\n            // b2Vec2 d = x - a;\r\n            b2Vec2.SubVV(x, a, d);\r\n\r\n            // Apply incremental impulse\r\n            // b2Vec2 P1 = d.x * normal;\r\n            b2Vec2.MulSV(d.x, normal, P1);\r\n            // b2Vec2 P2 = d.y * normal;\r\n            b2Vec2.MulSV(d.y, normal, P2);\r\n            b2Vec2.AddVV(P1, P2, P1P2);\r\n            // vA -= mA * (P1 + P2);\r\n            vA.SelfMulSub(mA, P1P2);\r\n            // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n            wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));\r\n\r\n            // vB += mB * (P1 + P2);\r\n            vB.SelfMulAdd(mB, P1P2);\r\n            // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n            wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));\r\n\r\n            // Accumulate\r\n            cp1.normalImpulse = x.x;\r\n            cp2.normalImpulse = x.y;\r\n\r\n            /*\r\n            #if B2_DEBUG_SOLVER === 1\r\n            // Postconditions\r\n            dv1 = vB + b2Cross(wB, cp1->rB) - vA - b2Cross(wA, cp1->rA);\r\n\r\n            // Compute normal velocity\r\n            vn1 = b2Dot(dv1, normal);\r\n\r\n            b2Assert(b2Abs(vn1 - cp1->velocityBias) < k_errorTol);\r\n            #endif\r\n            */\r\n            break;\r\n          }\r\n\r\n          //\r\n          // Case 3: vn2 = 0 and x1 = 0\r\n          //\r\n          // vn1 = a11 * 0 + a12 * x2 + b1'\r\n          //   0 = a21 * 0 + a22 * x2 + b2'\r\n          //\r\n          x.x = 0;\r\n          x.y = (-cp2.normalMass * b.y);\r\n          vn1 = vc.K.ey.x * x.y + b.x;\r\n          vn2 = 0;\r\n\r\n          if (x.y >= 0 && vn1 >= 0) {\r\n            // Resubstitute for the incremental impulse\r\n            // b2Vec2 d = x - a;\r\n            b2Vec2.SubVV(x, a, d);\r\n\r\n            // Apply incremental impulse\r\n            // b2Vec2 P1 = d.x * normal;\r\n            b2Vec2.MulSV(d.x, normal, P1);\r\n            // b2Vec2 P2 = d.y * normal;\r\n            b2Vec2.MulSV(d.y, normal, P2);\r\n            b2Vec2.AddVV(P1, P2, P1P2);\r\n            // vA -= mA * (P1 + P2);\r\n            vA.SelfMulSub(mA, P1P2);\r\n            // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n            wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));\r\n\r\n            // vB += mB * (P1 + P2);\r\n            vB.SelfMulAdd(mB, P1P2);\r\n            // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n            wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));\r\n\r\n            // Accumulate\r\n            cp1.normalImpulse = x.x;\r\n            cp2.normalImpulse = x.y;\r\n\r\n            /*\r\n            #if B2_DEBUG_SOLVER === 1\r\n            // Postconditions\r\n            dv2 = vB + b2Cross(wB, cp2->rB) - vA - b2Cross(wA, cp2->rA);\r\n\r\n            // Compute normal velocity\r\n            vn2 = b2Dot(dv2, normal);\r\n\r\n            b2Assert(b2Abs(vn2 - cp2->velocityBias) < k_errorTol);\r\n            #endif\r\n            */\r\n            break;\r\n          }\r\n\r\n          //\r\n          // Case 4: x1 = 0 and x2 = 0\r\n          //\r\n          // vn1 = b1\r\n          // vn2 = b2;\r\n          x.x = 0;\r\n          x.y = 0;\r\n          vn1 = b.x;\r\n          vn2 = b.y;\r\n\r\n          if (vn1 >= 0 && vn2 >= 0) {\r\n            // Resubstitute for the incremental impulse\r\n            // b2Vec2 d = x - a;\r\n            b2Vec2.SubVV(x, a, d);\r\n\r\n            // Apply incremental impulse\r\n            // b2Vec2 P1 = d.x * normal;\r\n            b2Vec2.MulSV(d.x, normal, P1);\r\n            // b2Vec2 P2 = d.y * normal;\r\n            b2Vec2.MulSV(d.y, normal, P2);\r\n            b2Vec2.AddVV(P1, P2, P1P2);\r\n            // vA -= mA * (P1 + P2);\r\n            vA.SelfMulSub(mA, P1P2);\r\n            // wA -= iA * (b2Cross(cp1->rA, P1) + b2Cross(cp2->rA, P2));\r\n            wA -= iA * (b2Vec2.CrossVV(cp1.rA, P1) + b2Vec2.CrossVV(cp2.rA, P2));\r\n\r\n            // vB += mB * (P1 + P2);\r\n            vB.SelfMulAdd(mB, P1P2);\r\n            // wB += iB * (b2Cross(cp1->rB, P1) + b2Cross(cp2->rB, P2));\r\n            wB += iB * (b2Vec2.CrossVV(cp1.rB, P1) + b2Vec2.CrossVV(cp2.rB, P2));\r\n\r\n            // Accumulate\r\n            cp1.normalImpulse = x.x;\r\n            cp2.normalImpulse = x.y;\r\n\r\n            break;\r\n          }\r\n\r\n          // No solution, give up. This is hit sometimes, but it doesn't seem to matter.\r\n          break;\r\n        }\r\n      }\r\n\r\n      // this.m_velocities[indexA].v = vA;\r\n      this.m_velocities[indexA].w = wA;\r\n      // this.m_velocities[indexB].v = vB;\r\n      this.m_velocities[indexB].w = wB;\r\n    }\r\n  }\r\n\r\n  public StoreImpulses(): void {\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const vc: b2ContactVelocityConstraint = this.m_velocityConstraints[i];\r\n      const manifold: b2Manifold = this.m_contacts[vc.contactIndex].GetManifold();\r\n\r\n      for (let j: number = 0; j < vc.pointCount; ++j) {\r\n        manifold.points[j].normalImpulse = vc.points[j].normalImpulse;\r\n        manifold.points[j].tangentImpulse = vc.points[j].tangentImpulse;\r\n      }\r\n    }\r\n  }\r\n\r\n  private static SolvePositionConstraints_s_xfA = new b2Transform();\r\n  private static SolvePositionConstraints_s_xfB = new b2Transform();\r\n  private static SolvePositionConstraints_s_psm = new b2PositionSolverManifold();\r\n  private static SolvePositionConstraints_s_rA = new b2Vec2();\r\n  private static SolvePositionConstraints_s_rB = new b2Vec2();\r\n  private static SolvePositionConstraints_s_P = new b2Vec2();\r\n  public SolvePositionConstraints(): boolean {\r\n    const xfA: b2Transform = b2ContactSolver.SolvePositionConstraints_s_xfA;\r\n    const xfB: b2Transform = b2ContactSolver.SolvePositionConstraints_s_xfB;\r\n    const psm: b2PositionSolverManifold = b2ContactSolver.SolvePositionConstraints_s_psm;\r\n    const rA: b2Vec2 = b2ContactSolver.SolvePositionConstraints_s_rA;\r\n    const rB: b2Vec2 = b2ContactSolver.SolvePositionConstraints_s_rB;\r\n    const P: b2Vec2 = b2ContactSolver.SolvePositionConstraints_s_P;\r\n\r\n    let minSeparation: number = 0;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const pc: b2ContactPositionConstraint = this.m_positionConstraints[i];\r\n\r\n      const indexA: number = pc.indexA;\r\n      const indexB: number = pc.indexB;\r\n      const localCenterA: b2Vec2 = pc.localCenterA;\r\n      const mA: number = pc.invMassA;\r\n      const iA: number = pc.invIA;\r\n      const localCenterB: b2Vec2 = pc.localCenterB;\r\n      const mB: number = pc.invMassB;\r\n      const iB: number = pc.invIB;\r\n      const pointCount: number = pc.pointCount;\r\n\r\n      const cA: b2Vec2 = this.m_positions[indexA].c;\r\n      let aA: number = this.m_positions[indexA].a;\r\n\r\n      const cB: b2Vec2 = this.m_positions[indexB].c;\r\n      let aB: number = this.m_positions[indexB].a;\r\n\r\n      // Solve normal constraints\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        xfA.q.SetAngle(aA);\r\n        xfB.q.SetAngle(aB);\r\n        b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);\r\n        b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);\r\n\r\n        psm.Initialize(pc, xfA, xfB, j);\r\n        const normal: b2Vec2 = psm.normal;\r\n\r\n        const point: b2Vec2 = psm.point;\r\n        const separation: number = psm.separation;\r\n\r\n        // b2Vec2 rA = point - cA;\r\n        b2Vec2.SubVV(point, cA, rA);\r\n        // b2Vec2 rB = point - cB;\r\n        b2Vec2.SubVV(point, cB, rB);\r\n\r\n        // Track max constraint error.\r\n        minSeparation = b2Min(minSeparation, separation);\r\n\r\n        // Prevent large corrections and allow slop.\r\n        const C: number = b2Clamp(b2_baumgarte * (separation + b2_linearSlop), (-b2_maxLinearCorrection), 0);\r\n\r\n        // Compute the effective mass.\r\n        // float32 rnA = b2Cross(rA, normal);\r\n        const rnA: number = b2Vec2.CrossVV(rA, normal);\r\n        // float32 rnB = b2Cross(rB, normal);\r\n        const rnB: number = b2Vec2.CrossVV(rB, normal);\r\n        // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n        const K: number = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n        // Compute normal impulse\r\n        const impulse: number = K > 0 ? - C / K : 0;\r\n\r\n        // b2Vec2 P = impulse * normal;\r\n        b2Vec2.MulSV(impulse, normal, P);\r\n\r\n        // cA -= mA * P;\r\n        cA.SelfMulSub(mA, P);\r\n        // aA -= iA * b2Cross(rA, P);\r\n        aA -= iA * b2Vec2.CrossVV(rA, P);\r\n\r\n        // cB += mB * P;\r\n        cB.SelfMulAdd(mB, P);\r\n        // aB += iB * b2Cross(rB, P);\r\n        aB += iB * b2Vec2.CrossVV(rB, P);\r\n      }\r\n\r\n      // this.m_positions[indexA].c = cA;\r\n      this.m_positions[indexA].a = aA;\r\n\r\n      // this.m_positions[indexB].c = cB;\r\n      this.m_positions[indexB].a = aB;\r\n    }\r\n\r\n    // We can't expect minSpeparation >= -b2_linearSlop because we don't\r\n    // push the separation above -b2_linearSlop.\r\n    return minSeparation > (-3 * b2_linearSlop);\r\n  }\r\n\r\n  private static SolveTOIPositionConstraints_s_xfA = new b2Transform();\r\n  private static SolveTOIPositionConstraints_s_xfB = new b2Transform();\r\n  private static SolveTOIPositionConstraints_s_psm = new b2PositionSolverManifold();\r\n  private static SolveTOIPositionConstraints_s_rA = new b2Vec2();\r\n  private static SolveTOIPositionConstraints_s_rB = new b2Vec2();\r\n  private static SolveTOIPositionConstraints_s_P = new b2Vec2();\r\n  public SolveTOIPositionConstraints(toiIndexA: number, toiIndexB: number): boolean {\r\n    const xfA: b2Transform = b2ContactSolver.SolveTOIPositionConstraints_s_xfA;\r\n    const xfB: b2Transform = b2ContactSolver.SolveTOIPositionConstraints_s_xfB;\r\n    const psm: b2PositionSolverManifold = b2ContactSolver.SolveTOIPositionConstraints_s_psm;\r\n    const rA: b2Vec2 = b2ContactSolver.SolveTOIPositionConstraints_s_rA;\r\n    const rB: b2Vec2 = b2ContactSolver.SolveTOIPositionConstraints_s_rB;\r\n    const P: b2Vec2 = b2ContactSolver.SolveTOIPositionConstraints_s_P;\r\n\r\n    let minSeparation: number = 0;\r\n\r\n    for (let i: number = 0; i < this.m_count; ++i) {\r\n      const pc: b2ContactPositionConstraint = this.m_positionConstraints[i];\r\n\r\n      const indexA: number = pc.indexA;\r\n      const indexB: number = pc.indexB;\r\n      const localCenterA: b2Vec2 = pc.localCenterA;\r\n      const localCenterB: b2Vec2 = pc.localCenterB;\r\n      const pointCount: number = pc.pointCount;\r\n\r\n      let mA: number = 0;\r\n      let iA: number = 0;\r\n      if (indexA === toiIndexA || indexA === toiIndexB) {\r\n        mA = pc.invMassA;\r\n        iA = pc.invIA;\r\n      }\r\n\r\n      let mB: number = 0;\r\n      let iB: number = 0;\r\n      if (indexB === toiIndexA || indexB === toiIndexB) {\r\n        mB = pc.invMassB;\r\n        iB = pc.invIB;\r\n      }\r\n\r\n      const cA: b2Vec2 = this.m_positions[indexA].c;\r\n      let aA: number = this.m_positions[indexA].a;\r\n\r\n      const cB: b2Vec2 = this.m_positions[indexB].c;\r\n      let aB: number = this.m_positions[indexB].a;\r\n\r\n      // Solve normal constraints\r\n      for (let j: number = 0; j < pointCount; ++j) {\r\n        xfA.q.SetAngle(aA);\r\n        xfB.q.SetAngle(aB);\r\n        b2Vec2.SubVV(cA, b2Rot.MulRV(xfA.q, localCenterA, b2Vec2.s_t0), xfA.p);\r\n        b2Vec2.SubVV(cB, b2Rot.MulRV(xfB.q, localCenterB, b2Vec2.s_t0), xfB.p);\r\n\r\n        psm.Initialize(pc, xfA, xfB, j);\r\n        const normal: b2Vec2 = psm.normal;\r\n\r\n        const point: b2Vec2 = psm.point;\r\n        const separation: number = psm.separation;\r\n\r\n        // b2Vec2 rA = point - cA;\r\n        b2Vec2.SubVV(point, cA, rA);\r\n        // b2Vec2 rB = point - cB;\r\n        b2Vec2.SubVV(point, cB, rB);\r\n\r\n        // Track max constraint error.\r\n        minSeparation = b2Min(minSeparation, separation);\r\n\r\n        // Prevent large corrections and allow slop.\r\n        const C: number = b2Clamp(b2_toiBaumgarte * (separation + b2_linearSlop), (-b2_maxLinearCorrection), 0);\r\n\r\n        // Compute the effective mass.\r\n        // float32 rnA = b2Cross(rA, normal);\r\n        const rnA: number = b2Vec2.CrossVV(rA, normal);\r\n        // float32 rnB = b2Cross(rB, normal);\r\n        const rnB: number = b2Vec2.CrossVV(rB, normal);\r\n        // float32 K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n        const K: number = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\r\n\r\n        // Compute normal impulse\r\n        const impulse: number = K > 0 ? - C / K : 0;\r\n\r\n        // b2Vec2 P = impulse * normal;\r\n        b2Vec2.MulSV(impulse, normal, P);\r\n\r\n        // cA -= mA * P;\r\n        cA.SelfMulSub(mA, P);\r\n        // aA -= iA * b2Cross(rA, P);\r\n        aA -= iA * b2Vec2.CrossVV(rA, P);\r\n\r\n        // cB += mB * P;\r\n        cB.SelfMulAdd(mB, P);\r\n        // aB += iB * b2Cross(rB, P);\r\n        aB += iB * b2Vec2.CrossVV(rB, P);\r\n      }\r\n\r\n      // this.m_positions[indexA].c = cA;\r\n      this.m_positions[indexA].a = aA;\r\n\r\n      // this.m_positions[indexB].c = cB;\r\n      this.m_positions[indexB].a = aB;\r\n    }\r\n\r\n    // We can't expect minSpeparation >= -b2_linearSlop because we don't\r\n    // push the separation above -b2_linearSlop.\r\n    return minSeparation >= -1.5 * b2_linearSlop;\r\n  }\r\n}\r\n"]}},"error":null,"hash":"96a5f4e644e5601f980de758801ead84","cacheData":{"env":{}}}